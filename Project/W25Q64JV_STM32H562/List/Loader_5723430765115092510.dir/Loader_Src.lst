###############################################################################
#
# IAR ANSI C/C++ Compiler V9.40.1.364/W64 for ARM         23/Nov/2023  21:46:18
# Copyright 1999-2023 IAR Systems AB.
#
#    Cpu mode                 =  thumb
#    Endian                   =  little
#    Source file              =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Loader\Loader_Src.c
#    Command line             =
#        -f
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Loader_5723430765115092510.dir\Loader_Src.o.rsp
#        (C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Loader\Loader_Src.c
#        -D STM32H562xx -lCN
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Loader_5723430765115092510.dir
#        -lA
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Loader_5723430765115092510.dir
#        -o
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Loader_5723430765115092510.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33.no_dsp.no_se -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\CMSIS\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Library\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Loader\
#        -Ol) --dependencies=n
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Loader_5723430765115092510.dir\Loader_Src.o.iar_deps
#    Locale                   =  C
#    List file                =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Loader_5723430765115092510.dir\Loader_Src.lst
#    Object file              =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Loader_5723430765115092510.dir\Loader_Src.o
#    Runtime model:              
#      __CPP_Runtime          =  1
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Loader\Loader_Src.c
      1          /**
      2            ******************************************************************************
      3            * @file    Loader_Src.c
      4            * @author  MCD Application Team
      5            * @brief   This file defines the operations of the external loader for
      6            *          MT25QL128A QSPI memory of STM32F469I-DISCO.
      7            *           
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
     12            * All rights reserved.</center></h2>
     13            *
     14            * This software component is licensed by ST under BSD 3-Clause license,
     15            * the "License"; You may not use this file except in compliance with the
     16            * License. You may obtain a copy of the License at:
     17            *                        opensource.org/licenses/BSD-3-Clause
     18            *
     19            ******************************************************************************
     20            */
     21          
     22          #include "Loader_Src.h"
     23          #include <string.h>
     24          #include <stdio.h>
     25          
     26          #pragma section=".bss"
     27          

   \                                 In section .bss, align 4
     28          XSPI_HandleTypeDef hospi1;
   \                     hospi1:
   \        0x0                      DS8 92

   \                                 In section .bss, align 4
     29          UART_HandleTypeDef huart1;
   \                     huart1:
   \        0x0                      DS8 148
     30          
     31          /* Private variables ---------------------------------------------------------*/
     32          #if defined(__ICCARM__)
     33          __ATTRIBUTES size_t __write(int, const unsigned char *, size_t);
     34          #endif /* __ICCARM__ */
     35          
     36          #if defined(__ICCARM__)
     37          /* New definition from EWARM V9, compatible with EWARM8 */
     38          int iar_fputc(int ch);
     39          #define PUTCHAR_PROTOTYPE int iar_fputc(int ch)
     40          #elif defined ( __CC_ARM ) || defined(__ARMCC_VERSION)
     41          /* ARM Compiler 5/6*/
     42          #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
     43          #elif defined(__GNUC__)
     44          #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
     45          #endif /* __ICCARM__ */
     46          #if defined(__ICCARM__)

   \                                 In section .text, align 2, keep-with-next
     47          size_t __write(int file, unsigned char const *ptr, size_t len)
     48          {
   \                     __write: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x000C             MOVS     R4,R1
   \        0x4   0x0015             MOVS     R5,R2
     49            size_t idx;
     50            unsigned char const *pdata = ptr;
     51          
     52            for (idx = 0; idx < len; idx++)
   \        0x6   0x2600             MOVS     R6,#+0
   \        0x8   0xE004             B.N      ??__write_0
     53            {
     54              iar_fputc((int)*pdata);
   \                     ??__write_1: (+1)
   \        0xA   0x7820             LDRB     R0,[R4, #+0]
   \        0xC   0x.... 0x....      BL       iar_fputc
     55              pdata++;
   \       0x10   0x1C64             ADDS     R4,R4,#+1
     56            }
   \       0x12   0x1C76             ADDS     R6,R6,#+1
   \                     ??__write_0: (+1)
   \       0x14   0x42AE             CMP      R6,R5
   \       0x16   0xD3F8             BCC.N    ??__write_1
     57            return len;
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0xBD70             POP      {R4-R6,PC}
     58          }
     59          #endif /* __ICCARM__ */
     60          /**
     61           * @brief  Retargets the C library printf function to the USART.
     62           */

   \                                 In section .text, align 2, keep-with-next
     63          PUTCHAR_PROTOTYPE
     64          {  
   \                     iar_fputc: (+1)
   \        0x0   0xB501             PUSH     {R0,LR}
     65              HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);
   \        0x2   0xF64F 0x73FF      MOVW     R3,#+65535
   \        0x6   0x2201             MOVS     R2,#+1
   \        0x8   0x4669             MOV      R1,SP
   \        0xA   0x....             LDR.N    R0,??DataTable3
   \        0xC   0x.... 0x....      BL       HAL_UART_Transmit
     66              return ch;
   \       0x10   0x9800             LDR      R0,[SP, #+0]
   \       0x12   0xBD02             POP      {R1,PC}
     67          }
     68          
     69          /* Private functions ---------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next, root
     70          KeepInCompilation HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
     71          { 
     72            return HAL_OK;
   \                     HAL_InitTick: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR
     73          }
     74          

   \                                 In section .text, align 2, keep-with-next
     75          uint32_t HAL_GetTick(void)
     76          {
     77            return 1;
   \                     HAL_GetTick: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4770             BX       LR
     78          }
     79          /** @defgroup STM32F469I_Discovery_QSPI_Private_Functions Private Functions
     80            * @{
     81            */
     82          
     83          
     84          /**
     85            * @brief  System initialization.
     86            * @param  None
     87            * @retval  1      : Operation succeeded
     88            * @retval  0      : Operation failed
     89            */

   \                                 In section .text, align 2, keep-with-next
     90          int Init()
     91          {
   \                     Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
     92            int32_t result=0;
   \        0x2   0x2000             MOVS     R0,#+0
     93          
     94            __disable_irq();
   \        0x4   0xB672             CPSID    I
     95            /* Init structs to Zero */
     96            //memset((void*)0x20005b94, 0, 0xf0);
     97            char *startadd = __section_begin(".bss");
   \        0x6   0x....             LDR.N    R4,??DataTable3_1
     98            uint32_t size = __section_size(".bss");
   \        0x8   0x....             LDR.N    R1,??DataTable3_2
     99            memset(startadd, 0, size);
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x.... 0x....      BL       __aeabi_memset
    100            //memset(&hospi1, 0, sizeof(hospi1));
    101           // memset(&huart1, 0, sizeof(huart1));
    102               
    103            /* init system */
    104            SystemInit(); 
   \       0x12   0x.... 0x....      BL       SystemInit
    105            HAL_Init();  
   \       0x16   0x.... 0x....      BL       HAL_Init
    106          
    107            /* Configure the system clock  */
    108            SystemClock_Config();  
   \       0x1A   0x.... 0x....      BL       SystemClock_Config
    109            DoTestFunctionInit();
   \       0x1E   0x.... 0x....      BL       DoTestFunctionInit
    110            
    111            printf("app start\n");
   \       0x22   0x....             LDR.N    R0,??DataTable3_3
   \       0x24   0x.... 0x....      BL       printf
    112            //QSPI_DeInit();
    113          
    114            /* QaudSPI Init */
    115            //QSPI_Init();
    116            
    117            //result = W25Q64JV_MemoryMappedMode();
    118            //if(result != W25Q_OK){
    119            //    return 0;
    120            //}  
    121            __enable_irq();
   \       0x28   0xB662             CPSIE    I
    122            return 1;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xBD10             POP      {R4,PC}
    123          }
    124          
    125          /**
    126            * @brief   Program memory.
    127            * @param   Address: page address
    128            * @param   Size   : size of data
    129            * @param   buffer : pointer to data buffer
    130            * @retval  1      : Operation succeeded
    131            * @retval  0      : Operation failed
    132            */

   \                                 In section .text, align 2, keep-with-next, root
    133          KeepInCompilation int Write (uint32_t Address, uint32_t Size, uint8_t* buffer)
    134          {
   \                     Write: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    135            Address = Address & 0x0FFFFFFF;
   \        0x8   0xF024 0x4470      BIC      R4,R4,#0xF0000000
    136          
    137            QSPI_DeInit();
   \        0xC   0x.... 0x....      BL       QSPI_DeInit
    138            QSPI_Init();
   \       0x10   0x.... 0x....      BL       QSPI_Init
    139          
    140            /* Writes an amount of data to the QSPI memory */
    141            if(W25Q64JV_ProgramRaw(buffer, Size, Address) != W25Q_OK){
   \       0x14   0x0022             MOVS     R2,R4
   \       0x16   0x0029             MOVS     R1,R5
   \       0x18   0xB289             UXTH     R1,R1
   \       0x1A   0x0030             MOVS     R0,R6
   \       0x1C   0x.... 0x....      BL       W25Q64JV_ProgramRaw
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD001             BEQ.N    ??Write_0
    142              return 0;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xE000             B.N      ??Write_1
    143            }
    144            
    145            return 1;
   \                     ??Write_0: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \                     ??Write_1: (+1)
   \       0x2A   0xBD70             POP      {R4-R6,PC}
    146          }
    147          
    148          /**
    149            * @brief 	 Full erase of the device 						
    150            * @param 	 Parallelism : 0 																		
    151            * @retval  1           : Operation succeeded
    152            * @retval  0           : Operation failed											
    153            */

   \                                 In section .text, align 2, keep-with-next, root
    154          KeepInCompilation int MassErase (uint32_t Parallelism )
    155          {
   \                     MassErase: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    156            QSPI_DeInit();
   \        0x2   0x.... 0x....      BL       QSPI_DeInit
    157            QSPI_Init();
   \        0x6   0x.... 0x....      BL       QSPI_Init
    158          
    159            /* Erase the entire QSPI memory */
    160            if(W25Q64JV_EraseChip() != W25Q_OK){
   \        0xA   0x.... 0x....      BL       W25Q64JV_EraseChip
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD001             BEQ.N    ??MassErase_0
    161              return 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE000             B.N      ??MassErase_1
    162            }
    163            
    164            return 1;
   \                     ??MassErase_0: (+1)
   \       0x16   0x2001             MOVS     R0,#+1
   \                     ??MassErase_1: (+1)
   \       0x18   0xBD02             POP      {R1,PC}
    165          }
    166          
    167          /**
    168            * @brief   Sector erase.
    169            * @param   EraseStartAddress :  erase start address
    170            * @param   EraseEndAddress   :  erase end address
    171            * @retval  None
    172            */

   \                                 In section .text, align 2, keep-with-next, root
    173          KeepInCompilation int SectorErase (uint32_t EraseStartAddress ,uint32_t EraseEndAddress)
    174          {
   \                     SectorErase: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    175            uint32_t BlockAddr;
    176            EraseStartAddress &= 0x0FFFFFFF;
   \        0x6   0xF024 0x4470      BIC      R4,R4,#0xF0000000
    177            EraseEndAddress &= 0x0FFFFFFF;
   \        0xA   0xF025 0x4570      BIC      R5,R5,#0xF0000000
    178            EraseStartAddress = EraseStartAddress - EraseStartAddress % 0x10000;
   \        0xE   0xB2A0             UXTH     R0,R4
   \       0x10   0x1A24             SUBS     R4,R4,R0
    179          
    180            QSPI_DeInit();
   \       0x12   0x.... 0x....      BL       QSPI_DeInit
    181            QSPI_Init();
   \       0x16   0x.... 0x....      BL       QSPI_Init
   \       0x1A   0xE004             B.N      ??SectorErase_0
    182          
    183            while(EraseEndAddress >= EraseStartAddress){
    184              BlockAddr = EraseStartAddress;
   \                     ??SectorErase_1: (+1)
   \       0x1C   0x0020             MOVS     R0,R4
    185          
    186              /* Erases the specified block of the QSPI memory */
    187              W25Q64JV_EraseBlock(BlockAddr);
   \       0x1E   0x.... 0x....      BL       W25Q64JV_EraseBlock
    188          
    189              /* Reads current status of the QSPI memory */
    190              EraseStartAddress += 0x10000;
   \       0x22   0xF514 0x3480      ADDS     R4,R4,#+65536
    191            }
   \                     ??SectorErase_0: (+1)
   \       0x26   0x42A5             CMP      R5,R4
   \       0x28   0xD2F8             BCS.N    ??SectorErase_1
    192            
    193            return 1;	
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}
    194          }
    195          
    196          
    197          /**
    198            * Description :
    199            * Calculates checksum value of the memory zone
    200            * Inputs    :
    201            *      StartAddress  : Flash start address
    202            *      Size          : Size (in WORD)  
    203            *      InitVal       : Initial CRC value
    204            * outputs   :
    205            *     R0             : Checksum value
    206            * Note: Optional for all types of device
    207            */

   \                                 In section .text, align 2, keep-with-next
    208          uint32_t CheckSum(uint32_t StartAddress, uint32_t Size, uint32_t InitVal)
    209          {
   \                     CheckSum: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0013             MOVS     R3,R2
    210          
    211            uint8_t missalignementAddress = StartAddress%4;
   \        0x4   0xF010 0x0403      ANDS     R4,R0,#0x3
    212            uint8_t missalignementSize = Size ;
   \        0x8   0x000D             MOVS     R5,R1
    213            int cnt;
    214            uint32_t Val;
    215          	
    216            StartAddress-=StartAddress%4;
   \        0xA   0xF010 0x0203      ANDS     R2,R0,#0x3
   \        0xE   0x1A80             SUBS     R0,R0,R2
    217            Size += (Size%4==0)?0:4-(Size%4);
   \       0x10   0xF011 0x0F03      TST      R1,#0x3
   \       0x14   0xD101             BNE.N    ??CheckSum_0
   \       0x16   0x2200             MOVS     R2,#+0
   \       0x18   0xE003             B.N      ??CheckSum_1
   \                     ??CheckSum_0: (+1)
   \       0x1A   0xF011 0x0203      ANDS     R2,R1,#0x3
   \       0x1E   0xF1D2 0x0204      RSBS     R2,R2,#+4
   \                     ??CheckSum_1: (+1)
   \       0x22   0x1851             ADDS     R1,R2,R1
    218            
    219            for(cnt=0; cnt<Size ; cnt+=4)
   \       0x24   0x2600             MOVS     R6,#+0
   \       0x26   0xE015             B.N      ??CheckSum_2
    220            {
    221              Val = *(uint32_t*)StartAddress;
    222              if(missalignementAddress)
    223              {
    224                switch (missalignementAddress)
    225                {
    226                  case 1:
    227                    InitVal += (uint8_t) (Val>>8 & 0xff);
    228                    InitVal += (uint8_t) (Val>>16 & 0xff);
    229                    InitVal += (uint8_t) (Val>>24 & 0xff);
    230                    missalignementAddress-=1;
    231                    break;
    232                  case 2:
    233                    InitVal += (uint8_t) (Val>>16 & 0xff);
    234                    InitVal += (uint8_t) (Val>>24 & 0xff);
    235                    missalignementAddress-=2;
    236                    break;
    237                  case 3:   
    238                    InitVal += (uint8_t) (Val>>24 & 0xff);
    239                    missalignementAddress-=3;
    240                    break;
    241                }  
    242              }
    243              else if((Size-missalignementSize)%4 && (Size-cnt) <=4)
    244              {
    245                switch (Size-missalignementSize)
    246                {
    247                  case 1:
    248                    InitVal += (uint8_t) Val;
    249                    InitVal += (uint8_t) (Val>>8 & 0xff);
    250                    InitVal += (uint8_t) (Val>>16 & 0xff);
    251                    missalignementSize-=1;
    252                    break;
    253                  case 2:
    254                    InitVal += (uint8_t) Val;
    255                    InitVal += (uint8_t) (Val>>8 & 0xff);
    256                    missalignementSize-=2;
    257                    break;
    258                  case 3:   
    259                    InitVal += (uint8_t) Val;
    260                    missalignementSize-=3;
    261                    break;
    262                } 
    263              }
    264              else
    265              {
    266                InitVal += (uint8_t) Val;
   \                     ??CheckSum_3: (+1)
   \       0x28   0x003A             MOVS     R2,R7
   \       0x2A   0xB2D2             UXTB     R2,R2
   \       0x2C   0x18D3             ADDS     R3,R2,R3
    267                InitVal += (uint8_t) (Val>>8 & 0xff);
   \       0x2E   0x003A             MOVS     R2,R7
   \       0x30   0x0A12             LSRS     R2,R2,#+8
   \       0x32   0xB2D2             UXTB     R2,R2
   \       0x34   0x18D3             ADDS     R3,R2,R3
    268                InitVal += (uint8_t) (Val>>16 & 0xff);
   \       0x36   0x003A             MOVS     R2,R7
   \       0x38   0x0C12             LSRS     R2,R2,#+16
   \       0x3A   0xB2D2             UXTB     R2,R2
   \       0x3C   0x18D3             ADDS     R3,R2,R3
    269                InitVal += (uint8_t) (Val>>24 & 0xff);
   \       0x3E   0x001A             MOVS     R2,R3
   \       0x40   0x003B             MOVS     R3,R7
   \       0x42   0x0E1B             LSRS     R3,R3,#+24
   \       0x44   0xB2DB             UXTB     R3,R3
   \       0x46   0x189B             ADDS     R3,R3,R2
   \       0x48   0xE002             B.N      ??CheckSum_4
    270              }
   \                     ??CheckSum_5: (+1)
   \       0x4A   0xB2FF             UXTB     R7,R7
   \       0x4C   0x18FB             ADDS     R3,R7,R3
   \       0x4E   0x1EED             SUBS     R5,R5,#+3
    271              StartAddress+=4;
   \                     ??CheckSum_4: (+1)
   \       0x50   0x1D00             ADDS     R0,R0,#+4
   \       0x52   0x1D36             ADDS     R6,R6,#+4
   \                     ??CheckSum_2: (+1)
   \       0x54   0x428E             CMP      R6,R1
   \       0x56   0xD257             BCS.N    ??CheckSum_6
   \       0x58   0x6807             LDR      R7,[R0, #+0]
   \       0x5A   0x0022             MOVS     R2,R4
   \       0x5C   0xB2D2             UXTB     R2,R2
   \       0x5E   0x2A00             CMP      R2,#+0
   \       0x60   0xD027             BEQ.N    ??CheckSum_7
   \       0x62   0x0022             MOVS     R2,R4
   \       0x64   0xB2D2             UXTB     R2,R2
   \       0x66   0x2A01             CMP      R2,#+1
   \       0x68   0xD004             BEQ.N    ??CheckSum_8
   \       0x6A   0xD3F1             BCC.N    ??CheckSum_4
   \       0x6C   0x2A03             CMP      R2,#+3
   \       0x6E   0xD01B             BEQ.N    ??CheckSum_9
   \       0x70   0xD30F             BCC.N    ??CheckSum_10
   \       0x72   0xE7ED             B.N      ??CheckSum_4
   \                     ??CheckSum_8: (+1)
   \       0x74   0x003A             MOVS     R2,R7
   \       0x76   0x0A12             LSRS     R2,R2,#+8
   \       0x78   0xB2D2             UXTB     R2,R2
   \       0x7A   0x18D3             ADDS     R3,R2,R3
   \       0x7C   0x003A             MOVS     R2,R7
   \       0x7E   0x0C12             LSRS     R2,R2,#+16
   \       0x80   0xB2D2             UXTB     R2,R2
   \       0x82   0x18D3             ADDS     R3,R2,R3
   \       0x84   0x001A             MOVS     R2,R3
   \       0x86   0x003B             MOVS     R3,R7
   \       0x88   0x0E1B             LSRS     R3,R3,#+24
   \       0x8A   0xB2DB             UXTB     R3,R3
   \       0x8C   0x189B             ADDS     R3,R3,R2
   \       0x8E   0x1E64             SUBS     R4,R4,#+1
   \       0x90   0xE7DE             B.N      ??CheckSum_4
   \                     ??CheckSum_10: (+1)
   \       0x92   0x003A             MOVS     R2,R7
   \       0x94   0x0C12             LSRS     R2,R2,#+16
   \       0x96   0xB2D2             UXTB     R2,R2
   \       0x98   0x18D3             ADDS     R3,R2,R3
   \       0x9A   0x001A             MOVS     R2,R3
   \       0x9C   0x003B             MOVS     R3,R7
   \       0x9E   0x0E1B             LSRS     R3,R3,#+24
   \       0xA0   0xB2DB             UXTB     R3,R3
   \       0xA2   0x189B             ADDS     R3,R3,R2
   \       0xA4   0x1EA4             SUBS     R4,R4,#+2
   \       0xA6   0xE7D3             B.N      ??CheckSum_4
   \                     ??CheckSum_9: (+1)
   \       0xA8   0x0E3F             LSRS     R7,R7,#+24
   \       0xAA   0xB2FF             UXTB     R7,R7
   \       0xAC   0x18FB             ADDS     R3,R7,R3
   \       0xAE   0x1EE4             SUBS     R4,R4,#+3
   \       0xB0   0xE7CE             B.N      ??CheckSum_4
   \                     ??CheckSum_7: (+1)
   \       0xB2   0x002A             MOVS     R2,R5
   \       0xB4   0xB2D2             UXTB     R2,R2
   \       0xB6   0x1A8A             SUBS     R2,R1,R2
   \       0xB8   0xF012 0x0F03      TST      R2,#0x3
   \       0xBC   0xD0B4             BEQ.N    ??CheckSum_3
   \       0xBE   0x1B8A             SUBS     R2,R1,R6
   \       0xC0   0x2A05             CMP      R2,#+5
   \       0xC2   0xD2B1             BCS.N    ??CheckSum_3
   \       0xC4   0x002A             MOVS     R2,R5
   \       0xC6   0xB2D2             UXTB     R2,R2
   \       0xC8   0x1A8A             SUBS     R2,R1,R2
   \       0xCA   0x2A01             CMP      R2,#+1
   \       0xCC   0xD004             BEQ.N    ??CheckSum_11
   \       0xCE   0xD3BF             BCC.N    ??CheckSum_4
   \       0xD0   0x2A03             CMP      R2,#+3
   \       0xD2   0xD0BA             BEQ.N    ??CheckSum_5
   \       0xD4   0xD30E             BCC.N    ??CheckSum_12
   \       0xD6   0xE7BB             B.N      ??CheckSum_4
   \                     ??CheckSum_11: (+1)
   \       0xD8   0x003A             MOVS     R2,R7
   \       0xDA   0xB2D2             UXTB     R2,R2
   \       0xDC   0x18D3             ADDS     R3,R2,R3
   \       0xDE   0x003A             MOVS     R2,R7
   \       0xE0   0x0A12             LSRS     R2,R2,#+8
   \       0xE2   0xB2D2             UXTB     R2,R2
   \       0xE4   0x18D3             ADDS     R3,R2,R3
   \       0xE6   0x001A             MOVS     R2,R3
   \       0xE8   0x003B             MOVS     R3,R7
   \       0xEA   0x0C1B             LSRS     R3,R3,#+16
   \       0xEC   0xB2DB             UXTB     R3,R3
   \       0xEE   0x189B             ADDS     R3,R3,R2
   \       0xF0   0x1E6D             SUBS     R5,R5,#+1
   \       0xF2   0xE7AD             B.N      ??CheckSum_4
   \                     ??CheckSum_12: (+1)
   \       0xF4   0x003A             MOVS     R2,R7
   \       0xF6   0xB2D2             UXTB     R2,R2
   \       0xF8   0x18D3             ADDS     R3,R2,R3
   \       0xFA   0x001A             MOVS     R2,R3
   \       0xFC   0x003B             MOVS     R3,R7
   \       0xFE   0x0A1B             LSRS     R3,R3,#+8
   \      0x100   0xB2DB             UXTB     R3,R3
   \      0x102   0x189B             ADDS     R3,R3,R2
   \      0x104   0x1EAD             SUBS     R5,R5,#+2
   \      0x106   0xE7A3             B.N      ??CheckSum_4
    272            }
    273            
    274            return (InitVal);
   \                     ??CheckSum_6: (+1)
   \      0x108   0x0018             MOVS     R0,R3
   \      0x10A   0xBCF0             POP      {R4-R7}
   \      0x10C   0x4770             BX       LR
    275          }
    276          
    277          
    278          /**
    279            * Description :
    280            * Verify flash memory with RAM buffer and calculates checksum value of
    281            * the programmed memory
    282            * Inputs    :
    283            *      FlashAddr     : Flash address
    284            *      RAMBufferAddr : RAM buffer address
    285            *      Size          : Size (in WORD)  
    286            *      InitVal       : Initial CRC value
    287            * outputs   :
    288            *     R0             : Operation failed (address of failure)
    289            *     R1             : Checksum value
    290            * Note: Optional for all types of device
    291            */

   \                                 In section .text, align 2, keep-with-next, root
    292          KeepInCompilation uint64_t Verify (uint32_t MemoryAddr, uint32_t RAMBufferAddr, uint32_t Size, uint32_t missalignement)
    293          {
   \                     Verify: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    294            uint32_t VerifiedData = 0, InitVal = 0;
   \        0x8   0x2700             MOVS     R7,#+0
   \        0xA   0x2200             MOVS     R2,#+0
    295            uint64_t checksum;
    296            Size*=4;
   \        0xC   0x00B6             LSLS     R6,R6,#+2
    297          
    298            
    299            checksum = CheckSum((uint32_t)MemoryAddr + (missalignement & 0xf), Size - ((missalignement >> 16) & 0xF), InitVal);
   \        0xE   0xF3C3 0x4103      UBFX     R1,R3,#+16,#+4
   \       0x12   0x1A71             SUBS     R1,R6,R1
   \       0x14   0xF013 0x030F      ANDS     R3,R3,#0xF
   \       0x18   0x191B             ADDS     R3,R3,R4
   \       0x1A   0x0018             MOVS     R0,R3
   \       0x1C   0x.... 0x....      BL       CheckSum
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0xE000             B.N      ??Verify_0
    300            while (Size>VerifiedData)
    301            {
    302              if ( *(uint8_t*)MemoryAddr++ != *((uint8_t*)RAMBufferAddr + VerifiedData))
    303                return ((checksum<<32) + (MemoryAddr + VerifiedData));  
    304             
    305              VerifiedData++;  
   \                     ??Verify_1: (+1)
   \       0x24   0x1C7F             ADDS     R7,R7,#+1
   \                     ??Verify_0: (+1)
   \       0x26   0x42B7             CMP      R7,R6
   \       0x28   0xD20C             BCS.N    ??Verify_2
   \       0x2A   0x0022             MOVS     R2,R4
   \       0x2C   0x1C54             ADDS     R4,R2,#+1
   \       0x2E   0x7812             LDRB     R2,[R2, #+0]
   \       0x30   0x5DEB             LDRB     R3,[R5, R7]
   \       0x32   0x429A             CMP      R2,R3
   \       0x34   0xD0F6             BEQ.N    ??Verify_1
   \       0x36   0x0001             MOVS     R1,R0
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x193C             ADDS     R4,R7,R4
   \       0x3C   0x2500             MOVS     R5,#+0
   \       0x3E   0x1900             ADDS     R0,R0,R4
   \       0x40   0x4169             ADCS     R1,R1,R5
   \       0x42   0xE001             B.N      ??Verify_3
    306            }
    307                  
    308            return (checksum<<32);
   \                     ??Verify_2: (+1)
   \       0x44   0x0001             MOVS     R1,R0
   \       0x46   0x2000             MOVS     R0,#+0
   \                     ??Verify_3: (+1)
   \       0x48   0xBDF4             POP      {R2,R4-R7,PC}
    309          }
    310          
    311          
    312          /**
    313            * @brief  System Clock Configuration
    314            *         The system Clock is configured as follow :
    315            *            System Clock source            = PLL (HSE)
    316            *            SYSCLK(Hz)                     = 180000000
    317            *            HCLK(Hz)                       = 180000000
    318            *            AHB Prescaler                  = 1
    319            *            APB1 Prescaler                 = 4
    320            *            APB2 Prescaler                 = 2
    321            *            HSE Frequency(Hz)              = 8000000
    322            *            PLL_M                          = 8
    323            *            PLL_N                          = 360
    324            *            PLL_P                          = 2
    325            *            PLL_Q                          = 7
    326            *            PLL_R                          = 6
    327            *            VDD(V)                         = 3.3
    328            *            Main regulator output voltage  = Scale1 mode
    329            *            Flash Latency(WS)              = 5
    330            * @param  None
    331            * @retval None
    332            */

   \                                 In section .text, align 2, keep-with-next
    333          int SystemClock_Config(void)
    334          {
   \                     SystemClock_Config: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB09B             SUB      SP,SP,#+108
   \        0x4   0x2150             MOVS     R1,#+80
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0xAC07             ADD      R4,SP,#+28
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       __aeabi_memset
   \       0x10   0x2118             MOVS     R1,#+24
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0xAC01             ADD      R4,SP,#+4
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       __aeabi_memset
    335            RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    336            RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
    337          
    338            /** Configure the main internal regulator output voltage
    339            */
    340            __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
   \       0x1C   0x....             LDR.N    R0,??DataTable3_4
   \       0x1E   0x6801             LDR      R1,[R0, #+0]
   \       0x20   0xF031 0x0130      BICS     R1,R1,#0x30
   \       0x24   0x6001             STR      R1,[R0, #+0]
   \       0x26   0x6800             LDR      R0,[R0, #+0]
   \       0x28   0xF010 0x0030      ANDS     R0,R0,#0x30
   \       0x2C   0x9000             STR      R0,[SP, #+0]
   \       0x2E   0x9800             LDR      R0,[SP, #+0]
    341          
    342            while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
   \                     ??SystemClock_Config_0: (+1)
   \       0x30   0x....             LDR.N    R0,??DataTable3_5
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0x0700             LSLS     R0,R0,#+28
   \       0x36   0xD5FB             BPL.N    ??SystemClock_Config_0
    343          
    344            /** Initializes the RCC Oscillators according to the specified parameters
    345            * in the RCC_OscInitTypeDef structure.
    346            */
    347            RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
   \       0x38   0x2002             MOVS     R0,#+2
   \       0x3A   0x9007             STR      R0,[SP, #+28]
    348            RCC_OscInitStruct.HSIState = RCC_HSI_ON;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0x900A             STR      R0,[SP, #+40]
    349            RCC_OscInitStruct.HSIDiv = RCC_HSI_DIV2;
   \       0x40   0x2008             MOVS     R0,#+8
   \       0x42   0x900B             STR      R0,[SP, #+44]
    350            RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
   \       0x44   0x2040             MOVS     R0,#+64
   \       0x46   0x900C             STR      R0,[SP, #+48]
    351            RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x9011             STR      R0,[SP, #+68]
    352            HAL_RCC_OscConfig(&RCC_OscInitStruct);
   \       0x4C   0xA807             ADD      R0,SP,#+28
   \       0x4E   0x.... 0x....      BL       HAL_RCC_OscConfig
    353          
    354            /** Initializes the CPU, AHB and APB buses clocks
    355            */
    356            RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
    357                                        |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
    358                                        |RCC_CLOCKTYPE_PCLK3;
   \       0x52   0x201F             MOVS     R0,#+31
   \       0x54   0x9001             STR      R0,[SP, #+4]
    359            RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x9002             STR      R0,[SP, #+8]
    360            RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x9003             STR      R0,[SP, #+12]
    361            RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x9004             STR      R0,[SP, #+16]
    362            RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x9005             STR      R0,[SP, #+20]
    363            RCC_ClkInitStruct.APB3CLKDivider = RCC_HCLK_DIV1;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x9006             STR      R0,[SP, #+24]
    364          
    365            HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);
   \       0x6A   0x2101             MOVS     R1,#+1
   \       0x6C   0xA801             ADD      R0,SP,#+4
   \       0x6E   0x.... 0x....      BL       HAL_RCC_ClockConfig
    366            
    367            return 1;
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0xB01C             ADD      SP,SP,#+112
   \       0x76   0xBD10             POP      {R4,PC}
    368          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     huart1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     SFB(`.bss`)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x....'....        DC32     SIZEOF(`.bss`)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x4402'0810        DC32     0x44020810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0x4402'0814        DC32     0x44020814

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x61 0x70          DC8 "app start\012"
   \              0x70 0x20    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x0A    
   \              0x00
   \        0xB                      DS8 1
    369          
    370          
    371          
    372          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CheckSum
       0   HAL_GetTick
       0   HAL_InitTick
       8   Init
         8   -> DoTestFunctionInit
         8   -> HAL_Init
         8   -> SystemClock_Config
         8   -> SystemInit
         8   -> __aeabi_memset
         8   -> printf
       8   MassErase
         8   -> QSPI_DeInit
         8   -> QSPI_Init
         8   -> W25Q64JV_EraseChip
      16   SectorErase
        16   -> QSPI_DeInit
        16   -> QSPI_Init
        16   -> W25Q64JV_EraseBlock
     120   SystemClock_Config
       120   -> HAL_RCC_ClockConfig
       120   -> HAL_RCC_OscConfig
       120   -> __aeabi_memset
      24   Verify
        24   -> CheckSum
      16   Write
        16   -> QSPI_DeInit
        16   -> QSPI_Init
        16   -> W25Q64JV_ProgramRaw
      16   __write
        16   -> iar_fputc
       8   iar_fputc
         8   -> HAL_UART_Transmit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
      12  ?_0
     270  CheckSum
       4  HAL_GetTick
       4  HAL_InitTick
      46  Init
      26  MassErase
      46  SectorErase
     120  SystemClock_Config
      74  Verify
      44  Write
      28  __write
      92  hospi1
     148  huart1
      20  iar_fputc

 
 240 bytes in section .bss
  12 bytes in section .rodata
 706 bytes in section .text
 
 706 bytes of CODE  memory
  12 bytes of CONST memory
 240 bytes of DATA  memory

Errors: none
Warnings: 1
