###############################################################################
#
# IAR ANSI C/C++ Compiler V9.40.1.364/W64 for ARM         23/Nov/2023  21:46:18
# Copyright 1999-2023 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\w25q64jv_driver.c
#    Command line      =
#        -f
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\w25q64jv_driver.o.rsp
#        (C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\w25q64jv_driver.c
#        -D STM32H562xx -lCN
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir
#        -lA
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir
#        -o
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33.no_dsp.no_se -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\CMSIS\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Library\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Loader\
#        -Ol) --dependencies=n
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\w25q64jv_driver.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir\w25q64jv_driver.lst
#    Object file       =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\w25q64jv_driver.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\w25q64jv_driver.c
      1          #include "w25q64jv_driver.h"
      2          
      3          extern XSPI_HandleTypeDef hospi1;
      4          extern UART_HandleTypeDef huart1;
      5          
      6          //static W25Q_STATE W25Q64JV_ReadRaw(uint8_t* pData, uint16_t len, uint32_t RawAddr);
      7          static W25Q_STATE W25Q64JV_WriteEnable(uint8_t enable);
      8          static W25Q_STATE W25Q64JV_ReadStatusReg(uint8_t* RegValue, uint8_t StatusReg);
      9          static W25Q_STATE W25Q64JV_WriteStatusReg(uint8_t RegValue, uint8_t StatusReg);
     10          static W25Q_STATE W25Q64JV_IsBusy(void);
     11          //static uint32_t PageToAddr(uint32_t nPage, uint8_t PageShift);
     12          /**
     13            * @brief OCTOSPI1 Initialization Function
     14            * @param None
     15            * @retval None
     16            */

   \                                 In section .text, align 2, keep-with-next
     17          void QSPI_Init(void)
     18          {  
   \                     QSPI_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
     19            HAL_XSPI_MspInit(&hospi1);
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable12
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x.... 0x....      BL       HAL_XSPI_MspInit
     20              
     21            /* QSPI parametqer configuration */
     22            hospi1.Instance = OCTOSPI1;
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \       0x10   0x6020             STR      R0,[R4, #+0]
     23            hospi1.Init.FifoThresholdByte = 1;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x6060             STR      R0,[R4, #+4]
     24            hospi1.Init.MemoryMode = HAL_XSPI_SINGLE_MEM;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x60A0             STR      R0,[R4, #+8]
     25            hospi1.Init.MemoryType = HAL_XSPI_MEMTYPE_MICRON;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x60E0             STR      R0,[R4, #+12]
     26            hospi1.Init.MemorySize = HAL_XSPI_SIZE_8MB;
   \       0x1E   0x2013             MOVS     R0,#+19
   \       0x20   0x6120             STR      R0,[R4, #+16]
     27            hospi1.Init.ChipSelectHighTimeCycle = 1;
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x6160             STR      R0,[R4, #+20]
     28            hospi1.Init.FreeRunningClock = HAL_XSPI_FREERUNCLK_DISABLE;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x61A0             STR      R0,[R4, #+24]
     29            hospi1.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x61E0             STR      R0,[R4, #+28]
     30            hospi1.Init.WrapSize = HAL_XSPI_WRAP_NOT_SUPPORTED;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x6220             STR      R0,[R4, #+32]
     31            hospi1.Init.ClockPrescaler = 6;
   \       0x32   0x2006             MOVS     R0,#+6
   \       0x34   0x6260             STR      R0,[R4, #+36]
     32            hospi1.Init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x62A0             STR      R0,[R4, #+40]
     33            hospi1.Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x62E0             STR      R0,[R4, #+44]
     34            hospi1.Init.ChipSelectBoundary = HAL_XSPI_BONDARYOF_NONE;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x6320             STR      R0,[R4, #+48]
     35            hospi1.Init.DelayBlockBypass = HAL_XSPI_DELAY_BLOCK_BYPASS;
   \       0x42   0x2008             MOVS     R0,#+8
   \       0x44   0x6360             STR      R0,[R4, #+52]
     36            hospi1.Init.Refresh = 0;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x63A0             STR      R0,[R4, #+56]
     37          
     38            HAL_XSPI_Init(&hospi1);
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       HAL_XSPI_Init
     39            
     40            W25Q64JV_QaudModeEnable();
   \       0x50   0x.... 0x....      BL       W25Q64JV_QaudModeEnable
     41            for(int i = 0; i < 0xEFFF; i++){
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xE000             B.N      ??QSPI_Init_0
   \                     ??QSPI_Init_1: (+1)
   \       0x58   0x1C40             ADDS     R0,R0,#+1
   \                     ??QSPI_Init_0: (+1)
   \       0x5A   0xF64E 0x74FF      MOVW     R4,#+61439
   \       0x5E   0x42A0             CMP      R0,R4
   \       0x60   0xDBFA             BLT.N    ??QSPI_Init_1
     42            }
     43            
     44            W25Q64JV_ResetMemory();
   \       0x62   0x.... 0x....      BL       W25Q64JV_ResetMemory
     45            for(int i = 0; i < 0xEFFF; i++){
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xE000             B.N      ??QSPI_Init_2
   \                     ??QSPI_Init_3: (+1)
   \       0x6A   0x1C40             ADDS     R0,R0,#+1
   \                     ??QSPI_Init_2: (+1)
   \       0x6C   0x42A0             CMP      R0,R4
   \       0x6E   0xDBFC             BLT.N    ??QSPI_Init_3
     46            }
     47          }
   \       0x70   0xBD10             POP      {R4,PC}
     48          

   \                                 In section .text, align 2, keep-with-next
     49          void QSPI_DeInit(void)
     50          {
   \                     QSPI_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     51            HAL_XSPI_DeInit(&hospi1);
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable12
   \        0x6   0x.... 0x....      BL       HAL_XSPI_DeInit
     52          
     53            __HAL_RCC_OSPI1_FORCE_RESET();
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0xF451 0x1180      ORRS     R1,R1,#0x100000
   \       0x14   0x6001             STR      R1,[R0, #+0]
     54            __HAL_RCC_OSPI1_RELEASE_RESET();
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0xF431 0x1180      BICS     R1,R1,#0x100000
   \       0x1C   0x6001             STR      R1,[R0, #+0]
     55          }
   \       0x1E   0xBD01             POP      {R0,PC}
     56          

   \                                 In section .text, align 2, keep-with-next
     57          W25Q_STATE W25Q64JV_MemoryMappedMode(void)
     58          {
   \                     W25Q64JV_MemoryMappedMode: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB096             SUB      SP,SP,#+88
   \        0x4   0x2250             MOVS     R2,#+80
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0xA802             ADD      R0,SP,#+8
   \        0xA   0x.... 0x....      BL       memset
   \        0xE   0x2208             MOVS     R2,#+8
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x4668             MOV      R0,SP
   \       0x14   0x.... 0x....      BL       memset
     59            XSPI_RegularCmdTypeDef Commands = {0};
     60            XSPI_MemoryMappedTypeDef MemMappedCfg = {0};  
     61          
     62            if(W25Q64JV_WriteEnable(1) != W25Q_OK){    
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x.... 0x....      BL       W25Q64JV_WriteEnable
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD001             BEQ.N    ??W25Q64JV_MemoryMappedMode_0
     63              return W25Q_SPI_ERR;
   \       0x22   0x2004             MOVS     R0,#+4
   \       0x24   0xE02B             B.N      ??W25Q64JV_MemoryMappedMode_1
     64            }
     65          
     66            Commands.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
   \                     ??W25Q64JV_MemoryMappedMode_0: (+1)
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0x9002             STR      R0,[SP, #+8]
     67            Commands.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0x9005             STR      R0,[SP, #+20]
     68            Commands.Instruction = W25Q_FAST_READ_QUAD_OUT;
   \       0x2E   0x206B             MOVS     R0,#+107
   \       0x30   0x9004             STR      R0,[SP, #+16]
     69            Commands.AddressMode = HAL_XSPI_ADDRESS_1_LINE;
   \       0x32   0xF44F 0x7080      MOV      R0,#+256
   \       0x36   0x9009             STR      R0,[SP, #+36]
     70            Commands.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
   \       0x38   0xF44F 0x5000      MOV      R0,#+8192
   \       0x3C   0x900A             STR      R0,[SP, #+40]
     71            Commands.DataMode = HAL_XSPI_DATA_4_LINES;
   \       0x3E   0xF05F 0x7040      MOVS     R0,#+50331648
   \       0x42   0x9010             STR      R0,[SP, #+64]
     72            Commands.DummyCycles = 8U;
   \       0x44   0x2008             MOVS     R0,#+8
   \       0x46   0x9013             STR      R0,[SP, #+76]
     73            Commands.DQSMode = HAL_XSPI_DQS_DISABLE;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x9014             STR      R0,[SP, #+80]
     74          
     75            if(HAL_XSPI_Command(&hospi1, &Commands, MAX_TIMEOUT_VALUE) != HAL_OK){      
   \       0x4C   0x.... 0x....      LDR.W    R4,??DataTable12
   \       0x50   0xF07F 0x427F      MVNS     R2,#+4278190080
   \       0x54   0xA902             ADD      R1,SP,#+8
   \       0x56   0x0020             MOVS     R0,R4
   \       0x58   0x.... 0x....      BL       HAL_XSPI_Command
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD001             BEQ.N    ??W25Q64JV_MemoryMappedMode_2
     76              return W25Q_SPI_ERR;
   \       0x60   0x2004             MOVS     R0,#+4
   \       0x62   0xE00C             B.N      ??W25Q64JV_MemoryMappedMode_1
     77            }
     78          
     79            MemMappedCfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_ENABLE;
   \                     ??W25Q64JV_MemoryMappedMode_2: (+1)
   \       0x64   0x2008             MOVS     R0,#+8
   \       0x66   0x9000             STR      R0,[SP, #+0]
     80            MemMappedCfg.TimeoutPeriodClock = 0x50;
   \       0x68   0x2050             MOVS     R0,#+80
   \       0x6A   0x9001             STR      R0,[SP, #+4]
     81          
     82            if(HAL_XSPI_MemoryMapped(&hospi1, &MemMappedCfg) != HAL_OK){      
   \       0x6C   0x4669             MOV      R1,SP
   \       0x6E   0x0020             MOVS     R0,R4
   \       0x70   0x.... 0x....      BL       HAL_XSPI_MemoryMapped
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD001             BEQ.N    ??W25Q64JV_MemoryMappedMode_3
     83              return W25Q_SPI_ERR;
   \       0x78   0x2004             MOVS     R0,#+4
   \       0x7A   0xE000             B.N      ??W25Q64JV_MemoryMappedMode_1
     84            }
     85          
     86            return W25Q_OK;
   \                     ??W25Q64JV_MemoryMappedMode_3: (+1)
   \       0x7C   0x2000             MOVS     R0,#+0
   \                     ??W25Q64JV_MemoryMappedMode_1: (+1)
   \       0x7E   0xB016             ADD      SP,SP,#+88
   \       0x80   0xBD10             POP      {R4,PC}
     87          }
     88          

   \                                 In section .text, align 2, keep-with-next
     89          W25Q_STATE W25Q64JV_EraseChip(void)
     90          {  
   \                     W25Q64JV_EraseChip: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xB094             SUB      SP,SP,#+80
   \        0x4   0x2250             MOVS     R2,#+80
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x4668             MOV      R0,SP
   \        0xA   0x.... 0x....      BL       memset
     91            XSPI_RegularCmdTypeDef Commands = {0};
     92          
     93            while (W25Q64JV_IsBusy() == W25Q_BUSY) {
   \                     ??W25Q64JV_EraseChip_0: (+1)
   \        0xE   0x.... 0x....      BL       W25Q64JV_IsBusy
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD0FB             BEQ.N    ??W25Q64JV_EraseChip_0
     94            }
     95          
     96            if(W25Q64JV_WriteEnable(1) != W25Q_OK){
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x.... 0x....      BL       W25Q64JV_WriteEnable
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD001             BEQ.N    ??W25Q64JV_EraseChip_1
     97              return W25Q_SPI_ERR;
   \       0x20   0x2004             MOVS     R0,#+4
   \       0x22   0xE021             B.N      ??W25Q64JV_EraseChip_2
     98            }
     99          
    100            Commands.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
   \                     ??W25Q64JV_EraseChip_1: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x9000             STR      R0,[SP, #+0]
    101            Commands.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0x9003             STR      R0,[SP, #+12]
    102            Commands.Instruction = W25Q_CHIP_ERASE;
   \       0x2C   0x20C7             MOVS     R0,#+199
   \       0x2E   0x9002             STR      R0,[SP, #+8]
    103            Commands.AddressMode = HAL_XSPI_ADDRESS_NONE;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x9007             STR      R0,[SP, #+28]
    104            Commands.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x900B             STR      R0,[SP, #+44]
    105            Commands.DummyCycles = 0U;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x9011             STR      R0,[SP, #+68]
    106            Commands.DataMode = HAL_XSPI_DATA_NONE;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x900E             STR      R0,[SP, #+56]
    107            Commands.DataLength = 0U;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x900F             STR      R0,[SP, #+60]
    108            Commands.DQSMode = HAL_XSPI_DQS_DISABLE;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x9012             STR      R0,[SP, #+72]
    109          
    110            if(HAL_XSPI_Command(&hospi1, &Commands, MAX_TIMEOUT_VALUE) != HAL_OK){  
   \       0x48   0xF07F 0x427F      MVNS     R2,#+4278190080
   \       0x4C   0x4669             MOV      R1,SP
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x52   0x.... 0x....      BL       HAL_XSPI_Command
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD001             BEQ.N    ??W25Q64JV_EraseChip_3
    111              return W25Q_SPI_ERR;
   \       0x5A   0x2004             MOVS     R0,#+4
   \       0x5C   0xE004             B.N      ??W25Q64JV_EraseChip_2
    112            }
    113          
    114            while(W25Q64JV_IsBusy() == W25Q_BUSY){
   \                     ??W25Q64JV_EraseChip_3: (+1)
   \       0x5E   0x.... 0x....      BL       W25Q64JV_IsBusy
   \       0x62   0x2801             CMP      R0,#+1
   \       0x64   0xD0FB             BEQ.N    ??W25Q64JV_EraseChip_3
    115            }
    116          
    117            return W25Q_OK;
   \       0x66   0x2000             MOVS     R0,#+0
   \                     ??W25Q64JV_EraseChip_2: (+1)
   \       0x68   0xB015             ADD      SP,SP,#+84
   \       0x6A   0xBD00             POP      {PC}
    118          }
    119          

   \                                 In section .text, align 2, keep-with-next
    120          W25Q_STATE W25Q64JV_EraseBlock(uint32_t BlockAddr)
    121          {  
   \                     W25Q64JV_EraseBlock: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB094             SUB      SP,SP,#+80
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x2250             MOVS     R2,#+80
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x.... 0x....      BL       memset
    122            XSPI_RegularCmdTypeDef Commands = { 0 };
    123            uint32_t RawAddr = 0;
   \       0x10   0x2000             MOVS     R0,#+0
    124          
    125            if (BlockAddr >= BLOCK_COUNT) {
   \       0x12   0x2C80             CMP      R4,#+128
   \       0x14   0xD301             BCC.N    ??W25Q64JV_EraseBlock_0
    126              return W25Q_PARAM_ERR;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0xE032             B.N      ??W25Q64JV_EraseBlock_1
    127            }
    128          
    129            while (W25Q64JV_IsBusy() == W25Q_BUSY) {
   \                     ??W25Q64JV_EraseBlock_0: (+1)
   \       0x1A   0x.... 0x....      BL       W25Q64JV_IsBusy
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD0FB             BEQ.N    ??W25Q64JV_EraseBlock_0
    130            }
    131          
    132            RawAddr = BlockAddr * MEM_BLOCK_SIZE * 1024U;
   \       0x22   0x0424             LSLS     R4,R4,#+16
    133          
    134            if(W25Q64JV_WriteEnable(1) != W25Q_OK){
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x.... 0x....      BL       W25Q64JV_WriteEnable
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD001             BEQ.N    ??W25Q64JV_EraseBlock_2
    135              return W25Q_SPI_ERR;
   \       0x2E   0x2004             MOVS     R0,#+4
   \       0x30   0xE026             B.N      ??W25Q64JV_EraseBlock_1
    136            }
    137          
    138            Commands.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
   \                     ??W25Q64JV_EraseBlock_2: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x9000             STR      R0,[SP, #+0]
    139            Commands.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0x9003             STR      R0,[SP, #+12]
    140            Commands.Instruction = W25Q_64KB_BLOCK_ERASE;
   \       0x3A   0x20D8             MOVS     R0,#+216
   \       0x3C   0x9002             STR      R0,[SP, #+8]
    141            Commands.AddressMode = HAL_XSPI_ADDRESS_1_LINE;
   \       0x3E   0xF44F 0x7080      MOV      R0,#+256
   \       0x42   0x9007             STR      R0,[SP, #+28]
    142            Commands.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
   \       0x44   0xF44F 0x5000      MOV      R0,#+8192
   \       0x48   0x9008             STR      R0,[SP, #+32]
    143            Commands.Address = RawAddr;
   \       0x4A   0x9406             STR      R4,[SP, #+24]
    144            Commands.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x900B             STR      R0,[SP, #+44]
    145            Commands.DummyCycles = 0U;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x9011             STR      R0,[SP, #+68]
    146            Commands.DataMode = HAL_XSPI_DATA_NONE;
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x900E             STR      R0,[SP, #+56]
    147            Commands.DataLength = 0U;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x900F             STR      R0,[SP, #+60]
    148            Commands.DQSMode = HAL_XSPI_DQS_DISABLE;
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x9012             STR      R0,[SP, #+72]
    149          
    150            if(HAL_XSPI_Command(&hospi1, &Commands, MAX_TIMEOUT_VALUE) != HAL_OK){
   \       0x60   0xF07F 0x427F      MVNS     R2,#+4278190080
   \       0x64   0x4669             MOV      R1,SP
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x6A   0x.... 0x....      BL       HAL_XSPI_Command
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD001             BEQ.N    ??W25Q64JV_EraseBlock_3
    151              return W25Q_SPI_ERR;
   \       0x72   0x2004             MOVS     R0,#+4
   \       0x74   0xE004             B.N      ??W25Q64JV_EraseBlock_1
    152            }
    153          
    154            while(W25Q64JV_IsBusy() == W25Q_BUSY){
   \                     ??W25Q64JV_EraseBlock_3: (+1)
   \       0x76   0x.... 0x....      BL       W25Q64JV_IsBusy
   \       0x7A   0x2801             CMP      R0,#+1
   \       0x7C   0xD0FB             BEQ.N    ??W25Q64JV_EraseBlock_3
    155            }
    156          
    157            return W25Q_OK;
   \       0x7E   0x2000             MOVS     R0,#+0
   \                     ??W25Q64JV_EraseBlock_1: (+1)
   \       0x80   0xB014             ADD      SP,SP,#+80
   \       0x82   0xBD10             POP      {R4,PC}
    158          }
    159          
    160          #if 0
    161          W25Q_STATE W25Q64JV_Program(uint8_t* pData, uint16_t len, uint8_t PageShift, uint32_t nPage)
    162          {
    163            uint32_t RawAddr = 0;
    164            if (nPage >= PAGE_COUNT || len == 0 || len > 256 || PageShift > 256 - len) {
    165              return W25Q_PARAM_ERR;
    166            }
    167          
    168            RawAddr = PageToAddr(nPage, PageShift);
    169          
    170            return W25Q64JV_ProgramRaw(pData, len, RawAddr);
    171          }
    172          #endif
    173          

   \                                 In section .text, align 2, keep-with-next
    174          W25Q_STATE W25Q64JV_ProgramRaw(uint8_t* pData, uint16_t len, uint32_t RawAddr)
    175          {
   \                     W25Q64JV_ProgramRaw: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB094             SUB      SP,SP,#+80
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x2250             MOVS     R2,#+80
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x4668             MOV      R0,SP
   \       0x12   0x.... 0x....      BL       memset
    176            XSPI_RegularCmdTypeDef Commands = { 0 };
    177            uint32_t EndAddr = 0;
   \       0x16   0x2000             MOVS     R0,#+0
    178            uint32_t CurrentAddr = 0;
   \       0x18   0x2000             MOVS     R0,#+0
    179            uint32_t CurrentSize = 0;
   \       0x1A   0x2000             MOVS     R0,#+0
    180          
    181            if (len > 256 || len == 0) {
   \       0x1C   0x0028             MOVS     R0,R5
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0xF240 0x1101      MOVW     R1,#+257
   \       0x24   0x4288             CMP      R0,R1
   \       0x26   0xDA03             BGE.N    ??W25Q64JV_ProgramRaw_0
   \       0x28   0x0028             MOVS     R0,R5
   \       0x2A   0xB280             UXTH     R0,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD101             BNE.N    ??W25Q64JV_ProgramRaw_1
    182              return W25Q_PARAM_ERR;
   \                     ??W25Q64JV_ProgramRaw_0: (+1)
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xE056             B.N      ??W25Q64JV_ProgramRaw_2
    183            }
    184            
    185            /* Calculation of the size between the write address and the end of the page */
    186            CurrentSize = MEM_PAGE_SIZE - (RawAddr % MEM_PAGE_SIZE);
   \                     ??W25Q64JV_ProgramRaw_1: (+1)
   \       0x34   0xF008 0x06FF      AND      R6,R8,#0xFF
   \       0x38   0xF5D6 0x7680      RSBS     R6,R6,#+256
    187          
    188            /* Check if the size of the data is less than the remaining place in the page */
    189            if (CurrentSize > len){
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0xB280             UXTH     R0,R0
   \       0x40   0x42B0             CMP      R0,R6
   \       0x42   0xD201             BCS.N    ??W25Q64JV_ProgramRaw_3
    190                CurrentSize = len;
   \       0x44   0x002E             MOVS     R6,R5
   \       0x46   0xB2B6             UXTH     R6,R6
    191            }
    192          
    193            /* Initialize the address variables */
    194            CurrentAddr = RawAddr;
   \                     ??W25Q64JV_ProgramRaw_3: (+1)
   \       0x48   0x4647             MOV      R7,R8
    195            EndAddr = RawAddr + len;
   \       0x4A   0xB2AD             UXTH     R5,R5
   \       0x4C   0xEB15 0x0508      ADDS     R5,R5,R8
    196            
    197            Commands.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x9000             STR      R0,[SP, #+0]
    198            Commands.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0x9003             STR      R0,[SP, #+12]
    199            Commands.Instruction = W25Q_PAGE_PROGRAM_QUAD_INP_4B;
   \       0x58   0x2034             MOVS     R0,#+52
   \       0x5A   0x9002             STR      R0,[SP, #+8]
    200            Commands.AddressMode = HAL_XSPI_ADDRESS_1_LINE;
   \       0x5C   0xF44F 0x7880      MOV      R8,#+256
   \       0x60   0xF8CD 0x801C      STR      R8,[SP, #+28]
    201            Commands.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
   \       0x64   0xF44F 0x5000      MOV      R0,#+8192
   \       0x68   0x9008             STR      R0,[SP, #+32]
    202            Commands.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x900B             STR      R0,[SP, #+44]
    203            Commands.DummyCycles = 0U;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0x9011             STR      R0,[SP, #+68]
    204            Commands.DataMode = HAL_XSPI_DATA_4_LINES;
   \       0x72   0xF05F 0x7040      MOVS     R0,#+50331648
   \       0x76   0x900E             STR      R0,[SP, #+56]
    205            Commands.DQSMode = HAL_XSPI_DQS_DISABLE;
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0x9012             STR      R0,[SP, #+72]
    206          
    207            do{
    208              Commands.Address = CurrentAddr;
   \                     ??W25Q64JV_ProgramRaw_4: (+1)
   \       0x7C   0x9706             STR      R7,[SP, #+24]
    209              Commands.DataLength = CurrentSize;
   \       0x7E   0x960F             STR      R6,[SP, #+60]
    210          
    211              while (W25Q64JV_IsBusy() == W25Q_BUSY) {
   \                     ??W25Q64JV_ProgramRaw_5: (+1)
   \       0x80   0x.... 0x....      BL       W25Q64JV_IsBusy
   \       0x84   0x2801             CMP      R0,#+1
   \       0x86   0xD0FB             BEQ.N    ??W25Q64JV_ProgramRaw_5
    212              }
    213          
    214              if(W25Q64JV_WriteEnable(1) != W25Q_OK){
   \       0x88   0x2001             MOVS     R0,#+1
   \       0x8A   0x.... 0x....      BL       W25Q64JV_WriteEnable
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD11D             BNE.N    ??W25Q64JV_ProgramRaw_6
    215                return W25Q_SPI_ERR;
    216              }
    217          
    218              if(HAL_XSPI_Command(&hospi1, &Commands, MAX_TIMEOUT_VALUE) != HAL_OK){
   \                     ??W25Q64JV_ProgramRaw_7: (+1)
   \       0x92   0x.... 0x....      LDR.W    R9,??DataTable12
   \       0x96   0xF07F 0x4A7F      MVNS     R10,#+4278190080
   \       0x9A   0x4652             MOV      R2,R10
   \       0x9C   0x4669             MOV      R1,SP
   \       0x9E   0x4648             MOV      R0,R9
   \       0xA0   0x.... 0x....      BL       HAL_XSPI_Command
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD114             BNE.N    ??W25Q64JV_ProgramRaw_8
    219                return W25Q_SPI_ERR;
    220              }
    221          
    222              if(HAL_XSPI_Transmit(&hospi1, pData, MAX_TIMEOUT_VALUE) != HAL_OK){
   \                     ??W25Q64JV_ProgramRaw_9: (+1)
   \       0xA8   0x4652             MOV      R2,R10
   \       0xAA   0x0021             MOVS     R1,R4
   \       0xAC   0x4648             MOV      R0,R9
   \       0xAE   0x.... 0x....      BL       HAL_XSPI_Transmit
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD10F             BNE.N    ??W25Q64JV_ProgramRaw_10
    223                return W25Q_SPI_ERR;
    224              }
    225          
    226              while (W25Q64JV_IsBusy() == W25Q_BUSY) {
   \                     ??W25Q64JV_ProgramRaw_11: (+1)
   \       0xB6   0x.... 0x....      BL       W25Q64JV_IsBusy
   \       0xBA   0x2801             CMP      R0,#+1
   \       0xBC   0xD0FB             BEQ.N    ??W25Q64JV_ProgramRaw_11
    227              }
    228          
    229              /* Update the address and size ariables for next page programming */
    230              CurrentAddr += CurrentSize;
   \       0xBE   0x19F7             ADDS     R7,R6,R7
    231              pData += CurrentSize;
   \       0xC0   0x4434             ADD      R4,R4,R6
    232              CurrentSize = ((CurrentAddr + MEM_PAGE_SIZE) > EndAddr) ? (EndAddr - CurrentAddr) : MEM_PAGE_SIZE;
   \       0xC2   0xF517 0x7080      ADDS     R0,R7,#+256
   \       0xC6   0x4285             CMP      R5,R0
   \       0xC8   0xD207             BCS.N    ??W25Q64JV_ProgramRaw_12
   \       0xCA   0x1BEE             SUBS     R6,R5,R7
   \       0xCC   0xE006             B.N      ??W25Q64JV_ProgramRaw_13
   \                     ??W25Q64JV_ProgramRaw_6: (+1)
   \       0xCE   0x2004             MOVS     R0,#+4
   \       0xD0   0xE007             B.N      ??W25Q64JV_ProgramRaw_2
   \                     ??W25Q64JV_ProgramRaw_8: (+1)
   \       0xD2   0x2004             MOVS     R0,#+4
   \       0xD4   0xE005             B.N      ??W25Q64JV_ProgramRaw_2
   \                     ??W25Q64JV_ProgramRaw_10: (+1)
   \       0xD6   0x2004             MOVS     R0,#+4
   \       0xD8   0xE003             B.N      ??W25Q64JV_ProgramRaw_2
    233              
    234            }while(CurrentAddr < EndAddr);
   \                     ??W25Q64JV_ProgramRaw_12: (+1)
   \       0xDA   0x4646             MOV      R6,R8
   \                     ??W25Q64JV_ProgramRaw_13: (+1)
   \       0xDC   0x42AF             CMP      R7,R5
   \       0xDE   0xD3CD             BCC.N    ??W25Q64JV_ProgramRaw_4
    235            
    236            return W25Q_OK;
   \       0xE0   0x2000             MOVS     R0,#+0
   \                     ??W25Q64JV_ProgramRaw_2: (+1)
   \       0xE2   0xB014             ADD      SP,SP,#+80
   \       0xE4   0xE8BD 0x87F0      POP      {R4-R10,PC}
    237          }
    238          
    239          #if 0
    240          static W25Q_STATE W25Q64JV_ReadRaw(uint8_t* pData, uint16_t len, uint32_t RawAddr)
    241          {  
    242            XSPI_RegularCmdTypeDef Commands = { 0 };
    243          
    244            if (len > 256 || len == 0) {
    245              return W25Q_PARAM_ERR;
    246            }
    247          
    248            while (W25Q64JV_IsBusy() == W25Q_BUSY) {
    249            }
    250          
    251            Commands.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
    252            Commands.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
    253            Commands.Instruction = W25Q_FAST_READ_QUAD_IO;
    254            Commands.AddressMode = HAL_XSPI_ADDRESS_4_LINES;
    255            Commands.Address = RawAddr;
    256            Commands.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
    257            Commands.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
    258            Commands.DummyCycles = 6U;
    259            Commands.DataMode = HAL_XSPI_DATA_4_LINES;
    260            Commands.DataLength = len;
    261            Commands.DQSMode = HAL_XSPI_DQS_DISABLE;
    262          
    263            if(HAL_XSPI_Command(&hospi1, &Commands, MAX_TIMEOUT_VALUE) != HAL_OK){
    264                return W25Q_SPI_ERR;
    265            }
    266          
    267            if(HAL_XSPI_Receive(&hospi1, pData, MAX_TIMEOUT_VALUE) != HAL_OK){  
    268              return W25Q_SPI_ERR;
    269            }
    270          
    271            return W25Q_OK;
    272          }
    273          #endif

   \                                 In section .text, align 2, keep-with-next
    274          W25Q_STATE W25Q64JV_ResetMemory(void)
    275          {
   \                     W25Q64JV_ResetMemory: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB094             SUB      SP,SP,#+80
   \        0x4   0x2250             MOVS     R2,#+80
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x4668             MOV      R0,SP
   \        0xA   0x.... 0x....      BL       memset
    276            XSPI_RegularCmdTypeDef Commands = {0};  
    277            
    278            Commands.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x9000             STR      R0,[SP, #+0]
    279            Commands.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x9003             STR      R0,[SP, #+12]
    280            Commands.Instruction = W25Q_ENABLE_RST;
   \       0x16   0x2066             MOVS     R0,#+102
   \       0x18   0x9002             STR      R0,[SP, #+8]
    281            Commands.AddressMode = HAL_XSPI_ADDRESS_NONE;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x9007             STR      R0,[SP, #+28]
    282            Commands.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x900B             STR      R0,[SP, #+44]
    283            Commands.DummyCycles = 0U;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x9011             STR      R0,[SP, #+68]
    284            Commands.DataMode = HAL_XSPI_DATA_NONE;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x900E             STR      R0,[SP, #+56]
    285            Commands.DataLength = 0U;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x900F             STR      R0,[SP, #+60]
    286            Commands.DQSMode = HAL_XSPI_DQS_DISABLE;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x9012             STR      R0,[SP, #+72]
    287          
    288            if(HAL_XSPI_Command(&hospi1, &Commands, MAX_TIMEOUT_VALUE) != HAL_OK){  
   \       0x32   0x.... 0x....      LDR.W    R4,??DataTable12
   \       0x36   0xF07F 0x457F      MVNS     R5,#+4278190080
   \       0x3A   0x002A             MOVS     R2,R5
   \       0x3C   0x4669             MOV      R1,SP
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x.... 0x....      BL       HAL_XSPI_Command
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD001             BEQ.N    ??W25Q64JV_ResetMemory_0
    289              return W25Q_SPI_ERR;
   \       0x48   0x2004             MOVS     R0,#+4
   \       0x4A   0xE00F             B.N      ??W25Q64JV_ResetMemory_1
    290            }
    291            
    292            Commands.Instruction = W25Q_RESET;
   \                     ??W25Q64JV_ResetMemory_0: (+1)
   \       0x4C   0x2099             MOVS     R0,#+153
   \       0x4E   0x9002             STR      R0,[SP, #+8]
    293            if(HAL_XSPI_Command(&hospi1, &Commands, MAX_TIMEOUT_VALUE) != HAL_OK){  
   \       0x50   0x002A             MOVS     R2,R5
   \       0x52   0x4669             MOV      R1,SP
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0x.... 0x....      BL       HAL_XSPI_Command
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD001             BEQ.N    ??W25Q64JV_ResetMemory_2
    294              return W25Q_SPI_ERR;
   \       0x5E   0x2004             MOVS     R0,#+4
   \       0x60   0xE004             B.N      ??W25Q64JV_ResetMemory_1
    295            }
    296            
    297            while (W25Q64JV_IsBusy() == W25Q_BUSY) {
   \                     ??W25Q64JV_ResetMemory_2: (+1)
   \       0x62   0x.... 0x....      BL       W25Q64JV_IsBusy
   \       0x66   0x2801             CMP      R0,#+1
   \       0x68   0xD0FB             BEQ.N    ??W25Q64JV_ResetMemory_2
    298            }
    299            
    300            return W25Q_OK;
   \       0x6A   0x2000             MOVS     R0,#+0
   \                     ??W25Q64JV_ResetMemory_1: (+1)
   \       0x6C   0xB015             ADD      SP,SP,#+84
   \       0x6E   0xBD30             POP      {R4,R5,PC}
    301          }
    302          

   \                                 In section .text, align 2, keep-with-next
    303          W25Q_STATE W25Q64JV_QaudModeEnable(void)
    304          {  
   \                     W25Q64JV_QaudModeEnable: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    305            uint8_t RegValue = 0;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0xF88D 0x0000      STRB     R0,[SP, #+0]
    306          
    307            if(W25Q64JV_ReadStatusReg(&RegValue, 2) != W25Q_OK){  
   \        0x8   0x2102             MOVS     R1,#+2
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x.... 0x....      BL       W25Q64JV_ReadStatusReg
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD001             BEQ.N    ??W25Q64JV_QaudModeEnable_0
    308              return W25Q_SPI_ERR;
   \       0x14   0x2004             MOVS     R0,#+4
   \       0x16   0xE019             B.N      ??W25Q64JV_QaudModeEnable_1
    309            }
    310          
    311            RegValue |= 0x2;
   \                     ??W25Q64JV_QaudModeEnable_0: (+1)
   \       0x18   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x1C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x20   0xF88D 0x0000      STRB     R0,[SP, #+0]
    312            if(W25Q64JV_WriteStatusReg(RegValue, 2) != W25Q_OK){  
   \       0x24   0x2102             MOVS     R1,#+2
   \       0x26   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2A   0x.... 0x....      BL       W25Q64JV_WriteStatusReg
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD001             BEQ.N    ??W25Q64JV_QaudModeEnable_2
    313              return W25Q_SPI_ERR;
   \       0x32   0x2004             MOVS     R0,#+4
   \       0x34   0xE00A             B.N      ??W25Q64JV_QaudModeEnable_1
    314            }
    315          
    316            /* Verification */
    317            if ((RegValue & W25Q_WEL_MASK) != W25Q_WEL_MASK) {
   \                     ??W25Q64JV_QaudModeEnable_2: (+1)
   \       0x36   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x3A   0x0780             LSLS     R0,R0,#+30
   \       0x3C   0xD401             BMI.N    ??W25Q64JV_QaudModeEnable_3
    318              return W25Q_SPI_ERR;
   \       0x3E   0x2004             MOVS     R0,#+4
   \       0x40   0xE004             B.N      ??W25Q64JV_QaudModeEnable_1
    319            }
    320          
    321            while (W25Q64JV_IsBusy() == W25Q_BUSY) {
   \                     ??W25Q64JV_QaudModeEnable_3: (+1)
   \       0x42   0x.... 0x....      BL       W25Q64JV_IsBusy
   \       0x46   0x2801             CMP      R0,#+1
   \       0x48   0xD0FB             BEQ.N    ??W25Q64JV_QaudModeEnable_3
    322            }
    323          
    324            return W25Q_OK;
   \       0x4A   0x2000             MOVS     R0,#+0
   \                     ??W25Q64JV_QaudModeEnable_1: (+1)
   \       0x4C   0xBD02             POP      {R1,PC}
    325          }
    326          

   \                                 In section .text, align 2, keep-with-next
    327          static W25Q_STATE W25Q64JV_WriteEnable(uint8_t enable)
    328          {
   \                     W25Q64JV_WriteEnable: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB094             SUB      SP,SP,#+80
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x2250             MOVS     R2,#+80
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x.... 0x....      BL       memset
    329            XSPI_RegularCmdTypeDef Commands = {0};  
    330            
    331            Commands.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x9000             STR      R0,[SP, #+0]
    332            Commands.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x9003             STR      R0,[SP, #+12]
    333            Commands.Instruction = enable ? W25Q_WRITE_ENABLE : W25Q_WRITE_DISABLE;
   \       0x18   0xB2E4             UXTB     R4,R4
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD001             BEQ.N    ??W25Q64JV_WriteEnable_0
   \       0x1E   0x2006             MOVS     R0,#+6
   \       0x20   0xE000             B.N      ??W25Q64JV_WriteEnable_1
   \                     ??W25Q64JV_WriteEnable_0: (+1)
   \       0x22   0x2004             MOVS     R0,#+4
   \                     ??W25Q64JV_WriteEnable_1: (+1)
   \       0x24   0x9002             STR      R0,[SP, #+8]
    334            Commands.AddressMode = HAL_XSPI_ADDRESS_NONE;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x9007             STR      R0,[SP, #+28]
    335            Commands.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x900B             STR      R0,[SP, #+44]
    336            Commands.DummyCycles = 0U;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x9011             STR      R0,[SP, #+68]
    337            Commands.DataMode = HAL_XSPI_DATA_NONE;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x900E             STR      R0,[SP, #+56]
    338            Commands.DataLength = 0U;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x900F             STR      R0,[SP, #+60]
    339            Commands.DQSMode = HAL_XSPI_DQS_DISABLE;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x9012             STR      R0,[SP, #+72]
    340          
    341            if(HAL_XSPI_Command(&hospi1, &Commands, MAX_TIMEOUT_VALUE) != HAL_OK){     
   \       0x3E   0xF07F 0x427F      MVNS     R2,#+4278190080
   \       0x42   0x4669             MOV      R1,SP
   \       0x44   0x....             LDR.N    R0,??DataTable12
   \       0x46   0x.... 0x....      BL       HAL_XSPI_Command
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD001             BEQ.N    ??W25Q64JV_WriteEnable_2
    342              return W25Q_SPI_ERR;
   \       0x4E   0x2004             MOVS     R0,#+4
   \       0x50   0xE000             B.N      ??W25Q64JV_WriteEnable_3
    343            }
    344          
    345            //W25qStatus.WEL = 0x01;
    346          
    347            return W25Q_OK;
   \                     ??W25Q64JV_WriteEnable_2: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \                     ??W25Q64JV_WriteEnable_3: (+1)
   \       0x54   0xB014             ADD      SP,SP,#+80
   \       0x56   0xBD10             POP      {R4,PC}
    348          }
    349          
    350          

   \                                 In section .text, align 2, keep-with-next
    351          static W25Q_STATE W25Q64JV_ReadStatusReg(uint8_t* RegValue, uint8_t StatusReg)
    352          {
   \                     W25Q64JV_ReadStatusReg: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB094             SUB      SP,SP,#+80
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x2250             MOVS     R2,#+80
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x.... 0x....      BL       memset
    353            XSPI_RegularCmdTypeDef Commands = { 0 };  
    354          
    355            Commands.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x9003             STR      R0,[SP, #+12]
    356            switch (StatusReg) {
   \       0x16   0xB2ED             UXTB     R5,R5
   \       0x18   0x2D01             CMP      R5,#+1
   \       0x1A   0xD004             BEQ.N    ??W25Q64JV_ReadStatusReg_0
   \       0x1C   0xD30C             BCC.N    ??W25Q64JV_ReadStatusReg_1
   \       0x1E   0x2D03             CMP      R5,#+3
   \       0x20   0xD007             BEQ.N    ??W25Q64JV_ReadStatusReg_2
   \       0x22   0xD303             BCC.N    ??W25Q64JV_ReadStatusReg_3
   \       0x24   0xE008             B.N      ??W25Q64JV_ReadStatusReg_1
    357            case 1:
    358              Commands.Instruction = W25Q_READ_SR1;
   \                     ??W25Q64JV_ReadStatusReg_0: (+1)
   \       0x26   0x2005             MOVS     R0,#+5
   \       0x28   0x9002             STR      R0,[SP, #+8]
    359              break;
   \       0x2A   0xE007             B.N      ??W25Q64JV_ReadStatusReg_4
    360            case 2:
    361              Commands.Instruction = W25Q_READ_SR2;
   \                     ??W25Q64JV_ReadStatusReg_3: (+1)
   \       0x2C   0x2035             MOVS     R0,#+53
   \       0x2E   0x9002             STR      R0,[SP, #+8]
    362              break;
   \       0x30   0xE004             B.N      ??W25Q64JV_ReadStatusReg_4
    363            case 3:
    364              Commands.Instruction = W25Q_READ_SR3;
   \                     ??W25Q64JV_ReadStatusReg_2: (+1)
   \       0x32   0x2015             MOVS     R0,#+21
   \       0x34   0x9002             STR      R0,[SP, #+8]
    365              break;
   \       0x36   0xE001             B.N      ??W25Q64JV_ReadStatusReg_4
    366            default:
    367              Commands.Instruction = W25Q_READ_SR1;
   \                     ??W25Q64JV_ReadStatusReg_1: (+1)
   \       0x38   0x2005             MOVS     R0,#+5
   \       0x3A   0x9002             STR      R0,[SP, #+8]
    368              break;
    369            }
    370          
    371            Commands.AddressMode = HAL_XSPI_ADDRESS_NONE;
   \                     ??W25Q64JV_ReadStatusReg_4: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x9007             STR      R0,[SP, #+28]
    372            Commands.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x900B             STR      R0,[SP, #+44]
    373            Commands.DummyCycles = 0U;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x9011             STR      R0,[SP, #+68]
    374            Commands.DataMode = HAL_XSPI_DATA_1_LINE;
   \       0x48   0xF05F 0x7080      MOVS     R0,#+16777216
   \       0x4C   0x900E             STR      R0,[SP, #+56]
    375            Commands.DataLength = 1U;
   \       0x4E   0x2001             MOVS     R0,#+1
   \       0x50   0x900F             STR      R0,[SP, #+60]
    376            Commands.DQSMode = HAL_XSPI_DQS_DISABLE;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x9012             STR      R0,[SP, #+72]
    377          
    378            if(HAL_XSPI_Command(&hospi1, &Commands, MAX_TIMEOUT_VALUE) != HAL_OK){  
   \       0x56   0x....             LDR.N    R5,??DataTable12
   \       0x58   0xF07F 0x467F      MVNS     R6,#+4278190080
   \       0x5C   0x0032             MOVS     R2,R6
   \       0x5E   0x4669             MOV      R1,SP
   \       0x60   0x0028             MOVS     R0,R5
   \       0x62   0x.... 0x....      BL       HAL_XSPI_Command
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD001             BEQ.N    ??W25Q64JV_ReadStatusReg_5
    379              return W25Q_SPI_ERR;
   \       0x6A   0x2004             MOVS     R0,#+4
   \       0x6C   0xE009             B.N      ??W25Q64JV_ReadStatusReg_6
    380            }
    381          
    382            if(HAL_XSPI_Receive(&hospi1, RegValue, MAX_TIMEOUT_VALUE) != HAL_OK){  
   \                     ??W25Q64JV_ReadStatusReg_5: (+1)
   \       0x6E   0x0032             MOVS     R2,R6
   \       0x70   0x0021             MOVS     R1,R4
   \       0x72   0x0028             MOVS     R0,R5
   \       0x74   0x.... 0x....      BL       HAL_XSPI_Receive
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD001             BEQ.N    ??W25Q64JV_ReadStatusReg_7
    383              return W25Q_SPI_ERR;
   \       0x7C   0x2004             MOVS     R0,#+4
   \       0x7E   0xE000             B.N      ??W25Q64JV_ReadStatusReg_6
    384            }
    385          
    386            return W25Q_OK;
   \                     ??W25Q64JV_ReadStatusReg_7: (+1)
   \       0x80   0x2000             MOVS     R0,#+0
   \                     ??W25Q64JV_ReadStatusReg_6: (+1)
   \       0x82   0xB014             ADD      SP,SP,#+80
   \       0x84   0xBD70             POP      {R4-R6,PC}
    387          }
    388          

   \                                 In section .text, align 2, keep-with-next
    389          static W25Q_STATE W25Q64JV_WriteStatusReg(uint8_t RegValue, uint8_t StatusReg)
    390          {
   \                     W25Q64JV_WriteStatusReg: (+1)
   \        0x0   0xB531             PUSH     {R0,R4,R5,LR}
   \        0x2   0xB094             SUB      SP,SP,#+80
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x2250             MOVS     R2,#+80
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x.... 0x....      BL       memset
    391            XSPI_RegularCmdTypeDef Commands = { 0 };
    392          
    393            while (W25Q64JV_IsBusy() == W25Q_BUSY) {
   \                     ??W25Q64JV_WriteStatusReg_0: (+1)
   \       0x10   0x.... 0x....      BL       W25Q64JV_IsBusy
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD0FB             BEQ.N    ??W25Q64JV_WriteStatusReg_0
    394            }
    395          
    396            if(W25Q64JV_WriteEnable(1) != W25Q_OK){
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x.... 0x....      BL       W25Q64JV_WriteEnable
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD001             BEQ.N    ??W25Q64JV_WriteStatusReg_1
    397              return W25Q_SPI_ERR;
   \       0x22   0x2004             MOVS     R0,#+4
   \       0x24   0xE037             B.N      ??W25Q64JV_WriteStatusReg_2
    398            }
    399          
    400            Commands.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
   \                     ??W25Q64JV_WriteStatusReg_1: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x9000             STR      R0,[SP, #+0]
    401            Commands.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0x9003             STR      R0,[SP, #+12]
    402            switch (StatusReg) {
   \       0x2E   0xB2E4             UXTB     R4,R4
   \       0x30   0x2C01             CMP      R4,#+1
   \       0x32   0xD004             BEQ.N    ??W25Q64JV_WriteStatusReg_3
   \       0x34   0xD30C             BCC.N    ??W25Q64JV_WriteStatusReg_4
   \       0x36   0x2C03             CMP      R4,#+3
   \       0x38   0xD007             BEQ.N    ??W25Q64JV_WriteStatusReg_5
   \       0x3A   0xD303             BCC.N    ??W25Q64JV_WriteStatusReg_6
   \       0x3C   0xE008             B.N      ??W25Q64JV_WriteStatusReg_4
    403            case 1:
    404              Commands.Instruction = W25Q_READ_SR1;
   \                     ??W25Q64JV_WriteStatusReg_3: (+1)
   \       0x3E   0x2005             MOVS     R0,#+5
   \       0x40   0x9002             STR      R0,[SP, #+8]
    405              break;
   \       0x42   0xE005             B.N      ??W25Q64JV_WriteStatusReg_7
    406            case 2:
    407              Commands.Instruction = W25Q_READ_SR2;
   \                     ??W25Q64JV_WriteStatusReg_6: (+1)
   \       0x44   0x2035             MOVS     R0,#+53
   \       0x46   0x9002             STR      R0,[SP, #+8]
    408              break;
   \       0x48   0xE002             B.N      ??W25Q64JV_WriteStatusReg_7
    409            case 3:
    410              Commands.Instruction = W25Q_READ_SR3;
   \                     ??W25Q64JV_WriteStatusReg_5: (+1)
   \       0x4A   0x2015             MOVS     R0,#+21
   \       0x4C   0x9002             STR      R0,[SP, #+8]
    411              break;
   \       0x4E   0xE7FF             B.N      ??W25Q64JV_WriteStatusReg_7
    412            default:
    413              break;
    414            }
    415          
    416            Commands.AddressMode = HAL_XSPI_ADDRESS_NONE;
   \                     ??W25Q64JV_WriteStatusReg_4: (+1)
   \                     ??W25Q64JV_WriteStatusReg_7: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x9007             STR      R0,[SP, #+28]
    417            Commands.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x900B             STR      R0,[SP, #+44]
    418            Commands.DummyCycles = 0U;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x9011             STR      R0,[SP, #+68]
    419            Commands.DataMode = HAL_XSPI_DATA_1_LINE;
   \       0x5C   0xF05F 0x7080      MOVS     R0,#+16777216
   \       0x60   0x900E             STR      R0,[SP, #+56]
    420            Commands.DataLength = 1U;
   \       0x62   0x2001             MOVS     R0,#+1
   \       0x64   0x900F             STR      R0,[SP, #+60]
    421            Commands.DQSMode = HAL_XSPI_DQS_DISABLE;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x9012             STR      R0,[SP, #+72]
    422          
    423            if(HAL_XSPI_Command(&hospi1, &Commands, MAX_TIMEOUT_VALUE) != HAL_OK){  
   \       0x6A   0x....             LDR.N    R4,??DataTable12
   \       0x6C   0xF07F 0x457F      MVNS     R5,#+4278190080
   \       0x70   0x002A             MOVS     R2,R5
   \       0x72   0x4669             MOV      R1,SP
   \       0x74   0x0020             MOVS     R0,R4
   \       0x76   0x.... 0x....      BL       HAL_XSPI_Command
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD001             BEQ.N    ??W25Q64JV_WriteStatusReg_8
    424              return W25Q_SPI_ERR;
   \       0x7E   0x2004             MOVS     R0,#+4
   \       0x80   0xE009             B.N      ??W25Q64JV_WriteStatusReg_2
    425            }
    426          
    427            if(HAL_XSPI_Transmit(&hospi1, &RegValue, MAX_TIMEOUT_VALUE) != HAL_OK){  
   \                     ??W25Q64JV_WriteStatusReg_8: (+1)
   \       0x82   0x002A             MOVS     R2,R5
   \       0x84   0xA914             ADD      R1,SP,#+80
   \       0x86   0x0020             MOVS     R0,R4
   \       0x88   0x.... 0x....      BL       HAL_XSPI_Transmit
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD001             BEQ.N    ??W25Q64JV_WriteStatusReg_9
    428              return W25Q_SPI_ERR;
   \       0x90   0x2004             MOVS     R0,#+4
   \       0x92   0xE000             B.N      ??W25Q64JV_WriteStatusReg_2
    429            }
    430          
    431            return W25Q_OK;
   \                     ??W25Q64JV_WriteStatusReg_9: (+1)
   \       0x94   0x2000             MOVS     R0,#+0
   \                     ??W25Q64JV_WriteStatusReg_2: (+1)
   \       0x96   0xB015             ADD      SP,SP,#+84
   \       0x98   0xBD30             POP      {R4,R5,PC}
    432          }
    433          

   \                                 In section .text, align 2, keep-with-next
    434          static W25Q_STATE W25Q64JV_IsBusy(void)
    435          {  
   \                     W25Q64JV_IsBusy: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    436            uint8_t SrReg = 0;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0xF88D 0x0000      STRB     R0,[SP, #+0]
    437            uint8_t BusyReg = 0;
   \        0x8   0x2000             MOVS     R0,#+0
    438          
    439            if(W25Q64JV_ReadStatusReg(&SrReg, 1) != W25Q_OK){  
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x.... 0x....      BL       W25Q64JV_ReadStatusReg
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD001             BEQ.N    ??W25Q64JV_IsBusy_0
    440              return W25Q_SPI_ERR;
   \       0x16   0x2004             MOVS     R0,#+4
   \       0x18   0xE00A             B.N      ??W25Q64JV_IsBusy_1
    441            }
    442          
    443            BusyReg = (SrReg & W25Q_BUSY_MASK);
   \                     ??W25Q64JV_IsBusy_0: (+1)
   \       0x1A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x1E   0xF010 0x0001      ANDS     R0,R0,#0x1
    444          
    445            return BusyReg ? W25Q_BUSY : W25Q_OK;
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD001             BEQ.N    ??W25Q64JV_IsBusy_2
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE000             B.N      ??W25Q64JV_IsBusy_3
   \                     ??W25Q64JV_IsBusy_2: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??W25Q64JV_IsBusy_3: (+1)
   \       0x2E   0xB2C0             UXTB     R0,R0
   \                     ??W25Q64JV_IsBusy_1: (+1)
   \       0x30   0xBD02             POP      {R1,PC}
    446          }
    447          
    448          #if 0
    449          static uint32_t PageToAddr(uint32_t nPage, uint8_t PageShift)
    450          {
    451            return nPage * MEM_PAGE_SIZE + PageShift;
    452          }
    453          #endif
    454          
    455          /**
    456          * @brief XSPI MSP Initialization
    457          * This function configures the hardware resources used in this example
    458          * @param hxspi: XSPI handle pointer
    459          * @retval None
    460          */

   \                                 In section .text, align 2, keep-with-next
    461          void HAL_XSPI_MspInit(XSPI_HandleTypeDef* hxspi)
    462          {
   \                     HAL_XSPI_MspInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB0C8             SUB      SP,SP,#+288
   \        0x4   0x2214             MOVS     R2,#+20
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x4668             MOV      R0,SP
   \        0xA   0x.... 0x....      BL       memset
   \        0xE   0xF44F 0x7284      MOV      R2,#+264
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0xA806             ADD      R0,SP,#+24
   \       0x16   0x.... 0x....      BL       memset
    463            GPIO_InitTypeDef GPIO_InitStruct = {0};
    464            RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
    465            
    466              /** Initializes the peripherals clock
    467               */
    468              PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_OSPI;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x2102             MOVS     R1,#+2
   \       0x1E   0xE9CD 0x0106      STRD     R0,R1,[SP, #+24]
    469              PeriphClkInitStruct.OspiClockSelection = RCC_OSPICLKSOURCE_HCLK;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x903C             STR      R0,[SP, #+240]
    470              HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
   \       0x26   0xA806             ADD      R0,SP,#+24
   \       0x28   0x.... 0x....      BL       HAL_RCCEx_PeriphCLKConfig
    471              
    472              /* Peripheral clock enable */
    473              __HAL_RCC_OSPI1_CLK_ENABLE();
   \       0x2C   0x....             LDR.N    R0,??DataTable12_3
   \       0x2E   0x6801             LDR      R1,[R0, #+0]
   \       0x30   0xF451 0x1180      ORRS     R1,R1,#0x100000
   \       0x34   0x6001             STR      R1,[R0, #+0]
   \       0x36   0x6800             LDR      R0,[R0, #+0]
   \       0x38   0xF410 0x1080      ANDS     R0,R0,#0x100000
   \       0x3C   0x9005             STR      R0,[SP, #+20]
   \       0x3E   0x9805             LDR      R0,[SP, #+20]
    474          
    475              __HAL_RCC_GPIOA_CLK_ENABLE();
   \       0x40   0x....             LDR.N    R0,??DataTable12_4
   \       0x42   0x6801             LDR      R1,[R0, #+0]
   \       0x44   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x48   0x6001             STR      R1,[R0, #+0]
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0xF011 0x0101      ANDS     R1,R1,#0x1
   \       0x50   0x9105             STR      R1,[SP, #+20]
   \       0x52   0x9905             LDR      R1,[SP, #+20]
    476              __HAL_RCC_GPIOB_CLK_ENABLE();
   \       0x54   0x6801             LDR      R1,[R0, #+0]
   \       0x56   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x5A   0x6001             STR      R1,[R0, #+0]
   \       0x5C   0x6800             LDR      R0,[R0, #+0]
   \       0x5E   0xF010 0x0002      ANDS     R0,R0,#0x2
   \       0x62   0x9005             STR      R0,[SP, #+20]
   \       0x64   0x9805             LDR      R0,[SP, #+20]
    477              /**OCTOSPI1 GPIO Configuration
    478              PA6     ------> OCTOSPI1_IO3
    479              PA7     ------> OCTOSPI1_IO2
    480              PB0     ------> OCTOSPI1_IO1
    481              PB1     ------> OCTOSPI1_IO0
    482              PB2     ------> OCTOSPI1_CLK
    483              PB10     ------> OCTOSPI1_NCS
    484              */
    485              GPIO_InitStruct.Pin = GPIO_PIN_6;
   \       0x66   0x2040             MOVS     R0,#+64
   \       0x68   0x9000             STR      R0,[SP, #+0]
    486              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \       0x6A   0x2002             MOVS     R0,#+2
   \       0x6C   0x9001             STR      R0,[SP, #+4]
    487              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0x9002             STR      R0,[SP, #+8]
    488              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \       0x72   0x2003             MOVS     R0,#+3
   \       0x74   0x9003             STR      R0,[SP, #+12]
    489              GPIO_InitStruct.Alternate = GPIO_AF6_OCTOSPI1;
   \       0x76   0x2006             MOVS     R0,#+6
   \       0x78   0x9004             STR      R0,[SP, #+16]
    490              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \       0x7A   0x....             LDR.N    R4,??DataTable12_5
   \       0x7C   0x4669             MOV      R1,SP
   \       0x7E   0x0020             MOVS     R0,R4
   \       0x80   0x.... 0x....      BL       HAL_GPIO_Init
    491          
    492              GPIO_InitStruct.Pin = GPIO_PIN_7;
   \       0x84   0x2080             MOVS     R0,#+128
   \       0x86   0x9000             STR      R0,[SP, #+0]
    493              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \       0x88   0x2002             MOVS     R0,#+2
   \       0x8A   0x9001             STR      R0,[SP, #+4]
    494              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x9002             STR      R0,[SP, #+8]
    495              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \       0x90   0x2003             MOVS     R0,#+3
   \       0x92   0x9003             STR      R0,[SP, #+12]
    496              GPIO_InitStruct.Alternate = GPIO_AF10_OCTOSPI1;
   \       0x94   0x200A             MOVS     R0,#+10
   \       0x96   0x9004             STR      R0,[SP, #+16]
    497              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \       0x98   0x4669             MOV      R1,SP
   \       0x9A   0x0020             MOVS     R0,R4
   \       0x9C   0x.... 0x....      BL       HAL_GPIO_Init
    498          
    499              GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
   \       0xA0   0x2003             MOVS     R0,#+3
   \       0xA2   0x9000             STR      R0,[SP, #+0]
    500              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \       0xA4   0x2002             MOVS     R0,#+2
   \       0xA6   0x9001             STR      R0,[SP, #+4]
    501              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0x9002             STR      R0,[SP, #+8]
    502              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \       0xAC   0x2003             MOVS     R0,#+3
   \       0xAE   0x9003             STR      R0,[SP, #+12]
    503              GPIO_InitStruct.Alternate = GPIO_AF6_OCTOSPI1;
   \       0xB0   0x2006             MOVS     R0,#+6
   \       0xB2   0x9004             STR      R0,[SP, #+16]
    504              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \       0xB4   0x....             LDR.N    R4,??DataTable12_6
   \       0xB6   0x4669             MOV      R1,SP
   \       0xB8   0x0020             MOVS     R0,R4
   \       0xBA   0x.... 0x....      BL       HAL_GPIO_Init
    505          
    506              GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_10;
   \       0xBE   0xF240 0x4004      MOVW     R0,#+1028
   \       0xC2   0x9000             STR      R0,[SP, #+0]
    507              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \       0xC4   0x2002             MOVS     R0,#+2
   \       0xC6   0x9001             STR      R0,[SP, #+4]
    508              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0x9002             STR      R0,[SP, #+8]
    509              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \       0xCC   0x2003             MOVS     R0,#+3
   \       0xCE   0x9003             STR      R0,[SP, #+12]
    510              GPIO_InitStruct.Alternate = GPIO_AF9_OCTOSPI1;
   \       0xD0   0x2009             MOVS     R0,#+9
   \       0xD2   0x9004             STR      R0,[SP, #+16]
    511              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \       0xD4   0x4669             MOV      R1,SP
   \       0xD6   0x0020             MOVS     R0,R4
   \       0xD8   0x.... 0x....      BL       HAL_GPIO_Init
    512          }
   \       0xDC   0xB048             ADD      SP,SP,#+288
   \       0xDE   0xBD10             POP      {R4,PC}
    513          
    514          

   \                                 In section .text, align 2, keep-with-next
    515          void DoTestFunctionInit(void)
    516          {
   \                     DoTestFunctionInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x2214             MOVS     R2,#+20
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0xA801             ADD      R0,SP,#+4
   \        0xA   0x.... 0x....      BL       memset
    517             GPIO_InitTypeDef GPIO_InitStruct = {0};
    518          
    519            /* GPIO Ports Clock Enable */
    520            __HAL_RCC_GPIOA_CLK_ENABLE();
   \        0xE   0x....             LDR.N    R0,??DataTable12_4
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x16   0x6001             STR      R1,[R0, #+0]
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xF011 0x0101      ANDS     R1,R1,#0x1
   \       0x1E   0x9100             STR      R1,[SP, #+0]
   \       0x20   0x9900             LDR      R1,[SP, #+0]
    521            __HAL_RCC_GPIOB_CLK_ENABLE();
   \       0x22   0x6801             LDR      R1,[R0, #+0]
   \       0x24   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x28   0x6001             STR      R1,[R0, #+0]
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0xF010 0x0002      ANDS     R0,R0,#0x2
   \       0x30   0x9000             STR      R0,[SP, #+0]
   \       0x32   0x9800             LDR      R0,[SP, #+0]
    522          
    523            /*Configure GPIO pin Output Level */
    524            HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, GPIO_PIN_RESET);
   \       0x34   0x....             LDR.N    R4,??DataTable12_6
   \       0x36   0x2200             MOVS     R2,#+0
   \       0x38   0x2108             MOVS     R1,#+8
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0x.... 0x....      BL       HAL_GPIO_WritePin
    525          
    526            /*Configure GPIO pin : PB3 */
    527            GPIO_InitStruct.Pin = GPIO_PIN_3;
   \       0x40   0x2008             MOVS     R0,#+8
   \       0x42   0x9001             STR      R0,[SP, #+4]
    528            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x9002             STR      R0,[SP, #+8]
    529            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x9003             STR      R0,[SP, #+12]
    530            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
   \       0x4C   0x2002             MOVS     R0,#+2
   \       0x4E   0x9004             STR      R0,[SP, #+16]
    531            HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \       0x50   0xA901             ADD      R1,SP,#+4
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       HAL_GPIO_Init
    532            
    533            huart1.Instance = USART1;
   \       0x58   0x....             LDR.N    R0,??DataTable12_7
   \       0x5A   0x....             LDR.N    R1,??DataTable12_8
   \       0x5C   0x6001             STR      R1,[R0, #+0]
    534            huart1.Init.BaudRate = 115200;
   \       0x5E   0xF45F 0x31E1      MOVS     R1,#+115200
   \       0x62   0x6041             STR      R1,[R0, #+4]
    535            huart1.Init.WordLength = UART_WORDLENGTH_8B;
   \       0x64   0x2100             MOVS     R1,#+0
   \       0x66   0x6081             STR      R1,[R0, #+8]
    536            huart1.Init.StopBits = UART_STOPBITS_1;
   \       0x68   0x2100             MOVS     R1,#+0
   \       0x6A   0x60C1             STR      R1,[R0, #+12]
    537            huart1.Init.Parity = UART_PARITY_NONE;
   \       0x6C   0x2100             MOVS     R1,#+0
   \       0x6E   0x6101             STR      R1,[R0, #+16]
    538            huart1.Init.Mode = UART_MODE_TX_RX;
   \       0x70   0x210C             MOVS     R1,#+12
   \       0x72   0x6141             STR      R1,[R0, #+20]
    539            huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
   \       0x74   0x2100             MOVS     R1,#+0
   \       0x76   0x6181             STR      R1,[R0, #+24]
    540            huart1.Init.OverSampling = UART_OVERSAMPLING_16;
   \       0x78   0x2100             MOVS     R1,#+0
   \       0x7A   0x61C1             STR      R1,[R0, #+28]
    541            huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
   \       0x7C   0x2100             MOVS     R1,#+0
   \       0x7E   0x6201             STR      R1,[R0, #+32]
    542            huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
   \       0x80   0x2100             MOVS     R1,#+0
   \       0x82   0x6241             STR      R1,[R0, #+36]
    543            huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
   \       0x84   0x2100             MOVS     R1,#+0
   \       0x86   0x6281             STR      R1,[R0, #+40]
    544              
    545            HAL_UART_Init(&huart1);  
   \       0x88   0x.... 0x....      BL       HAL_UART_Init
    546          }
   \       0x8C   0xB006             ADD      SP,SP,#+24
   \       0x8E   0xBD10             POP      {R4,PC}
    547          
    548          /**
    549          * @brief UART MSP Initialization
    550          * This function configures the hardware resources used in this example
    551          * @param huart: UART handle pointer
    552          * @retval None
    553          */

   \                                 In section .text, align 2, keep-with-next
    554          void HAL_UART_MspInit(UART_HandleTypeDef* huart)
    555          {
   \                     HAL_UART_MspInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xB0C8             SUB      SP,SP,#+288
   \        0x4   0x2214             MOVS     R2,#+20
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0xA801             ADD      R0,SP,#+4
   \        0xA   0x.... 0x....      BL       memset
   \        0xE   0xF44F 0x7284      MOV      R2,#+264
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0xA806             ADD      R0,SP,#+24
   \       0x16   0x.... 0x....      BL       memset
    556            GPIO_InitTypeDef GPIO_InitStruct = {0};
    557            RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
    558            /** Initializes the peripherals clock
    559            */  
    560          
    561              PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0xE9CD 0x0106      STRD     R0,R1,[SP, #+24]
    562              PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_HSI;
   \       0x22   0x2003             MOVS     R0,#+3
   \       0x24   0x901D             STR      R0,[SP, #+116]
    563            HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
   \       0x26   0xA806             ADD      R0,SP,#+24
   \       0x28   0x.... 0x....      BL       HAL_RCCEx_PeriphCLKConfig
    564          
    565            /* Peripheral clock enable */
    566            __HAL_RCC_USART1_CLK_ENABLE();
   \       0x2C   0x....             LDR.N    R0,??DataTable12_9
   \       0x2E   0x6801             LDR      R1,[R0, #+0]
   \       0x30   0xF451 0x4180      ORRS     R1,R1,#0x4000
   \       0x34   0x6001             STR      R1,[R0, #+0]
   \       0x36   0x6800             LDR      R0,[R0, #+0]
   \       0x38   0xF410 0x4080      ANDS     R0,R0,#0x4000
   \       0x3C   0x9000             STR      R0,[SP, #+0]
   \       0x3E   0x9800             LDR      R0,[SP, #+0]
    567          
    568              __HAL_RCC_GPIOA_CLK_ENABLE();
   \       0x40   0x....             LDR.N    R0,??DataTable12_4
   \       0x42   0x6801             LDR      R1,[R0, #+0]
   \       0x44   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x48   0x6001             STR      R1,[R0, #+0]
   \       0x4A   0x6800             LDR      R0,[R0, #+0]
   \       0x4C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0x9800             LDR      R0,[SP, #+0]
    569           
    570              /**USART1 GPIO Configuration
    571              PA9     ------> USART1_TX
    572              PA10     ------> USART1_RX
    573              */
    574              GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
   \       0x54   0xF44F 0x60C0      MOV      R0,#+1536
   \       0x58   0x9001             STR      R0,[SP, #+4]
    575              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \       0x5A   0x2002             MOVS     R0,#+2
   \       0x5C   0x9002             STR      R0,[SP, #+8]
    576              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x9003             STR      R0,[SP, #+12]
    577              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
   \       0x62   0x2002             MOVS     R0,#+2
   \       0x64   0x9004             STR      R0,[SP, #+16]
    578              GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
   \       0x66   0x2007             MOVS     R0,#+7
   \       0x68   0x9005             STR      R0,[SP, #+20]
    579              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \       0x6A   0xA901             ADD      R1,SP,#+4
   \       0x6C   0x....             LDR.N    R0,??DataTable12_5
   \       0x6E   0x.... 0x....      BL       HAL_GPIO_Init
    580          
    581          }
   \       0x72   0xB049             ADD      SP,SP,#+292
   \       0x74   0xBD00             POP      {PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     hospi1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x4700'1400        DC32     0x47001400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x4402'0C6C        DC32     0x44020c6c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x4402'0C94        DC32     0x44020c94

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0x4402'0C8C        DC32     0x44020c8c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0x4202'0000        DC32     0x42020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \        0x0   0x4202'0400        DC32     0x42020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \        0x0   0x....'....        DC32     huart1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \        0x0   0x4001'3800        DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \        0x0   0x4402'0CA4        DC32     0x44020ca4

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   DoTestFunctionInit
        32   -> HAL_GPIO_Init
        32   -> HAL_GPIO_WritePin
        32   -> HAL_UART_Init
        32   -> memset
     296   HAL_UART_MspInit
       296   -> HAL_GPIO_Init
       296   -> HAL_RCCEx_PeriphCLKConfig
       296   -> memset
     296   HAL_XSPI_MspInit
       296   -> HAL_GPIO_Init
       296   -> HAL_RCCEx_PeriphCLKConfig
       296   -> memset
       8   QSPI_DeInit
         8   -> HAL_XSPI_DeInit
       8   QSPI_Init
         8   -> HAL_XSPI_Init
         8   -> HAL_XSPI_MspInit
         8   -> W25Q64JV_QaudModeEnable
         8   -> W25Q64JV_ResetMemory
      88   W25Q64JV_EraseBlock
        88   -> HAL_XSPI_Command
        88   -> W25Q64JV_IsBusy
        88   -> W25Q64JV_WriteEnable
        88   -> memset
      88   W25Q64JV_EraseChip
        88   -> HAL_XSPI_Command
        88   -> W25Q64JV_IsBusy
        88   -> W25Q64JV_WriteEnable
        88   -> memset
       8   W25Q64JV_IsBusy
         8   -> W25Q64JV_ReadStatusReg
      96   W25Q64JV_MemoryMappedMode
        96   -> HAL_XSPI_Command
        96   -> HAL_XSPI_MemoryMapped
        96   -> W25Q64JV_WriteEnable
        96   -> memset
     112   W25Q64JV_ProgramRaw
       112   -> HAL_XSPI_Command
       112   -> HAL_XSPI_Transmit
       112   -> W25Q64JV_IsBusy
       112   -> W25Q64JV_WriteEnable
       112   -> memset
       8   W25Q64JV_QaudModeEnable
         8   -> W25Q64JV_IsBusy
         8   -> W25Q64JV_ReadStatusReg
         8   -> W25Q64JV_WriteStatusReg
      96   W25Q64JV_ReadStatusReg
        96   -> HAL_XSPI_Command
        96   -> HAL_XSPI_Receive
        96   -> memset
      96   W25Q64JV_ResetMemory
        96   -> HAL_XSPI_Command
        96   -> W25Q64JV_IsBusy
        96   -> memset
      88   W25Q64JV_WriteEnable
        88   -> HAL_XSPI_Command
        88   -> memset
      96   W25Q64JV_WriteStatusReg
        96   -> HAL_XSPI_Command
        96   -> HAL_XSPI_Transmit
        96   -> W25Q64JV_IsBusy
        96   -> W25Q64JV_WriteEnable
        96   -> memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
     144  DoTestFunctionInit
     118  HAL_UART_MspInit
     224  HAL_XSPI_MspInit
      32  QSPI_DeInit
     114  QSPI_Init
     132  W25Q64JV_EraseBlock
     108  W25Q64JV_EraseChip
      50  W25Q64JV_IsBusy
     130  W25Q64JV_MemoryMappedMode
     232  W25Q64JV_ProgramRaw
      78  W25Q64JV_QaudModeEnable
     134  W25Q64JV_ReadStatusReg
     112  W25Q64JV_ResetMemory
      88  W25Q64JV_WriteEnable
     154  W25Q64JV_WriteStatusReg

 
 1'890 bytes in section .text
 
 1'890 bytes of CODE memory

Errors: none
Warnings: none
