###############################################################################
#
# IAR ANSI C/C++ Compiler V9.40.1.364/W64 for ARM         23/Nov/2023  21:46:16
# Copyright 1999-2023 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_uart_ex.c
#    Command line      =
#        -f
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_uart_ex.o.rsp
#        (C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_uart_ex.c
#        -D STM32H562xx -lCN
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir
#        -lA
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir
#        -o
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33.no_dsp.no_se -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\CMSIS\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Library\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Loader\
#        -Ol) --dependencies=n
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_uart_ex.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir\stm32h5xx_hal_uart_ex.lst
#    Object file       =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_uart_ex.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_uart_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32h5xx_hal_uart_ex.c
      4            * @author  MCD Application Team
      5            * @brief   Extended UART HAL module driver.
      6            *          This file provides firmware functions to manage the following extended
      7            *          functionalities of the Universal Asynchronous Receiver Transmitter Peripheral (UART).
      8            *           + Initialization and de-initialization functions
      9            *           + Peripheral Control functions
     10            *
     11            *
     12            ******************************************************************************
     13            * @attention
     14            *
     15            * Copyright (c) 2023 STMicroelectronics.
     16            * All rights reserved.
     17            *
     18            * This software is licensed under terms that can be found in the LICENSE file
     19            * in the root directory of this software component.
     20            * If no LICENSE file comes with this software, it is provided AS-IS.
     21            *
     22            ******************************************************************************
     23            @verbatim
     24            ==============================================================================
     25                         ##### UART peripheral extended features  #####
     26            ==============================================================================
     27          
     28              (#) Declare a UART_HandleTypeDef handle structure.
     29          
     30              (#) For the UART RS485 Driver Enable mode, initialize the UART registers
     31                  by calling the HAL_RS485Ex_Init() API.
     32          
     33              (#) FIFO mode enabling/disabling and RX/TX FIFO threshold programming.
     34          
     35                  -@- When UART operates in FIFO mode, FIFO mode must be enabled prior
     36                      starting RX/TX transfers. Also RX/TX FIFO thresholds must be
     37                      configured prior starting RX/TX transfers.
     38          
     39            @endverbatim
     40            ******************************************************************************
     41            */
     42          
     43          /* Includes ------------------------------------------------------------------*/
     44          #include "stm32h5xx_hal.h"
     45          
     46          /** @addtogroup STM32H5xx_HAL_Driver
     47            * @{
     48            */
     49          
     50          /** @defgroup UARTEx UARTEx
     51            * @brief UART Extended HAL module driver
     52            * @{
     53            */
     54          
     55          #ifdef HAL_UART_MODULE_ENABLED
     56          
     57          /* Private typedef -----------------------------------------------------------*/
     58          /* Private define ------------------------------------------------------------*/
     59          /** @defgroup UARTEX_Private_Constants UARTEx Private Constants
     60            * @{
     61            */
     62          /* UART RX FIFO depth */
     63          #define RX_FIFO_DEPTH 8U
     64          
     65          /* UART TX FIFO depth */
     66          #define TX_FIFO_DEPTH 8U
     67          /**
     68            * @}
     69            */
     70          
     71          /* Private macros ------------------------------------------------------------*/
     72          /* Private variables ---------------------------------------------------------*/
     73          /* Private function prototypes -----------------------------------------------*/
     74          /** @defgroup UARTEx_Private_Functions UARTEx Private Functions
     75            * @{
     76            */
     77          static void UARTEx_Wakeup_AddressConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection);
     78          static void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart);
     79          /**
     80            * @}
     81            */
     82          
     83          /* Exported functions --------------------------------------------------------*/
     84          
     85          /** @defgroup UARTEx_Exported_Functions  UARTEx Exported Functions
     86            * @{
     87            */
     88          
     89          /** @defgroup UARTEx_Exported_Functions_Group1 Initialization and de-initialization functions
     90            * @brief    Extended Initialization and Configuration Functions
     91            *
     92          @verbatim
     93          ===============================================================================
     94                      ##### Initialization and Configuration functions #####
     95           ===============================================================================
     96              [..]
     97              This subsection provides a set of functions allowing to initialize the USARTx or the UARTy
     98              in asynchronous mode.
     99                (+) For the asynchronous mode the parameters below can be configured:
    100                  (++) Baud Rate
    101                  (++) Word Length
    102                  (++) Stop Bit
    103                  (++) Parity: If the parity is enabled, then the MSB bit of the data written
    104                       in the data register is transmitted but is changed by the parity bit.
    105                  (++) Hardware flow control
    106                  (++) Receiver/transmitter modes
    107                  (++) Over Sampling Method
    108                  (++) One-Bit Sampling Method
    109                (+) For the asynchronous mode, the following advanced features can be configured as well:
    110                  (++) TX and/or RX pin level inversion
    111                  (++) data logical level inversion
    112                  (++) RX and TX pins swap
    113                  (++) RX overrun detection disabling
    114                  (++) DMA disabling on RX error
    115                  (++) MSB first on communication line
    116                  (++) auto Baud rate detection
    117              [..]
    118              The HAL_RS485Ex_Init() API follows the UART RS485 mode configuration
    119               procedures (details for the procedures are available in reference manual).
    120          
    121          @endverbatim
    122          
    123            Depending on the frame length defined by the M1 and M0 bits (7-bit,
    124            8-bit or 9-bit), the possible UART formats are listed in the
    125            following table.
    126          
    127              Table 1. UART frame format.
    128              +-----------------------------------------------------------------------+
    129              |  M1 bit |  M0 bit |  PCE bit  |             UART frame                |
    130              |---------|---------|-----------|---------------------------------------|
    131              |    0    |    0    |    0      |    | SB |    8 bit data   | STB |     |
    132              |---------|---------|-----------|---------------------------------------|
    133              |    0    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    134              |---------|---------|-----------|---------------------------------------|
    135              |    0    |    1    |    0      |    | SB |    9 bit data   | STB |     |
    136              |---------|---------|-----------|---------------------------------------|
    137              |    0    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    138              |---------|---------|-----------|---------------------------------------|
    139              |    1    |    0    |    0      |    | SB |    7 bit data   | STB |     |
    140              |---------|---------|-----------|---------------------------------------|
    141              |    1    |    0    |    1      |    | SB | 6 bit data | PB | STB |     |
    142              +-----------------------------------------------------------------------+
    143          
    144            * @{
    145            */
    146          
    147          /**
    148            * @brief Initialize the RS485 Driver enable feature according to the specified
    149            *         parameters in the UART_InitTypeDef and creates the associated handle.
    150            * @param huart            UART handle.
    151            * @param Polarity         Select the driver enable polarity.
    152            *          This parameter can be one of the following values:
    153            *          @arg @ref UART_DE_POLARITY_HIGH DE signal is active high
    154            *          @arg @ref UART_DE_POLARITY_LOW  DE signal is active low
    155            * @param AssertionTime    Driver Enable assertion time:
    156            *       5-bit value defining the time between the activation of the DE (Driver Enable)
    157            *       signal and the beginning of the start bit. It is expressed in sample time
    158            *       units (1/8 or 1/16 bit time, depending on the oversampling rate)
    159            * @param DeassertionTime  Driver Enable deassertion time:
    160            *       5-bit value defining the time between the end of the last stop bit, in a
    161            *       transmitted message, and the de-activation of the DE (Driver Enable) signal.
    162            *       It is expressed in sample time units (1/8 or 1/16 bit time, depending on the
    163            *       oversampling rate).
    164            * @retval HAL status
    165            */

   \                                 In section .text, align 2, keep-with-next
    166          HAL_StatusTypeDef HAL_RS485Ex_Init(UART_HandleTypeDef *huart, uint32_t Polarity, uint32_t AssertionTime,
    167                                             uint32_t DeassertionTime)
    168          {
   \                     HAL_RS485Ex_Init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
    169            uint32_t temp;
    170          
    171            /* Check the UART handle allocation */
    172            if (huart == NULL)
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD101             BNE.N    ??HAL_RS485Ex_Init_0
    173            {
    174              return HAL_ERROR;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xE03F             B.N      ??HAL_RS485Ex_Init_1
    175            }
    176            /* Check the Driver Enable UART instance */
    177            assert_param(IS_UART_DRIVER_ENABLE_INSTANCE(huart->Instance));
    178          
    179            /* Check the Driver Enable polarity */
    180            assert_param(IS_UART_DE_POLARITY(Polarity));
    181          
    182            /* Check the Driver Enable assertion time */
    183            assert_param(IS_UART_ASSERTIONTIME(AssertionTime));
    184          
    185            /* Check the Driver Enable deassertion time */
    186            assert_param(IS_UART_DEASSERTIONTIME(DeassertionTime));
    187          
    188            if (huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_RS485Ex_Init_0: (+1)
   \       0x12   0xF8D4 0x0088      LDR      R0,[R4, #+136]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD105             BNE.N    ??HAL_RS485Ex_Init_2
    189            {
    190              /* Allocate lock resource and initialize it */
    191              huart->Lock = HAL_UNLOCKED;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xF884 0x0084      STRB     R0,[R4, #+132]
    192          
    193          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    194              UART_InitCallbacksToDefault(huart);
    195          
    196              if (huart->MspInitCallback == NULL)
    197              {
    198                huart->MspInitCallback = HAL_UART_MspInit;
    199              }
    200          
    201              /* Init the low level hardware */
    202              huart->MspInitCallback(huart);
    203          #else
    204              /* Init the low level hardware : GPIO, CLOCK, CORTEX */
    205              HAL_UART_MspInit(huart);
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       HAL_UART_MspInit
    206          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
    207            }
    208          
    209            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_RS485Ex_Init_2: (+1)
   \       0x26   0x2024             MOVS     R0,#+36
   \       0x28   0xF8C4 0x0088      STR      R0,[R4, #+136]
    210          
    211            /* Disable the Peripheral */
    212            __HAL_UART_DISABLE(huart);
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6800             LDR      R0,[R0, #+0]
   \       0x30   0x0840             LSRS     R0,R0,#+1
   \       0x32   0x0040             LSLS     R0,R0,#+1
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x6008             STR      R0,[R1, #+0]
    213          
    214            /* Perform advanced settings configuration */
    215            /* For some items, configuration requires to be done prior TE and RE bits are set */
    216            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
   \       0x38   0x6AA0             LDR      R0,[R4, #+40]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD002             BEQ.N    ??HAL_RS485Ex_Init_3
    217            {
    218              UART_AdvFeatureConfig(huart);
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x.... 0x....      BL       UART_AdvFeatureConfig
    219            }
    220          
    221            /* Set the UART Communication parameters */
    222            if (UART_SetConfig(huart) == HAL_ERROR)
   \                     ??HAL_RS485Ex_Init_3: (+1)
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       UART_SetConfig
   \       0x4A   0x2801             CMP      R0,#+1
   \       0x4C   0xD101             BNE.N    ??HAL_RS485Ex_Init_4
    223            {
    224              return HAL_ERROR;
   \       0x4E   0x2001             MOVS     R0,#+1
   \       0x50   0xE01F             B.N      ??HAL_RS485Ex_Init_1
    225            }
    226          
    227            /* Enable the Driver Enable mode by setting the DEM bit in the CR3 register */
    228            SET_BIT(huart->Instance->CR3, USART_CR3_DEM);
   \                     ??HAL_RS485Ex_Init_4: (+1)
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6880             LDR      R0,[R0, #+8]
   \       0x56   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \       0x5A   0x6821             LDR      R1,[R4, #+0]
   \       0x5C   0x6088             STR      R0,[R1, #+8]
    229          
    230            /* Set the Driver Enable polarity */
    231            MODIFY_REG(huart->Instance->CR3, USART_CR3_DEP, Polarity);
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6880             LDR      R0,[R0, #+8]
   \       0x62   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0x66   0x4305             ORRS     R5,R5,R0
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x6085             STR      R5,[R0, #+8]
    232          
    233            /* Set the Driver Enable assertion and deassertion times */
    234            temp = (AssertionTime << UART_CR1_DEAT_ADDRESS_LSB_POS);
   \       0x6C   0x0576             LSLS     R6,R6,#+21
    235            temp |= (DeassertionTime << UART_CR1_DEDT_ADDRESS_LSB_POS);
   \       0x6E   0xEA56 0x4607      ORRS     R6,R6,R7, LSL #+16
    236            MODIFY_REG(huart->Instance->CR1, (USART_CR1_DEDT | USART_CR1_DEAT), temp);
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x6800             LDR      R0,[R0, #+0]
   \       0x76   0xF36F 0x4019      BFC      R0,#+16,#+10
   \       0x7A   0x4306             ORRS     R6,R6,R0
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x6006             STR      R6,[R0, #+0]
    237          
    238            /* Enable the Peripheral */
    239            __HAL_UART_ENABLE(huart);
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6800             LDR      R0,[R0, #+0]
   \       0x84   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x88   0x6821             LDR      R1,[R4, #+0]
   \       0x8A   0x6008             STR      R0,[R1, #+0]
    240          
    241            /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
    242            return (UART_CheckIdleState(huart));
   \       0x8C   0x0020             MOVS     R0,R4
   \       0x8E   0x.... 0x....      BL       UART_CheckIdleState
   \                     ??HAL_RS485Ex_Init_1: (+1)
   \       0x92   0xBDF2             POP      {R1,R4-R7,PC}
    243          }
    244          
    245          /**
    246            * @}
    247            */
    248          
    249          /** @defgroup UARTEx_Exported_Functions_Group2 IO operation functions
    250            *  @brief Extended functions
    251            *
    252          @verbatim
    253           ===============================================================================
    254                                ##### IO operation functions #####
    255           ===============================================================================
    256              This subsection provides a set of Wakeup and FIFO mode related callback functions.
    257          
    258              (#) Wakeup from Stop mode Callback:
    259                  (+) HAL_UARTEx_WakeupCallback()
    260          
    261              (#) TX/RX Fifos Callbacks:
    262                  (+) HAL_UARTEx_RxFifoFullCallback()
    263                  (+) HAL_UARTEx_TxFifoEmptyCallback()
    264          
    265          @endverbatim
    266            * @{
    267            */
    268          
    269          /**
    270            * @brief UART wakeup from Stop mode callback.
    271            * @param huart UART handle.
    272            * @retval None
    273            */

   \                                 In section .text, align 2
    274          __weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)
    275          {
    276            /* Prevent unused argument(s) compilation warning */
    277            UNUSED(huart);
    278          
    279            /* NOTE : This function should not be modified, when the callback is needed,
    280                      the HAL_UARTEx_WakeupCallback can be implemented in the user file.
    281             */
    282          }
   \                     HAL_UARTEx_WakeupCallback: (+1)
   \        0x0   0x4770             BX       LR
    283          
    284          /**
    285            * @brief  UART RX Fifo full callback.
    286            * @param  huart UART handle.
    287            * @retval None
    288            */

   \                                 In section .text, align 2
    289          __weak void HAL_UARTEx_RxFifoFullCallback(UART_HandleTypeDef *huart)
    290          {
    291            /* Prevent unused argument(s) compilation warning */
    292            UNUSED(huart);
    293          
    294            /* NOTE : This function should not be modified, when the callback is needed,
    295                      the HAL_UARTEx_RxFifoFullCallback can be implemented in the user file.
    296             */
    297          }
   \                     HAL_UARTEx_RxFifoFullCallback: (+1)
   \        0x0   0x4770             BX       LR
    298          
    299          /**
    300            * @brief  UART TX Fifo empty callback.
    301            * @param  huart UART handle.
    302            * @retval None
    303            */

   \                                 In section .text, align 2
    304          __weak void HAL_UARTEx_TxFifoEmptyCallback(UART_HandleTypeDef *huart)
    305          {
    306            /* Prevent unused argument(s) compilation warning */
    307            UNUSED(huart);
    308          
    309            /* NOTE : This function should not be modified, when the callback is needed,
    310                      the HAL_UARTEx_TxFifoEmptyCallback can be implemented in the user file.
    311             */
    312          }
   \                     HAL_UARTEx_TxFifoEmptyCallback: (+1)
   \        0x0   0x4770             BX       LR
    313          
    314          /**
    315            * @}
    316            */
    317          
    318          /** @defgroup UARTEx_Exported_Functions_Group3 Peripheral Control functions
    319            * @brief    Extended Peripheral Control functions
    320            *
    321          @verbatim
    322           ===============================================================================
    323                                ##### Peripheral Control functions #####
    324           ===============================================================================
    325              [..] This section provides the following functions:
    326               (+) HAL_MultiProcessorEx_AddressLength_Set() API optionally sets the UART node address
    327                   detection length to more than 4 bits for multiprocessor address mark wake up.
    328               (+) HAL_UARTEx_StopModeWakeUpSourceConfig() API defines the wake-up from stop mode
    329                   trigger: address match, Start Bit detection or RXNE bit status.
    330               (+) HAL_UARTEx_EnableStopMode() API enables the UART to wake up the MCU from stop mode
    331               (+) HAL_UARTEx_DisableStopMode() API disables the above functionality
    332               (+) HAL_UARTEx_EnableFifoMode() API enables the FIFO mode
    333               (+) HAL_UARTEx_DisableFifoMode() API disables the FIFO mode
    334               (+) HAL_UARTEx_SetTxFifoThreshold() API sets the TX FIFO threshold
    335               (+) HAL_UARTEx_SetRxFifoThreshold() API sets the RX FIFO threshold
    336          
    337              [..] This subsection also provides a set of additional functions providing enhanced reception
    338              services to user. (For example, these functions allow application to handle use cases
    339              where number of data to be received is unknown).
    340          
    341              (#) Compared to standard reception services which only consider number of received
    342                  data elements as reception completion criteria, these functions also consider additional events
    343                  as triggers for updating reception status to caller :
    344                 (+) Detection of inactivity period (RX line has not been active for a given period).
    345                    (++) RX inactivity detected by IDLE event, i.e. RX line has been in idle state (normally high state)
    346                         for 1 frame time, after last received byte.
    347                    (++) RX inactivity detected by RTO, i.e. line has been in idle state
    348                         for a programmable time, after last received byte.
    349                 (+) Detection that a specific character has been received.
    350          
    351              (#) There are two mode of transfer:
    352                 (+) Blocking mode: The reception is performed in polling mode, until either expected number of data is received,
    353                     or till IDLE event occurs. Reception is handled only during function execution.
    354                     When function exits, no data reception could occur. HAL status and number of actually received data elements,
    355                     are returned by function after finishing transfer.
    356                 (+) Non-Blocking mode: The reception is performed using Interrupts or DMA.
    357                     These API's return the HAL status.
    358                     The end of the data processing will be indicated through the
    359                     dedicated UART IRQ when using Interrupt mode or the DMA IRQ when using DMA mode.
    360                     The HAL_UARTEx_RxEventCallback() user callback will be executed during Receive process
    361                     The HAL_UART_ErrorCallback()user callback will be executed when a reception error is detected.
    362          
    363              (#) Blocking mode API:
    364                  (+) HAL_UARTEx_ReceiveToIdle()
    365          
    366              (#) Non-Blocking mode API with Interrupt:
    367                  (+) HAL_UARTEx_ReceiveToIdle_IT()
    368          
    369              (#) Non-Blocking mode API with DMA:
    370                  (+) HAL_UARTEx_ReceiveToIdle_DMA()
    371          
    372          @endverbatim
    373            * @{
    374            */
    375          
    376          /**
    377            * @brief By default in multiprocessor mode, when the wake up method is set
    378            *        to address mark, the UART handles only 4-bit long addresses detection;
    379            *        this API allows to enable longer addresses detection (6-, 7- or 8-bit
    380            *        long).
    381            * @note  Addresses detection lengths are: 6-bit address detection in 7-bit data mode,
    382            *        7-bit address detection in 8-bit data mode, 8-bit address detection in 9-bit data mode.
    383            * @param huart         UART handle.
    384            * @param AddressLength This parameter can be one of the following values:
    385            *          @arg @ref UART_ADDRESS_DETECT_4B 4-bit long address
    386            *          @arg @ref UART_ADDRESS_DETECT_7B 6-, 7- or 8-bit long address
    387            * @retval HAL status
    388            */

   \                                 In section .text, align 2, keep-with-next
    389          HAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t AddressLength)
    390          {
   \                     HAL_MultiProcessorEx_AddressLength_Set: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    391            /* Check the UART handle allocation */
    392            if (huart == NULL)
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD101             BNE.N    ??HAL_MultiProcessorEx_AddressLength_Set_0
    393            {
    394              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xE017             B.N      ??HAL_MultiProcessorEx_AddressLength_Set_1
    395            }
    396          
    397            /* Check the address length parameter */
    398            assert_param(IS_UART_ADDRESSLENGTH_DETECT(AddressLength));
    399          
    400            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_MultiProcessorEx_AddressLength_Set_0: (+1)
   \        0xA   0x2224             MOVS     R2,#+36
   \        0xC   0xF8C0 0x2088      STR      R2,[R0, #+136]
    401          
    402            /* Disable the Peripheral */
    403            __HAL_UART_DISABLE(huart);
   \       0x10   0x6802             LDR      R2,[R0, #+0]
   \       0x12   0x6812             LDR      R2,[R2, #+0]
   \       0x14   0x0852             LSRS     R2,R2,#+1
   \       0x16   0x0052             LSLS     R2,R2,#+1
   \       0x18   0x6803             LDR      R3,[R0, #+0]
   \       0x1A   0x601A             STR      R2,[R3, #+0]
    404          
    405            /* Set the address length */
    406            MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, AddressLength);
   \       0x1C   0x6802             LDR      R2,[R0, #+0]
   \       0x1E   0x6852             LDR      R2,[R2, #+4]
   \       0x20   0xF032 0x0210      BICS     R2,R2,#0x10
   \       0x24   0x4311             ORRS     R1,R1,R2
   \       0x26   0x6802             LDR      R2,[R0, #+0]
   \       0x28   0x6051             STR      R1,[R2, #+4]
    407          
    408            /* Enable the Peripheral */
    409            __HAL_UART_ENABLE(huart);
   \       0x2A   0x6801             LDR      R1,[R0, #+0]
   \       0x2C   0x6809             LDR      R1,[R1, #+0]
   \       0x2E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x32   0x6802             LDR      R2,[R0, #+0]
   \       0x34   0x6011             STR      R1,[R2, #+0]
    410          
    411            /* TEACK and/or REACK to check before moving huart->gState to Ready */
    412            return (UART_CheckIdleState(huart));
   \       0x36   0x.... 0x....      BL       UART_CheckIdleState
   \                     ??HAL_MultiProcessorEx_AddressLength_Set_1: (+1)
   \       0x3A   0xBD02             POP      {R1,PC}
    413          }
    414          
    415          /**
    416            * @brief Set Wakeup from Stop mode interrupt flag selection.
    417            * @note It is the application responsibility to enable the interrupt used as
    418            *       usart_wkup interrupt source before entering low-power mode.
    419            * @param huart           UART handle.
    420            * @param WakeUpSelection Address match, Start Bit detection or RXNE/RXFNE bit status.
    421            *          This parameter can be one of the following values:
    422            *          @arg @ref UART_WAKEUP_ON_ADDRESS
    423            *          @arg @ref UART_WAKEUP_ON_STARTBIT
    424            *          @arg @ref UART_WAKEUP_ON_READDATA_NONEMPTY
    425            * @retval HAL status
    426            */

   \                                 In section .text, align 2, keep-with-next
    427          HAL_StatusTypeDef HAL_UARTEx_StopModeWakeUpSourceConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection)
    428          {
   \                     HAL_UARTEx_StopModeWakeUpSourceConfig: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0008             MOVS     R0,R1
   \        0x6   0x0011             MOVS     R1,R2
    429            HAL_StatusTypeDef status = HAL_OK;
   \        0x8   0x2500             MOVS     R5,#+0
    430            uint32_t tickstart;
    431          
    432            /* check the wake-up from stop mode UART instance */
    433            assert_param(IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance));
    434            /* check the wake-up selection parameter */
    435            assert_param(IS_UART_WAKEUP_SELECTION(WakeUpSelection.WakeUpEvent));
    436          
    437            /* Process Locked */
    438            __HAL_LOCK(huart);
   \        0xA   0xF894 0x2084      LDRB     R2,[R4, #+132]
   \        0xE   0x2A01             CMP      R2,#+1
   \       0x10   0xD101             BNE.N    ??HAL_UARTEx_StopModeWakeUpSourceConfig_0
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE037             B.N      ??HAL_UARTEx_StopModeWakeUpSourceConfig_1
   \                     ??HAL_UARTEx_StopModeWakeUpSourceConfig_0: (+1)
   \       0x16   0x2201             MOVS     R2,#+1
   \       0x18   0xF884 0x2084      STRB     R2,[R4, #+132]
    439          
    440            huart->gState = HAL_UART_STATE_BUSY;
   \       0x1C   0x2224             MOVS     R2,#+36
   \       0x1E   0xF8C4 0x2088      STR      R2,[R4, #+136]
    441          
    442            /* Disable the Peripheral */
    443            __HAL_UART_DISABLE(huart);
   \       0x22   0x6822             LDR      R2,[R4, #+0]
   \       0x24   0x6812             LDR      R2,[R2, #+0]
   \       0x26   0x0852             LSRS     R2,R2,#+1
   \       0x28   0x0052             LSLS     R2,R2,#+1
   \       0x2A   0x6823             LDR      R3,[R4, #+0]
   \       0x2C   0x601A             STR      R2,[R3, #+0]
    444          
    445            /* Set the wake-up selection scheme */
    446            MODIFY_REG(huart->Instance->CR3, USART_CR3_WUS, WakeUpSelection.WakeUpEvent);
   \       0x2E   0x6822             LDR      R2,[R4, #+0]
   \       0x30   0x6892             LDR      R2,[R2, #+8]
   \       0x32   0xF432 0x1240      BICS     R2,R2,#0x300000
   \       0x36   0x4302             ORRS     R2,R0,R2
   \       0x38   0x6823             LDR      R3,[R4, #+0]
   \       0x3A   0x609A             STR      R2,[R3, #+8]
    447          
    448            if (WakeUpSelection.WakeUpEvent == UART_WAKEUP_ON_ADDRESS)
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD104             BNE.N    ??HAL_UARTEx_StopModeWakeUpSourceConfig_2
    449            {
    450              UARTEx_Wakeup_AddressConfig(huart, WakeUpSelection);
   \       0x40   0x000A             MOVS     R2,R1
   \       0x42   0x0001             MOVS     R1,R0
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       UARTEx_Wakeup_AddressConfig
    451            }
    452          
    453            /* Enable the Peripheral */
    454            __HAL_UART_ENABLE(huart);
   \                     ??HAL_UARTEx_StopModeWakeUpSourceConfig_2: (+1)
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6800             LDR      R0,[R0, #+0]
   \       0x4E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x52   0x6821             LDR      R1,[R4, #+0]
   \       0x54   0x6008             STR      R0,[R1, #+0]
    455          
    456            /* Init tickstart for timeout management */
    457            tickstart = HAL_GetTick();
   \       0x56   0x.... 0x....      BL       HAL_GetTick
   \       0x5A   0x0003             MOVS     R3,R0
    458          
    459            /* Wait until REACK flag is set */
    460            if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
   \       0x5C   0xF07F 0x407E      MVNS     R0,#+4261412864
   \       0x60   0x9000             STR      R0,[SP, #+0]
   \       0x62   0x2200             MOVS     R2,#+0
   \       0x64   0xF45F 0x0180      MOVS     R1,#+4194304
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD001             BEQ.N    ??HAL_UARTEx_StopModeWakeUpSourceConfig_3
    461            {
    462              status = HAL_TIMEOUT;
   \       0x72   0x2503             MOVS     R5,#+3
   \       0x74   0xE002             B.N      ??HAL_UARTEx_StopModeWakeUpSourceConfig_4
    463            }
    464            else
    465            {
    466              /* Initialize the UART State */
    467              huart->gState = HAL_UART_STATE_READY;
   \                     ??HAL_UARTEx_StopModeWakeUpSourceConfig_3: (+1)
   \       0x76   0x2020             MOVS     R0,#+32
   \       0x78   0xF8C4 0x0088      STR      R0,[R4, #+136]
    468            }
    469          
    470            /* Process Unlocked */
    471            __HAL_UNLOCK(huart);
   \                     ??HAL_UARTEx_StopModeWakeUpSourceConfig_4: (+1)
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0xF884 0x0084      STRB     R0,[R4, #+132]
    472          
    473            return status;
   \       0x82   0x0028             MOVS     R0,R5
   \       0x84   0xB2C0             UXTB     R0,R0
   \                     ??HAL_UARTEx_StopModeWakeUpSourceConfig_1: (+1)
   \       0x86   0xBD32             POP      {R1,R4,R5,PC}
    474          }
    475          
    476          /**
    477            * @brief Enable UART Stop Mode.
    478            * @note The UART is able to wake up the MCU from Stop 1 mode as long as UART clock is HSI or LSE.
    479            * @param huart UART handle.
    480            * @retval HAL status
    481            */

   \                                 In section .text, align 2, keep-with-next
    482          HAL_StatusTypeDef HAL_UARTEx_EnableStopMode(UART_HandleTypeDef *huart)
    483          {
    484            /* Process Locked */
    485            __HAL_LOCK(huart);
   \                     HAL_UARTEx_EnableStopMode: (+1)
   \        0x0   0xF890 0x1084      LDRB     R1,[R0, #+132]
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD101             BNE.N    ??HAL_UARTEx_EnableStopMode_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE010             B.N      ??HAL_UARTEx_EnableStopMode_1
   \                     ??HAL_UARTEx_EnableStopMode_0: (+1)
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF880 0x1084      STRB     R1,[R0, #+132]
    486          
    487            /* Set UESM bit */
    488            ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_UESM);
   \                     ??HAL_UARTEx_EnableStopMode_2: (+1)
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x18   0xF052 0x0202      ORRS     R2,R2,#0x2
   \       0x1C   0x6803             LDR      R3,[R0, #+0]
   \       0x1E   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x22   0x2900             CMP      R1,#+0
   \       0x24   0xD1F5             BNE.N    ??HAL_UARTEx_EnableStopMode_2
    489          
    490            /* Process Unlocked */
    491            __HAL_UNLOCK(huart);
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0xF880 0x1084      STRB     R1,[R0, #+132]
    492          
    493            return HAL_OK;
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??HAL_UARTEx_EnableStopMode_1: (+1)
   \       0x2E   0x4770             BX       LR
    494          }
    495          
    496          /**
    497            * @brief Disable UART Stop Mode.
    498            * @param huart UART handle.
    499            * @retval HAL status
    500            */

   \                                 In section .text, align 2, keep-with-next
    501          HAL_StatusTypeDef HAL_UARTEx_DisableStopMode(UART_HandleTypeDef *huart)
    502          {
    503            /* Process Locked */
    504            __HAL_LOCK(huart);
   \                     HAL_UARTEx_DisableStopMode: (+1)
   \        0x0   0xF890 0x1084      LDRB     R1,[R0, #+132]
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD101             BNE.N    ??HAL_UARTEx_DisableStopMode_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE010             B.N      ??HAL_UARTEx_DisableStopMode_1
   \                     ??HAL_UARTEx_DisableStopMode_0: (+1)
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF880 0x1084      STRB     R1,[R0, #+132]
    505          
    506            /* Clear UESM bit */
    507            ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_UESM);
   \                     ??HAL_UARTEx_DisableStopMode_2: (+1)
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x18   0xF032 0x0202      BICS     R2,R2,#0x2
   \       0x1C   0x6803             LDR      R3,[R0, #+0]
   \       0x1E   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x22   0x2900             CMP      R1,#+0
   \       0x24   0xD1F5             BNE.N    ??HAL_UARTEx_DisableStopMode_2
    508          
    509            /* Process Unlocked */
    510            __HAL_UNLOCK(huart);
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0xF880 0x1084      STRB     R1,[R0, #+132]
    511          
    512            return HAL_OK;
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??HAL_UARTEx_DisableStopMode_1: (+1)
   \       0x2E   0x4770             BX       LR
    513          }
    514          
    515          /**
    516            * @brief  Enable the FIFO mode.
    517            * @param huart      UART handle.
    518            * @retval HAL status
    519            */

   \                                 In section .text, align 2, keep-with-next
    520          HAL_StatusTypeDef HAL_UARTEx_EnableFifoMode(UART_HandleTypeDef *huart)
    521          {
   \                     HAL_UARTEx_EnableFifoMode: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    522            uint32_t tmpcr1;
    523          
    524            /* Check parameters */
    525            assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
    526          
    527            /* Process Locked */
    528            __HAL_LOCK(huart);
   \        0x4   0xF894 0x0084      LDRB     R0,[R4, #+132]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??HAL_UARTEx_EnableFifoMode_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE01E             B.N      ??HAL_UARTEx_EnableFifoMode_1
   \                     ??HAL_UARTEx_EnableFifoMode_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF884 0x0084      STRB     R0,[R4, #+132]
    529          
    530            huart->gState = HAL_UART_STATE_BUSY;
   \       0x16   0x2024             MOVS     R0,#+36
   \       0x18   0xF8C4 0x0088      STR      R0,[R4, #+136]
    531          
    532            /* Save actual UART configuration */
    533            tmpcr1 = READ_REG(huart->Instance->CR1);
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x6800             LDR      R0,[R0, #+0]
    534          
    535            /* Disable UART */
    536            __HAL_UART_DISABLE(huart);
   \       0x20   0x6821             LDR      R1,[R4, #+0]
   \       0x22   0x6809             LDR      R1,[R1, #+0]
   \       0x24   0x0849             LSRS     R1,R1,#+1
   \       0x26   0x0049             LSLS     R1,R1,#+1
   \       0x28   0x6822             LDR      R2,[R4, #+0]
   \       0x2A   0x6011             STR      R1,[R2, #+0]
    537          
    538            /* Enable FIFO mode */
    539            SET_BIT(tmpcr1, USART_CR1_FIFOEN);
   \       0x2C   0xF050 0x5000      ORRS     R0,R0,#0x20000000
    540            huart->FifoMode = UART_FIFOMODE_ENABLE;
   \       0x30   0xF05F 0x5100      MOVS     R1,#+536870912
   \       0x34   0x6661             STR      R1,[R4, #+100]
    541          
    542            /* Restore UART configuration */
    543            WRITE_REG(huart->Instance->CR1, tmpcr1);
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x6008             STR      R0,[R1, #+0]
    544          
    545            /* Determine the number of data to process during RX/TX ISR execution */
    546            UARTEx_SetNbDataToProcess(huart);
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0x.... 0x....      BL       UARTEx_SetNbDataToProcess
    547          
    548            huart->gState = HAL_UART_STATE_READY;
   \       0x40   0x2020             MOVS     R0,#+32
   \       0x42   0xF8C4 0x0088      STR      R0,[R4, #+136]
    549          
    550            /* Process Unlocked */
    551            __HAL_UNLOCK(huart);
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xF884 0x0084      STRB     R0,[R4, #+132]
    552          
    553            return HAL_OK;
   \       0x4C   0x2000             MOVS     R0,#+0
   \                     ??HAL_UARTEx_EnableFifoMode_1: (+1)
   \       0x4E   0xBD10             POP      {R4,PC}
    554          }
    555          
    556          /**
    557            * @brief  Disable the FIFO mode.
    558            * @param huart      UART handle.
    559            * @retval HAL status
    560            */

   \                                 In section .text, align 2, keep-with-next
    561          HAL_StatusTypeDef HAL_UARTEx_DisableFifoMode(UART_HandleTypeDef *huart)
    562          {
    563            uint32_t tmpcr1;
    564          
    565            /* Check parameters */
    566            assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
    567          
    568            /* Process Locked */
    569            __HAL_LOCK(huart);
   \                     HAL_UARTEx_DisableFifoMode: (+1)
   \        0x0   0xF890 0x1084      LDRB     R1,[R0, #+132]
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD101             BNE.N    ??HAL_UARTEx_DisableFifoMode_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE01A             B.N      ??HAL_UARTEx_DisableFifoMode_1
   \                     ??HAL_UARTEx_DisableFifoMode_0: (+1)
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF880 0x1084      STRB     R1,[R0, #+132]
    570          
    571            huart->gState = HAL_UART_STATE_BUSY;
   \       0x12   0x2124             MOVS     R1,#+36
   \       0x14   0xF8C0 0x1088      STR      R1,[R0, #+136]
    572          
    573            /* Save actual UART configuration */
    574            tmpcr1 = READ_REG(huart->Instance->CR1);
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0x6809             LDR      R1,[R1, #+0]
    575          
    576            /* Disable UART */
    577            __HAL_UART_DISABLE(huart);
   \       0x1C   0x6802             LDR      R2,[R0, #+0]
   \       0x1E   0x6812             LDR      R2,[R2, #+0]
   \       0x20   0x0852             LSRS     R2,R2,#+1
   \       0x22   0x0052             LSLS     R2,R2,#+1
   \       0x24   0x6803             LDR      R3,[R0, #+0]
   \       0x26   0x601A             STR      R2,[R3, #+0]
    578          
    579            /* Enable FIFO mode */
    580            CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
   \       0x28   0xF031 0x5100      BICS     R1,R1,#0x20000000
    581            huart->FifoMode = UART_FIFOMODE_DISABLE;
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0x6642             STR      R2,[R0, #+100]
    582          
    583            /* Restore UART configuration */
    584            WRITE_REG(huart->Instance->CR1, tmpcr1);
   \       0x30   0x6802             LDR      R2,[R0, #+0]
   \       0x32   0x6011             STR      R1,[R2, #+0]
    585          
    586            huart->gState = HAL_UART_STATE_READY;
   \       0x34   0x2120             MOVS     R1,#+32
   \       0x36   0xF8C0 0x1088      STR      R1,[R0, #+136]
    587          
    588            /* Process Unlocked */
    589            __HAL_UNLOCK(huart);
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0xF880 0x1084      STRB     R1,[R0, #+132]
    590          
    591            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \                     ??HAL_UARTEx_DisableFifoMode_1: (+1)
   \       0x42   0x4770             BX       LR
    592          }
    593          
    594          /**
    595            * @brief  Set the TXFIFO threshold.
    596            * @param huart      UART handle.
    597            * @param Threshold  TX FIFO threshold value
    598            *          This parameter can be one of the following values:
    599            *            @arg @ref UART_TXFIFO_THRESHOLD_1_8
    600            *            @arg @ref UART_TXFIFO_THRESHOLD_1_4
    601            *            @arg @ref UART_TXFIFO_THRESHOLD_1_2
    602            *            @arg @ref UART_TXFIFO_THRESHOLD_3_4
    603            *            @arg @ref UART_TXFIFO_THRESHOLD_7_8
    604            *            @arg @ref UART_TXFIFO_THRESHOLD_8_8
    605            * @retval HAL status
    606            */

   \                                 In section .text, align 2, keep-with-next
    607          HAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
    608          {
   \                     HAL_UARTEx_SetTxFifoThreshold: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    609            uint32_t tmpcr1;
    610          
    611            /* Check parameters */
    612            assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
    613            assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));
    614          
    615            /* Process Locked */
    616            __HAL_LOCK(huart);
   \        0x4   0xF894 0x0084      LDRB     R0,[R4, #+132]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??HAL_UARTEx_SetTxFifoThreshold_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE020             B.N      ??HAL_UARTEx_SetTxFifoThreshold_1
   \                     ??HAL_UARTEx_SetTxFifoThreshold_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF884 0x0084      STRB     R0,[R4, #+132]
    617          
    618            huart->gState = HAL_UART_STATE_BUSY;
   \       0x16   0x2024             MOVS     R0,#+36
   \       0x18   0xF8C4 0x0088      STR      R0,[R4, #+136]
    619          
    620            /* Save actual UART configuration */
    621            tmpcr1 = READ_REG(huart->Instance->CR1);
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x6805             LDR      R5,[R0, #+0]
    622          
    623            /* Disable UART */
    624            __HAL_UART_DISABLE(huart);
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x6800             LDR      R0,[R0, #+0]
   \       0x24   0x0840             LSRS     R0,R0,#+1
   \       0x26   0x0040             LSLS     R0,R0,#+1
   \       0x28   0x6822             LDR      R2,[R4, #+0]
   \       0x2A   0x6010             STR      R0,[R2, #+0]
    625          
    626            /* Update TX threshold configuration */
    627            MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6880             LDR      R0,[R0, #+8]
   \       0x30   0xF020 0x4060      BIC      R0,R0,#0xE0000000
   \       0x34   0x4301             ORRS     R1,R1,R0
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x6081             STR      R1,[R0, #+8]
    628          
    629            /* Determine the number of data to process during RX/TX ISR execution */
    630            UARTEx_SetNbDataToProcess(huart);
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0x.... 0x....      BL       UARTEx_SetNbDataToProcess
    631          
    632            /* Restore UART configuration */
    633            WRITE_REG(huart->Instance->CR1, tmpcr1);
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x6005             STR      R5,[R0, #+0]
    634          
    635            huart->gState = HAL_UART_STATE_READY;
   \       0x44   0x2020             MOVS     R0,#+32
   \       0x46   0xF8C4 0x0088      STR      R0,[R4, #+136]
    636          
    637            /* Process Unlocked */
    638            __HAL_UNLOCK(huart);
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xF884 0x0084      STRB     R0,[R4, #+132]
    639          
    640            return HAL_OK;
   \       0x50   0x2000             MOVS     R0,#+0
   \                     ??HAL_UARTEx_SetTxFifoThreshold_1: (+1)
   \       0x52   0xBD32             POP      {R1,R4,R5,PC}
    641          }
    642          
    643          /**
    644            * @brief  Set the RXFIFO threshold.
    645            * @param huart      UART handle.
    646            * @param Threshold  RX FIFO threshold value
    647            *          This parameter can be one of the following values:
    648            *            @arg @ref UART_RXFIFO_THRESHOLD_1_8
    649            *            @arg @ref UART_RXFIFO_THRESHOLD_1_4
    650            *            @arg @ref UART_RXFIFO_THRESHOLD_1_2
    651            *            @arg @ref UART_RXFIFO_THRESHOLD_3_4
    652            *            @arg @ref UART_RXFIFO_THRESHOLD_7_8
    653            *            @arg @ref UART_RXFIFO_THRESHOLD_8_8
    654            * @retval HAL status
    655            */

   \                                 In section .text, align 2, keep-with-next
    656          HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
    657          {
   \                     HAL_UARTEx_SetRxFifoThreshold: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    658            uint32_t tmpcr1;
    659          
    660            /* Check the parameters */
    661            assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
    662            assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));
    663          
    664            /* Process Locked */
    665            __HAL_LOCK(huart);
   \        0x4   0xF894 0x0084      LDRB     R0,[R4, #+132]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??HAL_UARTEx_SetRxFifoThreshold_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE020             B.N      ??HAL_UARTEx_SetRxFifoThreshold_1
   \                     ??HAL_UARTEx_SetRxFifoThreshold_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF884 0x0084      STRB     R0,[R4, #+132]
    666          
    667            huart->gState = HAL_UART_STATE_BUSY;
   \       0x16   0x2024             MOVS     R0,#+36
   \       0x18   0xF8C4 0x0088      STR      R0,[R4, #+136]
    668          
    669            /* Save actual UART configuration */
    670            tmpcr1 = READ_REG(huart->Instance->CR1);
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x6805             LDR      R5,[R0, #+0]
    671          
    672            /* Disable UART */
    673            __HAL_UART_DISABLE(huart);
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x6800             LDR      R0,[R0, #+0]
   \       0x24   0x0840             LSRS     R0,R0,#+1
   \       0x26   0x0040             LSLS     R0,R0,#+1
   \       0x28   0x6822             LDR      R2,[R4, #+0]
   \       0x2A   0x6010             STR      R0,[R2, #+0]
    674          
    675            /* Update RX threshold configuration */
    676            MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6880             LDR      R0,[R0, #+8]
   \       0x30   0xF030 0x6060      BICS     R0,R0,#0xE000000
   \       0x34   0x4301             ORRS     R1,R1,R0
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x6081             STR      R1,[R0, #+8]
    677          
    678            /* Determine the number of data to process during RX/TX ISR execution */
    679            UARTEx_SetNbDataToProcess(huart);
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0x.... 0x....      BL       UARTEx_SetNbDataToProcess
    680          
    681            /* Restore UART configuration */
    682            WRITE_REG(huart->Instance->CR1, tmpcr1);
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x6005             STR      R5,[R0, #+0]
    683          
    684            huart->gState = HAL_UART_STATE_READY;
   \       0x44   0x2020             MOVS     R0,#+32
   \       0x46   0xF8C4 0x0088      STR      R0,[R4, #+136]
    685          
    686            /* Process Unlocked */
    687            __HAL_UNLOCK(huart);
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xF884 0x0084      STRB     R0,[R4, #+132]
    688          
    689            return HAL_OK;
   \       0x50   0x2000             MOVS     R0,#+0
   \                     ??HAL_UARTEx_SetRxFifoThreshold_1: (+1)
   \       0x52   0xBD32             POP      {R1,R4,R5,PC}
    690          }
    691          
    692          /**
    693            * @brief Receive an amount of data in blocking mode till either the expected number of data
    694            *        is received or an IDLE event occurs.
    695            * @note  HAL_OK is returned if reception is completed (expected number of data has been received)
    696            *        or if reception is stopped after IDLE event (less than the expected number of data has been received)
    697            *        In this case, RxLen output parameter indicates number of data available in reception buffer.
    698            * @note  When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
    699            *        the received data is handled as a set of uint16_t. In this case, Size must indicate the number
    700            *        of uint16_t available through pData.
    701            * @note When FIFO mode is enabled, the RXFNE flag is set as long as the RXFIFO
    702            *       is not empty. Read operations from the RDR register are performed when
    703            *       RXFNE flag is set. From hardware perspective, RXFNE flag and
    704            *       RXNE are mapped on the same bit-field.
    705            * @param huart   UART handle.
    706            * @param pData   Pointer to data buffer (uint8_t or uint16_t data elements).
    707            * @param Size    Amount of data elements (uint8_t or uint16_t) to be received.
    708            * @param RxLen   Number of data elements finally received
    709            *                (could be lower than Size, in case reception ends on IDLE event)
    710            * @param Timeout Timeout duration expressed in ms (covers the whole reception sequence).
    711            * @retval HAL status
    712            */

   \                                 In section .text, align 2, keep-with-next
    713          HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint16_t *RxLen,
    714                                                     uint32_t Timeout)
    715          {
   \                     HAL_UARTEx_ReceiveToIdle: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x469A             MOV      R10,R3
    716            uint8_t  *pdata8bits;
    717            uint16_t *pdata16bits;
    718            uint16_t uhMask;
    719            uint32_t tickstart;
    720          
    721            /* Check that a Rx process is not already ongoing */
    722            if (huart->RxState == HAL_UART_STATE_READY)
   \        0xC   0xF8D6 0x008C      LDR      R0,[R6, #+140]
   \       0x10   0x2820             CMP      R0,#+32
   \       0x12   0xF040 0x80AC      BNE.W    ??HAL_UARTEx_ReceiveToIdle_0
    723            {
    724              if ((pData == NULL) || (Size == 0U))
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD003             BEQ.N    ??HAL_UARTEx_ReceiveToIdle_1
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0xB280             UXTH     R0,R0
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD101             BNE.N    ??HAL_UARTEx_ReceiveToIdle_2
    725              {
    726                return  HAL_ERROR;
   \                     ??HAL_UARTEx_ReceiveToIdle_1: (+1)
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xE0A4             B.N      ??HAL_UARTEx_ReceiveToIdle_3
    727              }
    728          
    729              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \                     ??HAL_UARTEx_ReceiveToIdle_2: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xF8C6 0x0090      STR      R0,[R6, #+144]
    730              huart->RxState = HAL_UART_STATE_BUSY_RX;
   \       0x2C   0x2022             MOVS     R0,#+34
   \       0x2E   0xF8C6 0x008C      STR      R0,[R6, #+140]
    731              huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0x66F0             STR      R0,[R6, #+108]
    732              huart->RxEventType = HAL_UART_RXEVENT_TC;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6730             STR      R0,[R6, #+112]
    733          
    734              /* Init tickstart for timeout management */
    735              tickstart = HAL_GetTick();
   \       0x3A   0x.... 0x....      BL       HAL_GetTick
   \       0x3E   0x0007             MOVS     R7,R0
    736          
    737              huart->RxXferSize  = Size;
   \       0x40   0xF8A6 0x405C      STRH     R4,[R6, #+92]
    738              huart->RxXferCount = Size;
   \       0x44   0xF8A6 0x405E      STRH     R4,[R6, #+94]
    739          
    740              /* Computation of UART mask to apply to RDR register */
    741              UART_MASK_COMPUTATION(huart);
   \       0x48   0x68B0             LDR      R0,[R6, #+8]
   \       0x4A   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x4E   0xD10B             BNE.N    ??HAL_UARTEx_ReceiveToIdle_4
   \       0x50   0x6930             LDR      R0,[R6, #+16]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD104             BNE.N    ??HAL_UARTEx_ReceiveToIdle_5
   \       0x56   0xF240 0x10FF      MOVW     R0,#+511
   \       0x5A   0xF8A6 0x0060      STRH     R0,[R6, #+96]
   \       0x5E   0xE023             B.N      ??HAL_UARTEx_ReceiveToIdle_6
   \                     ??HAL_UARTEx_ReceiveToIdle_5: (+1)
   \       0x60   0x20FF             MOVS     R0,#+255
   \       0x62   0xF8A6 0x0060      STRH     R0,[R6, #+96]
   \       0x66   0xE01F             B.N      ??HAL_UARTEx_ReceiveToIdle_6
   \                     ??HAL_UARTEx_ReceiveToIdle_4: (+1)
   \       0x68   0x68B0             LDR      R0,[R6, #+8]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD10A             BNE.N    ??HAL_UARTEx_ReceiveToIdle_7
   \       0x6E   0x6930             LDR      R0,[R6, #+16]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD103             BNE.N    ??HAL_UARTEx_ReceiveToIdle_8
   \       0x74   0x20FF             MOVS     R0,#+255
   \       0x76   0xF8A6 0x0060      STRH     R0,[R6, #+96]
   \       0x7A   0xE015             B.N      ??HAL_UARTEx_ReceiveToIdle_6
   \                     ??HAL_UARTEx_ReceiveToIdle_8: (+1)
   \       0x7C   0x207F             MOVS     R0,#+127
   \       0x7E   0xF8A6 0x0060      STRH     R0,[R6, #+96]
   \       0x82   0xE011             B.N      ??HAL_UARTEx_ReceiveToIdle_6
   \                     ??HAL_UARTEx_ReceiveToIdle_7: (+1)
   \       0x84   0x68B0             LDR      R0,[R6, #+8]
   \       0x86   0xF1B0 0x5F80      CMP      R0,#+268435456
   \       0x8A   0xD10A             BNE.N    ??HAL_UARTEx_ReceiveToIdle_9
   \       0x8C   0x6930             LDR      R0,[R6, #+16]
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD103             BNE.N    ??HAL_UARTEx_ReceiveToIdle_10
   \       0x92   0x207F             MOVS     R0,#+127
   \       0x94   0xF8A6 0x0060      STRH     R0,[R6, #+96]
   \       0x98   0xE006             B.N      ??HAL_UARTEx_ReceiveToIdle_6
   \                     ??HAL_UARTEx_ReceiveToIdle_10: (+1)
   \       0x9A   0x203F             MOVS     R0,#+63
   \       0x9C   0xF8A6 0x0060      STRH     R0,[R6, #+96]
   \       0xA0   0xE002             B.N      ??HAL_UARTEx_ReceiveToIdle_6
   \                     ??HAL_UARTEx_ReceiveToIdle_9: (+1)
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0xF8A6 0x0060      STRH     R0,[R6, #+96]
    742              uhMask = huart->Mask;
   \                     ??HAL_UARTEx_ReceiveToIdle_6: (+1)
   \       0xA8   0xF8B6 0x8060      LDRH     R8,[R6, #+96]
    743          
    744              /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
    745              if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   \       0xAC   0x68B0             LDR      R0,[R6, #+8]
   \       0xAE   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0xB2   0xD105             BNE.N    ??HAL_UARTEx_ReceiveToIdle_11
   \       0xB4   0x6930             LDR      R0,[R6, #+16]
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD102             BNE.N    ??HAL_UARTEx_ReceiveToIdle_11
    746              {
    747                pdata8bits  = NULL;
   \       0xBA   0x2400             MOVS     R4,#+0
    748                pdata16bits = (uint16_t *) pData;
   \       0xBC   0x46A9             MOV      R9,R5
   \       0xBE   0xE002             B.N      ??HAL_UARTEx_ReceiveToIdle_12
    749              }
    750              else
    751              {
    752                pdata8bits  = pData;
   \                     ??HAL_UARTEx_ReceiveToIdle_11: (+1)
   \       0xC0   0x002C             MOVS     R4,R5
    753                pdata16bits = NULL;
   \       0xC2   0xF05F 0x0900      MOVS     R9,#+0
    754              }
    755          
    756              /* Initialize output number of received elements */
    757              *RxLen = 0U;
   \                     ??HAL_UARTEx_ReceiveToIdle_12: (+1)
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   \       0xCC   0x9D08             LDR      R5,[SP, #+32]
    758          
    759              /* as long as data have to be received */
    760              while (huart->RxXferCount > 0U)
   \                     ??HAL_UARTEx_ReceiveToIdle_13: (+1)
   \       0xCE   0xF8B6 0x005E      LDRH     R0,[R6, #+94]
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD03F             BEQ.N    ??HAL_UARTEx_ReceiveToIdle_14
    761              {
    762                /* Check if IDLE flag is set */
    763                if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
   \       0xD6   0x6830             LDR      R0,[R6, #+0]
   \       0xD8   0x69C0             LDR      R0,[R0, #+28]
   \       0xDA   0x06C0             LSLS     R0,R0,#+27
   \       0xDC   0xD50D             BPL.N    ??HAL_UARTEx_ReceiveToIdle_15
    764                {
    765                  /* Clear IDLE flag in ISR */
    766                  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
   \       0xDE   0x2010             MOVS     R0,#+16
   \       0xE0   0x6831             LDR      R1,[R6, #+0]
   \       0xE2   0x6208             STR      R0,[R1, #+32]
    767          
    768                  /* If Set, but no data ever received, clear flag without exiting loop */
    769                  /* If Set, and data has already been received, this means Idle Event is valid : End reception */
    770                  if (*RxLen > 0U)
   \       0xE4   0xF8BA 0x0000      LDRH     R0,[R10, #+0]
   \       0xE8   0x2800             CMP      R0,#+0
   \       0xEA   0xD006             BEQ.N    ??HAL_UARTEx_ReceiveToIdle_15
    771                  {
    772                    huart->RxEventType = HAL_UART_RXEVENT_IDLE;
   \       0xEC   0x2002             MOVS     R0,#+2
   \       0xEE   0x6730             STR      R0,[R6, #+112]
    773                    huart->RxState = HAL_UART_STATE_READY;
   \       0xF0   0x2020             MOVS     R0,#+32
   \       0xF2   0xF8C6 0x008C      STR      R0,[R6, #+140]
    774          
    775                    return HAL_OK;
   \       0xF6   0x2000             MOVS     R0,#+0
   \       0xF8   0xE03A             B.N      ??HAL_UARTEx_ReceiveToIdle_3
    776                  }
    777                }
    778          
    779                /* Check if RXNE flag is set */
    780                if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE))
   \                     ??HAL_UARTEx_ReceiveToIdle_15: (+1)
   \       0xFA   0x6830             LDR      R0,[R6, #+0]
   \       0xFC   0x69C0             LDR      R0,[R0, #+28]
   \       0xFE   0x0680             LSLS     R0,R0,#+26
   \      0x100   0xD51A             BPL.N    ??HAL_UARTEx_ReceiveToIdle_16
    781                {
    782                  if (pdata8bits == NULL)
   \      0x102   0x2C00             CMP      R4,#+0
   \      0x104   0xD108             BNE.N    ??HAL_UARTEx_ReceiveToIdle_17
    783                  {
    784                    *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
   \      0x106   0x6830             LDR      R0,[R6, #+0]
   \      0x108   0x6A40             LDR      R0,[R0, #+36]
   \      0x10A   0xEA18 0x0000      ANDS     R0,R8,R0
   \      0x10E   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    785                    pdata16bits++;
   \      0x112   0xF119 0x0902      ADDS     R9,R9,#+2
   \      0x116   0xE005             B.N      ??HAL_UARTEx_ReceiveToIdle_18
    786                  }
    787                  else
    788                  {
    789                    *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
   \                     ??HAL_UARTEx_ReceiveToIdle_17: (+1)
   \      0x118   0x6830             LDR      R0,[R6, #+0]
   \      0x11A   0x6A40             LDR      R0,[R0, #+36]
   \      0x11C   0xEA18 0x0000      ANDS     R0,R8,R0
   \      0x120   0x7020             STRB     R0,[R4, #+0]
    790                    pdata8bits++;
   \      0x122   0x1C64             ADDS     R4,R4,#+1
    791                  }
    792                  /* Increment number of received elements */
    793                  *RxLen += 1U;
   \                     ??HAL_UARTEx_ReceiveToIdle_18: (+1)
   \      0x124   0xF8BA 0x0000      LDRH     R0,[R10, #+0]
   \      0x128   0x1C40             ADDS     R0,R0,#+1
   \      0x12A   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    794                  huart->RxXferCount--;
   \      0x12E   0xF8B6 0x005E      LDRH     R0,[R6, #+94]
   \      0x132   0x1E40             SUBS     R0,R0,#+1
   \      0x134   0xF8A6 0x005E      STRH     R0,[R6, #+94]
    795                }
    796          
    797                /* Check for the Timeout */
    798                if (Timeout != HAL_MAX_DELAY)
   \                     ??HAL_UARTEx_ReceiveToIdle_16: (+1)
   \      0x138   0xF115 0x0F01      CMN      R5,#+1
   \      0x13C   0xD0C7             BEQ.N    ??HAL_UARTEx_ReceiveToIdle_13
    799                {
    800                  if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \      0x13E   0x.... 0x....      BL       HAL_GetTick
   \      0x142   0x1BC0             SUBS     R0,R0,R7
   \      0x144   0x4285             CMP      R5,R0
   \      0x146   0xD301             BCC.N    ??HAL_UARTEx_ReceiveToIdle_19
   \      0x148   0x2D00             CMP      R5,#+0
   \      0x14A   0xD1C0             BNE.N    ??HAL_UARTEx_ReceiveToIdle_13
    801                  {
    802                    huart->RxState = HAL_UART_STATE_READY;
   \                     ??HAL_UARTEx_ReceiveToIdle_19: (+1)
   \      0x14C   0x2020             MOVS     R0,#+32
   \      0x14E   0xF8C6 0x008C      STR      R0,[R6, #+140]
    803          
    804                    return HAL_TIMEOUT;
   \      0x152   0x2003             MOVS     R0,#+3
   \      0x154   0xE00C             B.N      ??HAL_UARTEx_ReceiveToIdle_3
    805                  }
    806                }
    807              }
    808          
    809              /* Set number of received elements in output parameter : RxLen */
    810              *RxLen = huart->RxXferSize - huart->RxXferCount;
   \                     ??HAL_UARTEx_ReceiveToIdle_14: (+1)
   \      0x156   0xF8B6 0x105C      LDRH     R1,[R6, #+92]
   \      0x15A   0xF8B6 0x005E      LDRH     R0,[R6, #+94]
   \      0x15E   0x1A09             SUBS     R1,R1,R0
   \      0x160   0xF8AA 0x1000      STRH     R1,[R10, #+0]
    811              /* At end of Rx process, restore huart->RxState to Ready */
    812              huart->RxState = HAL_UART_STATE_READY;
   \      0x164   0x2020             MOVS     R0,#+32
   \      0x166   0xF8C6 0x008C      STR      R0,[R6, #+140]
    813          
    814              return HAL_OK;
   \      0x16A   0x2000             MOVS     R0,#+0
   \      0x16C   0xE000             B.N      ??HAL_UARTEx_ReceiveToIdle_3
    815            }
    816            else
    817            {
    818              return HAL_BUSY;
   \                     ??HAL_UARTEx_ReceiveToIdle_0: (+1)
   \      0x16E   0x2002             MOVS     R0,#+2
   \                     ??HAL_UARTEx_ReceiveToIdle_3: (+1)
   \      0x170   0xE8BD 0x87F0      POP      {R4-R10,PC}
    819            }
    820          }
    821          
    822          /**
    823            * @brief Receive an amount of data in interrupt mode till either the expected number of data
    824            *        is received or an IDLE event occurs.
    825            * @note  Reception is initiated by this function call. Further progress of reception is achieved thanks
    826            *        to UART interrupts raised by RXNE and IDLE events. Callback is called at end of reception indicating
    827            *        number of received data elements.
    828            * @note  When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
    829            *        the received data is handled as a set of uint16_t. In this case, Size must indicate the number
    830            *        of uint16_t available through pData.
    831            * @param huart UART handle.
    832            * @param pData Pointer to data buffer (uint8_t or uint16_t data elements).
    833            * @param Size  Amount of data elements (uint8_t or uint16_t) to be received.
    834            * @retval HAL status
    835            */

   \                                 In section .text, align 2, keep-with-next
    836          HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    837          {
   \                     HAL_UARTEx_ReceiveToIdle_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    838            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
    839          
    840            /* Check that a Rx process is not already ongoing */
    841            if (huart->RxState == HAL_UART_STATE_READY)
   \        0x6   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0xD124             BNE.N    ??HAL_UARTEx_ReceiveToIdle_IT_0
    842            {
    843              if ((pData == NULL) || (Size == 0U))
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD003             BEQ.N    ??HAL_UARTEx_ReceiveToIdle_IT_1
   \       0x12   0x0010             MOVS     R0,R2
   \       0x14   0xB280             UXTH     R0,R0
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??HAL_UARTEx_ReceiveToIdle_IT_2
    844              {
    845                return HAL_ERROR;
   \                     ??HAL_UARTEx_ReceiveToIdle_IT_1: (+1)
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE01D             B.N      ??HAL_UARTEx_ReceiveToIdle_IT_3
    846              }
    847          
    848              /* Set Reception type to reception till IDLE Event*/
    849              huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
   \                     ??HAL_UARTEx_ReceiveToIdle_IT_2: (+1)
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x66E0             STR      R0,[R4, #+108]
    850              huart->RxEventType = HAL_UART_RXEVENT_TC;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x6720             STR      R0,[R4, #+112]
    851          
    852              (void)UART_Start_Receive_IT(huart, pData, Size);
   \       0x26   0xB292             UXTH     R2,R2
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x.... 0x....      BL       UART_Start_Receive_IT
    853          
    854              if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   \       0x2E   0x6EE0             LDR      R0,[R4, #+108]
   \       0x30   0x2801             CMP      R0,#+1
   \       0x32   0xD10D             BNE.N    ??HAL_UARTEx_ReceiveToIdle_IT_4
    855              {
    856                __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
   \       0x34   0x2010             MOVS     R0,#+16
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x6208             STR      R0,[R1, #+32]
    857                ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
   \                     ??HAL_UARTEx_ReceiveToIdle_IT_5: (+1)
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x40   0xF051 0x0110      ORRS     R1,R1,#0x10
   \       0x44   0x6822             LDR      R2,[R4, #+0]
   \       0x46   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD1F5             BNE.N    ??HAL_UARTEx_ReceiveToIdle_IT_5
   \       0x4E   0xE000             B.N      ??HAL_UARTEx_ReceiveToIdle_IT_6
    858              }
    859              else
    860              {
    861                /* In case of errors already pending when reception is started,
    862                   Interrupts may have already been raised and lead to reception abortion.
    863                   (Overrun error for instance).
    864                   In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */
    865                status = HAL_ERROR;
   \                     ??HAL_UARTEx_ReceiveToIdle_IT_4: (+1)
   \       0x50   0x2501             MOVS     R5,#+1
    866              }
    867          
    868              return status;
   \                     ??HAL_UARTEx_ReceiveToIdle_IT_6: (+1)
   \       0x52   0x0028             MOVS     R0,R5
   \       0x54   0xB2C0             UXTB     R0,R0
   \       0x56   0xE000             B.N      ??HAL_UARTEx_ReceiveToIdle_IT_3
    869            }
    870            else
    871            {
    872              return HAL_BUSY;
   \                     ??HAL_UARTEx_ReceiveToIdle_IT_0: (+1)
   \       0x58   0x2002             MOVS     R0,#+2
   \                     ??HAL_UARTEx_ReceiveToIdle_IT_3: (+1)
   \       0x5A   0xBD32             POP      {R1,R4,R5,PC}
    873            }
    874          }
    875          
    876          #if defined(HAL_DMA_MODULE_ENABLED)
    877          /**
    878            * @brief Receive an amount of data in DMA mode till either the expected number
    879            *        of data is received or an IDLE event occurs.
    880            * @note  Reception is initiated by this function call. Further progress of reception is achieved thanks
    881            *        to DMA services, transferring automatically received data elements in user reception buffer and
    882            *        calling registered callbacks at half/end of reception. UART IDLE events are also used to consider
    883            *        reception phase as ended. In all cases, callback execution will indicate number of received data elements.
    884            * @note  When the UART parity is enabled (PCE = 1), the received data contain
    885            *        the parity bit (MSB position).
    886            * @note  When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
    887            *        the received data is handled as a set of uint16_t. In this case, Size must indicate the number
    888            *        of uint16_t available through pData.
    889            * @param huart UART handle.
    890            * @param pData Pointer to data buffer (uint8_t or uint16_t data elements).
    891            * @param Size  Amount of data elements (uint8_t or uint16_t) to be received.
    892            * @retval HAL status
    893            */

   \                                 In section .text, align 2, keep-with-next
    894          HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    895          {
   \                     HAL_UARTEx_ReceiveToIdle_DMA: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    896            HAL_StatusTypeDef status;
    897          
    898            /* Check that a Rx process is not already ongoing */
    899            if (huart->RxState == HAL_UART_STATE_READY)
   \        0x4   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \        0x8   0x2820             CMP      R0,#+32
   \        0xA   0xD129             BNE.N    ??HAL_UARTEx_ReceiveToIdle_DMA_0
    900            {
    901              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD003             BEQ.N    ??HAL_UARTEx_ReceiveToIdle_DMA_1
   \       0x10   0x0010             MOVS     R0,R2
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??HAL_UARTEx_ReceiveToIdle_DMA_2
    902              {
    903                return HAL_ERROR;
   \                     ??HAL_UARTEx_ReceiveToIdle_DMA_1: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE022             B.N      ??HAL_UARTEx_ReceiveToIdle_DMA_3
    904              }
    905          
    906              /* Set Reception type to reception till IDLE Event*/
    907              huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
   \                     ??HAL_UARTEx_ReceiveToIdle_DMA_2: (+1)
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0x66E0             STR      R0,[R4, #+108]
    908              huart->RxEventType = HAL_UART_RXEVENT_TC;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x6720             STR      R0,[R4, #+112]
    909          
    910              status =  UART_Start_Receive_DMA(huart, pData, Size);
   \       0x24   0xB292             UXTH     R2,R2
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       UART_Start_Receive_DMA
   \       0x2C   0x0001             MOVS     R1,R0
    911          
    912              /* Check Rx process has been successfully started */
    913              if (status == HAL_OK)
   \       0x2E   0x0008             MOVS     R0,R1
   \       0x30   0xB2C0             UXTB     R0,R0
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD111             BNE.N    ??HAL_UARTEx_ReceiveToIdle_DMA_4
    914              {
    915                if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   \       0x36   0x6EE0             LDR      R0,[R4, #+108]
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD10D             BNE.N    ??HAL_UARTEx_ReceiveToIdle_DMA_5
    916                {
    917                  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
   \       0x3C   0x2010             MOVS     R0,#+16
   \       0x3E   0x6822             LDR      R2,[R4, #+0]
   \       0x40   0x6210             STR      R0,[R2, #+32]
    918                  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
   \                     ??HAL_UARTEx_ReceiveToIdle_DMA_6: (+1)
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0xE850 0x2F00      LDREX    R2,[R0]
   \       0x48   0xF052 0x0210      ORRS     R2,R2,#0x10
   \       0x4C   0x6823             LDR      R3,[R4, #+0]
   \       0x4E   0xE843 0x2000      STREX    R0,R2,[R3]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD1F5             BNE.N    ??HAL_UARTEx_ReceiveToIdle_DMA_6
   \       0x56   0xE000             B.N      ??HAL_UARTEx_ReceiveToIdle_DMA_4
    919                }
    920                else
    921                {
    922                  /* In case of errors already pending when reception is started,
    923                     Interrupts may have already been raised and lead to reception abortion.
    924                     (Overrun error for instance).
    925                     In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */
    926                  status = HAL_ERROR;
   \                     ??HAL_UARTEx_ReceiveToIdle_DMA_5: (+1)
   \       0x58   0x2101             MOVS     R1,#+1
    927                }
    928              }
    929          
    930              return status;
   \                     ??HAL_UARTEx_ReceiveToIdle_DMA_4: (+1)
   \       0x5A   0x0008             MOVS     R0,R1
   \       0x5C   0xB2C0             UXTB     R0,R0
   \       0x5E   0xE000             B.N      ??HAL_UARTEx_ReceiveToIdle_DMA_3
    931            }
    932            else
    933            {
    934              return HAL_BUSY;
   \                     ??HAL_UARTEx_ReceiveToIdle_DMA_0: (+1)
   \       0x60   0x2002             MOVS     R0,#+2
   \                     ??HAL_UARTEx_ReceiveToIdle_DMA_3: (+1)
   \       0x62   0xBD10             POP      {R4,PC}
    935            }
    936          }
    937          #endif /* HAL_DMA_MODULE_ENABLED */
    938          
    939          /**
    940            * @brief Provide Rx Event type that has lead to RxEvent callback execution.
    941            * @note  When HAL_UARTEx_ReceiveToIdle_IT() or HAL_UARTEx_ReceiveToIdle_DMA() API are called, progress
    942            *        of reception process is provided to application through calls of Rx Event callback (either default one
    943            *        HAL_UARTEx_RxEventCallback() or user registered one). As several types of events could occur (IDLE event,
    944            *        Half Transfer, or Transfer Complete), this function allows to retrieve the Rx Event type that has lead
    945            *        to Rx Event callback execution.
    946            * @note  This function is expected to be called within the user implementation of Rx Event Callback,
    947            *        in order to provide the accurate value :
    948            *        In Interrupt Mode :
    949            *           - HAL_UART_RXEVENT_TC : when Reception has been completed (expected nb of data has been received)
    950            *           - HAL_UART_RXEVENT_IDLE : when Idle event occurred prior reception has been completed (nb of
    951            *             received data is lower than expected one)
    952            *        In DMA Mode :
    953            *           - HAL_UART_RXEVENT_TC : when Reception has been completed (expected nb of data has been received)
    954            *           - HAL_UART_RXEVENT_HT : when half of expected nb of data has been received
    955            *           - HAL_UART_RXEVENT_IDLE : when Idle event occurred prior reception has been completed (nb of
    956            *             received data is lower than expected one).
    957            *        In DMA mode, RxEvent callback could be called several times;
    958            *        When DMA is configured in Normal Mode, HT event does not stop Reception process;
    959            *        When DMA is configured in Circular Mode, HT, TC or IDLE events don't stop Reception process;
    960            * @param  huart UART handle.
    961            * @retval Rx Event Type (return vale will be a value of @ref UART_RxEvent_Type_Values)
    962            */

   \                                 In section .text, align 2, keep-with-next
    963          HAL_UART_RxEventTypeTypeDef HAL_UARTEx_GetRxEventType(const UART_HandleTypeDef *huart)
    964          {
    965            /* Return Rx Event type value, as stored in UART handle */
    966            return (huart->RxEventType);
   \                     HAL_UARTEx_GetRxEventType: (+1)
   \        0x0   0x6F00             LDR      R0,[R0, #+112]
   \        0x2   0x4770             BX       LR
    967          }
    968          
    969          /**
    970            * @}
    971            */
    972          
    973          /**
    974            * @}
    975            */
    976          
    977          /** @addtogroup UARTEx_Private_Functions
    978            * @{
    979            */
    980          
    981          /**
    982            * @brief Initialize the UART wake-up from stop mode parameters when triggered by address detection.
    983            * @param huart           UART handle.
    984            * @param WakeUpSelection UART wake up from stop mode parameters.
    985            * @retval None
    986            */

   \                                 In section .text, align 2, keep-with-next
    987          static void UARTEx_Wakeup_AddressConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection)
    988          {
   \                     UARTEx_Wakeup_AddressConfig: (+1)
   \        0x0   0xB406             PUSH     {R1,R2}
    989            assert_param(IS_UART_ADDRESSLENGTH_DETECT(WakeUpSelection.AddressLength));
    990          
    991            /* Set the USART address length */
    992            MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x684A             LDR      R2,[R1, #+4]
   \        0x6   0xF032 0x0210      BICS     R2,R2,#0x10
   \        0xA   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \        0xE   0x430A             ORRS     R2,R1,R2
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0x604A             STR      R2,[R1, #+4]
    993          
    994            /* Set the USART address node */
    995            MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)WakeUpSelection.Address << UART_CR2_ADDRESS_LSB_POS));
   \       0x14   0xF89D 0x1006      LDRB     R1,[SP, #+6]
   \       0x18   0x6802             LDR      R2,[R0, #+0]
   \       0x1A   0x6852             LDR      R2,[R2, #+4]
   \       0x1C   0xF361 0x621F      BFI      R2,R1,#+24,#+8
   \       0x20   0x6800             LDR      R0,[R0, #+0]
   \       0x22   0x6042             STR      R2,[R0, #+4]
    996          }
   \       0x24   0xB002             ADD      SP,SP,#+8
   \       0x26   0x4770             BX       LR
    997          
    998          /**
    999            * @brief Calculate the number of data to process in RX/TX ISR.
   1000            * @note The RX FIFO depth and the TX FIFO depth is extracted from
   1001            *       the UART configuration registers.
   1002            * @param huart UART handle.
   1003            * @retval None
   1004            */

   \                                 In section .text, align 2, keep-with-next
   1005          static void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)
   1006          {
   \                     UARTEx_SetNbDataToProcess: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   1007            uint8_t rx_fifo_depth;
   1008            uint8_t tx_fifo_depth;
   1009            uint8_t rx_fifo_threshold;
   1010            uint8_t tx_fifo_threshold;
   1011            static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
   1012            static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};
   1013          
   1014            if (huart->FifoMode == UART_FIFOMODE_DISABLE)
   \        0x2   0x6E41             LDR      R1,[R0, #+100]
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD106             BNE.N    ??UARTEx_SetNbDataToProcess_0
   1015            {
   1016              huart->NbTxDataToProcess = 1U;
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0xF8A0 0x106A      STRH     R1,[R0, #+106]
   1017              huart->NbRxDataToProcess = 1U;
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0xF8A0 0x1068      STRH     R1,[R0, #+104]
   \       0x14   0xE021             B.N      ??UARTEx_SetNbDataToProcess_1
   1018            }
   1019            else
   1020            {
   1021              rx_fifo_depth = RX_FIFO_DEPTH;
   \                     ??UARTEx_SetNbDataToProcess_0: (+1)
   \       0x16   0x2208             MOVS     R2,#+8
   1022              tx_fifo_depth = TX_FIFO_DEPTH;
   \       0x18   0x2308             MOVS     R3,#+8
   1023              rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
   \       0x1A   0x6801             LDR      R1,[R0, #+0]
   \       0x1C   0x688C             LDR      R4,[R1, #+8]
   \       0x1E   0x0E64             LSRS     R4,R4,#+25
   \       0x20   0xF014 0x0407      ANDS     R4,R4,#0x7
   1024              tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
   \       0x24   0x6801             LDR      R1,[R0, #+0]
   \       0x26   0x688D             LDR      R5,[R1, #+8]
   \       0x28   0x0F6D             LSRS     R5,R5,#+29
   1025              huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
   1026                                         (uint16_t)denominator[tx_fifo_threshold];
   \       0x2A   0x....             LDR.N    R6,??DataTable1
   \       0x2C   0x....             LDR.N    R7,??DataTable1_1
   \       0x2E   0xB2DB             UXTB     R3,R3
   \       0x30   0x0029             MOVS     R1,R5
   \       0x32   0xB2C9             UXTB     R1,R1
   \       0x34   0x5C79             LDRB     R1,[R7, R1]
   \       0x36   0x434B             MULS     R3,R1,R3
   \       0x38   0xB2ED             UXTB     R5,R5
   \       0x3A   0x5D71             LDRB     R1,[R6, R5]
   \       0x3C   0xFB93 0xF1F1      SDIV     R1,R3,R1
   \       0x40   0xF8A0 0x106A      STRH     R1,[R0, #+106]
   1027              huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
   1028                                         (uint16_t)denominator[rx_fifo_threshold];
   \       0x44   0xB2D2             UXTB     R2,R2
   \       0x46   0x0021             MOVS     R1,R4
   \       0x48   0xB2C9             UXTB     R1,R1
   \       0x4A   0x5C79             LDRB     R1,[R7, R1]
   \       0x4C   0x434A             MULS     R2,R1,R2
   \       0x4E   0xB2E4             UXTB     R4,R4
   \       0x50   0x5D31             LDRB     R1,[R6, R4]
   \       0x52   0xFB92 0xF1F1      SDIV     R1,R2,R1
   \       0x56   0xF8A0 0x1068      STRH     R1,[R0, #+104]
   1029            }
   1030          }
   \                     ??UARTEx_SetNbDataToProcess_1: (+1)
   \       0x5A   0xBCF0             POP      {R4-R7}
   \       0x5C   0x4770             BX       LR

   \                                 In section .rodata, align 4
   \                     `UARTEx_SetNbDataToProcess::numerator`:
   \        0x0   0x01 0x01          DC8 1, 1, 1, 3, 7, 1, 0, 0
   \              0x01 0x03    
   \              0x07 0x01    
   \              0x00 0x00

   \                                 In section .rodata, align 4
   \                     `UARTEx_SetNbDataToProcess::denominator`:
   \        0x0   0x08 0x04          DC8 8, 4, 2, 4, 8, 1, 1, 1
   \              0x02 0x04    
   \              0x08 0x01    
   \              0x01 0x01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     `UARTEx_SetNbDataToProcess::denominator`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x....'....        DC32     `UARTEx_SetNbDataToProcess::numerator`
   1031          /**
   1032            * @}
   1033            */
   1034          
   1035          #endif /* HAL_UART_MODULE_ENABLED */
   1036          
   1037          /**
   1038            * @}
   1039            */
   1040          
   1041          /**
   1042            * @}
   1043            */
   1044          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_MultiProcessorEx_AddressLength_Set
         8   -> UART_CheckIdleState
      24   HAL_RS485Ex_Init
        24   -> HAL_UART_MspInit
        24   -> UART_AdvFeatureConfig
        24   -> UART_CheckIdleState
        24   -> UART_SetConfig
       0   HAL_UARTEx_DisableFifoMode
       0   HAL_UARTEx_DisableStopMode
       8   HAL_UARTEx_EnableFifoMode
         8   -> UARTEx_SetNbDataToProcess
       0   HAL_UARTEx_EnableStopMode
       0   HAL_UARTEx_GetRxEventType
      32   HAL_UARTEx_ReceiveToIdle
        32   -> HAL_GetTick
       8   HAL_UARTEx_ReceiveToIdle_DMA
         8   -> UART_Start_Receive_DMA
      16   HAL_UARTEx_ReceiveToIdle_IT
        16   -> UART_Start_Receive_IT
       0   HAL_UARTEx_RxFifoFullCallback
      16   HAL_UARTEx_SetRxFifoThreshold
        16   -> UARTEx_SetNbDataToProcess
      16   HAL_UARTEx_SetTxFifoThreshold
        16   -> UARTEx_SetNbDataToProcess
      16   HAL_UARTEx_StopModeWakeUpSourceConfig
        16   -> HAL_GetTick
        16   -> UARTEx_Wakeup_AddressConfig
        16   -> UART_WaitOnFlagUntilTimeout
       0   HAL_UARTEx_TxFifoEmptyCallback
       0   HAL_UARTEx_WakeupCallback
      16   UARTEx_SetNbDataToProcess
       8   UARTEx_Wakeup_AddressConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      60  HAL_MultiProcessorEx_AddressLength_Set
     148  HAL_RS485Ex_Init
      68  HAL_UARTEx_DisableFifoMode
      48  HAL_UARTEx_DisableStopMode
      80  HAL_UARTEx_EnableFifoMode
      48  HAL_UARTEx_EnableStopMode
       4  HAL_UARTEx_GetRxEventType
     372  HAL_UARTEx_ReceiveToIdle
     100  HAL_UARTEx_ReceiveToIdle_DMA
      92  HAL_UARTEx_ReceiveToIdle_IT
       2  HAL_UARTEx_RxFifoFullCallback
      84  HAL_UARTEx_SetRxFifoThreshold
      84  HAL_UARTEx_SetTxFifoThreshold
     136  HAL_UARTEx_StopModeWakeUpSourceConfig
       2  HAL_UARTEx_TxFifoEmptyCallback
       2  HAL_UARTEx_WakeupCallback
      94  UARTEx_SetNbDataToProcess
      40  UARTEx_Wakeup_AddressConfig
       8  denominator
       8  numerator

 
    16 bytes in section .rodata
 1'472 bytes in section .text
 
 1'466 bytes of CODE  memory (+ 6 bytes shared)
    16 bytes of CONST memory

Errors: none
Warnings: none
