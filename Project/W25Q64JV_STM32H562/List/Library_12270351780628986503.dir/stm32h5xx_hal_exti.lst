###############################################################################
#
# IAR ANSI C/C++ Compiler V9.40.1.364/W64 for ARM         23/Nov/2023  21:46:12
# Copyright 1999-2023 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_exti.c
#    Command line      =
#        -f
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_exti.o.rsp
#        (C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_exti.c
#        -D STM32H562xx -lCN
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir
#        -lA
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir
#        -o
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33.no_dsp.no_se -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\CMSIS\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Library\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Loader\
#        -Ol) --dependencies=n
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_exti.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir\stm32h5xx_hal_exti.lst
#    Object file       =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_exti.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_exti.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32h5xx_hal_exti.c
      4            * @author  MCD Application Team
      5            * @brief   EXTI HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the General Purpose Input/Output (EXTI) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *
     11            ******************************************************************************
     12            * @attention
     13            *
     14            * Copyright (c) 2023 STMicroelectronics.
     15            * All rights reserved.
     16            *
     17            * This software is licensed under terms that can be found in the LICENSE file
     18            * in the root directory of this software component.
     19            * If no LICENSE file comes with this software, it is provided AS-IS.
     20            *
     21            ******************************************************************************
     22            @verbatim
     23            ==============================================================================
     24                              ##### EXTI Peripheral features #####
     25            ==============================================================================
     26            [..]
     27              (+) Each Exti line can be configured within this driver.
     28          
     29              (+) Exti line can be configured in 3 different modes
     30                  (++) Interrupt
     31                  (++) Event
     32                  (++) Both of them
     33          
     34              (+) Configurable Exti lines can be configured with 3 different triggers
     35                  (++) Rising
     36                  (++) Falling
     37                  (++) Both of them
     38          
     39              (+) When set in interrupt mode, configurable Exti lines have two diffenrents
     40                  interrupt pending registers which allow to distinguish which transition
     41                  occurs:
     42                  (++) Rising edge pending interrupt
     43                  (++) Falling
     44          
     45              (+) Exti lines 0 to 15 are linked to gpio pin number 0 to 15. Gpio port can
     46                  be selected through multiplexer.
     47          
     48                               ##### How to use this driver #####
     49            ==============================================================================
     50            [..]
     51          
     52              (#) Configure the EXTI line using HAL_EXTI_SetConfigLine().
     53                  (++) Choose the interrupt line number by setting "Line" member from
     54                       EXTI_ConfigTypeDef structure.
     55                  (++) Configure the interrupt and/or event mode using "Mode" member from
     56                       EXTI_ConfigTypeDef structure.
     57                  (++) For configurable lines, configure rising and/or falling trigger
     58                       "Trigger" member from EXTI_ConfigTypeDef structure.
     59                  (++) For Exti lines linked to gpio, choose gpio port using "GPIOSel"
     60                       member from GPIO_InitTypeDef structure.
     61          
     62              (#) Get current Exti configuration of a dedicated line using
     63                  HAL_EXTI_GetConfigLine().
     64                  (++) Provide exiting handle as parameter.
     65                  (++) Provide pointer on EXTI_ConfigTypeDef structure as second parameter.
     66          
     67              (#) Clear Exti configuration of a dedicated line using HAL_EXTI_GetConfigLine().
     68                  (++) Provide exiting handle as parameter.
     69          
     70              (#) Register callback to treat Exti interrupts using HAL_EXTI_RegisterCallback().
     71                  (++) Provide exiting handle as first parameter.
     72                  (++) Provide which callback will be registered using one value from
     73                       EXTI_CallbackIDTypeDef.
     74                  (++) Provide callback function pointer.
     75          
     76              (#) Get interrupt pending bit using HAL_EXTI_GetPending().
     77          
     78              (#) Clear interrupt pending bit using HAL_EXTI_GetPending().
     79          
     80              (#) Generate software interrupt using HAL_EXTI_GenerateSWI().
     81          
     82            @endverbatim
     83            */
     84          
     85          /* Includes ------------------------------------------------------------------*/
     86          #include "stm32h5xx_hal.h"
     87          
     88          /** @addtogroup STM32H5xx_HAL_Driver
     89            * @{
     90            */
     91          
     92          /** @addtogroup EXTI
     93            * @{
     94            */
     95          
     96          #ifdef HAL_EXTI_MODULE_ENABLED
     97          
     98          /* Private typedef -----------------------------------------------------------*/
     99          /* Private defines ------------------------------------------------------------*/
    100          /** @defgroup EXTI_Private_Constants EXTI Private Constants
    101            * @{
    102            */
    103          #define EXTI_MODE_OFFSET                    0x04U   /* 0x10: byte offset between: IMR1/EMR1 and IMR2/EMR2 registers */
    104          #define EXTI_CONFIG_OFFSET                  0x08U   /* 0x20: byte offset between Rising1/Falling1 and Rising2/Falling2 
    105                                                                       configuration registers */
    106          #define EXTI_PRIVCFGR_OFFSET                0x08U   /* 0x20: byte offset between PRIVCFGR1 and PRIVCFGR2 registers */
    107          #define EXTI_SECCFGR_OFFSET                 0x08U   /* 0x20: byte offset between SECCFGR1 and SECCFGR2 registers */
    108          /**
    109            * @}
    110            */
    111          
    112          /* Private macros ------------------------------------------------------------*/
    113          /* Private variables ---------------------------------------------------------*/
    114          /* Private function prototypes -----------------------------------------------*/
    115          /* Exported functions --------------------------------------------------------*/
    116          
    117          /** @addtogroup EXTI_Exported_Functions
    118            * @{
    119            */
    120          
    121          /** @addtogroup EXTI_Exported_Functions_Group1
    122            *  @brief    Configuration functions
    123            *
    124          @verbatim
    125           ===============================================================================
    126                        ##### Configuration functions #####
    127           ===============================================================================
    128          
    129          @endverbatim
    130            * @{
    131            */
    132          
    133          /**
    134            * @brief  Set configuration of a dedicated Exti line.
    135            * @param  hexti Exti handle.
    136            * @param  pExtiConfig Pointer on EXTI configuration to be set.
    137            * @retval HAL Status.
    138            */

   \                                 In section .text, align 2, keep-with-next
    139          HAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
    140          {
   \                     HAL_EXTI_SetConfigLine: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
    141            __IO uint32_t *regaddr;
    142            uint32_t regval;
    143            uint32_t linepos;
    144            uint32_t maskline;
    145            uint32_t offset;
    146          
    147            /* Check null pointer */
    148            if ((hexti == NULL) || (pExtiConfig == NULL))
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD001             BEQ.N    ??HAL_EXTI_SetConfigLine_0
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD101             BNE.N    ??HAL_EXTI_SetConfigLine_1
    149            {
    150              return HAL_ERROR;
   \                     ??HAL_EXTI_SetConfigLine_0: (+1)
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE054             B.N      ??HAL_EXTI_SetConfigLine_2
    151            }
    152          
    153            /* Check the parameters */
    154            assert_param(IS_EXTI_LINE(pExtiConfig->Line));
    155            assert_param(IS_EXTI_MODE(pExtiConfig->Mode));
    156          
    157            /* Assign line number to handle */
    158            hexti->Line = pExtiConfig->Line;
   \                     ??HAL_EXTI_SetConfigLine_1: (+1)
   \        0xE   0x680A             LDR      R2,[R1, #+0]
   \       0x10   0x6002             STR      R2,[R0, #+0]
    159          
    160            /* compute line register offset and line mask */
    161            offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
   \       0x12   0x6808             LDR      R0,[R1, #+0]
   \       0x14   0xF3C0 0x4200      UBFX     R2,R0,#+16,#+1
    162            linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
   \       0x18   0x780B             LDRB     R3,[R1, #+0]
   \       0x1A   0xF013 0x031F      ANDS     R3,R3,#0x1F
    163            maskline = (1UL << linepos);
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x4098             LSLS     R0,R0,R3
    164          
    165            /* Configure triggers for configurable lines */
    166            if ((pExtiConfig->Line & EXTI_CONFIG) != 0U)
   \       0x22   0x680C             LDR      R4,[R1, #+0]
   \       0x24   0x01A4             LSLS     R4,R4,#+6
   \       0x26   0xD530             BPL.N    ??HAL_EXTI_SetConfigLine_3
    167            {
    168              assert_param(IS_EXTI_TRIGGER(pExtiConfig->Trigger));
    169          
    170              /* Configure rising trigger */
    171              regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
   \       0x28   0x....             LDR.N    R4,??DataTable8
   \       0x2A   0x0155             LSLS     R5,R2,#+5
   \       0x2C   0x442C             ADD      R4,R4,R5
    172              regval = *regaddr;
   \       0x2E   0x6825             LDR      R5,[R4, #+0]
    173          
    174              /* Mask or set line */
    175              if ((pExtiConfig->Trigger & EXTI_TRIGGER_RISING) != 0U)
   \       0x30   0x7A0E             LDRB     R6,[R1, #+8]
   \       0x32   0x07F6             LSLS     R6,R6,#+31
   \       0x34   0xD501             BPL.N    ??HAL_EXTI_SetConfigLine_4
    176              {
    177                regval |= maskline;
   \       0x36   0x4305             ORRS     R5,R0,R5
   \       0x38   0xE000             B.N      ??HAL_EXTI_SetConfigLine_5
    178              }
    179              else
    180              {
    181                regval &= ~maskline;
   \                     ??HAL_EXTI_SetConfigLine_4: (+1)
   \       0x3A   0x4385             BICS     R5,R5,R0
    182              }
    183          
    184              /* Store rising trigger mode */
    185              *regaddr = regval;
   \                     ??HAL_EXTI_SetConfigLine_5: (+1)
   \       0x3C   0x6025             STR      R5,[R4, #+0]
    186          
    187              /* Configure falling trigger */
    188              regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
   \       0x3E   0x....             LDR.N    R4,??DataTable8_1
   \       0x40   0x0155             LSLS     R5,R2,#+5
   \       0x42   0x442C             ADD      R4,R4,R5
    189              regval = *regaddr;
   \       0x44   0x6825             LDR      R5,[R4, #+0]
    190          
    191              /* Mask or set line */
    192              if ((pExtiConfig->Trigger & EXTI_TRIGGER_FALLING) != 0U)
   \       0x46   0x7A0E             LDRB     R6,[R1, #+8]
   \       0x48   0x07B6             LSLS     R6,R6,#+30
   \       0x4A   0xD501             BPL.N    ??HAL_EXTI_SetConfigLine_6
    193              {
    194                regval |= maskline;
   \       0x4C   0x4305             ORRS     R5,R0,R5
   \       0x4E   0xE000             B.N      ??HAL_EXTI_SetConfigLine_7
    195              }
    196              else
    197              {
    198                regval &= ~maskline;
   \                     ??HAL_EXTI_SetConfigLine_6: (+1)
   \       0x50   0x4385             BICS     R5,R5,R0
    199              }
    200          
    201              /* Store falling trigger mode */
    202              *regaddr = regval;
   \                     ??HAL_EXTI_SetConfigLine_7: (+1)
   \       0x52   0x6025             STR      R5,[R4, #+0]
    203          
    204              /* Configure gpio port selection in case of gpio exti line */
    205              if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
   \       0x54   0x680C             LDR      R4,[R1, #+0]
   \       0x56   0xF014 0x64C0      ANDS     R4,R4,#0x6000000
   \       0x5A   0xF1B4 0x6FC0      CMP      R4,#+100663296
   \       0x5E   0xD114             BNE.N    ??HAL_EXTI_SetConfigLine_3
    206              {
    207                assert_param(IS_EXTI_GPIO_PORT(pExtiConfig->GPIOSel));
    208                assert_param(IS_EXTI_GPIO_PIN(linepos));
    209          
    210                regval = EXTI->EXTICR[(linepos >> 2U) & 0x03UL];
   \       0x60   0x....             LDR.N    R5,??DataTable8_2
   \       0x62   0xF3C3 0x0481      UBFX     R4,R3,#+2,#+2
   \       0x66   0xF855 0x4024      LDR      R4,[R5, R4, LSL #+2]
    211                regval &= ~(EXTI_EXTICR1_EXTI0 << (EXTI_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
   \       0x6A   0x260F             MOVS     R6,#+15
   \       0x6C   0x00DF             LSLS     R7,R3,#+3
   \       0x6E   0xF017 0x0718      ANDS     R7,R7,#0x18
   \       0x72   0x40BE             LSLS     R6,R6,R7
   \       0x74   0x43B4             BICS     R4,R4,R6
    212                regval |= (pExtiConfig->GPIOSel << (EXTI_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
   \       0x76   0x68CE             LDR      R6,[R1, #+12]
   \       0x78   0x00DF             LSLS     R7,R3,#+3
   \       0x7A   0xF017 0x0718      ANDS     R7,R7,#0x18
   \       0x7E   0x40BE             LSLS     R6,R6,R7
   \       0x80   0x4334             ORRS     R4,R6,R4
    213                EXTI->EXTICR[(linepos >> 2U) & 0x03UL] = regval;
   \       0x82   0xF3C3 0x0381      UBFX     R3,R3,#+2,#+2
   \       0x86   0xF845 0x4023      STR      R4,[R5, R3, LSL #+2]
    214              }
    215            }
    216          
    217            /* Configure interrupt mode : read current mode */
    218            regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
   \                     ??HAL_EXTI_SetConfigLine_3: (+1)
   \       0x8A   0x....             LDR.N    R3,??DataTable8_3
   \       0x8C   0x0114             LSLS     R4,R2,#+4
   \       0x8E   0x4423             ADD      R3,R3,R4
    219            regval = *regaddr;
   \       0x90   0x681C             LDR      R4,[R3, #+0]
    220          
    221            /* Mask or set line */
    222            if ((pExtiConfig->Mode & EXTI_MODE_INTERRUPT) != 0U)
   \       0x92   0x790D             LDRB     R5,[R1, #+4]
   \       0x94   0x07ED             LSLS     R5,R5,#+31
   \       0x96   0xD501             BPL.N    ??HAL_EXTI_SetConfigLine_8
    223            {
    224              regval |= maskline;
   \       0x98   0x4304             ORRS     R4,R0,R4
   \       0x9A   0xE000             B.N      ??HAL_EXTI_SetConfigLine_9
    225            }
    226            else
    227            {
    228              regval &= ~maskline;
   \                     ??HAL_EXTI_SetConfigLine_8: (+1)
   \       0x9C   0x4384             BICS     R4,R4,R0
    229            }
    230          
    231            /* Store interrupt mode */
    232            *regaddr = regval;
   \                     ??HAL_EXTI_SetConfigLine_9: (+1)
   \       0x9E   0x601C             STR      R4,[R3, #+0]
    233          
    234            /* Configure event mode : read current mode */
    235            regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
   \       0xA0   0x....             LDR.N    R3,??DataTable8_4
   \       0xA2   0x0112             LSLS     R2,R2,#+4
   \       0xA4   0x441A             ADD      R2,R3,R2
    236            regval = *regaddr;
   \       0xA6   0x6813             LDR      R3,[R2, #+0]
    237          
    238            /* Mask or set line */
    239            if ((pExtiConfig->Mode & EXTI_MODE_EVENT) != 0U)
   \       0xA8   0x7909             LDRB     R1,[R1, #+4]
   \       0xAA   0x0789             LSLS     R1,R1,#+30
   \       0xAC   0xD501             BPL.N    ??HAL_EXTI_SetConfigLine_10
    240            {
    241              regval |= maskline;
   \       0xAE   0x4303             ORRS     R3,R0,R3
   \       0xB0   0xE000             B.N      ??HAL_EXTI_SetConfigLine_11
    242            }
    243            else
    244            {
    245              regval &= ~maskline;
   \                     ??HAL_EXTI_SetConfigLine_10: (+1)
   \       0xB2   0x4383             BICS     R3,R3,R0
    246            }
    247          
    248            /* Store event mode */
    249            *regaddr = regval;
   \                     ??HAL_EXTI_SetConfigLine_11: (+1)
   \       0xB4   0x6013             STR      R3,[R2, #+0]
    250          
    251            return HAL_OK;
   \       0xB6   0x2000             MOVS     R0,#+0
   \                     ??HAL_EXTI_SetConfigLine_2: (+1)
   \       0xB8   0xBCF0             POP      {R4-R7}
   \       0xBA   0x4770             BX       LR
    252          }
    253          
    254          
    255          /**
    256            * @brief  Get configuration of a dedicated Exti line.
    257            * @param  hexti Exti handle.
    258            * @param  pExtiConfig Pointer on structure to store Exti configuration.
    259            * @retval HAL Status.
    260            */

   \                                 In section .text, align 2, keep-with-next
    261          HAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
    262          {
   \                     HAL_EXTI_GetConfigLine: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    263            const __IO uint32_t *regaddr;
    264            uint32_t regval;
    265            uint32_t linepos;
    266            uint32_t maskline;
    267            uint32_t offset;
    268          
    269            /* Check null pointer */
    270            if ((hexti == NULL) || (pExtiConfig == NULL))
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD001             BEQ.N    ??HAL_EXTI_GetConfigLine_0
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD101             BNE.N    ??HAL_EXTI_GetConfigLine_1
    271            {
    272              return HAL_ERROR;
   \                     ??HAL_EXTI_GetConfigLine_0: (+1)
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE04A             B.N      ??HAL_EXTI_GetConfigLine_2
    273            }
    274          
    275            /* Check the parameter */
    276            assert_param(IS_EXTI_LINE(hexti->Line));
    277          
    278            /* Store handle line number to configiguration structure */
    279            pExtiConfig->Line = hexti->Line;
   \                     ??HAL_EXTI_GetConfigLine_1: (+1)
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x6008             STR      R0,[R1, #+0]
    280          
    281            /* compute line register offset and line mask */
    282            offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
   \       0x12   0x6808             LDR      R0,[R1, #+0]
   \       0x14   0xF3C0 0x4300      UBFX     R3,R0,#+16,#+1
    283            linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
   \       0x18   0x7808             LDRB     R0,[R1, #+0]
   \       0x1A   0xF010 0x001F      ANDS     R0,R0,#0x1F
    284            maskline = (1UL << linepos);
   \       0x1E   0x2201             MOVS     R2,#+1
   \       0x20   0x4082             LSLS     R2,R2,R0
    285          
    286            /* 1] Get core mode : interrupt */
    287            regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
   \       0x22   0x....             LDR.N    R4,??DataTable8_3
   \       0x24   0x011D             LSLS     R5,R3,#+4
   \       0x26   0x442C             ADD      R4,R4,R5
    288            regval = *regaddr;
   \       0x28   0x6824             LDR      R4,[R4, #+0]
    289          
    290            /* Check if selected line is enable */
    291            if ((regval & maskline) != 0U)
   \       0x2A   0x4214             TST      R4,R2
   \       0x2C   0xD002             BEQ.N    ??HAL_EXTI_GetConfigLine_3
    292            {
    293              pExtiConfig->Mode = EXTI_MODE_INTERRUPT;
   \       0x2E   0x2401             MOVS     R4,#+1
   \       0x30   0x604C             STR      R4,[R1, #+4]
   \       0x32   0xE001             B.N      ??HAL_EXTI_GetConfigLine_4
    294            }
    295            else
    296            {
    297              pExtiConfig->Mode = EXTI_MODE_NONE;
   \                     ??HAL_EXTI_GetConfigLine_3: (+1)
   \       0x34   0x2400             MOVS     R4,#+0
   \       0x36   0x604C             STR      R4,[R1, #+4]
    298            }
    299          
    300            /* Get event mode */
    301            regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
   \                     ??HAL_EXTI_GetConfigLine_4: (+1)
   \       0x38   0x....             LDR.N    R4,??DataTable8_4
   \       0x3A   0x011D             LSLS     R5,R3,#+4
   \       0x3C   0x442C             ADD      R4,R4,R5
    302            regval = *regaddr;
   \       0x3E   0x6824             LDR      R4,[R4, #+0]
    303          
    304            /* Check if selected line is enable */
    305            if ((regval & maskline) != 0U)
   \       0x40   0x4214             TST      R4,R2
   \       0x42   0xD003             BEQ.N    ??HAL_EXTI_GetConfigLine_5
    306            {
    307              pExtiConfig->Mode |= EXTI_MODE_EVENT;
   \       0x44   0x684C             LDR      R4,[R1, #+4]
   \       0x46   0xF054 0x0402      ORRS     R4,R4,#0x2
   \       0x4A   0x604C             STR      R4,[R1, #+4]
    308            }
    309          
    310            /* 2] Get trigger for configurable lines : rising */
    311            if ((pExtiConfig->Line & EXTI_CONFIG) != 0U)
   \                     ??HAL_EXTI_GetConfigLine_5: (+1)
   \       0x4C   0x680C             LDR      R4,[R1, #+0]
   \       0x4E   0x01A4             LSLS     R4,R4,#+6
   \       0x50   0xD527             BPL.N    ??HAL_EXTI_GetConfigLine_6
    312            {
    313              regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
   \       0x52   0x....             LDR.N    R4,??DataTable8
   \       0x54   0x015D             LSLS     R5,R3,#+5
   \       0x56   0x442C             ADD      R4,R4,R5
    314              regval = *regaddr;
   \       0x58   0x6824             LDR      R4,[R4, #+0]
    315          
    316              /* Get default Trigger and GPIOSel configuration */
    317              pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
   \       0x5A   0x2500             MOVS     R5,#+0
   \       0x5C   0x608D             STR      R5,[R1, #+8]
    318              pExtiConfig->GPIOSel = 0x00u;
   \       0x5E   0x2500             MOVS     R5,#+0
   \       0x60   0x60CD             STR      R5,[R1, #+12]
    319          
    320              /* Check if configuration of selected line is enable */
    321              if ((regval & maskline) != 0U)
   \       0x62   0x4214             TST      R4,R2
   \       0x64   0xD001             BEQ.N    ??HAL_EXTI_GetConfigLine_7
    322              {
    323                pExtiConfig->Trigger = EXTI_TRIGGER_RISING;
   \       0x66   0x2401             MOVS     R4,#+1
   \       0x68   0x608C             STR      R4,[R1, #+8]
    324              }
    325          
    326              /* Get falling configuration */
    327              regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
   \                     ??HAL_EXTI_GetConfigLine_7: (+1)
   \       0x6A   0x....             LDR.N    R4,??DataTable8_1
   \       0x6C   0x015B             LSLS     R3,R3,#+5
   \       0x6E   0x4423             ADD      R3,R4,R3
    328              regval = *regaddr;
   \       0x70   0x681B             LDR      R3,[R3, #+0]
    329          
    330              /* Check if configuration of selected line is enable */
    331              if ((regval & maskline) != 0U)
   \       0x72   0x4213             TST      R3,R2
   \       0x74   0xD003             BEQ.N    ??HAL_EXTI_GetConfigLine_8
    332              {
    333                pExtiConfig->Trigger |= EXTI_TRIGGER_FALLING;
   \       0x76   0x688A             LDR      R2,[R1, #+8]
   \       0x78   0xF052 0x0202      ORRS     R2,R2,#0x2
   \       0x7C   0x608A             STR      R2,[R1, #+8]
    334              }
    335          
    336              /* Get Gpio port selection for gpio lines */
    337              if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
   \                     ??HAL_EXTI_GetConfigLine_8: (+1)
   \       0x7E   0x680A             LDR      R2,[R1, #+0]
   \       0x80   0xF012 0x62C0      ANDS     R2,R2,#0x6000000
   \       0x84   0xF1B2 0x6FC0      CMP      R2,#+100663296
   \       0x88   0xD10B             BNE.N    ??HAL_EXTI_GetConfigLine_6
    338              {
    339                assert_param(IS_EXTI_GPIO_PIN(linepos));
    340          
    341                regval = EXTI->EXTICR[(linepos >> 2U) & 0x03UL];
   \       0x8A   0x....             LDR.N    R2,??DataTable8_2
   \       0x8C   0xF3C0 0x0381      UBFX     R3,R0,#+2,#+2
   \       0x90   0xF852 0x2023      LDR      R2,[R2, R3, LSL #+2]
    342                pExtiConfig->GPIOSel = (regval >> (EXTI_EXTICR1_EXTI1_Pos * (linepos & 0x03u))) & EXTI_EXTICR1_EXTI0;
   \       0x94   0x00C0             LSLS     R0,R0,#+3
   \       0x96   0xF010 0x0018      ANDS     R0,R0,#0x18
   \       0x9A   0x40C2             LSRS     R2,R2,R0
   \       0x9C   0xF012 0x020F      ANDS     R2,R2,#0xF
   \       0xA0   0x60CA             STR      R2,[R1, #+12]
    343              }
    344            }
    345          
    346            return HAL_OK;
   \                     ??HAL_EXTI_GetConfigLine_6: (+1)
   \       0xA2   0x2000             MOVS     R0,#+0
   \                     ??HAL_EXTI_GetConfigLine_2: (+1)
   \       0xA4   0xBC30             POP      {R4,R5}
   \       0xA6   0x4770             BX       LR
    347          }
    348          
    349          
    350          /**
    351            * @brief  Clear whole configuration of a dedicated Exti line.
    352            * @param  hexti Exti handle.
    353            * @retval HAL Status.
    354            */

   \                                 In section .text, align 2, keep-with-next
    355          HAL_StatusTypeDef HAL_EXTI_ClearConfigLine(const EXTI_HandleTypeDef *hexti)
    356          {
   \                     HAL_EXTI_ClearConfigLine: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    357            __IO uint32_t *regaddr;
    358            uint32_t regval;
    359            uint32_t linepos;
    360            uint32_t maskline;
    361            uint32_t offset;
    362          
    363            /* Check null pointer */
    364            if (hexti == NULL)
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD101             BNE.N    ??HAL_EXTI_ClearConfigLine_0
    365            {
    366              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xE038             B.N      ??HAL_EXTI_ClearConfigLine_1
    367            }
    368          
    369            /* Check the parameter */
    370            assert_param(IS_EXTI_LINE(hexti->Line));
    371          
    372            /* compute line register offset and line mask */
    373            offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
   \                     ??HAL_EXTI_ClearConfigLine_0: (+1)
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF3C1 0x4300      UBFX     R3,R1,#+16,#+1
    374            linepos = (hexti->Line & EXTI_PIN_MASK);
   \       0x10   0x7801             LDRB     R1,[R0, #+0]
   \       0x12   0xF011 0x011F      ANDS     R1,R1,#0x1F
    375            maskline = (1UL << linepos);
   \       0x16   0x2201             MOVS     R2,#+1
   \       0x18   0x408A             LSLS     R2,R2,R1
    376          
    377            /* 1] Clear interrupt mode */
    378            regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
   \       0x1A   0x....             LDR.N    R4,??DataTable8_3
   \       0x1C   0x011D             LSLS     R5,R3,#+4
   \       0x1E   0x442C             ADD      R4,R4,R5
    379            regval = (*regaddr & ~maskline);
   \       0x20   0x6825             LDR      R5,[R4, #+0]
   \       0x22   0x4395             BICS     R5,R5,R2
    380            *regaddr = regval;
   \       0x24   0x6025             STR      R5,[R4, #+0]
    381          
    382            /* 2] Clear event mode */
    383            regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
   \       0x26   0x....             LDR.N    R4,??DataTable8_4
   \       0x28   0x011D             LSLS     R5,R3,#+4
   \       0x2A   0x442C             ADD      R4,R4,R5
    384            regval = (*regaddr & ~maskline);
   \       0x2C   0x6825             LDR      R5,[R4, #+0]
   \       0x2E   0x4395             BICS     R5,R5,R2
    385            *regaddr = regval;
   \       0x30   0x6025             STR      R5,[R4, #+0]
    386          
    387            /* 3] Clear triggers in case of configurable lines */
    388            if ((hexti->Line & EXTI_CONFIG) != 0U)
   \       0x32   0x6804             LDR      R4,[R0, #+0]
   \       0x34   0x01A4             LSLS     R4,R4,#+6
   \       0x36   0xD520             BPL.N    ??HAL_EXTI_ClearConfigLine_2
    389            {
    390              regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
   \       0x38   0x....             LDR.N    R4,??DataTable8
   \       0x3A   0x015D             LSLS     R5,R3,#+5
   \       0x3C   0x442C             ADD      R4,R4,R5
    391              regval = (*regaddr & ~maskline);
   \       0x3E   0x6825             LDR      R5,[R4, #+0]
   \       0x40   0x4395             BICS     R5,R5,R2
    392              *regaddr = regval;
   \       0x42   0x6025             STR      R5,[R4, #+0]
    393          
    394              regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
   \       0x44   0x....             LDR.N    R4,??DataTable8_1
   \       0x46   0x015B             LSLS     R3,R3,#+5
   \       0x48   0x4423             ADD      R3,R4,R3
    395              regval = (*regaddr & ~maskline);
   \       0x4A   0x681C             LDR      R4,[R3, #+0]
   \       0x4C   0x4394             BICS     R4,R4,R2
    396              *regaddr = regval;
   \       0x4E   0x601C             STR      R4,[R3, #+0]
    397          
    398              /* Get Gpio port selection for gpio lines */
    399              if ((hexti->Line & EXTI_GPIO) == EXTI_GPIO)
   \       0x50   0x6800             LDR      R0,[R0, #+0]
   \       0x52   0xF010 0x60C0      ANDS     R0,R0,#0x6000000
   \       0x56   0xF1B0 0x6FC0      CMP      R0,#+100663296
   \       0x5A   0xD10E             BNE.N    ??HAL_EXTI_ClearConfigLine_2
    400              {
    401                assert_param(IS_EXTI_GPIO_PIN(linepos));
    402          
    403                regval = EXTI->EXTICR[(linepos >> 2U) & 0x03UL];
   \       0x5C   0x....             LDR.N    R2,??DataTable8_2
   \       0x5E   0xF3C1 0x0081      UBFX     R0,R1,#+2,#+2
   \       0x62   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
    404                regval &= ~(EXTI_EXTICR1_EXTI0 << (EXTI_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
   \       0x66   0x230F             MOVS     R3,#+15
   \       0x68   0x00CC             LSLS     R4,R1,#+3
   \       0x6A   0xF014 0x0418      ANDS     R4,R4,#0x18
   \       0x6E   0x40A3             LSLS     R3,R3,R4
   \       0x70   0x4398             BICS     R0,R0,R3
    405                EXTI->EXTICR[(linepos >> 2U) & 0x03UL] = regval;
   \       0x72   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \       0x76   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    406              }
    407            }
    408          
    409            return HAL_OK;
   \                     ??HAL_EXTI_ClearConfigLine_2: (+1)
   \       0x7A   0x2000             MOVS     R0,#+0
   \                     ??HAL_EXTI_ClearConfigLine_1: (+1)
   \       0x7C   0xBC30             POP      {R4,R5}
   \       0x7E   0x4770             BX       LR
    410          }
    411          
    412          
    413          /**
    414            * @brief  Register callback for a dedicaated Exti line.
    415            * @param  hexti Exti handle.
    416            * @param  CallbackID User callback identifier.
    417            *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
    418            * @param  pPendingCbfn function pointer to be stored as callback.
    419            * @retval HAL Status.
    420            */

   \                                 In section .text, align 2, keep-with-next
    421          HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID,
    422                                                      void (*pPendingCbfn)(void))
    423          {
   \                     HAL_EXTI_RegisterCallback: (+1)
   \        0x0   0x0003             MOVS     R3,R0
    424            HAL_StatusTypeDef status = HAL_OK;
   \        0x2   0x2000             MOVS     R0,#+0
    425          
    426            switch (CallbackID)
   \        0x4   0xB2C9             UXTB     R1,R1
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD003             BEQ.N    ??HAL_EXTI_RegisterCallback_0
   \        0xA   0x2902             CMP      R1,#+2
   \        0xC   0xD006             BEQ.N    ??HAL_EXTI_RegisterCallback_1
   \        0xE   0xD303             BCC.N    ??HAL_EXTI_RegisterCallback_2
   \       0x10   0xE006             B.N      ??HAL_EXTI_RegisterCallback_3
    427            {
    428              case  HAL_EXTI_COMMON_CB_ID:
    429                hexti->RisingCallback = pPendingCbfn;
   \                     ??HAL_EXTI_RegisterCallback_0: (+1)
   \       0x12   0x605A             STR      R2,[R3, #+4]
    430                hexti->FallingCallback = pPendingCbfn;
   \       0x14   0x609A             STR      R2,[R3, #+8]
    431                break;
   \       0x16   0xE004             B.N      ??HAL_EXTI_RegisterCallback_4
    432          
    433              case  HAL_EXTI_RISING_CB_ID:
    434                hexti->RisingCallback = pPendingCbfn;
   \                     ??HAL_EXTI_RegisterCallback_2: (+1)
   \       0x18   0x605A             STR      R2,[R3, #+4]
    435                break;
   \       0x1A   0xE002             B.N      ??HAL_EXTI_RegisterCallback_4
    436          
    437              case  HAL_EXTI_FALLING_CB_ID:
    438                hexti->FallingCallback = pPendingCbfn;
   \                     ??HAL_EXTI_RegisterCallback_1: (+1)
   \       0x1C   0x609A             STR      R2,[R3, #+8]
    439                break;
   \       0x1E   0xE000             B.N      ??HAL_EXTI_RegisterCallback_4
    440          
    441              default:
    442                status = HAL_ERROR;
   \                     ??HAL_EXTI_RegisterCallback_3: (+1)
   \       0x20   0x2001             MOVS     R0,#+1
    443                break;
    444            }
    445          
    446            return status;
   \                     ??HAL_EXTI_RegisterCallback_4: (+1)
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x4770             BX       LR
    447          }
    448          
    449          
    450          /**
    451            * @brief  Store line number as handle private field.
    452            * @param  hexti Exti handle.
    453            * @param  ExtiLine Exti line number.
    454            *         This parameter can be from 0 to @ref EXTI_LINE_NB.
    455            * @retval HAL Status.
    456            */

   \                                 In section .text, align 2, keep-with-next
    457          HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
    458          {
    459            /* Check the parameters */
    460            assert_param(IS_EXTI_LINE(ExtiLine));
    461          
    462            /* Check null pointer */
    463            if (hexti == NULL)
   \                     HAL_EXTI_GetHandle: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??HAL_EXTI_GetHandle_0
    464            {
    465              return HAL_ERROR;
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0xE001             B.N      ??HAL_EXTI_GetHandle_1
    466            }
    467            else
    468            {
    469              /* Store line number as handle private field */
    470              hexti->Line = ExtiLine;
   \                     ??HAL_EXTI_GetHandle_0: (+1)
   \        0x8   0x6001             STR      R1,[R0, #+0]
    471          
    472              return HAL_OK;
   \        0xA   0x2000             MOVS     R0,#+0
   \                     ??HAL_EXTI_GetHandle_1: (+1)
   \        0xC   0x4770             BX       LR
    473            }
    474          }
    475          
    476          
    477          /**
    478            * @}
    479            */
    480          
    481          /** @addtogroup EXTI_Exported_Functions_Group2
    482            *  @brief EXTI IO functions.
    483            *
    484          @verbatim
    485           ===============================================================================
    486                                 ##### IO operation functions #####
    487           ===============================================================================
    488          
    489          @endverbatim
    490            * @{
    491            */
    492          
    493          /**
    494            * @brief  Handle EXTI interrupt request.
    495            * @param  hexti Exti handle.
    496            * @retval none.
    497            */

   \                                 In section .text, align 2, keep-with-next
    498          void HAL_EXTI_IRQHandler(const EXTI_HandleTypeDef *hexti)
    499          {
   \                     HAL_EXTI_IRQHandler: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    500            __IO uint32_t *regaddr;
    501            uint32_t regval;
    502            uint32_t maskline;
    503            uint32_t offset;
    504          
    505            /* Compute line register offset and line mask */
    506            offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xF3C0 0x4600      UBFX     R6,R0,#+16,#+1
    507            maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
   \        0xA   0x2501             MOVS     R5,#+1
   \        0xC   0x7820             LDRB     R0,[R4, #+0]
   \        0xE   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \       0x12   0x4085             LSLS     R5,R5,R0
    508          
    509            /* Get rising edge pending bit  */
    510            regaddr = (__IO uint32_t *)(&EXTI->RPR1 + (EXTI_CONFIG_OFFSET * offset));
   \       0x14   0x....             LDR.N    R0,??DataTable8_5
   \       0x16   0x0171             LSLS     R1,R6,#+5
   \       0x18   0x4401             ADD      R1,R0,R1
    511            regval = (*regaddr & maskline);
   \       0x1A   0x6808             LDR      R0,[R1, #+0]
   \       0x1C   0x4028             ANDS     R0,R5,R0
    512          
    513            if (regval != 0U)
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD005             BEQ.N    ??HAL_EXTI_IRQHandler_0
    514            {
    515              /* Clear pending bit */
    516              *regaddr = maskline;
   \       0x22   0x600D             STR      R5,[R1, #+0]
    517          
    518              /* Call rising callback */
    519              if (hexti->RisingCallback != NULL)
   \       0x24   0x6860             LDR      R0,[R4, #+4]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD001             BEQ.N    ??HAL_EXTI_IRQHandler_0
    520              {
    521                hexti->RisingCallback();
   \       0x2A   0x6860             LDR      R0,[R4, #+4]
   \       0x2C   0x4780             BLX      R0
    522              }
    523            }
    524          
    525            /* Get falling edge pending bit  */
    526            regaddr = (__IO uint32_t *)(&EXTI->FPR1 + (EXTI_CONFIG_OFFSET * offset));
   \                     ??HAL_EXTI_IRQHandler_0: (+1)
   \       0x2E   0x....             LDR.N    R0,??DataTable8_6
   \       0x30   0x0176             LSLS     R6,R6,#+5
   \       0x32   0xEB00 0x0106      ADD      R1,R0,R6
    527            regval = (*regaddr & maskline);
   \       0x36   0x6808             LDR      R0,[R1, #+0]
   \       0x38   0x4028             ANDS     R0,R5,R0
    528          
    529            if (regval != 0U)
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD005             BEQ.N    ??HAL_EXTI_IRQHandler_1
    530            {
    531              /* Clear pending bit */
    532              *regaddr = maskline;
   \       0x3E   0x600D             STR      R5,[R1, #+0]
    533          
    534              /* Call rising callback */
    535              if (hexti->FallingCallback != NULL)
   \       0x40   0x68A0             LDR      R0,[R4, #+8]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD001             BEQ.N    ??HAL_EXTI_IRQHandler_1
    536              {
    537                hexti->FallingCallback();
   \       0x46   0x68A0             LDR      R0,[R4, #+8]
   \       0x48   0x4780             BLX      R0
    538              }
    539            }
    540          }
   \                     ??HAL_EXTI_IRQHandler_1: (+1)
   \       0x4A   0xBD70             POP      {R4-R6,PC}
    541          
    542          
    543          /**
    544            * @brief  Get interrupt pending bit of a dedicated line.
    545            * @param  hexti Exti handle.
    546            * @param  Edge Specify which pending edge as to be checked.
    547            *         This parameter can be one of the following values:
    548            *           @arg @ref EXTI_TRIGGER_RISING
    549            *           @arg @ref EXTI_TRIGGER_FALLING
    550            * @retval 1 if interrupt is pending else 0.
    551            */

   \                                 In section .text, align 2, keep-with-next
    552          uint32_t HAL_EXTI_GetPending(const EXTI_HandleTypeDef *hexti, uint32_t Edge)
    553          {
    554            const __IO uint32_t *regaddr;
    555            uint32_t regval;
    556            uint32_t linepos;
    557            uint32_t maskline;
    558            uint32_t offset;
    559          
    560            /* Check the parameters */
    561            assert_param(IS_EXTI_LINE(hexti->Line));
    562            assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
    563            assert_param(IS_EXTI_PENDING_EDGE(Edge));
    564          
    565            /* compute line register offset and line mask */
    566            offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
   \                     HAL_EXTI_GetPending: (+1)
   \        0x0   0x6802             LDR      R2,[R0, #+0]
   \        0x2   0xF3C2 0x4300      UBFX     R3,R2,#+16,#+1
    567            linepos = (hexti->Line & EXTI_PIN_MASK);
   \        0x6   0x7802             LDRB     R2,[R0, #+0]
   \        0x8   0xF012 0x021F      ANDS     R2,R2,#0x1F
    568            maskline = (1UL << linepos);
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x4090             LSLS     R0,R0,R2
    569          
    570            if (Edge != EXTI_TRIGGER_RISING)
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD003             BEQ.N    ??HAL_EXTI_GetPending_0
    571            {
    572              /* Get falling edge pending bit */
    573              regaddr = (__IO uint32_t *)(&EXTI->FPR1 + (EXTI_CONFIG_OFFSET * offset));
   \       0x14   0x....             LDR.N    R1,??DataTable8_6
   \       0x16   0x015B             LSLS     R3,R3,#+5
   \       0x18   0x4419             ADD      R1,R1,R3
   \       0x1A   0xE002             B.N      ??HAL_EXTI_GetPending_1
    574            }
    575            else
    576            {
    577              /* Get rising edge pending bit */
    578              regaddr = (__IO uint32_t *)(&EXTI->RPR1 + (EXTI_CONFIG_OFFSET * offset));
   \                     ??HAL_EXTI_GetPending_0: (+1)
   \       0x1C   0x....             LDR.N    R1,??DataTable8_5
   \       0x1E   0x015B             LSLS     R3,R3,#+5
   \       0x20   0x4419             ADD      R1,R1,R3
    579            }
    580          
    581            /* return 1 if bit is set else 0 */
    582            regval = ((*regaddr & maskline) >> linepos);
   \                     ??HAL_EXTI_GetPending_1: (+1)
   \       0x22   0x6809             LDR      R1,[R1, #+0]
   \       0x24   0x4008             ANDS     R0,R0,R1
   \       0x26   0x40D0             LSRS     R0,R0,R2
    583            return regval;
   \       0x28   0x4770             BX       LR
    584          }
    585          
    586          
    587          /**
    588            * @brief  Clear interrupt pending bit of a dedicated line.
    589            * @param  hexti Exti handle.
    590            * @param  Edge Specify which pending edge as to be clear.
    591            *         This parameter can be one of the following values:
    592            *           @arg @ref EXTI_TRIGGER_RISING
    593            *           @arg @ref EXTI_TRIGGER_FALLING
    594            * @retval None.
    595            */

   \                                 In section .text, align 2, keep-with-next
    596          void HAL_EXTI_ClearPending(const EXTI_HandleTypeDef *hexti, uint32_t Edge)
    597          {
    598            __IO uint32_t *regaddr;
    599            uint32_t maskline;
    600            uint32_t offset;
    601          
    602            /* Check the parameters */
    603            assert_param(IS_EXTI_LINE(hexti->Line));
    604            assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
    605            assert_param(IS_EXTI_PENDING_EDGE(Edge));
    606          
    607            /* compute line register offset and line mask */
    608            offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
   \                     HAL_EXTI_ClearPending: (+1)
   \        0x0   0x6802             LDR      R2,[R0, #+0]
   \        0x2   0xF3C2 0x4300      UBFX     R3,R2,#+16,#+1
    609            maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
   \        0x6   0x2201             MOVS     R2,#+1
   \        0x8   0x7800             LDRB     R0,[R0, #+0]
   \        0xA   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \        0xE   0x4082             LSLS     R2,R2,R0
    610          
    611            if (Edge != EXTI_TRIGGER_RISING)
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD003             BEQ.N    ??HAL_EXTI_ClearPending_0
    612            {
    613              /* Get falling edge pending register address */
    614              regaddr = (__IO uint32_t *)(&EXTI->FPR1 + (EXTI_CONFIG_OFFSET * offset));
   \       0x14   0x....             LDR.N    R0,??DataTable8_6
   \       0x16   0x015B             LSLS     R3,R3,#+5
   \       0x18   0x4418             ADD      R0,R0,R3
   \       0x1A   0xE002             B.N      ??HAL_EXTI_ClearPending_1
    615            }
    616            else
    617            {
    618              /* Get falling edge pending register address */
    619              regaddr = (__IO uint32_t *)(&EXTI->RPR1 + (EXTI_CONFIG_OFFSET * offset));
   \                     ??HAL_EXTI_ClearPending_0: (+1)
   \       0x1C   0x....             LDR.N    R0,??DataTable8_5
   \       0x1E   0x015B             LSLS     R3,R3,#+5
   \       0x20   0x4418             ADD      R0,R0,R3
    620            }
    621          
    622            /* Clear Pending bit */
    623            *regaddr =  maskline;
   \                     ??HAL_EXTI_ClearPending_1: (+1)
   \       0x22   0x6002             STR      R2,[R0, #+0]
    624          }
   \       0x24   0x4770             BX       LR
    625          
    626          
    627          /**
    628            * @brief  Generate a software interrupt for a dedicated line.
    629            * @param  hexti Exti handle.
    630            * @retval None.
    631            */

   \                                 In section .text, align 2, keep-with-next
    632          void HAL_EXTI_GenerateSWI(const EXTI_HandleTypeDef *hexti)
    633          {
    634            __IO uint32_t *regaddr;
    635            uint32_t maskline;
    636            uint32_t offset;
    637          
    638            /* Check the parameters */
    639            assert_param(IS_EXTI_LINE(hexti->Line));
    640            assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
    641          
    642            /* compute line register offset and line mask */
    643            offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
   \                     HAL_EXTI_GenerateSWI: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xF3C1 0x4200      UBFX     R2,R1,#+16,#+1
    644            maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
   \        0x6   0x2101             MOVS     R1,#+1
   \        0x8   0x7800             LDRB     R0,[R0, #+0]
   \        0xA   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \        0xE   0x4081             LSLS     R1,R1,R0
    645          
    646            regaddr = (__IO uint32_t *)(&EXTI->SWIER1 + (EXTI_CONFIG_OFFSET * offset));
   \       0x10   0x....             LDR.N    R0,??DataTable8_7
   \       0x12   0x0152             LSLS     R2,R2,#+5
   \       0x14   0x4410             ADD      R0,R0,R2
    647            *regaddr = maskline;
   \       0x16   0x6001             STR      R1,[R0, #+0]
    648          }
   \       0x18   0x4770             BX       LR
    649          
    650          
    651          /**
    652            * @}
    653            */
    654          
    655          /** @defgroup EXTI_Exported_Functions_Group3 EXTI line attributes management functions
    656            *  @brief EXTI attributes management functions.
    657            *
    658          @verbatim
    659           ===============================================================================
    660                                 ##### EXTI attributes functions #####
    661           ===============================================================================
    662          
    663          @endverbatim
    664            * @{
    665            */
    666          
    667          /**
    668            * @brief  Configure the EXTI line attribute(s).
    669            * @note   Available attributes are to secure EXTI line and set EXT line as privileged.
    670            *         Default state is not secure and unprivileged access allowed.
    671            * @note   Secure and non-secure attributes can only be set from the secure
    672            *         state when the system implements the security (TZEN=1).
    673            * @note   Security and privilege attributes can be set independently.
    674            * @param  ExtiLine Exti line number.
    675            *         This parameter can be from 0 to @ref EXTI_LINE_NB.
    676            * @param  LineAttributes can be one or a combination of the following values:
    677            *            @arg @ref EXTI_LINE_PRIV         Privileged-only access
    678            *            @arg @ref EXTI_LINE_NPRIV        Privileged/Non-privileged access
    679            *            @arg @ref EXTI_LINE_SEC          Secure-only access
    680            *            @arg @ref EXTI_LINE_NSEC         Secure/Non-secure access
    681            * @retval None
    682            */

   \                                 In section .text, align 2, keep-with-next
    683          void HAL_EXTI_ConfigLineAttributes(uint32_t ExtiLine, uint32_t LineAttributes)
    684          {
   \                     HAL_EXTI_ConfigLineAttributes: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    685            __IO uint32_t *regaddr;
    686            uint32_t regval;
    687            uint32_t linepos;
    688            uint32_t maskline;
    689            uint32_t offset;
    690          
    691            /* Check the parameters */
    692            assert_param(IS_EXTI_LINE(ExtiLine));
    693            assert_param(IS_EXTI_LINE_ATTRIBUTES(LineAttributes));
    694          
    695            /* compute line register offset and line mask */
    696            offset = ((ExtiLine & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
   \        0x2   0xF3C0 0x4200      UBFX     R2,R0,#+16,#+1
    697            linepos = (ExtiLine & EXTI_PIN_MASK);
   \        0x6   0xF010 0x001F      ANDS     R0,R0,#0x1F
    698            maskline = (1UL << linepos);
   \        0xA   0x2301             MOVS     R3,#+1
   \        0xC   0xFA13 0xF000      LSLS     R0,R3,R0
    699          
    700            /* Configure privilege or non-privilege attributes */
    701            regaddr = (__IO uint32_t *)(&EXTI->PRIVCFGR1 + (EXTI_PRIVCFGR_OFFSET * offset));
   \       0x10   0x....             LDR.N    R3,??DataTable8_8
   \       0x12   0x0152             LSLS     R2,R2,#+5
   \       0x14   0x441A             ADD      R2,R3,R2
    702            regval = *regaddr;
   \       0x16   0x6813             LDR      R3,[R2, #+0]
    703          
    704            /* Mask or set line */
    705            if ((LineAttributes & EXTI_LINE_PRIV) == EXTI_LINE_PRIV)
   \       0x18   0xF240 0x2402      MOVW     R4,#+514
   \       0x1C   0xEA14 0x0501      ANDS     R5,R4,R1
   \       0x20   0x42A5             CMP      R5,R4
   \       0x22   0xD102             BNE.N    ??HAL_EXTI_ConfigLineAttributes_0
    706            {
    707              regval |= maskline;
   \       0x24   0x4318             ORRS     R0,R0,R3
   \       0x26   0x0003             MOVS     R3,R0
   \       0x28   0xE004             B.N      ??HAL_EXTI_ConfigLineAttributes_1
    708            }
    709            else if ((LineAttributes & EXTI_LINE_NPRIV) == EXTI_LINE_NPRIV)
   \                     ??HAL_EXTI_ConfigLineAttributes_0: (+1)
   \       0x2A   0x0589             LSLS     R1,R1,#+22
   \       0x2C   0xD502             BPL.N    ??HAL_EXTI_ConfigLineAttributes_1
    710            {
    711              regval &= ~maskline;
   \       0x2E   0xEA33 0x0000      BICS     R0,R3,R0
   \       0x32   0x0003             MOVS     R3,R0
    712            }
    713            else
    714            {
    715              /* do nothing */
    716            }
    717          
    718            /* Store privilege or non-privilege attribute */
    719            *regaddr = regval;
   \                     ??HAL_EXTI_ConfigLineAttributes_1: (+1)
   \       0x34   0x6013             STR      R3,[R2, #+0]
    720          
    721          #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
    722          
    723            /* Configure secure or non-secure attributes */
    724            regaddr = (__IO uint32_t *)(&EXTI->SECCFGR1 + (EXTI_SECCFGR_OFFSET * offset));
    725            regval = *regaddr;
    726          
    727            /* Mask or set line */
    728            if ((LineAttributes & EXTI_LINE_SEC) == EXTI_LINE_SEC)
    729            {
    730              regval |= maskline;
    731            }
    732            else if ((LineAttributes & EXTI_LINE_NSEC) == EXTI_LINE_NSEC)
    733            {
    734              regval &= ~maskline;
    735            }
    736            else
    737            {
    738              /* do nothing */
    739            }
    740          
    741            /* Store secure or non-secure attribute */
    742            *regaddr = regval;
    743          
    744          #endif /* __ARM_FEATURE_CMSE */
    745          }
   \       0x36   0xBC30             POP      {R4,R5}
   \       0x38   0x4770             BX       LR
    746          
    747          /**
    748            * @brief  Get the EXTI line attribute(s).
    749            * @note   Secure and non-secure attributes are only available from secure state
    750            *         when the system implements the security (TZEN=1)
    751            * @param  ExtiLine Exti line number.
    752            *         This parameter can be from 0 to @ref EXTI_LINE_NB.
    753            * @param  pLineAttributes: pointer to return line attributes.
    754            * @retval HAL Status.
    755            */

   \                                 In section .text, align 2, keep-with-next
    756          HAL_StatusTypeDef HAL_EXTI_GetConfigLineAttributes(uint32_t ExtiLine, uint32_t *pLineAttributes)
    757          {
    758            const __IO uint32_t *regaddr;
    759            uint32_t linepos;
    760            uint32_t maskline;
    761            uint32_t offset;
    762            uint32_t attributes;
    763          
    764            /* Check null pointer */
    765            if (pLineAttributes == NULL)
   \                     HAL_EXTI_GetConfigLineAttributes: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0xD101             BNE.N    ??HAL_EXTI_GetConfigLineAttributes_0
    766            {
    767              return HAL_ERROR;
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0xE013             B.N      ??HAL_EXTI_GetConfigLineAttributes_1
    768            }
    769          
    770            /* Check the parameters */
    771            assert_param(IS_EXTI_LINE(ExtiLine));
    772          
    773            /* Compute line register offset and line mask */
    774            offset = ((ExtiLine & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
   \                     ??HAL_EXTI_GetConfigLineAttributes_0: (+1)
   \        0x8   0xF3C0 0x4200      UBFX     R2,R0,#+16,#+1
    775            linepos = (ExtiLine & EXTI_PIN_MASK);
   \        0xC   0xF010 0x001F      ANDS     R0,R0,#0x1F
    776            maskline = (1UL << linepos);
   \       0x10   0x2301             MOVS     R3,#+1
   \       0x12   0xFA13 0xF000      LSLS     R0,R3,R0
    777          
    778            /* Get privilege or non-privilege attribute */
    779            regaddr = (__IO uint32_t *)(&EXTI->PRIVCFGR1 + (EXTI_PRIVCFGR_OFFSET * offset));
   \       0x16   0x....             LDR.N    R3,??DataTable8_8
   \       0x18   0x0152             LSLS     R2,R2,#+5
   \       0x1A   0x441A             ADD      R2,R3,R2
    780          
    781            if ((*regaddr & maskline) != 0U)
   \       0x1C   0x6812             LDR      R2,[R2, #+0]
   \       0x1E   0x4202             TST      R2,R0
   \       0x20   0xD002             BEQ.N    ??HAL_EXTI_GetConfigLineAttributes_2
    782            {
    783              attributes = EXTI_LINE_PRIV;
   \       0x22   0xF240 0x2002      MOVW     R0,#+514
   \       0x26   0xE001             B.N      ??HAL_EXTI_GetConfigLineAttributes_3
    784            }
    785            else
    786            {
    787              attributes = EXTI_LINE_NPRIV;
   \                     ??HAL_EXTI_GetConfigLineAttributes_2: (+1)
   \       0x28   0xF44F 0x7000      MOV      R0,#+512
    788            }
    789          
    790          #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
    791          
    792            /* Get secure or non-secure attribute */
    793            regaddr = (__IO uint32_t *)(&EXTI->SECCFGR1 + (EXTI_SECCFGR_OFFSET * offset));
    794          
    795            if ((*regaddr & maskline) != 0U)
    796            {
    797              attributes |= EXTI_LINE_SEC;
    798            }
    799            else
    800            {
    801              attributes |= EXTI_LINE_NSEC;
    802            }
    803          
    804          #endif /* __ARM_FEATURE_CMSE */
    805          
    806            /* return value */
    807            *pLineAttributes = attributes;
   \                     ??HAL_EXTI_GetConfigLineAttributes_3: (+1)
   \       0x2C   0x6008             STR      R0,[R1, #+0]
    808          
    809            return HAL_OK;
   \       0x2E   0x2000             MOVS     R0,#+0
   \                     ??HAL_EXTI_GetConfigLineAttributes_1: (+1)
   \       0x30   0x4770             BX       LR
    810          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x4402'2000        DC32     0x44022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x4402'2004        DC32     0x44022004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x4402'2060        DC32     0x44022060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x4402'2080        DC32     0x44022080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x4402'2084        DC32     0x44022084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x4402'200C        DC32     0x4402200c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x4402'2010        DC32     0x44022010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x4402'2008        DC32     0x44022008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0x4402'2018        DC32     0x44022018
    811          #if defined (EXTI_LOCKR_LOCK)
    812          #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
    813          /**
    814            * @brief  Lock the global EXTI security and privilege configuration.
    815            * @retval HAL Status.
    816            */
    817          HAL_StatusTypeDef HAL_EXTI_LockConfigAttributes(void)
    818          {
    819            EXTI->LOCKR = EXTI_ATTRIBUTES_LOCKED;
    820          
    821            return HAL_OK;
    822          }
    823          
    824          /**
    825            * @brief  Get the global EXTI security and privilege lock configuration.
    826            * @param  pLockState : Pointer to returned security and privilege configuration
    827            * @retval HAL Status.
    828            */
    829          HAL_StatusTypeDef HAL_EXTI_GetLockConfigAttributes(uint32_t *const pLockState)
    830          {
    831            uint32_t attributes;
    832            const __IO uint32_t *regaddr;
    833          
    834            /* Check null pointer */
    835            if (pLockState == NULL)
    836            {
    837              return HAL_ERROR;
    838            }
    839          
    840            /* Get security and privilege configuration */
    841            regaddr = (__IO uint32_t *)(&EXTI->LOCKR);
    842          
    843            if ((*regaddr & EXTI_LOCKR_LOCK) != 0U)
    844            {
    845              attributes = EXTI_ATTRIBUTES_LOCKED;
    846            }
    847            else
    848            {
    849              attributes = EXTI_ATTRIBUTES_UNLOCKED;
    850            }
    851          
    852            /* return value */
    853            *pLockState = attributes;
    854          
    855            return HAL_OK;
    856          }
    857          #endif /* defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U) */
    858          #endif /* defined (EXTI_LOCKR_LOCK) */
    859          /**
    860            * @}
    861            */
    862          
    863          /**
    864            * @}
    865            */
    866          
    867          #endif /* HAL_EXTI_MODULE_ENABLED */
    868          /**
    869            * @}
    870            */
    871          
    872          /**
    873            * @}
    874            */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_EXTI_ClearConfigLine
       0   HAL_EXTI_ClearPending
       8   HAL_EXTI_ConfigLineAttributes
       0   HAL_EXTI_GenerateSWI
       8   HAL_EXTI_GetConfigLine
       0   HAL_EXTI_GetConfigLineAttributes
       0   HAL_EXTI_GetHandle
       0   HAL_EXTI_GetPending
      16   HAL_EXTI_IRQHandler
        16   -- Indirect call
       0   HAL_EXTI_RegisterCallback
      16   HAL_EXTI_SetConfigLine


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
     128  HAL_EXTI_ClearConfigLine
      38  HAL_EXTI_ClearPending
      58  HAL_EXTI_ConfigLineAttributes
      26  HAL_EXTI_GenerateSWI
     168  HAL_EXTI_GetConfigLine
      50  HAL_EXTI_GetConfigLineAttributes
      14  HAL_EXTI_GetHandle
      42  HAL_EXTI_GetPending
      76  HAL_EXTI_IRQHandler
      38  HAL_EXTI_RegisterCallback
     188  HAL_EXTI_SetConfigLine

 
 862 bytes in section .text
 
 862 bytes of CODE memory

Errors: none
Warnings: none
