###############################################################################
#
# IAR ANSI C/C++ Compiler V9.40.1.364/W64 for ARM         23/Nov/2023  21:46:16
# Copyright 1999-2023 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_rcc_ex.c
#    Command line      =
#        -f
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_rcc_ex.o.rsp
#        (C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_rcc_ex.c
#        -D STM32H562xx -lCN
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir
#        -lA
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir
#        -o
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33.no_dsp.no_se -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\CMSIS\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Library\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Loader\
#        -Ol) --dependencies=n
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_rcc_ex.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir\stm32h5xx_hal_rcc_ex.lst
#    Object file       =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_rcc_ex.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_rcc_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32h5xx_hal_rcc_ex.c
      4            * @author  MCD Application Team
      5            * @brief   Extended RCC HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities RCC extended peripheral:
      8            *           + Extended Peripheral Control functions
      9            *           + Extended Clock management functions
     10            *           + Extended Clock Recovery System Control functions
     11            *
     12            ******************************************************************************
     13            * @attention
     14            *
     15            * Copyright (c) 2023 STMicroelectronics.
     16            * All rights reserved.
     17            *
     18            * This software is licensed under terms that can be found in the LICENSE file
     19            * in the root directory of this software component.
     20            * If no LICENSE file comes with this software, it is provided AS-IS.
     21            *
     22            ******************************************************************************
     23            */
     24          
     25          /* Includes ------------------------------------------------------------------*/
     26          #include "stm32h5xx_hal.h"
     27          
     28          /** @addtogroup STM32H5xx_HAL_Driver
     29            * @{
     30            */
     31          
     32          /** @defgroup RCCEx RCCEx
     33            * @brief RCC Extended HAL module driver
     34            * @{
     35            */
     36          
     37          #ifdef HAL_RCC_MODULE_ENABLED
     38          
     39          /* Private typedef -----------------------------------------------------------*/
     40          /* Private defines -----------------------------------------------------------*/
     41          /** @defgroup RCCEx_Private_Constants RCCEx Private Constants
     42            * @{
     43            */
     44          #define PLL1_TIMEOUT_VALUE     ((uint32_t)2U)          /* 2 ms (minimum Tick + 1) */
     45          #define PLL2_TIMEOUT_VALUE     ((uint32_t)2U)          /* 2 ms (minimum Tick + 1) */
     46          #if defined(RCC_CR_PLL3ON)
     47          #define PLL3_TIMEOUT_VALUE     ((uint32_t)2U)          /* 2 ms (minimum Tick + 1) */
     48          #endif /* RCC_CR_PLL3ON */
     49          
     50          /**
     51            * @}
     52            */
     53          
     54          /* Private macros ------------------------------------------------------------*/
     55          /* Private variables ---------------------------------------------------------*/
     56          /* Private function prototypes -----------------------------------------------*/
     57          /** @defgroup RCCEx_Private_Functions RCCEx Private Functions
     58            * @{
     59            */
     60          static HAL_StatusTypeDef RCCEx_PLLSource_Enable(uint32_t PllSource);
     61          static HAL_StatusTypeDef RCCEx_PLL2_Config(const RCC_PLL2InitTypeDef *Pll2);
     62          #if defined(RCC_CR_PLL3ON)
     63          static HAL_StatusTypeDef RCCEx_PLL3_Config(const RCC_PLL3InitTypeDef *Pll3);
     64          #endif /* RCC_CR_PLL3ON */
     65          /**
     66            * @}
     67            */
     68          
     69          /* Exported functions --------------------------------------------------------*/
     70          
     71          /** @defgroup RCCEx_Exported_Functions RCCEx Exported Functions
     72            * @{
     73            */
     74          
     75          /** @defgroup RCCEx_Exported_Functions_Group1 Extended Peripheral Control functions
     76            *  @brief  Extended Peripheral Control functions
     77            *
     78          @verbatim
     79           ===============================================================================
     80                          ##### Extended Peripheral Control functions  #####
     81           ===============================================================================
     82              [..]
     83              This subsection provides a set of functions allowing to control the RCC Clocks
     84              frequencies.
     85              [..]
     86              (@) Important note: Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to
     87                  select the RTC clock source; in this case the Backup domain will be reset in
     88                  order to modify the RTC Clock source, as consequence RTC registers (including
     89                  the backup registers) are set to their reset values.
     90          
     91          @endverbatim
     92            * @{
     93            */
     94          /**
     95            * @brief  Initialize the RCC extended peripherals clocks according to the specified
     96            *         parameters in the RCC_PeriphCLKInitTypeDef.
     97            * @param  pPeriphClkInit  pointer to an RCC_PeriphCLKInitTypeDef structure that
     98            *         contains a field PeriphClockSelection which can be a combination of the following values:
     99            *            @arg @ref RCC_PERIPHCLK_USART1  USART1 peripheral clock
    100            *            @arg @ref RCC_PERIPHCLK_USART2  USART2 peripheral clock
    101            *            @arg @ref RCC_PERIPHCLK_USART3  USART3 peripheral clock
    102            *            @arg @ref RCC_PERIPHCLK_UART4   UART4 peripheral clock (*)
    103            *            @arg @ref RCC_PERIPHCLK_UART5   UART5 peripheral clock (*)
    104            *            @arg @ref RCC_PERIPHCLK_USART6  USART6 peripheral clock (*)
    105            *            @arg @ref RCC_PERIPHCLK_UART7   UART7 peripheral clock (*)
    106            *            @arg @ref RCC_PERIPHCLK_UART8   UART8 peripheral clock (*)
    107            *            @arg @ref RCC_PERIPHCLK_UART9   UART9 peripheral clock (*)
    108            *            @arg @ref RCC_PERIPHCLK_USART10 USART10 peripheral clock (*)
    109            *            @arg @ref RCC_PERIPHCLK_USART11 USART11 peripheral clock (*)
    110            *            @arg @ref RCC_PERIPHCLK_UART12  UART12 peripheral clock (*)
    111            *            @arg @ref RCC_PERIPHCLK_LPUART1 LPUART1 peripheral clock
    112            *            @arg @ref RCC_PERIPHCLK_I2C1    I2C1 peripheral clock
    113            *            @arg @ref RCC_PERIPHCLK_I2C2    I2C2 peripheral clock
    114            *            @arg @ref RCC_PERIPHCLK_I2C3    I2C3 peripheral clock (*)
    115            *            @arg @ref RCC_PERIPHCLK_I2C4    I2C4 peripheral clock (*)
    116            *            @arg @ref RCC_PERIPHCLK_I3C1    I3C1 peripheral clock
    117            *            @arg @ref RCC_PERIPHCLK_I3C2    I3C2 peripheral clock (***)
    118            *            @arg @ref RCC_PERIPHCLK_LPTIM1  LPTIM1 peripheral clock
    119            *            @arg @ref RCC_PERIPHCLK_LPTIM2  LPTIM2 peripheral clock
    120            *            @arg @ref RCC_PERIPHCLK_SAI1    SAI1 peripheral clock (*)
    121            *            @arg @ref RCC_PERIPHCLK_SAI2    SAI2 peripheral clock (*)
    122            *            @arg @ref RCC_PERIPHCLK_ADCDAC  ADCDAC peripheral clock
    123            *            @arg @ref RCC_PERIPHCLK_ADC     ADC peripheral clock
    124            *            @arg @ref RCC_PERIPHCLK_SDMMC1  SDMMC1 peripheral clock (*)
    125            *            @arg @ref RCC_PERIPHCLK_SDMMC2  SDMMC2 peripheral clock (**)
    126            *            @arg @ref RCC_PERIPHCLK_CKPER   CKPER peripheral clock
    127            *            @arg @ref RCC_PERIPHCLK_RTC     RTC peripheral clock
    128            *            @arg @ref RCC_PERIPHCLK_RNG     RNG peripheral clock
    129            *            @arg @ref RCC_PERIPHCLK_SPI1    SPI1 peripheral clock
    130            *            @arg @ref RCC_PERIPHCLK_SPI2    SPI2 peripheral clock
    131            *            @arg @ref RCC_PERIPHCLK_SPI3    SPI3 peripheral clock
    132            *            @arg @ref RCC_PERIPHCLK_SPI4    SPI4 peripheral clock (*)
    133            *            @arg @ref RCC_PERIPHCLK_SPI5    SPI5 peripheral clock (*)
    134            *            @arg @ref RCC_PERIPHCLK_SPI6    SPI6 peripheral clock (*)
    135            *            @arg @ref RCC_PERIPHCLK_OSPI    OCTOSPI peripheral clock (*)
    136            *            @arg @ref RCC_PERIPHCLK_FDCAN   FDCAN peripheral clock
    137            *            @arg @ref RCC_PERIPHCLK_CEC     CEC peripheral clock (*)
    138            *            @arg @ref RCC_PERIPHCLK_USB     USB peripheral clock
    139            *            @arg @ref RCC_PERIPHCLK_LPTIM3  LPTIM3 peripheral clock (*)
    140            *            @arg @ref RCC_PERIPHCLK_LPTIM4  LPTIM4 peripheral clock (*)
    141            *            @arg @ref RCC_PERIPHCLK_LPTIM5  LPTIM5 peripheral clock (*)
    142            *            @arg @ref RCC_PERIPHCLK_LPTIM6  LPTIM6 peripheral clock (*)
    143            *            @arg @ref RCC_PERIPHCLK_DAC_LP  DAC peripheral low-power clock
    144            *            @arg @ref RCC_PERIPHCLK_TIM     TIM peripheral clock
    145            *
    146            * @note   Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to select
    147            *         the RTC clock source: in this case the access to Backup domain is enabled.
    148            *
    149            * @retval HAL status
    150            *
    151            *  (*)   : For stm32h56xxx and stm32h57xxx family lines only.
    152            *  (**)  : For stm32h563xx and stm32h57xxx family lines only.
    153            *  (***) : For stm32h503xx family line only.
    154            */

   \                                 In section .text, align 4, keep-with-next
    155          HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *pPeriphClkInit)
    156          {
   \                     HAL_RCCEx_PeriphCLKConfig: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
    157            uint32_t tmpregister;
    158            uint32_t tickstart;
    159            HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
   \        0x6   0x2500             MOVS     R5,#+0
    160            HAL_StatusTypeDef status = HAL_OK;   /* Final status */
   \        0x8   0x2600             MOVS     R6,#+0
    161          
    162            /* Check the parameters */
    163            assert_param(IS_RCC_PERIPHCLOCK(pPeriphClkInit->PeriphClockSelection));
    164          
    165            /*------------------------------------ CKPER configuration --------------------------------------*/
    166            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
   \        0xA   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \        0xE   0x01C0             LSLS     R0,R0,#+7
   \       0x10   0xD507             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_3
    167            {
    168              /* Check the parameters */
    169              assert_param(IS_RCC_CLKPSOURCE(pPeriphClkInit->CkperClockSelection));
    170          
    171              /* Configure the CKPER clock source */
    172              __HAL_RCC_CLKP_CONFIG(pPeriphClkInit->CkperClockSelection);
   \       0x12   0xF8DF 0x1A70      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_0
   \       0x16   0x680A             LDR      R2,[R1, #+0]
   \       0x18   0xF022 0x4240      BIC      R2,R2,#0xC0000000
   \       0x1C   0x6DA0             LDR      R0,[R4, #+88]
   \       0x1E   0x4302             ORRS     R2,R0,R2
   \       0x20   0x600A             STR      R2,[R1, #+0]
    173            }
    174          
    175            /*-------------------------- USART1 clock source configuration -------------------*/
    176            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
   \                     ??HAL_RCCEx_PeriphCLKConfig_3: (+1)
   \       0x22   0x7820             LDRB     R0,[R4, #+0]
   \       0x24   0x07C0             LSLS     R0,R0,#+31
   \       0x26   0xD52A             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_4
    177            {
    178              /* Check the parameters */
    179              assert_param(IS_RCC_USART1CLKSOURCE(pPeriphClkInit->Usart1ClockSelection));
    180          
    181              switch (pPeriphClkInit->Usart1ClockSelection)
   \       0x28   0x6DE0             LDR      R0,[R4, #+92]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD008             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_5
   \       0x2E   0x2802             CMP      R0,#+2
   \       0x30   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_6
   \       0x32   0xD306             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_7
   \       0x34   0x2804             CMP      R0,#+4
   \       0x36   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_8
   \       0x38   0xD30F             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_9
   \       0x3A   0x2805             CMP      R0,#+5
   \       0x3C   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_10
   \       0x3E   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_11
    182              {
    183                case RCC_USART1CLKSOURCE_PCLK2:      /* PCLK2 is used as clock source for USART1*/
    184          
    185                  /* USART1 clock source config set later after clock selection check */
    186                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_5: (+1)
   \       0x40   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_12
    187          
    188                case RCC_USART1CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for USART1*/
    189                  /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
    190                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_7: (+1)
   \       0x42   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x46   0x.... 0x....      BL       RCCEx_PLL2_Config
   \       0x4A   0x0005             MOVS     R5,R0
    191                  /* USART1 clock source config set later after clock selection check */
    192                  break;
   \       0x4C   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_12
    193          #if defined(RCC_USART1CLKSOURCE_PLL3Q)
    194                case RCC_USART1CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for USART1*/
    195                  /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
    196                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_6: (+1)
   \       0x4E   0xF114 0x0030      ADDS     R0,R4,#+48
   \       0x52   0x.... 0x....      BL       RCCEx_PLL3_Config
   \       0x56   0x0005             MOVS     R5,R0
    197                  /* USART1 clock source config set later after clock selection check */
    198                  break;
   \       0x58   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_12
    199          #endif /* RCC_CR_PLL3ON */
    200          
    201                case RCC_USART1CLKSOURCE_HSI:      /* HSI clock is used as source of USART1 clock*/
    202                  /* USART1 clock source config set later after clock selection check */
    203                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_9: (+1)
   \       0x5A   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_12
    204          
    205                case RCC_USART1CLKSOURCE_CSI:      /* CSI clock is used as source of USART1 clock*/
    206                  /* USART1 clock source config set later after clock selection check */
    207                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_8: (+1)
   \       0x5C   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_12
    208          
    209                case RCC_USART1CLKSOURCE_LSE:      /* LSE clock is used as source of USART1 clock*/
    210                  /* USART1 clock source config set later after clock selection check */
    211                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_10: (+1)
   \       0x5E   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_12
    212          
    213                default:
    214                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_11: (+1)
   \       0x60   0x2501             MOVS     R5,#+1
    215                  break;
    216              }
    217          
    218              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_12: (+1)
   \       0x62   0x0028             MOVS     R0,R5
   \       0x64   0xB2C0             UXTB     R0,R0
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_13
    219              {
    220                /* Set the source of USART1 clock*/
    221                __HAL_RCC_USART1_CONFIG(pPeriphClkInit->Usart1ClockSelection);
   \       0x6A   0xF8DF 0x1A1C      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_0+0x4
   \       0x6E   0x680A             LDR      R2,[R1, #+0]
   \       0x70   0x08D2             LSRS     R2,R2,#+3
   \       0x72   0x00D2             LSLS     R2,R2,#+3
   \       0x74   0x6DE0             LDR      R0,[R4, #+92]
   \       0x76   0x4302             ORRS     R2,R0,R2
   \       0x78   0x600A             STR      R2,[R1, #+0]
   \       0x7A   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_4
    222              }
    223              else
    224              {
    225                /* set overall return value */
    226                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_13: (+1)
   \       0x7C   0x002E             MOVS     R6,R5
    227              }    
    228            }    
    229            /*-------------------------- USART2 clock source configuration -------------------*/
    230            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
   \                     ??HAL_RCCEx_PeriphCLKConfig_4: (+1)
   \       0x7E   0x7820             LDRB     R0,[R4, #+0]
   \       0x80   0x0780             LSLS     R0,R0,#+30
   \       0x82   0xD52C             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_14
    231            {
    232              /* Check the parameters */
    233              assert_param(IS_RCC_USART2CLKSOURCE(pPeriphClkInit->Usart2ClockSelection));
    234          
    235              switch (pPeriphClkInit->Usart2ClockSelection)
   \       0x84   0x6E20             LDR      R0,[R4, #+96]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD00A             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_15
   \       0x8A   0x2808             CMP      R0,#+8
   \       0x8C   0xD009             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_16
   \       0x8E   0x2810             CMP      R0,#+16
   \       0x90   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_17
   \       0x92   0x2818             CMP      R0,#+24
   \       0x94   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_18
   \       0x96   0x2820             CMP      R0,#+32
   \       0x98   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_19
   \       0x9A   0x2828             CMP      R0,#+40
   \       0x9C   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_20
   \       0x9E   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_21
    236              {
    237                case RCC_USART2CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for USART2*/
    238          
    239                  /* USART2 clock source config set later after clock selection check */
    240                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_15: (+1)
   \       0xA0   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_22
    241          
    242                case RCC_USART2CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for USART2*/
    243                  /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
    244                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_16: (+1)
   \       0xA2   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0xA6   0x.... 0x....      BL       RCCEx_PLL2_Config
   \       0xAA   0x0005             MOVS     R5,R0
    245                  /* USART2 clock source config set later after clock selection check */
    246                  break;
   \       0xAC   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_22
    247          
    248          #if defined(RCC_USART2CLKSOURCE_PLL3Q)
    249                case RCC_USART2CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for USART2*/
    250                  /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
    251                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_17: (+1)
   \       0xAE   0xF114 0x0030      ADDS     R0,R4,#+48
   \       0xB2   0x.... 0x....      BL       RCCEx_PLL3_Config
   \       0xB6   0x0005             MOVS     R5,R0
    252                  /* USART2 clock source config set later after clock selection check */
    253                  break;
   \       0xB8   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_22
    254          #endif /* RCC_USART2CLKSOURCE_PLL3 */
    255          
    256                case RCC_USART2CLKSOURCE_HSI:      /* HSI clock is used as source of USART2 clock*/
    257                  /* USART2 clock source config set later after clock selection check */
    258                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_18: (+1)
   \       0xBA   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_22
    259          
    260                case RCC_USART2CLKSOURCE_CSI:      /* CSI clock is used as source of USART2 clock*/
    261                  /* USART2 clock source config set later after clock selection check */
    262                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_19: (+1)
   \       0xBC   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_22
    263          
    264                case RCC_USART2CLKSOURCE_LSE:      /* LSE clock is used as source of USART2 clock*/
    265                  /* USART2 clock source config set later after clock selection check */
    266                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_20: (+1)
   \       0xBE   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_22
    267          
    268                default:
    269                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_21: (+1)
   \       0xC0   0x2501             MOVS     R5,#+1
    270                  break;
    271              }
    272          
    273              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_22: (+1)
   \       0xC2   0x0028             MOVS     R0,R5
   \       0xC4   0xB2C0             UXTB     R0,R0
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_23
    274              {
    275                /* Set the source of USART2 clock*/
    276                __HAL_RCC_USART2_CONFIG(pPeriphClkInit->Usart2ClockSelection);
   \       0xCA   0xF8DF 0x19BC      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_0+0x4
   \       0xCE   0x680A             LDR      R2,[R1, #+0]
   \       0xD0   0xF032 0x0238      BICS     R2,R2,#0x38
   \       0xD4   0x6E20             LDR      R0,[R4, #+96]
   \       0xD6   0x4302             ORRS     R2,R0,R2
   \       0xD8   0x600A             STR      R2,[R1, #+0]
   \       0xDA   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_14
    277              }
    278              else
    279              {
    280                /* set overall return value */
    281                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_23: (+1)
   \       0xDC   0x002E             MOVS     R6,R5
    282              }
    283            }
    284          
    285            /*-------------------------- USART3 clock source configuration -------------------*/
    286            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
   \                     ??HAL_RCCEx_PeriphCLKConfig_14: (+1)
   \       0xDE   0x7820             LDRB     R0,[R4, #+0]
   \       0xE0   0x0740             LSLS     R0,R0,#+29
   \       0xE2   0xD52E             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_24
    287            {
    288              /* Check the parameters */
    289              assert_param(IS_RCC_USART3CLKSOURCE(pPeriphClkInit->Usart3ClockSelection));
    290          
    291              switch (pPeriphClkInit->Usart3ClockSelection)
   \       0xE4   0x6E60             LDR      R0,[R4, #+100]
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD00C             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_25
   \       0xEA   0x2840             CMP      R0,#+64
   \       0xEC   0xD00B             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_26
   \       0xEE   0x2880             CMP      R0,#+128
   \       0xF0   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_27
   \       0xF2   0x28C0             CMP      R0,#+192
   \       0xF4   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_28
   \       0xF6   0xF5B0 0x7F80      CMP      R0,#+256
   \       0xFA   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_29
   \       0xFC   0xF5B0 0x7FA0      CMP      R0,#+320
   \      0x100   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_30
   \      0x102   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_31
    292              {
    293                case RCC_USART3CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for USART3*/
    294          
    295                  /* USART3 clock source config set later after clock selection check */
    296                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_25: (+1)
   \      0x104   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_32
    297          
    298                case RCC_USART3CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for USART3*/
    299                  /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
    300                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_26: (+1)
   \      0x106   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x10A   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x10E   0x0005             MOVS     R5,R0
    301                  /* USART3 clock source config set later after clock selection check */
    302                  break;
   \      0x110   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_32
    303          
    304          #if defined(RCC_USART3CLKSOURCE_PLL3Q)
    305                case RCC_USART3CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for USART3*/
    306                  /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
    307                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_27: (+1)
   \      0x112   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x116   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x11A   0x0005             MOVS     R5,R0
    308                  /* USART3 clock source config set later after clock selection check */
    309                  break;
   \      0x11C   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_32
    310          #endif /* RCC_USART3CLKSOURCE_PLL3 */
    311          
    312                case RCC_USART3CLKSOURCE_HSI:      /* HSI clock is used as source of USART3 clock*/
    313                  /* USART3 clock source config set later after clock selection check */
    314                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_28: (+1)
   \      0x11E   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_32
    315          
    316                case RCC_USART3CLKSOURCE_CSI:      /* CSI clock is used as source of USART3 clock*/
    317                  /* USART3 clock source config set later after clock selection check */
    318                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_29: (+1)
   \      0x120   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_32
    319          
    320                case RCC_USART3CLKSOURCE_LSE:      /* LSE clock is used as source of USART3 clock*/
    321                  /* USART3 clock source config set later after clock selection check */
    322                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_30: (+1)
   \      0x122   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_32
    323          
    324                default:
    325                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_31: (+1)
   \      0x124   0x2501             MOVS     R5,#+1
    326                  break;
    327              }
    328          
    329              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_32: (+1)
   \      0x126   0x0028             MOVS     R0,R5
   \      0x128   0xB2C0             UXTB     R0,R0
   \      0x12A   0x2800             CMP      R0,#+0
   \      0x12C   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_33
    330              {
    331                /* Set the source of USART3 clock*/
    332                __HAL_RCC_USART3_CONFIG(pPeriphClkInit->Usart3ClockSelection);
   \      0x12E   0xF8DF 0x1958      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_0+0x4
   \      0x132   0x680A             LDR      R2,[R1, #+0]
   \      0x134   0xF432 0x72E0      BICS     R2,R2,#0x1C0
   \      0x138   0x6E60             LDR      R0,[R4, #+100]
   \      0x13A   0x4302             ORRS     R2,R0,R2
   \      0x13C   0x600A             STR      R2,[R1, #+0]
   \      0x13E   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_24
    333              }
    334              else
    335              {
    336                /* set overall return value */
    337                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_33: (+1)
   \      0x140   0x002E             MOVS     R6,R5
    338              }
    339            }
    340          
    341          #if defined(UART4)
    342            /*-------------------------- UART4 clock source configuration --------------------*/
    343            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
   \                     ??HAL_RCCEx_PeriphCLKConfig_24: (+1)
   \      0x142   0x7820             LDRB     R0,[R4, #+0]
   \      0x144   0x0700             LSLS     R0,R0,#+28
   \      0x146   0xD531             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_34
    344            {
    345              /* Check the parameters */
    346              assert_param(IS_RCC_UART4CLKSOURCE(pPeriphClkInit->Uart4ClockSelection));
    347          
    348              switch (pPeriphClkInit->Uart4ClockSelection)
   \      0x148   0x6EA0             LDR      R0,[R4, #+104]
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_35
   \      0x14E   0xF5B0 0x7F00      CMP      R0,#+512
   \      0x152   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_36
   \      0x154   0xF5B0 0x6F80      CMP      R0,#+1024
   \      0x158   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_37
   \      0x15A   0xF5B0 0x6FC0      CMP      R0,#+1536
   \      0x15E   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_38
   \      0x160   0xF5B0 0x6F00      CMP      R0,#+2048
   \      0x164   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_39
   \      0x166   0xF5B0 0x6F20      CMP      R0,#+2560
   \      0x16A   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_40
   \      0x16C   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_41
    349              {
    350                case RCC_UART4CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for UART4*/
    351          
    352                  /* UART4 clock source config set later after clock selection check */
    353                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_35: (+1)
   \      0x16E   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_42
    354          
    355                case RCC_UART4CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for UART4*/
    356                  /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
    357                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_36: (+1)
   \      0x170   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x174   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x178   0x0005             MOVS     R5,R0
    358                  /* UART4 clock source config set later after clock selection check */
    359                  break;
   \      0x17A   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_42
    360          
    361                case RCC_UART4CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for UART4*/
    362                  /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
    363                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_37: (+1)
   \      0x17C   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x180   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x184   0x0005             MOVS     R5,R0
    364                  /* UART4 clock source config set later after clock selection check */
    365                  break;
   \      0x186   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_42
    366          
    367                case RCC_UART4CLKSOURCE_HSI:      /* HSI clock is used as source of UART4 clock*/
    368                  /* UART4 clock source config set later after clock selection check */
    369                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_38: (+1)
   \      0x188   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_42
    370          
    371                case RCC_UART4CLKSOURCE_CSI:      /* CSI clock is used as source of UART4 clock*/
    372                  /* UART4 clock source config set later after clock selection check */
    373                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_39: (+1)
   \      0x18A   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_42
    374          
    375                case RCC_UART4CLKSOURCE_LSE:      /* LSE clock is used as source of UART4 clock*/
    376                  /* UART4 clock source config set later after clock selection check */
    377                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_40: (+1)
   \      0x18C   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_42
    378          
    379                default:
    380                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_41: (+1)
   \      0x18E   0x2501             MOVS     R5,#+1
    381                  break;
    382              }
    383          
    384              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_42: (+1)
   \      0x190   0x0028             MOVS     R0,R5
   \      0x192   0xB2C0             UXTB     R0,R0
   \      0x194   0x2800             CMP      R0,#+0
   \      0x196   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_43
    385              {
    386                /* Set the source of UART4 clock*/
    387                __HAL_RCC_UART4_CONFIG(pPeriphClkInit->Uart4ClockSelection);
   \      0x198   0xF8DF 0x18EC      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_0+0x4
   \      0x19C   0x680A             LDR      R2,[R1, #+0]
   \      0x19E   0xF432 0x6260      BICS     R2,R2,#0xE00
   \      0x1A2   0x6EA0             LDR      R0,[R4, #+104]
   \      0x1A4   0x4302             ORRS     R2,R0,R2
   \      0x1A6   0x600A             STR      R2,[R1, #+0]
   \      0x1A8   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_34
    388              }
    389              else
    390              {
    391                /* set overall return value */
    392                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_43: (+1)
   \      0x1AA   0x002E             MOVS     R6,R5
    393              }
    394            }
    395          #endif /* UART4 */
    396          
    397          #if defined(UART5)
    398            /*-------------------------- UART5 clock source configuration --------------------*/
    399            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
   \                     ??HAL_RCCEx_PeriphCLKConfig_34: (+1)
   \      0x1AC   0x7820             LDRB     R0,[R4, #+0]
   \      0x1AE   0x06C0             LSLS     R0,R0,#+27
   \      0x1B0   0xD531             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_44
    400            {
    401              /* Check the parameters */
    402              assert_param(IS_RCC_UART5CLKSOURCE(pPeriphClkInit->Uart5ClockSelection));
    403          
    404              switch (pPeriphClkInit->Uart5ClockSelection)
   \      0x1B2   0x6EE0             LDR      R0,[R4, #+108]
   \      0x1B4   0x2800             CMP      R0,#+0
   \      0x1B6   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_45
   \      0x1B8   0xF5B0 0x5F80      CMP      R0,#+4096
   \      0x1BC   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_46
   \      0x1BE   0xF5B0 0x5F00      CMP      R0,#+8192
   \      0x1C2   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_47
   \      0x1C4   0xF5B0 0x5F40      CMP      R0,#+12288
   \      0x1C8   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_48
   \      0x1CA   0xF5B0 0x4F80      CMP      R0,#+16384
   \      0x1CE   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_49
   \      0x1D0   0xF5B0 0x4FA0      CMP      R0,#+20480
   \      0x1D4   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_50
   \      0x1D6   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_51
    405              {
    406                case RCC_UART5CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for UART5*/
    407          
    408                  /* UART5 clock source config set later after clock selection check */
    409                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_45: (+1)
   \      0x1D8   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_52
    410          
    411                case RCC_UART5CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for UART5*/
    412                  /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
    413                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_46: (+1)
   \      0x1DA   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x1DE   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x1E2   0x0005             MOVS     R5,R0
    414                  /* UART5 clock source config set later after clock selection check */
    415                  break;
   \      0x1E4   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_52
    416          
    417                case RCC_UART5CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for UART5*/
    418                  /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
    419                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_47: (+1)
   \      0x1E6   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x1EA   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x1EE   0x0005             MOVS     R5,R0
    420                  /* UART5 clock source config set later after clock selection check */
    421                  break;
   \      0x1F0   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_52
    422          
    423                case RCC_UART5CLKSOURCE_HSI:      /* HSI clock is used as source of UART5 clock*/
    424                  /* UART5 clock source config set later after clock selection check */
    425                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_48: (+1)
   \      0x1F2   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_52
    426          
    427                case RCC_UART5CLKSOURCE_CSI:      /* CSI clock is used as source of UART5 clock*/
    428                  /* UART5 clock source config set later after clock selection check */
    429                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_49: (+1)
   \      0x1F4   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_52
    430          
    431                case RCC_UART5CLKSOURCE_LSE:      /* LSE clock is used as source of UART5 clock*/
    432                  /* UART5 clock source config set later after clock selection check */
    433                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_50: (+1)
   \      0x1F6   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_52
    434          
    435                default:
    436                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_51: (+1)
   \      0x1F8   0x2501             MOVS     R5,#+1
    437                  break;
    438              }
    439          
    440              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_52: (+1)
   \      0x1FA   0x0028             MOVS     R0,R5
   \      0x1FC   0xB2C0             UXTB     R0,R0
   \      0x1FE   0x2800             CMP      R0,#+0
   \      0x200   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_53
    441              {
    442                /* Set the source of UART5 clock*/
    443                __HAL_RCC_UART5_CONFIG(pPeriphClkInit->Uart5ClockSelection);
   \      0x202   0xF8DF 0x1884      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_0+0x4
   \      0x206   0x680A             LDR      R2,[R1, #+0]
   \      0x208   0xF432 0x42E0      BICS     R2,R2,#0x7000
   \      0x20C   0x6EE0             LDR      R0,[R4, #+108]
   \      0x20E   0x4302             ORRS     R2,R0,R2
   \      0x210   0x600A             STR      R2,[R1, #+0]
   \      0x212   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_44
    444              }
    445              else
    446              {
    447                /* set overall return value */
    448                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_53: (+1)
   \      0x214   0x002E             MOVS     R6,R5
    449              }
    450            }
    451          #endif /* UART5 */
    452          
    453          #if defined(USART6)
    454            /*-------------------------- USART6 clock source configuration -------------------*/
    455            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
   \                     ??HAL_RCCEx_PeriphCLKConfig_44: (+1)
   \      0x216   0x7820             LDRB     R0,[R4, #+0]
   \      0x218   0x0680             LSLS     R0,R0,#+26
   \      0x21A   0xD531             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_54
    456            {
    457              /* Check the parameters */
    458              assert_param(IS_RCC_USART6CLKSOURCE(pPeriphClkInit->Usart6ClockSelection));
    459          
    460              switch (pPeriphClkInit->Usart6ClockSelection)
   \      0x21C   0x6F20             LDR      R0,[R4, #+112]
   \      0x21E   0x2800             CMP      R0,#+0
   \      0x220   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_55
   \      0x222   0xF5B0 0x4F00      CMP      R0,#+32768
   \      0x226   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_56
   \      0x228   0xF5B0 0x3F80      CMP      R0,#+65536
   \      0x22C   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_57
   \      0x22E   0xF5B0 0x3FC0      CMP      R0,#+98304
   \      0x232   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_58
   \      0x234   0xF5B0 0x3F00      CMP      R0,#+131072
   \      0x238   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_59
   \      0x23A   0xF5B0 0x3F20      CMP      R0,#+163840
   \      0x23E   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_60
   \      0x240   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_61
    461              {
    462                case RCC_USART6CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for USART6*/
    463          
    464                  /* USART6 clock source config set later after clock selection check */
    465                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_55: (+1)
   \      0x242   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_62
    466          
    467                case RCC_USART6CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for USART6*/
    468                  /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
    469                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_56: (+1)
   \      0x244   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x248   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x24C   0x0005             MOVS     R5,R0
    470                  /* USART6 clock source config set later after clock selection check */
    471                  break;
   \      0x24E   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_62
    472          
    473                case RCC_USART6CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for USART6*/
    474                  /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
    475                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_57: (+1)
   \      0x250   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x254   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x258   0x0005             MOVS     R5,R0
    476                  /* USART6 clock source config set later after clock selection check */
    477                  break;
   \      0x25A   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_62
    478          
    479                case RCC_USART6CLKSOURCE_HSI:      /* HSI clock is used as source of USART6 clock*/
    480                  /* USART6 clock source config set later after clock selection check */
    481                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_58: (+1)
   \      0x25C   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_62
    482          
    483                case RCC_USART6CLKSOURCE_CSI:      /* CSI clock is used as source of USART6 clock*/
    484                  /* USART6 clock source config set later after clock selection check */
    485                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_59: (+1)
   \      0x25E   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_62
    486          
    487                case RCC_USART6CLKSOURCE_LSE:      /* LSE clock is used as source of USART6 clock*/
    488                  /* USART6 clock source config set later after clock selection check */
    489                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_60: (+1)
   \      0x260   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_62
    490          
    491                default:
    492                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_61: (+1)
   \      0x262   0x2501             MOVS     R5,#+1
    493                  break;
    494              }
    495          
    496              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_62: (+1)
   \      0x264   0x0028             MOVS     R0,R5
   \      0x266   0xB2C0             UXTB     R0,R0
   \      0x268   0x2800             CMP      R0,#+0
   \      0x26A   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_63
    497              {
    498                /* Set the source of USART6 clock*/
    499                __HAL_RCC_USART6_CONFIG(pPeriphClkInit->Usart6ClockSelection);
   \      0x26C   0xF8DF 0x1818      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_0+0x4
   \      0x270   0x680A             LDR      R2,[R1, #+0]
   \      0x272   0xF432 0x3260      BICS     R2,R2,#0x38000
   \      0x276   0x6F20             LDR      R0,[R4, #+112]
   \      0x278   0x4302             ORRS     R2,R0,R2
   \      0x27A   0x600A             STR      R2,[R1, #+0]
   \      0x27C   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_54
    500              }
    501              else
    502              {
    503                /* set overall return value */
    504                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_63: (+1)
   \      0x27E   0x002E             MOVS     R6,R5
    505              }
    506            }
    507          #endif /* USART6 */
    508          
    509          #if defined(UART7)
    510            /*-------------------------- UART7 clock source configuration -------------------*/
    511            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
   \                     ??HAL_RCCEx_PeriphCLKConfig_54: (+1)
   \      0x280   0x7820             LDRB     R0,[R4, #+0]
   \      0x282   0x0640             LSLS     R0,R0,#+25
   \      0x284   0xD531             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_64
    512            {
    513              /* Check the parameters */
    514              assert_param(IS_RCC_UART7CLKSOURCE(pPeriphClkInit->Uart7ClockSelection));
    515          
    516              switch (pPeriphClkInit->Uart7ClockSelection)
   \      0x286   0x6F60             LDR      R0,[R4, #+116]
   \      0x288   0x2800             CMP      R0,#+0
   \      0x28A   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_65
   \      0x28C   0xF5B0 0x2F80      CMP      R0,#+262144
   \      0x290   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_66
   \      0x292   0xF5B0 0x2F00      CMP      R0,#+524288
   \      0x296   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_67
   \      0x298   0xF5B0 0x2F40      CMP      R0,#+786432
   \      0x29C   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_68
   \      0x29E   0xF5B0 0x1F80      CMP      R0,#+1048576
   \      0x2A2   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_69
   \      0x2A4   0xF5B0 0x1FA0      CMP      R0,#+1310720
   \      0x2A8   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_70
   \      0x2AA   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_71
    517              {
    518                case RCC_UART7CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for UART7*/
    519          
    520                  /* UART7 clock source config set later after clock selection check */
    521                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_65: (+1)
   \      0x2AC   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_72
    522          
    523                case RCC_UART7CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for UART7*/
    524                  /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
    525                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_66: (+1)
   \      0x2AE   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x2B2   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x2B6   0x0005             MOVS     R5,R0
    526                  /* UART7 clock source config set later after clock selection check */
    527                  break;
   \      0x2B8   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_72
    528          
    529                case RCC_UART7CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for UART7*/
    530                  /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
    531                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_67: (+1)
   \      0x2BA   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x2BE   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x2C2   0x0005             MOVS     R5,R0
    532                  /* UART7 clock source config set later after clock selection check */
    533                  break;
   \      0x2C4   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_72
    534          
    535                case RCC_UART7CLKSOURCE_HSI:      /* HSI clock is used as source of UART7 clock*/
    536                  /* UART7 clock source config set later after clock selection check */
    537                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_68: (+1)
   \      0x2C6   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_72
    538          
    539                case RCC_UART7CLKSOURCE_CSI:      /* CSI clock is used as source of UART7 clock*/
    540                  /* UART7 clock source config set later after clock selection check */
    541                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_69: (+1)
   \      0x2C8   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_72
    542          
    543                case RCC_UART7CLKSOURCE_LSE:      /* LSE clock is used as source of UART7 clock*/
    544                  /* UART7 clock source config set later after clock selection check */
    545                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_70: (+1)
   \      0x2CA   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_72
    546          
    547                default:
    548                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_71: (+1)
   \      0x2CC   0x2501             MOVS     R5,#+1
    549                  break;
    550              }
    551          
    552              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_72: (+1)
   \      0x2CE   0x0028             MOVS     R0,R5
   \      0x2D0   0xB2C0             UXTB     R0,R0
   \      0x2D2   0x2800             CMP      R0,#+0
   \      0x2D4   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_73
    553              {
    554                /* Set the source of UART7 clock*/
    555                __HAL_RCC_UART7_CONFIG(pPeriphClkInit->Uart7ClockSelection);
   \      0x2D6   0xF8DF 0x17B0      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_0+0x4
   \      0x2DA   0x680A             LDR      R2,[R1, #+0]
   \      0x2DC   0xF432 0x12E0      BICS     R2,R2,#0x1C0000
   \      0x2E0   0x6F60             LDR      R0,[R4, #+116]
   \      0x2E2   0x4302             ORRS     R2,R0,R2
   \      0x2E4   0x600A             STR      R2,[R1, #+0]
   \      0x2E6   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_64
    556              }
    557              else
    558              {
    559                /* set overall return value */
    560                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_73: (+1)
   \      0x2E8   0x002E             MOVS     R6,R5
    561              }
    562            }
    563          #endif /* UART7 */
    564          
    565          #if defined(UART8)
    566            /*-------------------------- UART8 clock source configuration -------------------*/
    567            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
   \                     ??HAL_RCCEx_PeriphCLKConfig_64: (+1)
   \      0x2EA   0x7820             LDRB     R0,[R4, #+0]
   \      0x2EC   0x0600             LSLS     R0,R0,#+24
   \      0x2EE   0xD531             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_74
    568            {
    569              /* Check the parameters */
    570              assert_param(IS_RCC_UART8CLKSOURCE(pPeriphClkInit->Uart8ClockSelection));
    571          
    572              switch (pPeriphClkInit->Uart8ClockSelection)
   \      0x2F0   0x6FA0             LDR      R0,[R4, #+120]
   \      0x2F2   0x2800             CMP      R0,#+0
   \      0x2F4   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_75
   \      0x2F6   0xF5B0 0x1F00      CMP      R0,#+2097152
   \      0x2FA   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_76
   \      0x2FC   0xF5B0 0x0F80      CMP      R0,#+4194304
   \      0x300   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_77
   \      0x302   0xF5B0 0x0FC0      CMP      R0,#+6291456
   \      0x306   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_78
   \      0x308   0xF5B0 0x0F00      CMP      R0,#+8388608
   \      0x30C   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_79
   \      0x30E   0xF5B0 0x0F20      CMP      R0,#+10485760
   \      0x312   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_80
   \      0x314   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_81
    573              {
    574                case RCC_UART8CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for UART8*/
    575          
    576                  /* UART8 clock source config set later after clock selection check */
    577                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_75: (+1)
   \      0x316   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_82
    578          
    579                case RCC_UART8CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for UART8*/
    580                  /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
    581                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_76: (+1)
   \      0x318   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x31C   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x320   0x0005             MOVS     R5,R0
    582                  /* UART8 clock source config set later after clock selection check */
    583                  break;
   \      0x322   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_82
    584          
    585                case RCC_UART8CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for UART8*/
    586                  /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
    587                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_77: (+1)
   \      0x324   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x328   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x32C   0x0005             MOVS     R5,R0
    588                  /* UART8 clock source config set later after clock selection check */
    589                  break;
   \      0x32E   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_82
    590          
    591                case RCC_UART8CLKSOURCE_HSI:      /* HSI clock is used as source of UART8 clock*/
    592                  /* UART8 clock source config set later after clock selection check */
    593                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_78: (+1)
   \      0x330   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_82
    594          
    595                case RCC_UART8CLKSOURCE_CSI:      /* CSI clock is used as source of UART8 clock*/
    596                  /* UART8 clock source config set later after clock selection check */
    597                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_79: (+1)
   \      0x332   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_82
    598          
    599                case RCC_UART8CLKSOURCE_LSE:      /* LSE clock is used as source of UART8 clock*/
    600                  /* UART8 clock source config set later after clock selection check */
    601                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_80: (+1)
   \      0x334   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_82
    602          
    603                default:
    604                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_81: (+1)
   \      0x336   0x2501             MOVS     R5,#+1
    605                  break;
    606              }
    607          
    608              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_82: (+1)
   \      0x338   0x0028             MOVS     R0,R5
   \      0x33A   0xB2C0             UXTB     R0,R0
   \      0x33C   0x2800             CMP      R0,#+0
   \      0x33E   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_83
    609              {
    610                /* Set the source of UART8 clock*/
    611                __HAL_RCC_UART8_CONFIG(pPeriphClkInit->Uart8ClockSelection);
   \      0x340   0xF8DF 0x1744      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_0+0x4
   \      0x344   0x680A             LDR      R2,[R1, #+0]
   \      0x346   0xF432 0x0260      BICS     R2,R2,#0xE00000
   \      0x34A   0x6FA0             LDR      R0,[R4, #+120]
   \      0x34C   0x4302             ORRS     R2,R0,R2
   \      0x34E   0x600A             STR      R2,[R1, #+0]
   \      0x350   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_74
    612              }
    613              else
    614              {
    615                /* set overall return value */
    616                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_83: (+1)
   \      0x352   0x002E             MOVS     R6,R5
    617              }
    618            }
    619          #endif /* UART9 */
    620          
    621          #if defined(UART9)
    622            /*-------------------------- UART9 clock source configuration -------------------*/
    623            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
   \                     ??HAL_RCCEx_PeriphCLKConfig_74: (+1)
   \      0x354   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x358   0x05C0             LSLS     R0,R0,#+23
   \      0x35A   0xD531             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_84
    624            {
    625              /* Check the parameters */
    626              assert_param(IS_RCC_UART9CLKSOURCE(pPeriphClkInit->Uart9ClockSelection));
    627          
    628              switch (pPeriphClkInit->Uart9ClockSelection)
   \      0x35C   0x6FE0             LDR      R0,[R4, #+124]
   \      0x35E   0x2800             CMP      R0,#+0
   \      0x360   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_85
   \      0x362   0xF1B0 0x7F80      CMP      R0,#+16777216
   \      0x366   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_86
   \      0x368   0xF1B0 0x7F00      CMP      R0,#+33554432
   \      0x36C   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_87
   \      0x36E   0xF1B0 0x7F40      CMP      R0,#+50331648
   \      0x372   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_88
   \      0x374   0xF1B0 0x6F80      CMP      R0,#+67108864
   \      0x378   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_89
   \      0x37A   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \      0x37E   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_90
   \      0x380   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_91
    629              {
    630                case RCC_UART9CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for UART9*/
    631          
    632                  /* UART9 clock source config set later after clock selection check */
    633                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_85: (+1)
   \      0x382   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_92
    634          
    635                case RCC_UART9CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for UART9*/
    636                  /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
    637                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_86: (+1)
   \      0x384   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x388   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x38C   0x0005             MOVS     R5,R0
    638                  /* UART9 clock source config set later after clock selection check */
    639                  break;
   \      0x38E   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_92
    640          
    641                case RCC_UART9CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for UART9*/
    642                  /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
    643                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_87: (+1)
   \      0x390   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x394   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x398   0x0005             MOVS     R5,R0
    644                  /* UART9 clock source config set later after clock selection check */
    645                  break;
   \      0x39A   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_92
    646          
    647                case RCC_UART9CLKSOURCE_HSI:      /* HSI clock is used as source of UART9 clock*/
    648                  /* UART9 clock source config set later after clock selection check */
    649                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_88: (+1)
   \      0x39C   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_92
    650          
    651                case RCC_UART9CLKSOURCE_CSI:      /* CSI clock is used as source of UART9 clock*/
    652                  /* UART9 clock source config set later after clock selection check */
    653                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_89: (+1)
   \      0x39E   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_92
    654          
    655                case RCC_UART9CLKSOURCE_LSE:      /* LSE clock is used as source of UART9 clock*/
    656                  /* UART9 clock source config set later after clock selection check */
    657                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_90: (+1)
   \      0x3A0   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_92
    658          
    659                default:
    660                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_91: (+1)
   \      0x3A2   0x2501             MOVS     R5,#+1
    661                  break;
    662              }
    663          
    664              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_92: (+1)
   \      0x3A4   0x0028             MOVS     R0,R5
   \      0x3A6   0xB2C0             UXTB     R0,R0
   \      0x3A8   0x2800             CMP      R0,#+0
   \      0x3AA   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_93
    665              {
    666                /* Set the source of UART9 clock*/
    667                __HAL_RCC_UART9_CONFIG(pPeriphClkInit->Uart9ClockSelection);
   \      0x3AC   0xF8DF 0x16D8      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_0+0x4
   \      0x3B0   0x680A             LDR      R2,[R1, #+0]
   \      0x3B2   0xF032 0x62E0      BICS     R2,R2,#0x7000000
   \      0x3B6   0x6FE0             LDR      R0,[R4, #+124]
   \      0x3B8   0x4302             ORRS     R2,R0,R2
   \      0x3BA   0x600A             STR      R2,[R1, #+0]
   \      0x3BC   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_84
    668              }
    669              else
    670              {
    671                /* set overall return value */
    672                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_93: (+1)
   \      0x3BE   0x002E             MOVS     R6,R5
    673              }
    674            }
    675          #endif /* UART9 */
    676          
    677          #if defined(USART10)
    678            /*-------------------------- USART10 clock source configuration -------------------*/
    679            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
   \                     ??HAL_RCCEx_PeriphCLKConfig_84: (+1)
   \      0x3C0   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x3C4   0x0580             LSLS     R0,R0,#+22
   \      0x3C6   0xD533             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_94
    680            {
    681              /* Check the parameters */
    682              assert_param(IS_RCC_USART10CLKSOURCE(pPeriphClkInit->Usart10ClockSelection));
    683          
    684              switch (pPeriphClkInit->Usart10ClockSelection)
   \      0x3C8   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \      0x3CC   0x2800             CMP      R0,#+0
   \      0x3CE   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_95
   \      0x3D0   0xF1B0 0x6F00      CMP      R0,#+134217728
   \      0x3D4   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_96
   \      0x3D6   0xF1B0 0x5F80      CMP      R0,#+268435456
   \      0x3DA   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_97
   \      0x3DC   0xF1B0 0x5FC0      CMP      R0,#+402653184
   \      0x3E0   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_98
   \      0x3E2   0xF1B0 0x5F00      CMP      R0,#+536870912
   \      0x3E6   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_99
   \      0x3E8   0xF1B0 0x5F20      CMP      R0,#+671088640
   \      0x3EC   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_100
   \      0x3EE   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_101
    685              {
    686                case RCC_USART10CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for USART10*/
    687          
    688                  /* USART10 clock source config set later after clock selection check */
    689                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_95: (+1)
   \      0x3F0   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_102
    690          
    691                case RCC_USART10CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for USART10*/
    692                  /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
    693                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_96: (+1)
   \      0x3F2   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x3F6   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x3FA   0x0005             MOVS     R5,R0
    694                  /* USART10 clock source config set later after clock selection check */
    695                  break;
   \      0x3FC   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_102
    696          
    697                case RCC_USART10CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for USART10*/
    698                  /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
    699                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_97: (+1)
   \      0x3FE   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x402   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x406   0x0005             MOVS     R5,R0
    700                  /* USART10 clock source config set later after clock selection check */
    701                  break;
   \      0x408   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_102
    702          
    703                case RCC_USART10CLKSOURCE_HSI:      /* HSI clock is used as source of USART10 clock*/
    704                  /* USART10 clock source config set later after clock selection check */
    705                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_98: (+1)
   \      0x40A   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_102
    706          
    707                case RCC_USART10CLKSOURCE_CSI:      /* CSI clock is used as source of USART10 clock*/
    708                  /* USART10 clock source config set later after clock selection check */
    709                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_99: (+1)
   \      0x40C   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_102
    710          
    711                case RCC_USART10CLKSOURCE_LSE:      /* LSE clock is used as source of USART10 clock*/
    712                  /* USART10 clock source config set later after clock selection check */
    713                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_100: (+1)
   \      0x40E   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_102
    714          
    715                default:
    716                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_101: (+1)
   \      0x410   0x2501             MOVS     R5,#+1
    717                  break;
    718              }
    719          
    720              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_102: (+1)
   \      0x412   0x0028             MOVS     R0,R5
   \      0x414   0xB2C0             UXTB     R0,R0
   \      0x416   0x2800             CMP      R0,#+0
   \      0x418   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_103
    721              {
    722                /* Set the source of USART10 clock*/
    723                __HAL_RCC_USART10_CONFIG(pPeriphClkInit->Usart10ClockSelection);
   \      0x41A   0xF8DF 0x166C      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_0+0x4
   \      0x41E   0x680A             LDR      R2,[R1, #+0]
   \      0x420   0xF032 0x5260      BICS     R2,R2,#0x38000000
   \      0x424   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \      0x428   0x4302             ORRS     R2,R0,R2
   \      0x42A   0x600A             STR      R2,[R1, #+0]
   \      0x42C   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_94
    724              }
    725              else
    726              {
    727                /* set overall return value */
    728                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_103: (+1)
   \      0x42E   0x002E             MOVS     R6,R5
    729              }
    730            }
    731          #endif /* USART10 */
    732          
    733          #if defined(USART11)
    734            /*-------------------------- USART11 clock source configuration -------------------*/
    735            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART11) == RCC_PERIPHCLK_USART11)
   \                     ??HAL_RCCEx_PeriphCLKConfig_94: (+1)
   \      0x430   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x434   0x0540             LSLS     R0,R0,#+21
   \      0x436   0xD52C             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_104
    736            {
    737              /* Check the parameters */
    738              assert_param(IS_RCC_USART11CLKSOURCE(pPeriphClkInit->Usart11ClockSelection));
    739          
    740              switch (pPeriphClkInit->Usart11ClockSelection)
   \      0x438   0xF8D4 0x0084      LDR      R0,[R4, #+132]
   \      0x43C   0x2800             CMP      R0,#+0
   \      0x43E   0xD008             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_105
   \      0x440   0x2802             CMP      R0,#+2
   \      0x442   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_106
   \      0x444   0xD306             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_107
   \      0x446   0x2804             CMP      R0,#+4
   \      0x448   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_108
   \      0x44A   0xD30F             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_109
   \      0x44C   0x2805             CMP      R0,#+5
   \      0x44E   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_110
   \      0x450   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_111
    741              {
    742                case RCC_USART11CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for USART11*/
    743          
    744                  /* USART11 clock source config set later after clock selection check */
    745                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_105: (+1)
   \      0x452   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_112
    746          
    747                case RCC_USART11CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for USART11*/
    748                  /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
    749                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_107: (+1)
   \      0x454   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x458   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x45C   0x0005             MOVS     R5,R0
    750                  /* USART11 clock source config set later after clock selection check */
    751                  break;
   \      0x45E   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_112
    752          
    753                case RCC_USART11CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for USART11*/
    754                  /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
    755                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_106: (+1)
   \      0x460   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x464   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x468   0x0005             MOVS     R5,R0
    756                  /* USART11 clock source config set later after clock selection check */
    757                  break;
   \      0x46A   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_112
    758          
    759                case RCC_USART11CLKSOURCE_HSI:      /* HSI clock is used as source of USART11 clock*/
    760                  /* USART11 clock source config set later after clock selection check */
    761                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_109: (+1)
   \      0x46C   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_112
    762          
    763                case RCC_USART11CLKSOURCE_CSI:      /* CSI clock is used as source of USART11 clock*/
    764                  /* USART11 clock source config set later after clock selection check */
    765                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_108: (+1)
   \      0x46E   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_112
    766          
    767                case RCC_USART11CLKSOURCE_LSE:      /* LSE clock is used as source of USART11 clock*/
    768                  /* USART11 clock source config set later after clock selection check */
    769                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_110: (+1)
   \      0x470   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_112
    770          
    771                default:
    772                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_111: (+1)
   \      0x472   0x2501             MOVS     R5,#+1
    773                  break;
    774              }
    775          
    776              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_112: (+1)
   \      0x474   0x0028             MOVS     R0,R5
   \      0x476   0xB2C0             UXTB     R0,R0
   \      0x478   0x2800             CMP      R0,#+0
   \      0x47A   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_113
    777              {
    778                /* Set the source of USART11 clock*/
    779                __HAL_RCC_USART11_CONFIG(pPeriphClkInit->Usart11ClockSelection);
   \      0x47C   0xF8DF 0x17F4      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_1
   \      0x480   0x680A             LDR      R2,[R1, #+0]
   \      0x482   0x08D2             LSRS     R2,R2,#+3
   \      0x484   0x00D2             LSLS     R2,R2,#+3
   \      0x486   0xF8D4 0x0084      LDR      R0,[R4, #+132]
   \      0x48A   0x4302             ORRS     R2,R0,R2
   \      0x48C   0x600A             STR      R2,[R1, #+0]
   \      0x48E   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_104
    780              }
    781              else
    782              {
    783                /* set overall return value */
    784                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_113: (+1)
   \      0x490   0x002E             MOVS     R6,R5
    785              }
    786            }
    787          #endif /*USART11*/
    788          
    789          #if defined(UART12)
    790            /*-------------------------- UART12 clock source configuration -------------------*/
    791            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART12) == RCC_PERIPHCLK_UART12)
   \                     ??HAL_RCCEx_PeriphCLKConfig_104: (+1)
   \      0x492   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x496   0x0500             LSLS     R0,R0,#+20
   \      0x498   0xD52E             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_114
    792            {
    793              /* Check the parameters */
    794              assert_param(IS_RCC_UART12CLKSOURCE(pPeriphClkInit->Uart12ClockSelection));
    795          
    796              switch (pPeriphClkInit->Uart12ClockSelection)
   \      0x49A   0xF8D4 0x0088      LDR      R0,[R4, #+136]
   \      0x49E   0x2800             CMP      R0,#+0
   \      0x4A0   0xD00A             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_115
   \      0x4A2   0x2810             CMP      R0,#+16
   \      0x4A4   0xD009             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_116
   \      0x4A6   0x2820             CMP      R0,#+32
   \      0x4A8   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_117
   \      0x4AA   0x2830             CMP      R0,#+48
   \      0x4AC   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_118
   \      0x4AE   0x2840             CMP      R0,#+64
   \      0x4B0   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_119
   \      0x4B2   0x2850             CMP      R0,#+80
   \      0x4B4   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_120
   \      0x4B6   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_121
    797              {
    798                case RCC_UART12CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for UART12*/
    799          
    800                  /* UART12 clock source config set later after clock selection check */
    801                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_115: (+1)
   \      0x4B8   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_122
    802          
    803                case RCC_UART12CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for UART12*/
    804                  /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
    805                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_116: (+1)
   \      0x4BA   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x4BE   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x4C2   0x0005             MOVS     R5,R0
    806                  /* UART12 clock source config set later after clock selection check */
    807                  break;
   \      0x4C4   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_122
    808          
    809                case RCC_UART12CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for UART12*/
    810                  /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
    811                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_117: (+1)
   \      0x4C6   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x4CA   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x4CE   0x0005             MOVS     R5,R0
    812                  /* UART12 clock source config set later after clock selection check */
    813                  break;
   \      0x4D0   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_122
    814          
    815                case RCC_UART12CLKSOURCE_HSI:      /* HSI clock is used as source of UART12 clock*/
    816                  /* UART12 clock source config set later after clock selection check */
    817                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_118: (+1)
   \      0x4D2   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_122
    818          
    819                case RCC_UART12CLKSOURCE_CSI:      /* CSI clock is used as source of UART12 clock*/
    820                  /* UART12 clock source config set later after clock selection check */
    821                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_119: (+1)
   \      0x4D4   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_122
    822          
    823                case RCC_UART12CLKSOURCE_LSE:      /* LSE clock is used as source of UART12 clock*/
    824                  /* UART12 clock source config set later after clock selection check */
    825                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_120: (+1)
   \      0x4D6   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_122
    826          
    827                default:
    828                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_121: (+1)
   \      0x4D8   0x2501             MOVS     R5,#+1
    829                  break;
    830              }
    831          
    832              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_122: (+1)
   \      0x4DA   0x0028             MOVS     R0,R5
   \      0x4DC   0xB2C0             UXTB     R0,R0
   \      0x4DE   0x2800             CMP      R0,#+0
   \      0x4E0   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_123
    833              {
    834                /* Set the source of UART12 clock*/
    835                __HAL_RCC_UART12_CONFIG(pPeriphClkInit->Uart12ClockSelection);
   \      0x4E2   0xF8DF 0x1790      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_1
   \      0x4E6   0x680A             LDR      R2,[R1, #+0]
   \      0x4E8   0xF032 0x0270      BICS     R2,R2,#0x70
   \      0x4EC   0xF8D4 0x0088      LDR      R0,[R4, #+136]
   \      0x4F0   0x4302             ORRS     R2,R0,R2
   \      0x4F2   0x600A             STR      R2,[R1, #+0]
   \      0x4F4   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_114
    836              }
    837              else
    838              {
    839                /* set overall return value */
    840                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_123: (+1)
   \      0x4F6   0x002E             MOVS     R6,R5
    841              }
    842            }
    843          #endif /* UART12 */
    844          
    845            /*-------------------------- LPUART1 clock source configuration ------------------*/
    846            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
   \                     ??HAL_RCCEx_PeriphCLKConfig_114: (+1)
   \      0x4F8   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x4FC   0x04C0             LSLS     R0,R0,#+19
   \      0x4FE   0xD533             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_124
    847            {
    848              /* Check the parameters */
    849              assert_param(IS_RCC_LPUART1CLKSOURCE(pPeriphClkInit->Lpuart1ClockSelection));
    850          
    851              switch (pPeriphClkInit->Lpuart1ClockSelection)
   \      0x500   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \      0x504   0x2800             CMP      R0,#+0
   \      0x506   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_125
   \      0x508   0xF1B0 0x7F80      CMP      R0,#+16777216
   \      0x50C   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_126
   \      0x50E   0xF1B0 0x7F00      CMP      R0,#+33554432
   \      0x512   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_127
   \      0x514   0xF1B0 0x7F40      CMP      R0,#+50331648
   \      0x518   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_128
   \      0x51A   0xF1B0 0x6F80      CMP      R0,#+67108864
   \      0x51E   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_129
   \      0x520   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \      0x524   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_130
   \      0x526   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_131
    852              {
    853                case RCC_LPUART1CLKSOURCE_PCLK3:      /* PCLK3 is used as clock source for LPUART1*/
    854          
    855                  /* LPUART1 clock source config set later after clock selection check */
    856                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_125: (+1)
   \      0x528   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_132
    857          
    858                case RCC_LPUART1CLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for LPUART1*/
    859                  /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
    860                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_126: (+1)
   \      0x52A   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x52E   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x532   0x0005             MOVS     R5,R0
    861                  /* LPUART1 clock source config set later after clock selection check */
    862                  break;
   \      0x534   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_132
    863          
    864          #if defined(RCC_LPUART1CLKSOURCE_PLL3Q)
    865                case RCC_LPUART1CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for LPUART1*/
    866                  /* PLL3  input clock, parameters M, N & Q configuration clock output (PLL3ClockOut) */
    867                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_127: (+1)
   \      0x536   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x53A   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x53E   0x0005             MOVS     R5,R0
    868                  /* LPUART1 clock source config set later after clock selection check */
    869                  break;
   \      0x540   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_132
    870          #endif /* RCC_LPUART1CLKSOURCE_PLL3Q */
    871          
    872                case RCC_LPUART1CLKSOURCE_HSI:      /* HSI clock is used as source of LPUART1 clock*/
    873                  /* LPUART1 clock source config set later after clock selection check */
    874                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_128: (+1)
   \      0x542   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_132
    875          
    876                case RCC_LPUART1CLKSOURCE_CSI:      /* CSI clock is used as source of LPUART1 clock*/
    877                  /* LPUART1 clock source config set later after clock selection check */
    878                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_129: (+1)
   \      0x544   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_132
    879          
    880                case RCC_LPUART1CLKSOURCE_LSE:      /* LSE clock is used as source of LPUART1 clock*/
    881                  /* LPUART1 clock source config set later after clock selection check */
    882                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_130: (+1)
   \      0x546   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_132
    883          
    884                default:
    885                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_131: (+1)
   \      0x548   0x2501             MOVS     R5,#+1
    886                  break;
    887              }
    888          
    889              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_132: (+1)
   \      0x54A   0x0028             MOVS     R0,R5
   \      0x54C   0xB2C0             UXTB     R0,R0
   \      0x54E   0x2800             CMP      R0,#+0
   \      0x550   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_133
    890              {
    891                /* Set the source of LPUART1 clock*/
    892                __HAL_RCC_LPUART1_CONFIG(pPeriphClkInit->Lpuart1ClockSelection);
   \      0x552   0xF8DF 0x1AC0      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_2
   \      0x556   0x680A             LDR      R2,[R1, #+0]
   \      0x558   0xF032 0x62E0      BICS     R2,R2,#0x7000000
   \      0x55C   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \      0x560   0x4302             ORRS     R2,R0,R2
   \      0x562   0x600A             STR      R2,[R1, #+0]
   \      0x564   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_124
    893              }
    894              else
    895              {
    896                /* set overall return value */
    897                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_133: (+1)
   \      0x566   0x002E             MOVS     R6,R5
    898              }
    899            }
    900          
    901            /*-------------------------- I2C1 clock source configuration ---------------------*/
    902            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
   \                     ??HAL_RCCEx_PeriphCLKConfig_124: (+1)
   \      0x568   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x56C   0x0480             LSLS     R0,R0,#+18
   \      0x56E   0xD526             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_134
    903            {
    904              /* Check the parameters */
    905              assert_param(IS_RCC_I2C1CLKSOURCE(pPeriphClkInit->I2c1ClockSelection));
    906          
    907              switch (pPeriphClkInit->I2c1ClockSelection)
   \      0x570   0xF8D4 0x0090      LDR      R0,[R4, #+144]
   \      0x574   0x2800             CMP      R0,#+0
   \      0x576   0xD009             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_135
   \      0x578   0xF5B0 0x3F80      CMP      R0,#+65536
   \      0x57C   0xD007             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_136
   \      0x57E   0xF5B0 0x3F00      CMP      R0,#+131072
   \      0x582   0xD00A             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_137
   \      0x584   0xF5B0 0x3F40      CMP      R0,#+196608
   \      0x588   0xD008             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_138
   \      0x58A   0xE008             B.N      ??HAL_RCCEx_PeriphCLKConfig_139
    908              {
    909                case RCC_I2C1CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for I2C1*/
    910          
    911                  /* I2C1 clock source config set later after clock selection check */
    912                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_135: (+1)
   \      0x58C   0xE008             B.N      ??HAL_RCCEx_PeriphCLKConfig_140
    913          
    914          #if defined(RCC_I2C1CLKSOURCE_PLL3R)
    915                case RCC_I2C1CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for I2C1*/
    916                  /* PLL3  input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
    917                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_136: (+1)
   \      0x58E   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x592   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x596   0x0005             MOVS     R5,R0
    918          #else
    919                case RCC_I2C1CLKSOURCE_PLL2R:  /* PLL2 is used as clock source for I2C1*/
    920                  /* PLL2  input clock, parameters M, N & R configuration clock output (PLL2ClockOut) */
    921                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
    922          #endif /* RCC_I2C1CLKSOURCE_PLL3R */
    923                  /* I2C1 clock source config set later after clock selection check */
    924                  break;
   \      0x598   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_140
    925          
    926          
    927                case RCC_I2C1CLKSOURCE_HSI:      /* HSI clock is used as source of I2C1 clock*/
    928                  /* I2C1 clock source config set later after clock selection check */
    929                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_137: (+1)
   \      0x59A   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_140
    930          
    931                case RCC_I2C1CLKSOURCE_CSI:      /* CSI clock is used as source of I2C1 clock*/
    932                  /* I2C1 clock source config set later after clock selection check */
    933                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_138: (+1)
   \      0x59C   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_140
    934          
    935                default:
    936                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_139: (+1)
   \      0x59E   0x2501             MOVS     R5,#+1
    937                  break;
    938              }
    939          
    940              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_140: (+1)
   \      0x5A0   0x0028             MOVS     R0,R5
   \      0x5A2   0xB2C0             UXTB     R0,R0
   \      0x5A4   0x2800             CMP      R0,#+0
   \      0x5A6   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_141
    941              {
    942                /* Set the source of I2C1 clock*/
    943                __HAL_RCC_I2C1_CONFIG(pPeriphClkInit->I2c1ClockSelection);
   \      0x5A8   0xF8DF 0x1A6C      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_2+0x4
   \      0x5AC   0x680A             LDR      R2,[R1, #+0]
   \      0x5AE   0xF432 0x3240      BICS     R2,R2,#0x30000
   \      0x5B2   0xF8D4 0x0090      LDR      R0,[R4, #+144]
   \      0x5B6   0x4302             ORRS     R2,R0,R2
   \      0x5B8   0x600A             STR      R2,[R1, #+0]
   \      0x5BA   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_134
    944              }
    945              else
    946              {
    947                /* set overall return value */
    948                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_141: (+1)
   \      0x5BC   0x002E             MOVS     R6,R5
    949              }
    950            }
    951          
    952            /*-------------------------- I2C2 clock source configuration ---------------------*/
    953            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
   \                     ??HAL_RCCEx_PeriphCLKConfig_134: (+1)
   \      0x5BE   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x5C2   0x0440             LSLS     R0,R0,#+17
   \      0x5C4   0xD526             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_142
    954            {
    955              /* Check the parameters */
    956              assert_param(IS_RCC_I2C2CLKSOURCE(pPeriphClkInit->I2c2ClockSelection));
    957          
    958              switch (pPeriphClkInit->I2c2ClockSelection)
   \      0x5C6   0xF8D4 0x0094      LDR      R0,[R4, #+148]
   \      0x5CA   0x2800             CMP      R0,#+0
   \      0x5CC   0xD009             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_143
   \      0x5CE   0xF5B0 0x2F80      CMP      R0,#+262144
   \      0x5D2   0xD007             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_144
   \      0x5D4   0xF5B0 0x2F00      CMP      R0,#+524288
   \      0x5D8   0xD00A             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_145
   \      0x5DA   0xF5B0 0x2F40      CMP      R0,#+786432
   \      0x5DE   0xD008             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_146
   \      0x5E0   0xE008             B.N      ??HAL_RCCEx_PeriphCLKConfig_147
    959              {
    960                case RCC_I2C2CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for I2C2*/
    961          
    962                  /* I2C2 clock source config set later after clock selection check */
    963                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_143: (+1)
   \      0x5E2   0xE008             B.N      ??HAL_RCCEx_PeriphCLKConfig_148
    964          
    965          #if defined(RCC_I2C2CLKSOURCE_PLL3R)
    966                case RCC_I2C2CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for I2C2*/
    967                  /* PLL3  input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
    968                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_144: (+1)
   \      0x5E4   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x5E8   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x5EC   0x0005             MOVS     R5,R0
    969          #else
    970                case RCC_I2C2CLKSOURCE_PLL2R:  /* PLL32 is used as clock source for I2C2*/
    971                  /* PLL2  input clock, parameters M, N & R configuration clock output (PLL2ClockOut) */
    972                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
    973          #endif /* RCC_I2C2CLKSOURCE_PLL3R */
    974                  /* I2C2 clock source config set later after clock selection check */
    975                  break;
   \      0x5EE   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_148
    976          
    977                case RCC_I2C2CLKSOURCE_HSI:      /* HSI clock is used as source of I2C2 clock*/
    978                  /* I2C2 clock source config set later after clock selection check */
    979                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_145: (+1)
   \      0x5F0   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_148
    980          
    981                case RCC_I2C2CLKSOURCE_CSI:      /* CSI clock is used as source of I2C2 clock*/
    982                  /* I2C2 clock source config set later after clock selection check */
    983                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_146: (+1)
   \      0x5F2   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_148
    984          
    985                default:
    986                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_147: (+1)
   \      0x5F4   0x2501             MOVS     R5,#+1
    987                  break;
    988              }
    989          
    990              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_148: (+1)
   \      0x5F6   0x0028             MOVS     R0,R5
   \      0x5F8   0xB2C0             UXTB     R0,R0
   \      0x5FA   0x2800             CMP      R0,#+0
   \      0x5FC   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_149
    991              {
    992                /* Set the source of I2C2 clock*/
    993                __HAL_RCC_I2C2_CONFIG(pPeriphClkInit->I2c2ClockSelection);
   \      0x5FE   0xF8DF 0x1A18      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_2+0x4
   \      0x602   0x680A             LDR      R2,[R1, #+0]
   \      0x604   0xF432 0x2240      BICS     R2,R2,#0xC0000
   \      0x608   0xF8D4 0x0094      LDR      R0,[R4, #+148]
   \      0x60C   0x4302             ORRS     R2,R0,R2
   \      0x60E   0x600A             STR      R2,[R1, #+0]
   \      0x610   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_142
    994              }
    995              else
    996              {
    997                /* set overall return value */
    998                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_149: (+1)
   \      0x612   0x002E             MOVS     R6,R5
    999              }
   1000            }
   1001          
   1002          #if defined(I2C3)
   1003            /*-------------------------- I2C3 clock source configuration ---------------------*/
   1004            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
   \                     ??HAL_RCCEx_PeriphCLKConfig_142: (+1)
   \      0x614   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x618   0x0400             LSLS     R0,R0,#+16
   \      0x61A   0xD526             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_150
   1005            {
   1006              /* Check the parameters */
   1007              assert_param(IS_RCC_I2C3CLKSOURCE(pPeriphClkInit->I2c3ClockSelection));
   1008          
   1009              switch (pPeriphClkInit->I2c3ClockSelection)
   \      0x61C   0xF8D4 0x0098      LDR      R0,[R4, #+152]
   \      0x620   0x2800             CMP      R0,#+0
   \      0x622   0xD009             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_151
   \      0x624   0xF5B0 0x1F80      CMP      R0,#+1048576
   \      0x628   0xD007             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_152
   \      0x62A   0xF5B0 0x1F00      CMP      R0,#+2097152
   \      0x62E   0xD00A             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_153
   \      0x630   0xF5B0 0x1F40      CMP      R0,#+3145728
   \      0x634   0xD008             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_154
   \      0x636   0xE008             B.N      ??HAL_RCCEx_PeriphCLKConfig_155
   1010              {
   1011                case RCC_I2C3CLKSOURCE_PCLK3:      /* PCLK3 is used as clock source for I2C3*/
   1012          
   1013                  /* I2C3 clock source config set later after clock selection check */
   1014                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_151: (+1)
   \      0x638   0xE008             B.N      ??HAL_RCCEx_PeriphCLKConfig_156
   1015          
   1016                case RCC_I2C3CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for I2C3*/
   1017                  /* PLL3  input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
   1018                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_152: (+1)
   \      0x63A   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x63E   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x642   0x0005             MOVS     R5,R0
   1019                  /* I2C3 clock source config set later after clock selection check */
   1020                  break;
   \      0x644   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_156
   1021          
   1022                case RCC_I2C3CLKSOURCE_HSI:      /* HSI clock is used as source of I2C3 clock*/
   1023                  /* I2C3 clock source config set later after clock selection check */
   1024                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_153: (+1)
   \      0x646   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_156
   1025          
   1026                case RCC_I2C3CLKSOURCE_CSI:      /* CSI clock is used as source of I2C3 clock*/
   1027                  /* I2C3 clock source config set later after clock selection check */
   1028                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_154: (+1)
   \      0x648   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_156
   1029          
   1030                default:
   1031                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_155: (+1)
   \      0x64A   0x2501             MOVS     R5,#+1
   1032                  break;
   1033              }
   1034          
   1035              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_156: (+1)
   \      0x64C   0x0028             MOVS     R0,R5
   \      0x64E   0xB2C0             UXTB     R0,R0
   \      0x650   0x2800             CMP      R0,#+0
   \      0x652   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_157
   1036              {
   1037                /* Set the source of I2C3 clock*/
   1038                __HAL_RCC_I2C3_CONFIG(pPeriphClkInit->I2c3ClockSelection);
   \      0x654   0xF8DF 0x19C0      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_2+0x4
   \      0x658   0x680A             LDR      R2,[R1, #+0]
   \      0x65A   0xF432 0x1240      BICS     R2,R2,#0x300000
   \      0x65E   0xF8D4 0x0098      LDR      R0,[R4, #+152]
   \      0x662   0x4302             ORRS     R2,R0,R2
   \      0x664   0x600A             STR      R2,[R1, #+0]
   \      0x666   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_150
   1039              }
   1040              else
   1041              {
   1042                /* set overall return value */
   1043                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_157: (+1)
   \      0x668   0x002E             MOVS     R6,R5
   1044              }
   1045            }
   1046          #endif /* I2C3 */
   1047          
   1048          #if defined(I2C4)
   1049            /*-------------------------- I2C4 clock source configuration ---------------------*/
   1050            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
   \                     ??HAL_RCCEx_PeriphCLKConfig_150: (+1)
   \      0x66A   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x66E   0xF010 0x0000      ANDS     R0,R0,#0x0
   \      0x672   0xF411 0x6180      ANDS     R1,R1,#0x400
   \      0x676   0x2900             CMP      R1,#+0
   \      0x678   0xD101             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_158
   \      0x67A   0x2800             CMP      R0,#+0
   \      0x67C   0xD026             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_159
   1051            {
   1052              /* Check the parameters */
   1053              assert_param(IS_RCC_I2C4CLKSOURCE(pPeriphClkInit->I2c4ClockSelection));
   1054          
   1055              switch (pPeriphClkInit->I2c4ClockSelection)
   \                     ??HAL_RCCEx_PeriphCLKConfig_158: (+1)
   \      0x67E   0xF8D4 0x009C      LDR      R0,[R4, #+156]
   \      0x682   0x2800             CMP      R0,#+0
   \      0x684   0xD009             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_160
   \      0x686   0xF5B0 0x0F80      CMP      R0,#+4194304
   \      0x68A   0xD007             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_161
   \      0x68C   0xF5B0 0x0F00      CMP      R0,#+8388608
   \      0x690   0xD00A             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_162
   \      0x692   0xF5B0 0x0F40      CMP      R0,#+12582912
   \      0x696   0xD008             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_163
   \      0x698   0xE008             B.N      ??HAL_RCCEx_PeriphCLKConfig_164
   1056              {
   1057                case RCC_I2C4CLKSOURCE_PCLK3:      /* PCLK3 is used as clock source for I2C4*/
   1058          
   1059                  /* I2C4 clock source config set later after clock selection check */
   1060                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_160: (+1)
   \      0x69A   0xE008             B.N      ??HAL_RCCEx_PeriphCLKConfig_165
   1061          
   1062                case RCC_I2C4CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for I2C4*/
   1063                  /* PLL3  input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
   1064                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_161: (+1)
   \      0x69C   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x6A0   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x6A4   0x0005             MOVS     R5,R0
   1065                  /* I2C4 clock source config set later after clock selection check */
   1066                  break;
   \      0x6A6   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_165
   1067          
   1068                case RCC_I2C4CLKSOURCE_HSI:      /* HSI clock is used as source of I2C4 clock*/
   1069                  /* I2C4 clock source config set later after clock selection check */
   1070                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_162: (+1)
   \      0x6A8   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_165
   1071          
   1072                case RCC_I2C4CLKSOURCE_CSI:      /* CSI clock is used as source of I2C4 clock*/
   1073                  /* I2C4 clock source config set later after clock selection check */
   1074                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_163: (+1)
   \      0x6AA   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_165
   1075          
   1076                default:
   1077                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_164: (+1)
   \      0x6AC   0x2501             MOVS     R5,#+1
   1078                  break;
   1079              }
   1080          
   1081              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_165: (+1)
   \      0x6AE   0x0028             MOVS     R0,R5
   \      0x6B0   0xB2C0             UXTB     R0,R0
   \      0x6B2   0x2800             CMP      R0,#+0
   \      0x6B4   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_166
   1082              {
   1083                /* Set the source of I2C4 clock*/
   1084                __HAL_RCC_I2C4_CONFIG(pPeriphClkInit->I2c4ClockSelection);
   \      0x6B6   0xF8DF 0x1960      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_2+0x4
   \      0x6BA   0x680A             LDR      R2,[R1, #+0]
   \      0x6BC   0xF432 0x0240      BICS     R2,R2,#0xC00000
   \      0x6C0   0xF8D4 0x009C      LDR      R0,[R4, #+156]
   \      0x6C4   0x4302             ORRS     R2,R0,R2
   \      0x6C6   0x600A             STR      R2,[R1, #+0]
   \      0x6C8   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_159
   1085              }
   1086              else
   1087              {
   1088                /* set overall return value */
   1089                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_166: (+1)
   \      0x6CA   0x002E             MOVS     R6,R5
   1090              }
   1091            }
   1092          #endif /* I2C4 */
   1093          
   1094            /*-------------------------- I3C1 clock source configuration ---------------------*/
   1095            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
   \                     ??HAL_RCCEx_PeriphCLKConfig_159: (+1)
   \      0x6CC   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x6D0   0x03C0             LSLS     R0,R0,#+15
   \      0x6D2   0xD522             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_167
   1096            {
   1097              /* Check the parameters */
   1098              assert_param(IS_RCC_I3C1CLKSOURCE(pPeriphClkInit->I3c1ClockSelection));
   1099          
   1100              switch (pPeriphClkInit->I3c1ClockSelection)
   \      0x6D4   0xF8D4 0x00A0      LDR      R0,[R4, #+160]
   \      0x6D8   0x2800             CMP      R0,#+0
   \      0x6DA   0xD006             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_168
   \      0x6DC   0xF1B0 0x7F80      CMP      R0,#+16777216
   \      0x6E0   0xD004             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_169
   \      0x6E2   0xF1B0 0x7F00      CMP      R0,#+33554432
   \      0x6E6   0xD007             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_170
   \      0x6E8   0xE007             B.N      ??HAL_RCCEx_PeriphCLKConfig_171
   1101              {
   1102                case RCC_I3C1CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for I3C1*/
   1103          
   1104                  /* I3C1 clock source config set later after clock selection check */
   1105                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_168: (+1)
   \      0x6EA   0xE007             B.N      ??HAL_RCCEx_PeriphCLKConfig_172
   1106          
   1107          #if defined(RCC_I3C1CLKSOURCE_PLL3R)
   1108                case RCC_I3C1CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for I3C1*/
   1109                  /* PLL3  input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
   1110                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_169: (+1)
   \      0x6EC   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x6F0   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x6F4   0x0005             MOVS     R5,R0
   1111          #else
   1112                case RCC_I3C1CLKSOURCE_PLL2R:  /* PLL2 is used as clock source for I3C1*/
   1113                  /* PLL2  input clock, parameters M, N & R configuration clock output (PLL2ClockOut) */
   1114                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   1115          #endif /* RCC_I3C1CLKSOURCE_PLL3R */
   1116                  /* I3C1 clock source config set later after clock selection check */
   1117                  break;
   \      0x6F6   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_172
   1118          
   1119                case RCC_I3C1CLKSOURCE_HSI:      /* HSI clock is used as source of I3C1 clock*/
   1120                  /* I3C1 clock source config set later after clock selection check */
   1121                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_170: (+1)
   \      0x6F8   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_172
   1122          
   1123                default:
   1124                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_171: (+1)
   \      0x6FA   0x2501             MOVS     R5,#+1
   1125                  break;
   1126              }
   1127          
   1128              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_172: (+1)
   \      0x6FC   0x0028             MOVS     R0,R5
   \      0x6FE   0xB2C0             UXTB     R0,R0
   \      0x700   0x2800             CMP      R0,#+0
   \      0x702   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_173
   1129              {
   1130                /* Set the source of I3C1 clock*/
   1131                __HAL_RCC_I3C1_CONFIG(pPeriphClkInit->I3c1ClockSelection);
   \      0x704   0xF8DF 0x1910      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_2+0x4
   \      0x708   0x680A             LDR      R2,[R1, #+0]
   \      0x70A   0xF032 0x7240      BICS     R2,R2,#0x3000000
   \      0x70E   0xF8D4 0x00A0      LDR      R0,[R4, #+160]
   \      0x712   0x4302             ORRS     R2,R0,R2
   \      0x714   0x600A             STR      R2,[R1, #+0]
   \      0x716   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_167
   1132              }
   1133              else
   1134              {
   1135                /* set overall return value */
   1136                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_173: (+1)
   \      0x718   0x002E             MOVS     R6,R5
   1137              }
   1138            }
   1139          
   1140          #if defined (I3C2)
   1141            /*-------------------------- I3C2 clock source configuration ---------------------*/
   1142            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
   1143            {
   1144              /* Check the parameters */
   1145              assert_param(IS_RCC_I3C2CLKSOURCE(pPeriphClkInit->I3c2ClockSelection));
   1146          
   1147              switch (pPeriphClkInit->I3c2ClockSelection)
   1148              {
   1149                case RCC_I3C2CLKSOURCE_PCLK3:      /* PCLK1 is used as clock source for I3C2*/
   1150          
   1151                  /* I3C2 clock source config set later after clock selection check */
   1152                  break;
   1153          
   1154                case RCC_I3C2CLKSOURCE_PLL2R:  /* PLL2 is used as clock source for I3C2*/
   1155                  /* PLL2  input clock, parameters M, N & R configuration clock output (PLL2ClockOut) */
   1156                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   1157                  /* I3C2 clock source config set later after clock selection check */
   1158                  break;
   1159          
   1160                case RCC_I3C2CLKSOURCE_HSI:      /* HSI clock is used as source of I3C2 clock*/
   1161                  /* I3C2 clock source config set later after clock selection check */
   1162                  break;
   1163          
   1164                default:
   1165                  ret = HAL_ERROR;
   1166                  break;
   1167              }
   1168          
   1169              if (ret == HAL_OK)
   1170              {
   1171                /* Set the source of I3C2 clock*/
   1172                __HAL_RCC_I3C2_CONFIG(pPeriphClkInit->I3c2ClockSelection);
   1173              }
   1174              else
   1175              {
   1176                /* set overall return value */
   1177                status = ret;
   1178              }
   1179            }
   1180          #endif /* I3C2 */
   1181          
   1182            /*------------------------------------ TIM configuration --------------------------------------*/
   1183            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
   \                     ??HAL_RCCEx_PeriphCLKConfig_167: (+1)
   \      0x71A   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x71E   0xF010 0x0000      ANDS     R0,R0,#0x0
   \      0x722   0xF411 0x6100      ANDS     R1,R1,#0x800
   \      0x726   0x2900             CMP      R1,#+0
   \      0x728   0xD101             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_174
   \      0x72A   0x2800             CMP      R0,#+0
   \      0x72C   0xD00A             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_175
   1184            {
   1185              /* Check the parameters */
   1186              assert_param(IS_RCC_TIMPRES(pPeriphClkInit->TimPresSelection));
   1187          
   1188              /* Configure Timer Prescaler */
   1189              __HAL_RCC_TIMCLKPRESCALER(pPeriphClkInit->TimPresSelection);
   \                     ??HAL_RCCEx_PeriphCLKConfig_174: (+1)
   \      0x72E   0x.... 0x....      LDR.W    R1,??DataTable0
   \      0x732   0x6808             LDR      R0,[R1, #+0]
   \      0x734   0xF430 0x4000      BICS     R0,R0,#0x8000
   \      0x738   0x6008             STR      R0,[R1, #+0]
   \      0x73A   0x680A             LDR      R2,[R1, #+0]
   \      0x73C   0xF8D4 0x0100      LDR      R0,[R4, #+256]
   \      0x740   0x4302             ORRS     R2,R0,R2
   \      0x742   0x600A             STR      R2,[R1, #+0]
   1190            }
   1191          
   1192            /*-------------------------- LPTIM1 clock source configuration ---------------------*/
   1193            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
   \                     ??HAL_RCCEx_PeriphCLKConfig_175: (+1)
   \      0x744   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x748   0x0380             LSLS     R0,R0,#+14
   \      0x74A   0xD533             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_176
   1194            {
   1195              /* Check the parameters */
   1196              assert_param(IS_RCC_LPTIM1CLK(pPeriphClkInit->Lptim1ClockSelection));
   1197          
   1198              switch (pPeriphClkInit->Lptim1ClockSelection)
   \      0x74C   0xF8D4 0x00A4      LDR      R0,[R4, #+164]
   \      0x750   0x2800             CMP      R0,#+0
   \      0x752   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_177
   \      0x754   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x758   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_178
   \      0x75A   0xF5B0 0x7F00      CMP      R0,#+512
   \      0x75E   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_179
   \      0x760   0xF5B0 0x7F40      CMP      R0,#+768
   \      0x764   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_180
   \      0x766   0xF5B0 0x6F80      CMP      R0,#+1024
   \      0x76A   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_181
   \      0x76C   0xF5B0 0x6FA0      CMP      R0,#+1280
   \      0x770   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_182
   \      0x772   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_183
   1199              {
   1200                case RCC_LPTIM1CLKSOURCE_PCLK3:      /* PCLK3 is used as clock source for LPTIM1*/
   1201          
   1202                  /* LPTIM1 clock source config set later after clock selection check */
   1203                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_177: (+1)
   \      0x774   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_184
   1204          
   1205                case RCC_LPTIM1CLKSOURCE_PLL2P:  /* PLL2 is used as clock source for LPTIM1*/
   1206                  /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
   1207                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_178: (+1)
   \      0x776   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x77A   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x77E   0x0005             MOVS     R5,R0
   1208                  /* LPTIM1 clock source config set later after clock selection check */
   1209                  break;
   \      0x780   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_184
   1210          
   1211          #if defined(RCC_LPTIM1CLKSOURCE_PLL3R)
   1212                case RCC_LPTIM1CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for LPTIM1*/
   1213                  /* PLL3 R input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
   1214                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_179: (+1)
   \      0x782   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x786   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x78A   0x0005             MOVS     R5,R0
   1215                  /* LPTIM1 clock source config set later after clock selection check */
   1216                  break;
   \      0x78C   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_184
   1217          #endif /* RCC_LPTIM1CLKSOURCE_PLL3R */
   1218          
   1219                case RCC_LPTIM1CLKSOURCE_LSE:      /* LSE clock is used as source of LPTIM1 clock*/
   1220                  /* LPTIM1 clock source config set later after clock selection check */
   1221                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_180: (+1)
   \      0x78E   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_184
   1222          
   1223                case RCC_LPTIM1CLKSOURCE_LSI:      /* LSI clock is used as source of LPTIM1 clock*/
   1224                  /* LPTIM1 clock source config set later after clock selection check */
   1225                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_181: (+1)
   \      0x790   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_184
   1226          
   1227                case RCC_LPTIM1CLKSOURCE_CLKP:      /* CLKP is used as source of LPTIM1 clock*/
   1228                  /* LPTIM1 clock source config set later after clock selection check */
   1229                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_182: (+1)
   \      0x792   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_184
   1230          
   1231                default:
   1232                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_183: (+1)
   \      0x794   0x2501             MOVS     R5,#+1
   1233                  break;
   1234              }
   1235          
   1236              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_184: (+1)
   \      0x796   0x0028             MOVS     R0,R5
   \      0x798   0xB2C0             UXTB     R0,R0
   \      0x79A   0x2800             CMP      R0,#+0
   \      0x79C   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_185
   1237              {
   1238                /* Set the source of LPTIM1 clock*/
   1239                __HAL_RCC_LPTIM1_CONFIG(pPeriphClkInit->Lptim1ClockSelection);
   \      0x79E   0xF8DF 0x14D4      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_1
   \      0x7A2   0x680A             LDR      R2,[R1, #+0]
   \      0x7A4   0xF432 0x62E0      BICS     R2,R2,#0x700
   \      0x7A8   0xF8D4 0x00A4      LDR      R0,[R4, #+164]
   \      0x7AC   0x4302             ORRS     R2,R0,R2
   \      0x7AE   0x600A             STR      R2,[R1, #+0]
   \      0x7B0   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_176
   1240              }
   1241              else
   1242              {
   1243                /* set overall return value */
   1244                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_185: (+1)
   \      0x7B2   0x002E             MOVS     R6,R5
   1245              }
   1246            }
   1247          
   1248            /*-------------------------- LPTIM2 clock source configuration ---------------------*/
   1249            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
   \                     ??HAL_RCCEx_PeriphCLKConfig_176: (+1)
   \      0x7B4   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x7B8   0x0340             LSLS     R0,R0,#+13
   \      0x7BA   0xD533             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_186
   1250            {
   1251              /* Check the parameters */
   1252              assert_param(IS_RCC_LPTIM2CLK(pPeriphClkInit->Lptim2ClockSelection));
   1253          
   1254              switch (pPeriphClkInit->Lptim2ClockSelection)
   \      0x7BC   0xF8D4 0x00A8      LDR      R0,[R4, #+168]
   \      0x7C0   0x2800             CMP      R0,#+0
   \      0x7C2   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_187
   \      0x7C4   0xF5B0 0x5F80      CMP      R0,#+4096
   \      0x7C8   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_188
   \      0x7CA   0xF5B0 0x5F00      CMP      R0,#+8192
   \      0x7CE   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_189
   \      0x7D0   0xF5B0 0x5F40      CMP      R0,#+12288
   \      0x7D4   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_190
   \      0x7D6   0xF5B0 0x4F80      CMP      R0,#+16384
   \      0x7DA   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_191
   \      0x7DC   0xF5B0 0x4FA0      CMP      R0,#+20480
   \      0x7E0   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_192
   \      0x7E2   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_193
   1255              {
   1256                case RCC_LPTIM2CLKSOURCE_PCLK1:      /* PCLK1 is used as clock source for LPTIM2*/
   1257          
   1258                  /* LPTIM2 clock source config set later after clock selection check */
   1259                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_187: (+1)
   \      0x7E4   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_194
   1260          
   1261                case RCC_LPTIM2CLKSOURCE_PLL2P:  /* PLL2 is used as clock source for LPTIM2*/
   1262                  /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
   1263                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_188: (+1)
   \      0x7E6   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x7EA   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x7EE   0x0005             MOVS     R5,R0
   1264                  /* LPTIM2 clock source config set later after clock selection check */
   1265                  break;
   \      0x7F0   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_194
   1266          
   1267          #if defined(RCC_LPTIM2CLKSOURCE_PLL3R)
   1268                case RCC_LPTIM2CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for LPTIM2*/
   1269                  /* PLL3 R input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
   1270                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_189: (+1)
   \      0x7F2   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x7F6   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x7FA   0x0005             MOVS     R5,R0
   1271                  /* LPTIM2 clock source config set later after clock selection check */
   1272                  break;
   \      0x7FC   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_194
   1273          #endif /* RCC_LPTIM2CLKSOURCE_PLL3R */
   1274          
   1275                case RCC_LPTIM2CLKSOURCE_LSE:      /* LSE clock is used as source of LPTIM2 clock*/
   1276                  /* LPTIM2 clock source config set later after clock selection check */
   1277                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_190: (+1)
   \      0x7FE   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_194
   1278          
   1279                case RCC_LPTIM2CLKSOURCE_LSI:      /* LSI clock is used as source of LPTIM2 clock*/
   1280                  /* LPTIM2 clock source config set later after clock selection check */
   1281                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_191: (+1)
   \      0x800   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_194
   1282          
   1283                case RCC_LPTIM2CLKSOURCE_CLKP:      /* CLKP is used as source of LPTIM2 clock*/
   1284                  /* LPTIM2 clock source config set later after clock selection check */
   1285                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_192: (+1)
   \      0x802   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_194
   1286          
   1287                default:
   1288                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_193: (+1)
   \      0x804   0x2501             MOVS     R5,#+1
   1289                  break;
   1290              }
   1291          
   1292              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_194: (+1)
   \      0x806   0x0028             MOVS     R0,R5
   \      0x808   0xB2C0             UXTB     R0,R0
   \      0x80A   0x2800             CMP      R0,#+0
   \      0x80C   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_195
   1293              {
   1294                /* Set the source of LPTIM2 clock*/
   1295                __HAL_RCC_LPTIM2_CONFIG(pPeriphClkInit->Lptim2ClockSelection);
   \      0x80E   0xF8DF 0x1464      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_1
   \      0x812   0x680A             LDR      R2,[R1, #+0]
   \      0x814   0xF432 0x42E0      BICS     R2,R2,#0x7000
   \      0x818   0xF8D4 0x00A8      LDR      R0,[R4, #+168]
   \      0x81C   0x4302             ORRS     R2,R0,R2
   \      0x81E   0x600A             STR      R2,[R1, #+0]
   \      0x820   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_186
   1296              }
   1297              else
   1298              {
   1299                /* set overall return value */
   1300                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_195: (+1)
   \      0x822   0x002E             MOVS     R6,R5
   1301              }
   1302            }
   1303          
   1304          #if defined(LPTIM3)
   1305            /*-------------------------- LPTIM3 clock source configuration ---------------------*/
   1306            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
   \                     ??HAL_RCCEx_PeriphCLKConfig_186: (+1)
   \      0x824   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x828   0xF010 0x0000      ANDS     R0,R0,#0x0
   \      0x82C   0xF011 0x0120      ANDS     R1,R1,#0x20
   \      0x830   0x2900             CMP      R1,#+0
   \      0x832   0xD101             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_196
   \      0x834   0x2800             CMP      R0,#+0
   \      0x836   0xD033             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_197
   1307            {
   1308              /* Check the parameters */
   1309              assert_param(IS_RCC_LPTIM3CLK(pPeriphClkInit->Lptim3ClockSelection));
   1310          
   1311              switch (pPeriphClkInit->Lptim3ClockSelection)
   \                     ??HAL_RCCEx_PeriphCLKConfig_196: (+1)
   \      0x838   0xF8D4 0x00AC      LDR      R0,[R4, #+172]
   \      0x83C   0x2800             CMP      R0,#+0
   \      0x83E   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_198
   \      0x840   0xF5B0 0x3F80      CMP      R0,#+65536
   \      0x844   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_199
   \      0x846   0xF5B0 0x3F00      CMP      R0,#+131072
   \      0x84A   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_200
   \      0x84C   0xF5B0 0x3F40      CMP      R0,#+196608
   \      0x850   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_201
   \      0x852   0xF5B0 0x2F80      CMP      R0,#+262144
   \      0x856   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_202
   \      0x858   0xF5B0 0x2FA0      CMP      R0,#+327680
   \      0x85C   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_203
   \      0x85E   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_204
   1312              {
   1313                case RCC_LPTIM3CLKSOURCE_PCLK3:  /* PCLK3 is used as clock source for LPTIM3*/
   1314          
   1315                  /* LPTIM3 clock source config set later after clock selection check */
   1316                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_198: (+1)
   \      0x860   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_205
   1317          
   1318                case RCC_LPTIM3CLKSOURCE_PLL2P:  /* PLL2 is used as clock source for LPTIM3*/
   1319                  /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
   1320                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_199: (+1)
   \      0x862   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x866   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x86A   0x0005             MOVS     R5,R0
   1321                  /* LPTIM3 clock source config set later after clock selection check */
   1322                  break;
   \      0x86C   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_205
   1323          
   1324                case RCC_LPTIM3CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for LPTIM3*/
   1325                  /* PLL3 R input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
   1326                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_200: (+1)
   \      0x86E   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x872   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x876   0x0005             MOVS     R5,R0
   1327                  /* LPTIM3 clock source config set later after clock selection check */
   1328                  break;
   \      0x878   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_205
   1329          
   1330                case RCC_LPTIM3CLKSOURCE_LSE:      /* LSE clock is used as source of LPTIM3 clock*/
   1331                  /* LPTIM3 clock source config set later after clock selection check */
   1332                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_201: (+1)
   \      0x87A   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_205
   1333          
   1334                case RCC_LPTIM3CLKSOURCE_LSI:      /* LSI clock is used as source of LPTIM3 clock*/
   1335                  /* LPTIM3 clock source config set later after clock selection check */
   1336                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_202: (+1)
   \      0x87C   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_205
   1337          
   1338                case RCC_LPTIM3CLKSOURCE_CLKP:      /* CLKP is used as source of LPTIM3 clock*/
   1339                  /* LPTIM3 clock source config set later after clock selection check */
   1340                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_203: (+1)
   \      0x87E   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_205
   1341          
   1342                default:
   1343                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_204: (+1)
   \      0x880   0x2501             MOVS     R5,#+1
   1344                  break;
   1345              }
   1346          
   1347              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_205: (+1)
   \      0x882   0x0028             MOVS     R0,R5
   \      0x884   0xB2C0             UXTB     R0,R0
   \      0x886   0x2800             CMP      R0,#+0
   \      0x888   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_206
   1348              {
   1349                /* Set the source of LPTIM3 clock*/
   1350                __HAL_RCC_LPTIM3_CONFIG(pPeriphClkInit->Lptim3ClockSelection);
   \      0x88A   0xF8DF 0x13E8      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_1
   \      0x88E   0x680A             LDR      R2,[R1, #+0]
   \      0x890   0xF432 0x22E0      BICS     R2,R2,#0x70000
   \      0x894   0xF8D4 0x00AC      LDR      R0,[R4, #+172]
   \      0x898   0x4302             ORRS     R2,R0,R2
   \      0x89A   0x600A             STR      R2,[R1, #+0]
   \      0x89C   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_197
   1351              }
   1352              else
   1353              {
   1354                /* set overall return value */
   1355                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_206: (+1)
   \      0x89E   0x002E             MOVS     R6,R5
   1356              }
   1357            }
   1358          #endif /* LPTIM3 */
   1359          
   1360          #if defined(LPTIM4)
   1361            /*-------------------------- LPTIM4 clock source configuration ---------------------*/
   1362            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
   \                     ??HAL_RCCEx_PeriphCLKConfig_197: (+1)
   \      0x8A0   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x8A4   0xF010 0x0000      ANDS     R0,R0,#0x0
   \      0x8A8   0xF011 0x0140      ANDS     R1,R1,#0x40
   \      0x8AC   0x2900             CMP      R1,#+0
   \      0x8AE   0xD101             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_207
   \      0x8B0   0x2800             CMP      R0,#+0
   \      0x8B2   0xD033             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_208
   1363            {
   1364              /* Check the parameters */
   1365              assert_param(IS_RCC_LPTIM4CLK(pPeriphClkInit->Lptim4ClockSelection));
   1366          
   1367              switch (pPeriphClkInit->Lptim4ClockSelection)
   \                     ??HAL_RCCEx_PeriphCLKConfig_207: (+1)
   \      0x8B4   0xF8D4 0x00B0      LDR      R0,[R4, #+176]
   \      0x8B8   0x2800             CMP      R0,#+0
   \      0x8BA   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_209
   \      0x8BC   0xF5B0 0x1F80      CMP      R0,#+1048576
   \      0x8C0   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_210
   \      0x8C2   0xF5B0 0x1F00      CMP      R0,#+2097152
   \      0x8C6   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_211
   \      0x8C8   0xF5B0 0x1F40      CMP      R0,#+3145728
   \      0x8CC   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_212
   \      0x8CE   0xF5B0 0x0F80      CMP      R0,#+4194304
   \      0x8D2   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_213
   \      0x8D4   0xF5B0 0x0FA0      CMP      R0,#+5242880
   \      0x8D8   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_214
   \      0x8DA   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_215
   1368              {
   1369                case RCC_LPTIM4CLKSOURCE_PCLK3:      /* PCLK3 is used as clock source for LPTIM4*/
   1370          
   1371                  /* LPTIM4 clock source config set later after clock selection check */
   1372                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_209: (+1)
   \      0x8DC   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_216
   1373          
   1374                case RCC_LPTIM4CLKSOURCE_PLL2P:  /* PLL2 is used as clock source for LPTIM4*/
   1375                  /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
   1376                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_210: (+1)
   \      0x8DE   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x8E2   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x8E6   0x0005             MOVS     R5,R0
   1377                  /* LPTIM4 clock source config set later after clock selection check */
   1378                  break;
   \      0x8E8   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_216
   1379          
   1380                case RCC_LPTIM4CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for LPTIM4*/
   1381                  /* PLL3 R input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
   1382                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_211: (+1)
   \      0x8EA   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x8EE   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x8F2   0x0005             MOVS     R5,R0
   1383                  /* LPTIM4 clock source config set later after clock selection check */
   1384                  break;
   \      0x8F4   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_216
   1385          
   1386                case RCC_LPTIM4CLKSOURCE_LSE:      /* LSE clock is used as source of LPTIM4 clock*/
   1387                  /* LPTIM4 clock source config set later after clock selection check */
   1388                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_212: (+1)
   \      0x8F6   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_216
   1389          
   1390                case RCC_LPTIM4CLKSOURCE_LSI:      /* LSI clock is used as source of LPTIM4 clock*/
   1391                  /* LPTIM4 clock source config set later after clock selection check */
   1392                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_213: (+1)
   \      0x8F8   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_216
   1393          
   1394                case RCC_LPTIM4CLKSOURCE_CLKP:      /* CLKP is used as source of LPTIM4 clock*/
   1395                  /* LPTIM4 clock source config set later after clock selection check */
   1396                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_214: (+1)
   \      0x8FA   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_216
   1397          
   1398                default:
   1399                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_215: (+1)
   \      0x8FC   0x2501             MOVS     R5,#+1
   1400                  break;
   1401              }
   1402          
   1403              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_216: (+1)
   \      0x8FE   0x0028             MOVS     R0,R5
   \      0x900   0xB2C0             UXTB     R0,R0
   \      0x902   0x2800             CMP      R0,#+0
   \      0x904   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_217
   1404              {
   1405                /* Set the source of LPTIM4 clock*/
   1406                __HAL_RCC_LPTIM4_CONFIG(pPeriphClkInit->Lptim4ClockSelection);
   \      0x906   0xF8DF 0x136C      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_1
   \      0x90A   0x680A             LDR      R2,[R1, #+0]
   \      0x90C   0xF432 0x02E0      BICS     R2,R2,#0x700000
   \      0x910   0xF8D4 0x00B0      LDR      R0,[R4, #+176]
   \      0x914   0x4302             ORRS     R2,R0,R2
   \      0x916   0x600A             STR      R2,[R1, #+0]
   \      0x918   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_208
   1407              }
   1408              else
   1409              {
   1410                /* set overall return value */
   1411                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_217: (+1)
   \      0x91A   0x002E             MOVS     R6,R5
   1412              }
   1413            }
   1414          #endif /* LPTIM4 */
   1415          
   1416          #if defined(LPTIM5)
   1417            /*-------------------------- LPTIM5 clock source configuration ---------------------*/
   1418            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
   \                     ??HAL_RCCEx_PeriphCLKConfig_208: (+1)
   \      0x91C   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x920   0xF010 0x0000      ANDS     R0,R0,#0x0
   \      0x924   0xF011 0x0180      ANDS     R1,R1,#0x80
   \      0x928   0x2900             CMP      R1,#+0
   \      0x92A   0xD101             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_218
   \      0x92C   0x2800             CMP      R0,#+0
   \      0x92E   0xD033             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_219
   1419            {
   1420              /* Check the parameters */
   1421              assert_param(IS_RCC_LPTIM5CLK(pPeriphClkInit->Lptim5ClockSelection));
   1422          
   1423              switch (pPeriphClkInit->Lptim5ClockSelection)
   \                     ??HAL_RCCEx_PeriphCLKConfig_218: (+1)
   \      0x930   0xF8D4 0x00B4      LDR      R0,[R4, #+180]
   \      0x934   0x2800             CMP      R0,#+0
   \      0x936   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_220
   \      0x938   0xF1B0 0x7F80      CMP      R0,#+16777216
   \      0x93C   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_221
   \      0x93E   0xF1B0 0x7F00      CMP      R0,#+33554432
   \      0x942   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_222
   \      0x944   0xF1B0 0x7F40      CMP      R0,#+50331648
   \      0x948   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_223
   \      0x94A   0xF1B0 0x6F80      CMP      R0,#+67108864
   \      0x94E   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_224
   \      0x950   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \      0x954   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_225
   \      0x956   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_226
   1424              {
   1425                case RCC_LPTIM5CLKSOURCE_PCLK3:      /* PCLK3 is used as clock source for LPTIM5*/
   1426          
   1427                  /* LPTIM5 clock source config set later after clock selection check */
   1428                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_220: (+1)
   \      0x958   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_227
   1429          
   1430                case RCC_LPTIM5CLKSOURCE_PLL2P:  /* PLL2 is used as clock source for LPTIM5*/
   1431                  /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
   1432                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_221: (+1)
   \      0x95A   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x95E   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x962   0x0005             MOVS     R5,R0
   1433                  /* LPTIM5 clock source config set later after clock selection check */
   1434                  break;
   \      0x964   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_227
   1435          
   1436                case RCC_LPTIM5CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for LPTIM5*/
   1437                  /* PLL3 R input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
   1438                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_222: (+1)
   \      0x966   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x96A   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x96E   0x0005             MOVS     R5,R0
   1439                  /* LPTIM5 clock source config set later after clock selection check */
   1440                  break;
   \      0x970   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_227
   1441          
   1442                case RCC_LPTIM5CLKSOURCE_LSE:      /* LSE clock is used as source of LPTIM5 clock*/
   1443                  /* LPTIM5 clock source config set later after clock selection check */
   1444                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_223: (+1)
   \      0x972   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_227
   1445          
   1446                case RCC_LPTIM5CLKSOURCE_LSI:      /* LSI clock is used as source of LPTIM5 clock*/
   1447                  /* LPTIM5 clock source config set later after clock selection check */
   1448                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_224: (+1)
   \      0x974   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_227
   1449          
   1450                case RCC_LPTIM5CLKSOURCE_CLKP:      /* CLKP is used as source of LPTIM5 clock*/
   1451                  /* LPTIM5 clock source config set later after clock selection check */
   1452                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_225: (+1)
   \      0x976   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_227
   1453          
   1454                default:
   1455                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_226: (+1)
   \      0x978   0x2501             MOVS     R5,#+1
   1456                  break;
   1457              }
   1458          
   1459              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_227: (+1)
   \      0x97A   0x0028             MOVS     R0,R5
   \      0x97C   0xB2C0             UXTB     R0,R0
   \      0x97E   0x2800             CMP      R0,#+0
   \      0x980   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_228
   1460              {
   1461                /* Set the source of LPTIM5 clock*/
   1462                __HAL_RCC_LPTIM5_CONFIG(pPeriphClkInit->Lptim5ClockSelection);
   \      0x982   0xF8DF 0x12F0      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_1
   \      0x986   0x680A             LDR      R2,[R1, #+0]
   \      0x988   0xF032 0x62E0      BICS     R2,R2,#0x7000000
   \      0x98C   0xF8D4 0x00B4      LDR      R0,[R4, #+180]
   \      0x990   0x4302             ORRS     R2,R0,R2
   \      0x992   0x600A             STR      R2,[R1, #+0]
   \      0x994   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_219
   1463              }
   1464              else
   1465              {
   1466                /* set overall return value */
   1467                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_228: (+1)
   \      0x996   0x002E             MOVS     R6,R5
   1468              }
   1469            }
   1470          #endif /* LPTIM5 */
   1471          
   1472          #if defined(LPTIM6)
   1473            /*-------------------------- LPTIM6 clock source configuration ---------------------*/
   1474            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM6) == RCC_PERIPHCLK_LPTIM6)
   \                     ??HAL_RCCEx_PeriphCLKConfig_219: (+1)
   \      0x998   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x99C   0xF010 0x0000      ANDS     R0,R0,#0x0
   \      0x9A0   0xF411 0x7180      ANDS     R1,R1,#0x100
   \      0x9A4   0x2900             CMP      R1,#+0
   \      0x9A6   0xD101             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_229
   \      0x9A8   0x2800             CMP      R0,#+0
   \      0x9AA   0xD032             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_230
   1475            {
   1476              /* Check the parameters */
   1477              assert_param(IS_RCC_LPTIM6CLK(pPeriphClkInit->Lptim6ClockSelection));
   1478          
   1479              switch (pPeriphClkInit->Lptim6ClockSelection)
   \                     ??HAL_RCCEx_PeriphCLKConfig_229: (+1)
   \      0x9AC   0xF8D4 0x00B8      LDR      R0,[R4, #+184]
   \      0x9B0   0x2800             CMP      R0,#+0
   \      0x9B2   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_231
   \      0x9B4   0xF1B0 0x5F80      CMP      R0,#+268435456
   \      0x9B8   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_232
   \      0x9BA   0xF1B0 0x5F00      CMP      R0,#+536870912
   \      0x9BE   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_233
   \      0x9C0   0xF1B0 0x5F40      CMP      R0,#+805306368
   \      0x9C4   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_234
   \      0x9C6   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \      0x9CA   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_235
   \      0x9CC   0xF1B0 0x4FA0      CMP      R0,#+1342177280
   \      0x9D0   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_236
   \      0x9D2   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_237
   1480              {
   1481                case RCC_LPTIM6CLKSOURCE_PCLK3:      /* PCLK3 is used as clock source for LPTIM6*/
   1482          
   1483                  /* LPTIM6 clock source config set later after clock selection check */
   1484                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_231: (+1)
   \      0x9D4   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_238
   1485          
   1486                case RCC_LPTIM6CLKSOURCE_PLL2P:  /* PLL2 is used as clock source for LPTIM6*/
   1487                  /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
   1488                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_232: (+1)
   \      0x9D6   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x9DA   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0x9DE   0x0005             MOVS     R5,R0
   1489                  /* LPTIM6 clock source config set later after clock selection check */
   1490                  break;
   \      0x9E0   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_238
   1491          
   1492                case RCC_LPTIM6CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for LPTIM6*/
   1493                  /* PLL3 R input clock, parameters M, N & R configuration clock output (PLL3ClockOut) */
   1494                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_233: (+1)
   \      0x9E2   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x9E6   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0x9EA   0x0005             MOVS     R5,R0
   1495                  /* LPTIM6 clock source config set later after clock selection check */
   1496                  break;
   \      0x9EC   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_238
   1497          
   1498                case RCC_LPTIM6CLKSOURCE_LSE:      /* LSE clock is used as source of LPTIM6 clock*/
   1499                  /* LPTIM6 clock source config set later after clock selection check */
   1500                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_234: (+1)
   \      0x9EE   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_238
   1501          
   1502                case RCC_LPTIM6CLKSOURCE_LSI:      /* LSI clock is used as source of LPTIM6 clock*/
   1503                  /* LPTIM6 clock source config set later after clock selection check */
   1504                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_235: (+1)
   \      0x9F0   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_238
   1505          
   1506                case RCC_LPTIM6CLKSOURCE_CLKP:      /* CLKP is used as source of LPTIM6 clock*/
   1507                  /* LPTIM6 clock source config set later after clock selection check */
   1508                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_236: (+1)
   \      0x9F2   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_238
   1509          
   1510                default:
   1511                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_237: (+1)
   \      0x9F4   0x2501             MOVS     R5,#+1
   1512                  break;
   1513              }
   1514          
   1515              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_238: (+1)
   \      0x9F6   0x0028             MOVS     R0,R5
   \      0x9F8   0xB2C0             UXTB     R0,R0
   \      0x9FA   0x2800             CMP      R0,#+0
   \      0x9FC   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_239
   1516              {
   1517                /* Set the source of LPTIM6 clock*/
   1518                __HAL_RCC_LPTIM6_CONFIG(pPeriphClkInit->Lptim6ClockSelection);
   \      0x9FE   0x499D             LDR.N    R1,??HAL_RCCEx_PeriphCLKConfig_1
   \      0xA00   0x680A             LDR      R2,[R1, #+0]
   \      0xA02   0xF032 0x42E0      BICS     R2,R2,#0x70000000
   \      0xA06   0xF8D4 0x00B8      LDR      R0,[R4, #+184]
   \      0xA0A   0x4302             ORRS     R2,R0,R2
   \      0xA0C   0x600A             STR      R2,[R1, #+0]
   \      0xA0E   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_230
   1519              }
   1520              else
   1521              {
   1522                /* set overall return value */
   1523                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_239: (+1)
   \      0xA10   0x002E             MOVS     R6,R5
   1524              }
   1525            }
   1526          #endif /* LPTIM6 */
   1527          
   1528          #if defined(SAI1)
   1529            /*-------------------------- SAI1 clock source configuration ---------------------*/
   1530            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
   \                     ??HAL_RCCEx_PeriphCLKConfig_230: (+1)
   \      0xA12   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0xA16   0x0300             LSLS     R0,R0,#+12
   \      0xA18   0xD539             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_240
   1531            {
   1532              /* Check the parameters */
   1533              assert_param(IS_RCC_SAI1CLK(pPeriphClkInit->Sai1ClockSelection));
   1534          
   1535              switch (pPeriphClkInit->Sai1ClockSelection)
   \      0xA1A   0xF8D4 0x00C0      LDR      R0,[R4, #+192]
   \      0xA1E   0x2800             CMP      R0,#+0
   \      0xA20   0xD00C             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_241
   \      0xA22   0xF5B0 0x3F80      CMP      R0,#+65536
   \      0xA26   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_242
   \      0xA28   0xF5B0 0x3F00      CMP      R0,#+131072
   \      0xA2C   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_243
   \      0xA2E   0xF5B0 0x3F40      CMP      R0,#+196608
   \      0xA32   0xD016             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_244
   \      0xA34   0xF5B0 0x2F80      CMP      R0,#+262144
   \      0xA38   0xD014             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_245
   \      0xA3A   0xE014             B.N      ??HAL_RCCEx_PeriphCLKConfig_246
   1536              {
   1537                case RCC_SAI1CLKSOURCE_PLL1Q:      /* PLL is used as clock source for SAI1*/
   1538                  /* Enable SAI Clock output generated from System PLL . */
   1539                  __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
   \                     ??HAL_RCCEx_PeriphCLKConfig_241: (+1)
   \      0xA3C   0x.... 0x....      LDR.W    R0,??DataTable1
   \      0xA40   0x6801             LDR      R1,[R0, #+0]
   \      0xA42   0xF451 0x3100      ORRS     R1,R1,#0x20000
   \      0xA46   0x6001             STR      R1,[R0, #+0]
   1540                  /* SAI1 clock source config set later after clock selection check */
   1541                  break;
   \      0xA48   0xE00E             B.N      ??HAL_RCCEx_PeriphCLKConfig_247
   1542          
   1543                case RCC_SAI1CLKSOURCE_PLL2P:  /* PLL2 is used as clock source for SAI1*/
   1544                  /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
   1545                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_242: (+1)
   \      0xA4A   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0xA4E   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0xA52   0x0005             MOVS     R5,R0
   1546                  /* SAI1 clock source config set later after clock selection check */
   1547                  break;
   \      0xA54   0xE008             B.N      ??HAL_RCCEx_PeriphCLKConfig_247
   1548          
   1549                case RCC_SAI1CLKSOURCE_PLL3P:  /* PLL3 is used as clock source for SAI1*/
   1550                  /* PLL3 P input clock, parameters M, N & P configuration clock output (PLL3ClockOut) */
   1551                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_243: (+1)
   \      0xA56   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0xA5A   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0xA5E   0x0005             MOVS     R5,R0
   1552                  /* SAI1 clock source config set later after clock selection check */
   1553                  break;
   \      0xA60   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_247
   1554          
   1555                case RCC_SAI1CLKSOURCE_PIN:      /* External clock is used as source of SAI1 clock*/
   1556                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_244: (+1)
   \      0xA62   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_247
   1557          
   1558                case RCC_SAI1CLKSOURCE_CLKP:      /* CLKP is used as source of SAI1 clock*/
   1559                  /* SAI1 clock source config set later after clock selection check */
   1560                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_245: (+1)
   \      0xA64   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_247
   1561          
   1562                default:
   1563                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_246: (+1)
   \      0xA66   0x2501             MOVS     R5,#+1
   1564                  break;
   1565              }
   1566          
   1567              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_247: (+1)
   \      0xA68   0x0028             MOVS     R0,R5
   \      0xA6A   0xB2C0             UXTB     R0,R0
   \      0xA6C   0x2800             CMP      R0,#+0
   \      0xA6E   0xD10D             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_248
   1568              {
   1569                /* Set the source of SAI1 clock*/
   1570                __HAL_RCC_SAI1_CONFIG(pPeriphClkInit->Sai1ClockSelection);
   \      0xA70   0x4904             LDR.N    R1,??HAL_RCCEx_PeriphCLKConfig_0
   \      0xA72   0x680A             LDR      R2,[R1, #+0]
   \      0xA74   0xF432 0x22E0      BICS     R2,R2,#0x70000
   \      0xA78   0xF8D4 0x00C0      LDR      R0,[R4, #+192]
   \      0xA7C   0x4302             ORRS     R2,R0,R2
   \      0xA7E   0x600A             STR      R2,[R1, #+0]
   \      0xA80   0xE005             B.N      ??HAL_RCCEx_PeriphCLKConfig_240
   \      0xA82   0xBF00             Nop
   \                     ??HAL_RCCEx_PeriphCLKConfig_0:
   \      0xA84   0x4402'0CE8        DC32     0x44020ce8
   \      0xA88   0x4402'0CD8        DC32     0x44020cd8
   1571              }
   1572              else
   1573              {
   1574                /* set overall return value */
   1575                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_248: (+1)
   \      0xA8C   0x002E             MOVS     R6,R5
   1576              }
   1577            }
   1578          #endif /* SAI1*/
   1579          
   1580          #if defined(SAI2)
   1581            /*-------------------------- SAI2 clock source configuration ---------------------*/
   1582            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
   \                     ??HAL_RCCEx_PeriphCLKConfig_240: (+1)
   \      0xA8E   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0xA92   0x02C0             LSLS     R0,R0,#+11
   \      0xA94   0xD534             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_249
   1583            {
   1584              /* Check the parameters */
   1585              assert_param(IS_RCC_SAI2CLK(pPeriphClkInit->Sai2ClockSelection));
   1586          
   1587              switch (pPeriphClkInit->Sai2ClockSelection)
   \      0xA96   0xF8D4 0x00C4      LDR      R0,[R4, #+196]
   \      0xA9A   0x2800             CMP      R0,#+0
   \      0xA9C   0xD00C             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_250
   \      0xA9E   0xF5B0 0x2F00      CMP      R0,#+524288
   \      0xAA2   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_251
   \      0xAA4   0xF5B0 0x1F80      CMP      R0,#+1048576
   \      0xAA8   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_252
   \      0xAAA   0xF5B0 0x1FC0      CMP      R0,#+1572864
   \      0xAAE   0xD016             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_253
   \      0xAB0   0xF5B0 0x1F00      CMP      R0,#+2097152
   \      0xAB4   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_253
   \      0xAB6   0xE013             B.N      ??HAL_RCCEx_PeriphCLKConfig_254
   1588              {
   1589                case RCC_SAI2CLKSOURCE_PLL1Q:      /* PLL is used as clock source for SAI2*/
   1590                  /* Enable SAI Clock output generated from System PLL . */
   1591                  __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
   \                     ??HAL_RCCEx_PeriphCLKConfig_250: (+1)
   \      0xAB8   0x.... 0x....      LDR.W    R0,??DataTable1
   \      0xABC   0x6801             LDR      R1,[R0, #+0]
   \      0xABE   0xF451 0x3100      ORRS     R1,R1,#0x20000
   \      0xAC2   0x6001             STR      R1,[R0, #+0]
   1592                  /* SAI2 clock source config set later after clock selection check */
   1593                  break;
   \      0xAC4   0xE00D             B.N      ??HAL_RCCEx_PeriphCLKConfig_255
   1594          
   1595                case RCC_SAI2CLKSOURCE_PLL2P: /* PLL2 is used as clock source for SAI2*/
   1596                  /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
   1597                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_251: (+1)
   \      0xAC6   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0xACA   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0xACE   0x0005             MOVS     R5,R0
   1598                  /* SAI2 clock source config set later after clock selection check */
   1599                  break;
   \      0xAD0   0xE007             B.N      ??HAL_RCCEx_PeriphCLKConfig_255
   1600          
   1601                case RCC_SAI2CLKSOURCE_PLL3P:  /* PLL3 is used as clock source for SAI2*/
   1602                  /* PLL3 P input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
   1603                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_252: (+1)
   \      0xAD2   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0xAD6   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0xADA   0x0005             MOVS     R5,R0
   1604                  /* SAI2 clock source config set later after clock selection check */
   1605                  break;
   \      0xADC   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_255
   1606          
   1607                case RCC_SAI2CLKSOURCE_PIN:      /* External clock is used as source of SAI2 clock*/
   1608                case RCC_SAI2CLKSOURCE_CLKP:      /* CLKP is used as source of SAI2 clock*/
   1609                  /* SAI2 clock source config set later after clock selection check */
   1610                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_253: (+1)
   \      0xADE   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_255
   1611          
   1612                default:
   1613                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_254: (+1)
   \      0xAE0   0x2501             MOVS     R5,#+1
   1614                  break;
   1615              }
   1616          
   1617              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_255: (+1)
   \      0xAE2   0x0028             MOVS     R0,R5
   \      0xAE4   0xB2C0             UXTB     R0,R0
   \      0xAE6   0x2800             CMP      R0,#+0
   \      0xAE8   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_256
   1618              {
   1619                /* Set the source of SAI2 clock*/
   1620                __HAL_RCC_SAI2_CONFIG(pPeriphClkInit->Sai2ClockSelection);
   \      0xAEA   0x.... 0x....      LDR.W    R1,??DataTable2
   \      0xAEE   0x680A             LDR      R2,[R1, #+0]
   \      0xAF0   0xF432 0x1260      BICS     R2,R2,#0x380000
   \      0xAF4   0xF8D4 0x00C4      LDR      R0,[R4, #+196]
   \      0xAF8   0x4302             ORRS     R2,R0,R2
   \      0xAFA   0x600A             STR      R2,[R1, #+0]
   \      0xAFC   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_249
   1621              }
   1622              else
   1623              {
   1624                /* set overall return value */
   1625                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_256: (+1)
   \      0xAFE   0x002E             MOVS     R6,R5
   1626              }
   1627            }
   1628          #endif /* SAI2*/
   1629          
   1630            /*-------------------------- ADCDAC clock source configuration ----------------------*/
   1631            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADCDAC) == RCC_PERIPHCLK_ADCDAC)
   \                     ??HAL_RCCEx_PeriphCLKConfig_249: (+1)
   \      0xB00   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0xB04   0x0280             LSLS     R0,R0,#+10
   \      0xB06   0xD522             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_257
   1632            {
   1633              /* Check the parameters */
   1634              assert_param(IS_RCC_ADCDACCLKSOURCE(pPeriphClkInit->AdcDacClockSelection));
   1635          
   1636              switch (pPeriphClkInit->AdcDacClockSelection)
   \      0xB08   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \      0xB0C   0x2800             CMP      R0,#+0
   \      0xB0E   0x2801             CMP      R0,#+1
   \      0xB10   0xD905             BLS.N    ??HAL_RCCEx_PeriphCLKConfig_258
   \      0xB12   0x1E80             SUBS     R0,R0,#+2
   \      0xB14   0xD004             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_259
   \      0xB16   0x1E40             SUBS     R0,R0,#+1
   \      0xB18   0x2802             CMP      R0,#+2
   \      0xB1A   0xD907             BLS.N    ??HAL_RCCEx_PeriphCLKConfig_260
   \      0xB1C   0xE007             B.N      ??HAL_RCCEx_PeriphCLKConfig_261
   1637              {
   1638          
   1639                case RCC_ADCDACCLKSOURCE_HCLK:   /* Bus clock is used as source of ADCDAC clock*/
   1640                case RCC_ADCDACCLKSOURCE_SYSCLK: /* System clock is used as source of ADCDAC clock*/
   1641                  /* ADCDAC clock source config set later after clock selection check */
   1642                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_258: (+1)
   \      0xB1E   0xE007             B.N      ??HAL_RCCEx_PeriphCLKConfig_262
   1643          
   1644                case RCC_ADCDACCLKSOURCE_PLL2R:
   1645                  /* PLL2 input clock, parameters M, N & R configuration and clock output (PLL2ClockOut) */
   1646                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_259: (+1)
   \      0xB20   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0xB24   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0xB28   0x0005             MOVS     R5,R0
   1647                  break;
   \      0xB2A   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_262
   1648          
   1649                case RCC_ADCDACCLKSOURCE_HSE:/* HSE clock is used as source of ADCDAC clock*/
   1650                case RCC_ADCDACCLKSOURCE_HSI:/* HSI clock is used as source of ADCDAC clock*/
   1651                case RCC_ADCDACCLKSOURCE_CSI:/* CSI clock is used as source of ADCDAC clock*/
   1652                  /* ADCDAC clock source configuration done later after clock selection check */
   1653                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_260: (+1)
   \      0xB2C   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_262
   1654          
   1655          
   1656                default:
   1657                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_261: (+1)
   \      0xB2E   0x2501             MOVS     R5,#+1
   1658                  break;
   1659              }
   1660          
   1661              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_262: (+1)
   \      0xB30   0x0028             MOVS     R0,R5
   \      0xB32   0xB2C0             UXTB     R0,R0
   \      0xB34   0x2800             CMP      R0,#+0
   \      0xB36   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_263
   1662              {
   1663                /* Configure the ADCDAC interface clock source */
   1664                __HAL_RCC_ADCDAC_CONFIG(pPeriphClkInit->AdcDacClockSelection);
   \      0xB38   0x.... 0x....      LDR.W    R1,??DataTable2
   \      0xB3C   0x680A             LDR      R2,[R1, #+0]
   \      0xB3E   0x08D2             LSRS     R2,R2,#+3
   \      0xB40   0x00D2             LSLS     R2,R2,#+3
   \      0xB42   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \      0xB46   0x4302             ORRS     R2,R0,R2
   \      0xB48   0x600A             STR      R2,[R1, #+0]
   \      0xB4A   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_257
   1665              }
   1666              else
   1667              {
   1668                /* set overall return value */
   1669                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_263: (+1)
   \      0xB4C   0x002E             MOVS     R6,R5
   1670              }
   1671          
   1672            }
   1673          
   1674            /*-------------------------- DAC low-power clock source configuration ----------------------*/
   1675            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DAC_LP) == RCC_PERIPHCLK_DAC_LP)
   \                     ??HAL_RCCEx_PeriphCLKConfig_257: (+1)
   \      0xB4E   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0xB52   0xF010 0x0000      ANDS     R0,R0,#0x0
   \      0xB56   0xF411 0x7100      ANDS     R1,R1,#0x200
   \      0xB5A   0x2900             CMP      R1,#+0
   \      0xB5C   0xD101             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_264
   \      0xB5E   0x2800             CMP      R0,#+0
   \      0xB60   0xD018             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_265
   1676            {
   1677              /* Check the parameters */
   1678              assert_param(IS_RCC_DACLPCLKSOURCE(pPeriphClkInit->DacLowPowerClockSelection));
   1679          
   1680              switch (pPeriphClkInit->DacLowPowerClockSelection)
   \                     ??HAL_RCCEx_PeriphCLKConfig_264: (+1)
   \      0xB62   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0xB66   0x2800             CMP      R0,#+0
   \      0xB68   0xD002             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_266
   \      0xB6A   0x2808             CMP      R0,#+8
   \      0xB6C   0xD001             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_267
   \      0xB6E   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_268
   1681              {
   1682          
   1683                case RCC_DACLPCLKSOURCE_LSE:
   1684                  /* LSE oscillator is used as source of DAC low-power clock */
   1685                  /* DAC clock source configuration done later after clock selection check */
   1686                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_266: (+1)
   \      0xB70   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_269
   1687          
   1688                case RCC_DACLPCLKSOURCE_LSI:
   1689                  /* LSI is used as clock source for DAC low-power clock */
   1690                  /* DAC clock source configuration done later after clock selection check */
   1691                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_267: (+1)
   \      0xB72   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_269
   1692          
   1693                default:
   1694                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_268: (+1)
   \      0xB74   0x2501             MOVS     R5,#+1
   1695                  break;
   1696              }
   1697          
   1698              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_269: (+1)
   \      0xB76   0x0028             MOVS     R0,R5
   \      0xB78   0xB2C0             UXTB     R0,R0
   \      0xB7A   0x2800             CMP      R0,#+0
   \      0xB7C   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_270
   1699              {
   1700                /* Configure the DAC low-power interface clock source */
   1701                __HAL_RCC_DAC_LP_CONFIG(pPeriphClkInit->DacLowPowerClockSelection);
   \      0xB7E   0x.... 0x....      LDR.W    R1,??DataTable2
   \      0xB82   0x680A             LDR      R2,[R1, #+0]
   \      0xB84   0xF032 0x0208      BICS     R2,R2,#0x8
   \      0xB88   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0xB8C   0x4302             ORRS     R2,R0,R2
   \      0xB8E   0x600A             STR      R2,[R1, #+0]
   \      0xB90   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_265
   1702              }
   1703              else
   1704              {
   1705                /* set overall return value */
   1706                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_270: (+1)
   \      0xB92   0x002E             MOVS     R6,R5
   1707              }
   1708          
   1709            }
   1710          
   1711            /*-------------------------- RTC clock source configuration ----------------------*/
   1712            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
   \                     ??HAL_RCCEx_PeriphCLKConfig_265: (+1)
   \      0xB94   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0xB98   0x0180             LSLS     R0,R0,#+6
   \      0xB9A   0xD570             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_271
   1713            {
   1714          
   1715              /* Check for RTC Parameters used to output RTCCLK */
   1716              assert_param(IS_RCC_RTCCLKSOURCE(pPeriphClkInit->RTCClockSelection));
   1717          
   1718              /* Enable write access to Backup domain */
   1719              SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
   \      0xB9C   0x.... 0x....      LDR.W    R8,??DataTable2_1
   \      0xBA0   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0xBA4   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0xBA8   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1720          
   1721              /* Wait for Backup domain Write protection disable */
   1722              tickstart = HAL_GetTick();
   \      0xBAC   0x.... 0x....      BL       HAL_GetTick
   \      0xBB0   0x0007             MOVS     R7,R0
   1723          
   1724              while (HAL_IS_BIT_CLR(PWR->DBPCR, PWR_DBPCR_DBP))
   \                     ??HAL_RCCEx_PeriphCLKConfig_272: (+1)
   \      0xBB2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0xBB6   0x07C0             LSLS     R0,R0,#+31
   \      0xBB8   0xD405             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_273
   1725              {
   1726                if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
   \      0xBBA   0x.... 0x....      BL       HAL_GetTick
   \      0xBBE   0x1BC0             SUBS     R0,R0,R7
   \      0xBC0   0x2803             CMP      R0,#+3
   \      0xBC2   0xD3F6             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_272
   1727                {
   1728                  ret = HAL_TIMEOUT;
   \      0xBC4   0x2503             MOVS     R5,#+3
   1729                  break;
   1730                }
   1731              }
   1732          
   1733              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_273: (+1)
   \      0xBC6   0x0028             MOVS     R0,R5
   \      0xBC8   0xB2C0             UXTB     R0,R0
   \      0xBCA   0x2800             CMP      R0,#+0
   \      0xBCC   0xD156             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_274
   1734              {
   1735                /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
   1736                tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
   \      0xBCE   0x.... 0x....      LDR.W    R7,??DataTable2_2
   \      0xBD2   0x6838             LDR      R0,[R7, #+0]
   \      0xBD4   0xF410 0x7040      ANDS     R0,R0,#0x300
   1737          
   1738                if ((tmpregister != RCC_RTCCLKSOURCE_NO_CLK) && (tmpregister != pPeriphClkInit->RTCClockSelection))
   \      0xBD8   0x2800             CMP      R0,#+0
   \      0xBDA   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_275
   \      0xBDC   0xF8D4 0x10F4      LDR      R1,[R4, #+244]
   \      0xBE0   0x4288             CMP      R0,R1
   \      0xBE2   0xD00B             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_275
   1739                {
   1740                  /* Store the content of BDCR register before the reset of Backup Domain */
   1741                  tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
   \      0xBE4   0x6838             LDR      R0,[R7, #+0]
   \      0xBE6   0xF430 0x7040      BICS     R0,R0,#0x300
   1742                  /* RTC Clock selection can be changed only if the Backup Domain is reset */
   1743                  __HAL_RCC_BACKUPRESET_FORCE();
   \      0xBEA   0x6839             LDR      R1,[R7, #+0]
   \      0xBEC   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \      0xBF0   0x6039             STR      R1,[R7, #+0]
   1744                  __HAL_RCC_BACKUPRESET_RELEASE();
   \      0xBF2   0x6839             LDR      R1,[R7, #+0]
   \      0xBF4   0xF431 0x3180      BICS     R1,R1,#0x10000
   \      0xBF8   0x6039             STR      R1,[R7, #+0]
   1745                  /* Restore the Content of BDCR register */
   1746                  RCC->BDCR = tmpregister;
   \      0xBFA   0x6038             STR      R0,[R7, #+0]
   1747                }
   1748          
   1749                /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
   1750                if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
   \                     ??HAL_RCCEx_PeriphCLKConfig_275: (+1)
   \      0xBFC   0x07C0             LSLS     R0,R0,#+31
   \      0xBFE   0xD50E             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_276
   1751                {
   1752                  /* Get Start Tick*/
   1753                  tickstart = HAL_GetTick();
   \      0xC00   0x.... 0x....      BL       HAL_GetTick
   \      0xC04   0x4680             MOV      R8,R0
   1754          
   1755                  /* Wait till LSE is ready */
   1756                  while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
   \                     ??HAL_RCCEx_PeriphCLKConfig_277: (+1)
   \      0xC06   0x6838             LDR      R0,[R7, #+0]
   \      0xC08   0x0780             LSLS     R0,R0,#+30
   \      0xC0A   0xD408             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_276
   1757                  {
   1758                    if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
   \      0xC0C   0x.... 0x....      BL       HAL_GetTick
   \      0xC10   0xEBB0 0x0008      SUBS     R0,R0,R8
   \      0xC14   0xF241 0x3189      MOVW     R1,#+5001
   \      0xC18   0x4288             CMP      R0,R1
   \      0xC1A   0xD3F4             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_277
   1759                    {
   1760                      ret = HAL_TIMEOUT;
   \      0xC1C   0x2503             MOVS     R5,#+3
   1761                      break;
   1762                    }
   1763                  }
   1764                }
   1765          
   1766                if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_276: (+1)
   \      0xC1E   0x0028             MOVS     R0,R5
   \      0xC20   0xB2C0             UXTB     R0,R0
   \      0xC22   0x2800             CMP      R0,#+0
   \      0xC24   0xD128             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_278
   1767                {
   1768                  /* Apply new RTC clock source selection */
   1769                  __HAL_RCC_RTC_CONFIG(pPeriphClkInit->RTCClockSelection);
   \      0xC26   0xF8D4 0x00F4      LDR      R0,[R4, #+244]
   \      0xC2A   0xF410 0x7040      ANDS     R0,R0,#0x300
   \      0xC2E   0xF5B0 0x7F40      CMP      R0,#+768
   \      0xC32   0xD10D             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_279
   \      0xC34   0x.... 0x....      LDR.W    R0,??DataTable0
   \      0xC38   0x6802             LDR      R2,[R0, #+0]
   \      0xC3A   0xF432 0x527C      BICS     R2,R2,#0x3F00
   \      0xC3E   0xF8D4 0x30F4      LDR      R3,[R4, #+244]
   \      0xC42   0x.... 0x....      LDR.W    R1,??DataTable2_6
   \      0xC46   0xEA11 0x1113      ANDS     R1,R1,R3, LSR #+4
   \      0xC4A   0x4311             ORRS     R1,R1,R2
   \      0xC4C   0x6001             STR      R1,[R0, #+0]
   \      0xC4E   0xE005             B.N      ??HAL_RCCEx_PeriphCLKConfig_280
   \                     ??HAL_RCCEx_PeriphCLKConfig_279: (+1)
   \      0xC50   0x.... 0x....      LDR.W    R0,??DataTable0
   \      0xC54   0x6801             LDR      R1,[R0, #+0]
   \      0xC56   0xF431 0x517C      BICS     R1,R1,#0x3F00
   \      0xC5A   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_RCCEx_PeriphCLKConfig_280: (+1)
   \      0xC5C   0x6838             LDR      R0,[R7, #+0]
   \      0xC5E   0xF430 0x7040      BICS     R0,R0,#0x300
   \      0xC62   0x6038             STR      R0,[R7, #+0]
   \      0xC64   0x6838             LDR      R0,[R7, #+0]
   \      0xC66   0xF8D4 0x10F4      LDR      R1,[R4, #+244]
   \      0xC6A   0x0509             LSLS     R1,R1,#+20
   \      0xC6C   0x0D09             LSRS     R1,R1,#+20
   \      0xC6E   0x4308             ORRS     R0,R1,R0
   \      0xC70   0x6038             STR      R0,[R7, #+0]
   \      0xC72   0xE004             B.N      ??HAL_RCCEx_PeriphCLKConfig_271
   \                     ??HAL_RCCEx_PeriphCLKConfig_1:
   \      0xC74   0x4402'0CDC        DC32     0x44020cdc
   1770                }
   1771                else
   1772                {
   1773                  /* set overall return value */
   1774                  status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_278: (+1)
   \      0xC78   0x002E             MOVS     R6,R5
   \      0xC7A   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_271
   1775                }
   1776              }
   1777              else
   1778              {
   1779                /* set overall return value */
   1780                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_274: (+1)
   \      0xC7C   0x002E             MOVS     R6,R5
   1781              }
   1782          
   1783            }
   1784          
   1785            /*------------------------------ RNG Configuration -------------------------*/
   1786            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
   \                     ??HAL_RCCEx_PeriphCLKConfig_271: (+1)
   \      0xC7E   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0xC82   0x0140             LSLS     R0,R0,#+5
   \      0xC84   0xD524             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_281
   1787            {
   1788          
   1789              /* Check the parameters */
   1790              assert_param(IS_RCC_RNGCLKSOURCE(pPeriphClkInit->RngClockSelection));
   1791          
   1792              switch (pPeriphClkInit->RngClockSelection)
   \      0xC86   0xF8D4 0x00C8      LDR      R0,[R4, #+200]
   \      0xC8A   0x2800             CMP      R0,#+0
   \      0xC8C   0xD006             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_282
   \      0xC8E   0x2810             CMP      R0,#+16
   \      0xC90   0xD005             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_283
   \      0xC92   0x2820             CMP      R0,#+32
   \      0xC94   0xD00A             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_284
   \      0xC96   0x2830             CMP      R0,#+48
   \      0xC98   0xD009             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_285
   \      0xC9A   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_286
   1793              {
   1794          
   1795                case RCC_RNGCLKSOURCE_HSI48: /* HSI48 is used as clock source for RNG*/
   1796          
   1797                  /* RNG clock source configuration done later after clock selection check */
   1798                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_282: (+1)
   \      0xC9C   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_287
   1799          
   1800                case RCC_RNGCLKSOURCE_PLL1Q: /* PLL1 is used as clock source for RNG*/
   1801                  /* Enable PLL1Q Clock output generated from System PLL . */
   1802                  __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
   \                     ??HAL_RCCEx_PeriphCLKConfig_283: (+1)
   \      0xC9E   0x.... 0x....      LDR.W    R0,??DataTable1
   \      0xCA2   0x6801             LDR      R1,[R0, #+0]
   \      0xCA4   0xF451 0x3100      ORRS     R1,R1,#0x20000
   \      0xCA8   0x6001             STR      R1,[R0, #+0]
   1803                  /* RNG clock source configuration done later after clock selection check */
   1804                  break;
   \      0xCAA   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_287
   1805                case RCC_RNGCLKSOURCE_LSE:
   1806                  /* LSE oscillator is used as source of RNG clock */
   1807                  /* RNG clock source configuration done later after clock selection check */
   1808                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_284: (+1)
   \      0xCAC   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_287
   1809          
   1810                case RCC_RNGCLKSOURCE_LSI: /* HSI48 is used as clock source for RNG*/
   1811          
   1812                  /* RNG clock source configuration done later after clock selection check */
   1813                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_285: (+1)
   \      0xCAE   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_287
   1814          
   1815                default:
   1816                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_286: (+1)
   \      0xCB0   0x2501             MOVS     R5,#+1
   1817                  break;
   1818              }
   1819          
   1820              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_287: (+1)
   \      0xCB2   0x0028             MOVS     R0,R5
   \      0xCB4   0xB2C0             UXTB     R0,R0
   \      0xCB6   0x2800             CMP      R0,#+0
   \      0xCB8   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_288
   1821              {
   1822                /* Set the source of RNG clock*/
   1823                __HAL_RCC_RNG_CONFIG(pPeriphClkInit->RngClockSelection);
   \      0xCBA   0x.... 0x....      LDR.W    R1,??DataTable2
   \      0xCBE   0x680A             LDR      R2,[R1, #+0]
   \      0xCC0   0xF032 0x0230      BICS     R2,R2,#0x30
   \      0xCC4   0xF8D4 0x00C8      LDR      R0,[R4, #+200]
   \      0xCC8   0x4302             ORRS     R2,R0,R2
   \      0xCCA   0x600A             STR      R2,[R1, #+0]
   \      0xCCC   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_281
   1824              }
   1825              else
   1826              {
   1827                /* set overall return value */
   1828                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_288: (+1)
   \      0xCCE   0x002E             MOVS     R6,R5
   1829              }
   1830          
   1831            }
   1832          
   1833          #if defined(SDMMC1)
   1834            /*-------------------------- SDMMC1 clock source configuration -------------------*/
   1835            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
   \                     ??HAL_RCCEx_PeriphCLKConfig_281: (+1)
   \      0xCD0   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0xCD4   0x0240             LSLS     R0,R0,#+9
   \      0xCD6   0xD523             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_289
   1836            {
   1837          
   1838              /* Check the parameters */
   1839              assert_param(IS_RCC_SDMMC1CLKSOURCE(pPeriphClkInit->Sdmmc1ClockSelection));
   1840          
   1841              switch (pPeriphClkInit->Sdmmc1ClockSelection)
   \      0xCD8   0xF8D4 0x00CC      LDR      R0,[R4, #+204]
   \      0xCDC   0x2800             CMP      R0,#+0
   \      0xCDE   0xD002             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_290
   \      0xCE0   0x2840             CMP      R0,#+64
   \      0xCE2   0xD007             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_291
   \      0xCE4   0xE00C             B.N      ??HAL_RCCEx_PeriphCLKConfig_292
   1842              {
   1843                case RCC_SDMMC1CLKSOURCE_PLL1Q:      /* PLL1 is used as clock source for SDMMC1 kernel clock*/
   1844                  /* Enable PLL1Q Clock output generated from System PLL . */
   1845                  __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
   \                     ??HAL_RCCEx_PeriphCLKConfig_290: (+1)
   \      0xCE6   0x.... 0x....      LDR.W    R0,??DataTable1
   \      0xCEA   0x6801             LDR      R1,[R0, #+0]
   \      0xCEC   0xF451 0x3100      ORRS     R1,R1,#0x20000
   \      0xCF0   0x6001             STR      R1,[R0, #+0]
   1846                  /* SDMMC1 kernel clock source config set later after clock selection check */
   1847                  break;
   \      0xCF2   0xE006             B.N      ??HAL_RCCEx_PeriphCLKConfig_293
   1848          
   1849                case RCC_SDMMC1CLKSOURCE_PLL2R:  /* PLL2 is used as clock source for SDMMC1 kernel clock*/
   1850                  /* PLL2R input clock, parameters M, N & R configuration and clock output (PLL2ClockOut) */
   1851                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_291: (+1)
   \      0xCF4   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0xCF8   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0xCFC   0x0005             MOVS     R5,R0
   1852                  /* SDMMC1 kernel clock source config set later after clock selection check */
   1853                  break;
   \      0xCFE   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_293
   1854          
   1855                default:
   1856                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_292: (+1)
   \      0xD00   0x2501             MOVS     R5,#+1
   1857                  break;
   1858              }
   1859          
   1860              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_293: (+1)
   \      0xD02   0x0028             MOVS     R0,R5
   \      0xD04   0xB2C0             UXTB     R0,R0
   \      0xD06   0x2800             CMP      R0,#+0
   \      0xD08   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_294
   1861              {
   1862                /* Configure the SDMMC1 clock source */
   1863                __HAL_RCC_SDMMC1_CONFIG(pPeriphClkInit->Sdmmc1ClockSelection);
   \      0xD0A   0xF8DF 0x130C      LDR.W    R1,??HAL_RCCEx_PeriphCLKConfig_2+0x4
   \      0xD0E   0x680A             LDR      R2,[R1, #+0]
   \      0xD10   0xF032 0x0240      BICS     R2,R2,#0x40
   \      0xD14   0xF8D4 0x00CC      LDR      R0,[R4, #+204]
   \      0xD18   0x4302             ORRS     R2,R0,R2
   \      0xD1A   0x600A             STR      R2,[R1, #+0]
   \      0xD1C   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_289
   1864              }
   1865              else
   1866              {
   1867                /* set overall return value */
   1868                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_294: (+1)
   \      0xD1E   0x002E             MOVS     R6,R5
   1869              }
   1870          
   1871            }
   1872          #endif /* SDMMC1 */
   1873          
   1874          #if defined(SDMMC2)
   1875            /*-------------------------- SDMMC2 clock source configuration -------------------*/
   1876            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
   1877            {
   1878          
   1879              /* Check the parameters */
   1880              assert_param(IS_RCC_SDMMC2CLKSOURCE(pPeriphClkInit->Sdmmc2ClockSelection));
   1881          
   1882              switch (pPeriphClkInit->Sdmmc2ClockSelection)
   1883              {
   1884                case RCC_SDMMC2CLKSOURCE_PLL1Q:      /* PLL1 is used as clock source for SDMMC2 kernel clock*/
   1885                  /* Enable PLL1Q Clock output generated from System PLL . */
   1886                  __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
   1887                  /* SDMMC2 kernel clock source config set later after clock selection check */
   1888                  break;
   1889          
   1890                case RCC_SDMMC2CLKSOURCE_PLL2R:  /* PLL2 is used as clock source for SDMMC2 kernel clock*/
   1891                  /* PLL2R input clock, parameters M, N & R configuration and clock output (PLL2ClockOut) */
   1892                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   1893                  /* SDMMC2 kernel clock source config set later after clock selection check */
   1894                  break;
   1895          
   1896                default:
   1897                  ret = HAL_ERROR;
   1898                  break;
   1899              }
   1900          
   1901              if (ret == HAL_OK)
   1902              {
   1903                /* Configure the SDMMC2 clock source */
   1904                __HAL_RCC_SDMMC2_CONFIG(pPeriphClkInit->Sdmmc2ClockSelection);
   1905              }
   1906              else
   1907              {
   1908                /* set overall return value */
   1909                status = ret;
   1910              }
   1911          
   1912            }
   1913          #endif /* SDMMC2 */
   1914          
   1915            /*-------------------------- SPI1 clock source configuration ----------------*/
   1916            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
   \                     ??HAL_RCCEx_PeriphCLKConfig_289: (+1)
   \      0xD20   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0xD24   0x0100             LSLS     R0,R0,#+4
   \      0xD26   0xD52E             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_295
   1917            {
   1918          
   1919              /* Check the parameters */
   1920              assert_param(IS_RCC_SPI1CLKSOURCE(pPeriphClkInit->Spi1ClockSelection));
   1921          
   1922              switch (pPeriphClkInit->Spi1ClockSelection)
   \      0xD28   0xF8D4 0x00DC      LDR      R0,[R4, #+220]
   \      0xD2C   0x2800             CMP      R0,#+0
   \      0xD2E   0xD006             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_296
   \      0xD30   0x2802             CMP      R0,#+2
   \      0xD32   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_297
   \      0xD34   0xD30A             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_298
   \      0xD36   0x2804             CMP      R0,#+4
   \      0xD38   0xD015             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_299
   \      0xD3A   0xD313             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_300
   \      0xD3C   0xE014             B.N      ??HAL_RCCEx_PeriphCLKConfig_301
   1923              {
   1924                case RCC_SPI1CLKSOURCE_PLL1Q:      /* PLL1 is used as clock source for SPI1 */
   1925                  /* Enable SPI Clock output generated from System PLL . */
   1926                  __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
   \                     ??HAL_RCCEx_PeriphCLKConfig_296: (+1)
   \      0xD3E   0x.... 0x....      LDR.W    R0,??DataTable1
   \      0xD42   0x6801             LDR      R1,[R0, #+0]
   \      0xD44   0xF451 0x3100      ORRS     R1,R1,#0x20000
   \      0xD48   0x6001             STR      R1,[R0, #+0]
   1927          
   1928                  /* SPI1 clock source configuration done later after clock selection check */
   1929                  break;
   \      0xD4A   0xE00E             B.N      ??HAL_RCCEx_PeriphCLKConfig_302
   1930          
   1931                case RCC_SPI1CLKSOURCE_PLL2P: /* PLL2 is used as clock source for SPI1*/
   1932                  /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
   1933                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_298: (+1)
   \      0xD4C   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0xD50   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0xD54   0x0005             MOVS     R5,R0
   1934          
   1935                  /* SPI1 clock source configuration done later after clock selection check */
   1936                  break;
   \      0xD56   0xE008             B.N      ??HAL_RCCEx_PeriphCLKConfig_302
   1937          
   1938          #if defined(RCC_SPI1CLKSOURCE_PLL3P)
   1939                case RCC_SPI1CLKSOURCE_PLL3P:  /* PLL3 is used as clock source for SPI1 */
   1940                  /* PLL3 P input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
   1941                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_297: (+1)
   \      0xD58   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0xD5C   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0xD60   0x0005             MOVS     R5,R0
   1942          
   1943                  /* SPI1 clock source configuration done later after clock selection check */
   1944                  break;
   \      0xD62   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_302
   1945          #endif /* RCC_SPI1CLKSOURCE_PLL3P */
   1946          
   1947                case RCC_SPI1CLKSOURCE_PIN:
   1948                  /* External clock is used as source of SPI1 clock*/
   1949                  /* SPI1 clock source configuration done later after clock selection check */
   1950                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_300: (+1)
   \      0xD64   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_302
   1951          
   1952                case RCC_SPI1CLKSOURCE_CLKP:
   1953                  /* HSI, HSE, or CSI oscillator is used as source of SPI1 clock */
   1954                  /* SPI1 clock source configuration done later after clock selection check */
   1955                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_299: (+1)
   \      0xD66   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_302
   1956          
   1957                default:
   1958                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_301: (+1)
   \      0xD68   0x2501             MOVS     R5,#+1
   1959                  break;
   1960              }
   1961          
   1962              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_302: (+1)
   \      0xD6A   0x0028             MOVS     R0,R5
   \      0xD6C   0xB2C0             UXTB     R0,R0
   \      0xD6E   0x2800             CMP      R0,#+0
   \      0xD70   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_303
   1963              {
   1964                /* Configure the SPI1 clock source */
   1965                __HAL_RCC_SPI1_CONFIG(pPeriphClkInit->Spi1ClockSelection);
   \      0xD72   0x49A8             LDR.N    R1,??HAL_RCCEx_PeriphCLKConfig_2
   \      0xD74   0x680A             LDR      R2,[R1, #+0]
   \      0xD76   0x08D2             LSRS     R2,R2,#+3
   \      0xD78   0x00D2             LSLS     R2,R2,#+3
   \      0xD7A   0xF8D4 0x00DC      LDR      R0,[R4, #+220]
   \      0xD7E   0x4302             ORRS     R2,R0,R2
   \      0xD80   0x600A             STR      R2,[R1, #+0]
   \      0xD82   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_295
   1966              }
   1967              else
   1968              {
   1969                /* set overall return value */
   1970                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_303: (+1)
   \      0xD84   0x002E             MOVS     R6,R5
   1971              }
   1972          
   1973            }
   1974          
   1975            /*-------------------------- SPI2 clock source configuration ----------------*/
   1976            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
   \                     ??HAL_RCCEx_PeriphCLKConfig_295: (+1)
   \      0xD86   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0xD8A   0x00C0             LSLS     R0,R0,#+3
   \      0xD8C   0xD530             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_304
   1977            {
   1978          
   1979              /* Check the parameters */
   1980              assert_param(IS_RCC_SPI2CLKSOURCE(pPeriphClkInit->Spi2ClockSelection));
   1981          
   1982              switch (pPeriphClkInit->Spi2ClockSelection)
   \      0xD8E   0xF8D4 0x00E0      LDR      R0,[R4, #+224]
   \      0xD92   0x2800             CMP      R0,#+0
   \      0xD94   0xD008             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_305
   \      0xD96   0x2808             CMP      R0,#+8
   \      0xD98   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_306
   \      0xD9A   0x2810             CMP      R0,#+16
   \      0xD9C   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_307
   \      0xD9E   0x2818             CMP      R0,#+24
   \      0xDA0   0xD015             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_308
   \      0xDA2   0x2820             CMP      R0,#+32
   \      0xDA4   0xD014             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_309
   \      0xDA6   0xE014             B.N      ??HAL_RCCEx_PeriphCLKConfig_310
   1983              {
   1984                case RCC_SPI2CLKSOURCE_PLL1Q:      /* PLL1 is used as clock source for SPI2 */
   1985                  /* Enable SPI Clock output generated from System PLL . */
   1986                  __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
   \                     ??HAL_RCCEx_PeriphCLKConfig_305: (+1)
   \      0xDA8   0x.... 0x....      LDR.W    R0,??DataTable1
   \      0xDAC   0x6801             LDR      R1,[R0, #+0]
   \      0xDAE   0xF451 0x3100      ORRS     R1,R1,#0x20000
   \      0xDB2   0x6001             STR      R1,[R0, #+0]
   1987          
   1988                  /* SPI2 clock source configuration done later after clock selection check */
   1989                  break;
   \      0xDB4   0xE00E             B.N      ??HAL_RCCEx_PeriphCLKConfig_311
   1990          
   1991                case RCC_SPI2CLKSOURCE_PLL2P: /* PLL2 is used as clock source for SPI2*/
   1992                  /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
   1993                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_306: (+1)
   \      0xDB6   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0xDBA   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0xDBE   0x0005             MOVS     R5,R0
   1994          
   1995                  /* SPI2 clock source configuration done later after clock selection check */
   1996                  break;
   \      0xDC0   0xE008             B.N      ??HAL_RCCEx_PeriphCLKConfig_311
   1997          
   1998          #if defined(RCC_SPI2CLKSOURCE_PLL3P)
   1999                case RCC_SPI2CLKSOURCE_PLL3P:  /* PLL3 is used as clock source for SPI2 */
   2000                  /* PLL3 P input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
   2001                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_307: (+1)
   \      0xDC2   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0xDC6   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0xDCA   0x0005             MOVS     R5,R0
   2002          
   2003                  /* SPI2 clock source configuration done later after clock selection check */
   2004                  break;
   \      0xDCC   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_311
   2005          #endif /* RCC_SPI2CLKSOURCE_PLL3P */
   2006          
   2007                case RCC_SPI2CLKSOURCE_PIN:
   2008                  /* External clock is used as source of SPI2 clock*/
   2009                  /* SPI2 clock source configuration done later after clock selection check */
   2010                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_308: (+1)
   \      0xDCE   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_311
   2011          
   2012                case RCC_SPI2CLKSOURCE_CLKP:
   2013                  /* HSI, HSE, or CSI oscillator is used as source of SPI2 clock */
   2014                  /* SPI2 clock source configuration done later after clock selection check */
   2015                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_309: (+1)
   \      0xDD0   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_311
   2016          
   2017                default:
   2018                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_310: (+1)
   \      0xDD2   0x2501             MOVS     R5,#+1
   2019                  break;
   2020              }
   2021          
   2022              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_311: (+1)
   \      0xDD4   0x0028             MOVS     R0,R5
   \      0xDD6   0xB2C0             UXTB     R0,R0
   \      0xDD8   0x2800             CMP      R0,#+0
   \      0xDDA   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_312
   2023              {
   2024                /* Configure the SPI2 clock source */
   2025                __HAL_RCC_SPI2_CONFIG(pPeriphClkInit->Spi2ClockSelection);
   \      0xDDC   0x498D             LDR.N    R1,??HAL_RCCEx_PeriphCLKConfig_2
   \      0xDDE   0x680A             LDR      R2,[R1, #+0]
   \      0xDE0   0xF032 0x0238      BICS     R2,R2,#0x38
   \      0xDE4   0xF8D4 0x00E0      LDR      R0,[R4, #+224]
   \      0xDE8   0x4302             ORRS     R2,R0,R2
   \      0xDEA   0x600A             STR      R2,[R1, #+0]
   \      0xDEC   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_304
   2026              }
   2027              else
   2028              {
   2029                /* set overall return value */
   2030                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_312: (+1)
   \      0xDEE   0x002E             MOVS     R6,R5
   2031              }
   2032          
   2033            }
   2034          
   2035            /*-------------------------- SPI3 clock source configuration ----------------*/
   2036            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
   \                     ??HAL_RCCEx_PeriphCLKConfig_304: (+1)
   \      0xDF0   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0xDF4   0x0080             LSLS     R0,R0,#+2
   \      0xDF6   0xD531             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_313
   2037            {
   2038          
   2039              /* Check the parameters */
   2040              assert_param(IS_RCC_SPI3CLKSOURCE(pPeriphClkInit->Spi3ClockSelection));
   2041          
   2042              switch (pPeriphClkInit->Spi3ClockSelection)
   \      0xDF8   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \      0xDFC   0x2800             CMP      R0,#+0
   \      0xDFE   0xD009             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_314
   \      0xE00   0x2840             CMP      R0,#+64
   \      0xE02   0xD00E             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_315
   \      0xE04   0x2880             CMP      R0,#+128
   \      0xE06   0xD012             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_316
   \      0xE08   0x28C0             CMP      R0,#+192
   \      0xE0A   0xD016             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_317
   \      0xE0C   0xF5B0 0x7F80      CMP      R0,#+256
   \      0xE10   0xD014             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_318
   \      0xE12   0xE014             B.N      ??HAL_RCCEx_PeriphCLKConfig_319
   2043              {
   2044                case RCC_SPI3CLKSOURCE_PLL1Q:      /* PLL1 is used as clock source for SPI3 */
   2045                  /* Enable SPI Clock output generated from System PLL . */
   2046                  __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
   \                     ??HAL_RCCEx_PeriphCLKConfig_314: (+1)
   \      0xE14   0x.... 0x....      LDR.W    R0,??DataTable1
   \      0xE18   0x6801             LDR      R1,[R0, #+0]
   \      0xE1A   0xF451 0x3100      ORRS     R1,R1,#0x20000
   \      0xE1E   0x6001             STR      R1,[R0, #+0]
   2047          
   2048                  /* SPI3 clock source configuration done later after clock selection check */
   2049                  break;
   \      0xE20   0xE00E             B.N      ??HAL_RCCEx_PeriphCLKConfig_320
   2050          
   2051                case RCC_SPI3CLKSOURCE_PLL2P: /* PLL2 is used as clock source for SPI3*/
   2052                  /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
   2053                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_315: (+1)
   \      0xE22   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0xE26   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0xE2A   0x0005             MOVS     R5,R0
   2054          
   2055                  /* SPI3 clock source configuration done later after clock selection check */
   2056                  break;
   \      0xE2C   0xE008             B.N      ??HAL_RCCEx_PeriphCLKConfig_320
   2057          
   2058          #if defined(RCC_SPI3CLKSOURCE_PLL3P)
   2059                case RCC_SPI3CLKSOURCE_PLL3P:  /* PLL3 is used as clock source for SPI3 */
   2060                  /* PLL3 P input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
   2061                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_316: (+1)
   \      0xE2E   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0xE32   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0xE36   0x0005             MOVS     R5,R0
   2062          
   2063                  /* SPI3 clock source configuration done later after clock selection check */
   2064                  break;
   \      0xE38   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_320
   2065          #endif /* RCC_SPI3CLKSOURCE_PLL3P */
   2066          
   2067                case RCC_SPI3CLKSOURCE_PIN:
   2068                  /* External clock is used as source of SPI3 clock*/
   2069                  /* SPI3 clock source configuration done later after clock selection check */
   2070                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_317: (+1)
   \      0xE3A   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_320
   2071          
   2072                case RCC_SPI3CLKSOURCE_CLKP:
   2073                  /* HSI, HSE, or CSI oscillator is used as source of SPI3 clock */
   2074                  /* SPI3 clock source configuration done later after clock selection check */
   2075                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_318: (+1)
   \      0xE3C   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_320
   2076          
   2077                default:
   2078                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_319: (+1)
   \      0xE3E   0x2501             MOVS     R5,#+1
   2079                  break;
   2080              }
   2081          
   2082              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_320: (+1)
   \      0xE40   0x0028             MOVS     R0,R5
   \      0xE42   0xB2C0             UXTB     R0,R0
   \      0xE44   0x2800             CMP      R0,#+0
   \      0xE46   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_321
   2083              {
   2084                /* Configure the SPI3 clock source */
   2085                __HAL_RCC_SPI3_CONFIG(pPeriphClkInit->Spi3ClockSelection);
   \      0xE48   0x4972             LDR.N    R1,??HAL_RCCEx_PeriphCLKConfig_2
   \      0xE4A   0x680A             LDR      R2,[R1, #+0]
   \      0xE4C   0xF432 0x72E0      BICS     R2,R2,#0x1C0
   \      0xE50   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \      0xE54   0x4302             ORRS     R2,R0,R2
   \      0xE56   0x600A             STR      R2,[R1, #+0]
   \      0xE58   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_313
   2086              }
   2087              else
   2088              {
   2089                /* set overall return value */
   2090                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_321: (+1)
   \      0xE5A   0x002E             MOVS     R6,R5
   2091              }
   2092          
   2093            }
   2094          
   2095          #if defined(SPI4)
   2096            /*-------------------------- SPI4 clock source configuration ----------------*/
   2097            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
   \                     ??HAL_RCCEx_PeriphCLKConfig_313: (+1)
   \      0xE5C   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0xE60   0x0040             LSLS     R0,R0,#+1
   \      0xE62   0xD532             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_322
   2098            {
   2099          
   2100              /* Check the parameters */
   2101              assert_param(IS_RCC_SPI4CLKSOURCE(pPeriphClkInit->Spi4ClockSelection));
   2102          
   2103              switch (pPeriphClkInit->Spi4ClockSelection)
   \      0xE64   0xF8D4 0x00E8      LDR      R0,[R4, #+232]
   \      0xE68   0x2800             CMP      R0,#+0
   \      0xE6A   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_323
   \      0xE6C   0xF5B0 0x7F00      CMP      R0,#+512
   \      0xE70   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_324
   \      0xE72   0xF5B0 0x6F80      CMP      R0,#+1024
   \      0xE76   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_325
   \      0xE78   0xF5B0 0x6FC0      CMP      R0,#+1536
   \      0xE7C   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_326
   \      0xE7E   0xF5B0 0x6F00      CMP      R0,#+2048
   \      0xE82   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_327
   \      0xE84   0xF5B0 0x6F20      CMP      R0,#+2560
   \      0xE88   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_328
   \      0xE8A   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_329
   2104              {
   2105                case RCC_SPI4CLKSOURCE_PCLK2:  /* PCLK2 (APB2 Clock) is used as clock source for SPI4 */
   2106                  /* SPI4 clock source configuration done later after clock selection check */
   2107                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_323: (+1)
   \      0xE8C   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_330
   2108          
   2109                case RCC_SPI4CLKSOURCE_PLL2Q: /* PLL2 is used as clock source for SPI4*/
   2110                  /* PLL2 Q input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
   2111                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_324: (+1)
   \      0xE8E   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0xE92   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0xE96   0x0005             MOVS     R5,R0
   2112          
   2113                  /* SPI4 clock source configuration done later after clock selection check */
   2114                  break;
   \      0xE98   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_330
   2115          
   2116                case RCC_SPI4CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for SPI4 */
   2117                  /* PLL3 Q input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
   2118                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_325: (+1)
   \      0xE9A   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0xE9E   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0xEA2   0x0005             MOVS     R5,R0
   2119          
   2120                  /* SPI4 clock source configuration done later after clock selection check */
   2121                  break;
   \      0xEA4   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_330
   2122          
   2123                case RCC_SPI4CLKSOURCE_HSI:
   2124                  /* HSI oscillator is used as source of SPI4 clock*/
   2125                  /* SPI4 clock source configuration done later after clock selection check */
   2126                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_326: (+1)
   \      0xEA6   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_330
   2127          
   2128                case RCC_SPI4CLKSOURCE_CSI:
   2129                  /*  CSI oscillator is used as source of SPI4 clock */
   2130                  /* SPI4 clock source configuration done later after clock selection check */
   2131                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_327: (+1)
   \      0xEA8   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_330
   2132          
   2133                case RCC_SPI4CLKSOURCE_HSE:
   2134                  /*  HSE oscillator is used as source of SPI4 clock */
   2135                  /* SPI4 clock source configuration done later after clock selection check */
   2136                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_328: (+1)
   \      0xEAA   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_330
   2137          
   2138                default:
   2139                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_329: (+1)
   \      0xEAC   0x2501             MOVS     R5,#+1
   2140                  break;
   2141              }
   2142          
   2143              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_330: (+1)
   \      0xEAE   0x0028             MOVS     R0,R5
   \      0xEB0   0xB2C0             UXTB     R0,R0
   \      0xEB2   0x2800             CMP      R0,#+0
   \      0xEB4   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_331
   2144              {
   2145                /* Configure the SPI4 clock source */
   2146                __HAL_RCC_SPI4_CONFIG(pPeriphClkInit->Spi4ClockSelection);
   \      0xEB6   0x4957             LDR.N    R1,??HAL_RCCEx_PeriphCLKConfig_2
   \      0xEB8   0x680A             LDR      R2,[R1, #+0]
   \      0xEBA   0xF432 0x6260      BICS     R2,R2,#0xE00
   \      0xEBE   0xF8D4 0x00E8      LDR      R0,[R4, #+232]
   \      0xEC2   0x4302             ORRS     R2,R0,R2
   \      0xEC4   0x600A             STR      R2,[R1, #+0]
   \      0xEC6   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_322
   2147              }
   2148              else
   2149              {
   2150                /* set overall return value */
   2151                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_331: (+1)
   \      0xEC8   0x002E             MOVS     R6,R5
   2152              }
   2153          
   2154            }
   2155          #endif /* SPI4 */
   2156          
   2157          #if defined(SPI5)
   2158            /*-------------------------- SPI5 clock source configuration ----------------*/
   2159            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
   \                     ??HAL_RCCEx_PeriphCLKConfig_322: (+1)
   \      0xECA   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0xECE   0x2800             CMP      R0,#+0
   \      0xED0   0xD532             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_332
   2160            {
   2161          
   2162              /* Check the parameters */
   2163              assert_param(IS_RCC_SPI5CLKSOURCE(pPeriphClkInit->Spi5ClockSelection));
   2164          
   2165              switch (pPeriphClkInit->Spi5ClockSelection)
   \      0xED2   0xF8D4 0x00EC      LDR      R0,[R4, #+236]
   \      0xED6   0x2800             CMP      R0,#+0
   \      0xED8   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_333
   \      0xEDA   0xF5B0 0x5F80      CMP      R0,#+4096
   \      0xEDE   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_334
   \      0xEE0   0xF5B0 0x5F00      CMP      R0,#+8192
   \      0xEE4   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_335
   \      0xEE6   0xF5B0 0x5F40      CMP      R0,#+12288
   \      0xEEA   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_336
   \      0xEEC   0xF5B0 0x4F80      CMP      R0,#+16384
   \      0xEF0   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_337
   \      0xEF2   0xF5B0 0x4FA0      CMP      R0,#+20480
   \      0xEF6   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_338
   \      0xEF8   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_339
   2166              {
   2167                case RCC_SPI5CLKSOURCE_PCLK3:  /* PCLK3 (APB3 Clock) is used as clock source for SPI5 */
   2168                  /* SPI5 clock source configuration done later after clock selection check */
   2169                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_333: (+1)
   \      0xEFA   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_340
   2170          
   2171                case RCC_SPI5CLKSOURCE_PLL2Q: /* PLL2 is used as clock source for SPI5*/
   2172                  /* PLL2 Q input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
   2173                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_334: (+1)
   \      0xEFC   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0xF00   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0xF04   0x0005             MOVS     R5,R0
   2174          
   2175                  /* SPI5 clock source configuration done later after clock selection check */
   2176                  break;
   \      0xF06   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_340
   2177          
   2178                case RCC_SPI5CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for SPI5 */
   2179                  /* PLL3 Q input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
   2180                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_335: (+1)
   \      0xF08   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0xF0C   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0xF10   0x0005             MOVS     R5,R0
   2181          
   2182                  /* SPI5 clock source configuration done later after clock selection check */
   2183                  break;
   \      0xF12   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_340
   2184          
   2185                case RCC_SPI5CLKSOURCE_HSI:
   2186                  /* HSI oscillator is used as source of SPI5 clock*/
   2187                  /* SPI5 clock source configuration done later after clock selection check */
   2188                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_336: (+1)
   \      0xF14   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_340
   2189          
   2190                case RCC_SPI5CLKSOURCE_CSI:
   2191                  /*  CSI oscillator is used as source of SPI5 clock */
   2192                  /* SPI5 clock source configuration done later after clock selection check */
   2193                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_337: (+1)
   \      0xF16   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_340
   2194          
   2195                case RCC_SPI5CLKSOURCE_HSE:
   2196                  /*  HSE oscillator is used as source of SPI5 clock */
   2197                  /* SPI5 clock source configuration done later after clock selection check */
   2198                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_338: (+1)
   \      0xF18   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_340
   2199          
   2200                default:
   2201                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_339: (+1)
   \      0xF1A   0x2501             MOVS     R5,#+1
   2202                  break;
   2203              }
   2204          
   2205              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_340: (+1)
   \      0xF1C   0x0028             MOVS     R0,R5
   \      0xF1E   0xB2C0             UXTB     R0,R0
   \      0xF20   0x2800             CMP      R0,#+0
   \      0xF22   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_341
   2206              {
   2207                /* Configure the SPI5 clock source */
   2208                __HAL_RCC_SPI5_CONFIG(pPeriphClkInit->Spi5ClockSelection);
   \      0xF24   0x493B             LDR.N    R1,??HAL_RCCEx_PeriphCLKConfig_2
   \      0xF26   0x680A             LDR      R2,[R1, #+0]
   \      0xF28   0xF432 0x42E0      BICS     R2,R2,#0x7000
   \      0xF2C   0xF8D4 0x00EC      LDR      R0,[R4, #+236]
   \      0xF30   0x4302             ORRS     R2,R0,R2
   \      0xF32   0x600A             STR      R2,[R1, #+0]
   \      0xF34   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_332
   2209              }
   2210              else
   2211              {
   2212                /* set overall return value */
   2213                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_341: (+1)
   \      0xF36   0x002E             MOVS     R6,R5
   2214              }
   2215          
   2216            }
   2217          #endif /* SPI5 */
   2218          
   2219          #if defined(SPI6)
   2220            /*-------------------------- SPI6 clock source configuration ----------------*/
   2221            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
   \                     ??HAL_RCCEx_PeriphCLKConfig_332: (+1)
   \      0xF38   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0xF3C   0xF010 0x0000      ANDS     R0,R0,#0x0
   \      0xF40   0xF011 0x0101      ANDS     R1,R1,#0x1
   \      0xF44   0x2900             CMP      R1,#+0
   \      0xF46   0xD101             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_342
   \      0xF48   0x2800             CMP      R0,#+0
   \      0xF4A   0xD032             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_343
   2222            {
   2223              /* Check the parameters */
   2224              assert_param(IS_RCC_SPI6CLKSOURCE(pPeriphClkInit->Spi6ClockSelection));
   2225          
   2226              switch (pPeriphClkInit->Spi6ClockSelection)
   \                     ??HAL_RCCEx_PeriphCLKConfig_342: (+1)
   \      0xF4C   0xF8D4 0x00F0      LDR      R0,[R4, #+240]
   \      0xF50   0x2800             CMP      R0,#+0
   \      0xF52   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_344
   \      0xF54   0xF5B0 0x4F00      CMP      R0,#+32768
   \      0xF58   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_345
   \      0xF5A   0xF5B0 0x3F80      CMP      R0,#+65536
   \      0xF5E   0xD010             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_346
   \      0xF60   0xF5B0 0x3FC0      CMP      R0,#+98304
   \      0xF64   0xD013             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_347
   \      0xF66   0xF5B0 0x3F00      CMP      R0,#+131072
   \      0xF6A   0xD011             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_348
   \      0xF6C   0xF5B0 0x3F20      CMP      R0,#+163840
   \      0xF70   0xD00F             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_349
   \      0xF72   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_350
   2227              {
   2228                case RCC_SPI6CLKSOURCE_PCLK2:  /* PCLK2 (APB2 Clock) is used as clock source for SPI6 */
   2229                  /* SPI6 clock source configuration done later after clock selection check */
   2230                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_344: (+1)
   \      0xF74   0xE00F             B.N      ??HAL_RCCEx_PeriphCLKConfig_351
   2231          
   2232                case RCC_SPI6CLKSOURCE_PLL2Q: /* PLL2 is used as clock source for SPI6*/
   2233                  /* PLL2 Q input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
   2234                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_345: (+1)
   \      0xF76   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0xF7A   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0xF7E   0x0005             MOVS     R5,R0
   2235          
   2236                  /* SPI6 clock source configuration done later after clock selection check */
   2237                  break;
   \      0xF80   0xE009             B.N      ??HAL_RCCEx_PeriphCLKConfig_351
   2238          
   2239                case RCC_SPI6CLKSOURCE_PLL3Q:  /* PLL3 is used as clock source for SPI6 */
   2240                  /* PLL3 Q input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
   2241                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_346: (+1)
   \      0xF82   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0xF86   0x.... 0x....      BL       RCCEx_PLL3_Config
   \      0xF8A   0x0005             MOVS     R5,R0
   2242          
   2243                  /* SPI6 clock source configuration done later after clock selection check */
   2244                  break;
   \      0xF8C   0xE003             B.N      ??HAL_RCCEx_PeriphCLKConfig_351
   2245          
   2246                case RCC_SPI6CLKSOURCE_HSI:
   2247                  /* HSI oscillator is used as source of SPI6 clock*/
   2248                  /* SPI6 clock source configuration done later after clock selection check */
   2249                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_347: (+1)
   \      0xF8E   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_351
   2250          
   2251                case RCC_SPI6CLKSOURCE_CSI:
   2252                  /*  CSI oscillator is used as source of SPI6 clock */
   2253                  /* SPI6 clock source configuration done later after clock selection check */
   2254                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_348: (+1)
   \      0xF90   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_351
   2255          
   2256                case RCC_SPI6CLKSOURCE_HSE:
   2257                  /*  HSE oscillator is used as source of SPI6 clock */
   2258                  /* SPI6 clock source configuration done later after clock selection check */
   2259                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_349: (+1)
   \      0xF92   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_351
   2260          
   2261                default:
   2262                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_350: (+1)
   \      0xF94   0x2501             MOVS     R5,#+1
   2263                  break;
   2264              }
   2265          
   2266              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_351: (+1)
   \      0xF96   0x0028             MOVS     R0,R5
   \      0xF98   0xB2C0             UXTB     R0,R0
   \      0xF9A   0x2800             CMP      R0,#+0
   \      0xF9C   0xD108             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_352
   2267              {
   2268                /* Configure the SPI6 clock source */
   2269                __HAL_RCC_SPI6_CONFIG(pPeriphClkInit->Spi6ClockSelection);
   \      0xF9E   0x491D             LDR.N    R1,??HAL_RCCEx_PeriphCLKConfig_2
   \      0xFA0   0x680A             LDR      R2,[R1, #+0]
   \      0xFA2   0xF432 0x3260      BICS     R2,R2,#0x38000
   \      0xFA6   0xF8D4 0x00F0      LDR      R0,[R4, #+240]
   \      0xFAA   0x4302             ORRS     R2,R0,R2
   \      0xFAC   0x600A             STR      R2,[R1, #+0]
   \      0xFAE   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_343
   2270              }
   2271              else
   2272              {
   2273                /* set overall return value */
   2274                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_352: (+1)
   \      0xFB0   0x002E             MOVS     R6,R5
   2275              }
   2276            }
   2277          #endif /* SPI6 */
   2278          
   2279          #if defined(OCTOSPI1)
   2280            /*-------------------------- OctoSPIx clock source configuration ----------------*/
   2281            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
   \                     ??HAL_RCCEx_PeriphCLKConfig_343: (+1)
   \      0xFB2   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0xFB6   0xF010 0x0000      ANDS     R0,R0,#0x0
   \      0xFBA   0xF011 0x0102      ANDS     R1,R1,#0x2
   \      0xFBE   0x2900             CMP      R1,#+0
   \      0xFC0   0xD101             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_353
   \      0xFC2   0x2800             CMP      R0,#+0
   \      0xFC4   0xD02B             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_354
   2282            {  
   2283              /* Check the parameters */
   2284              assert_param(IS_RCC_OSPICLKSOURCE(pPeriphClkInit->OspiClockSelection));
   2285          
   2286              switch (pPeriphClkInit->OspiClockSelection)
   \                     ??HAL_RCCEx_PeriphCLKConfig_353: (+1)
   \      0xFC6   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0xFCA   0x2800             CMP      R0,#+0
   \      0xFCC   0xD005             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_355
   \      0xFCE   0x2802             CMP      R0,#+2
   \      0xFD0   0xD00B             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_356
   \      0xFD2   0xD303             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_357
   \      0xFD4   0x2803             CMP      R0,#+3
   \      0xFD6   0xD00E             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_358
   \      0xFD8   0xE00E             B.N      ??HAL_RCCEx_PeriphCLKConfig_359
   2287              {
   2288                case RCC_OSPICLKSOURCE_HCLK:      /* HCLK is used as clock source for OCTOSPI */
   2289          
   2290                  /* OCTOSPI clock source config set later after clock selection check */
   2291                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_355: (+1)
   \      0xFDA   0xE00E             B.N      ??HAL_RCCEx_PeriphCLKConfig_360
   2292          
   2293                case RCC_OSPICLKSOURCE_PLL1Q:  /* PLL1 Q is used as clock source for OCTOSPI*/
   2294          
   2295                  /* Enable PLL1 Q CLK output */
   2296                  __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
   \                     ??HAL_RCCEx_PeriphCLKConfig_357: (+1)
   \      0xFDC   0x.... 0x....      LDR.W    R0,??DataTable1
   \      0xFE0   0x6801             LDR      R1,[R0, #+0]
   \      0xFE2   0xF451 0x3100      ORRS     R1,R1,#0x20000
   \      0xFE6   0x6001             STR      R1,[R0, #+0]
   2297                  break;
   \      0xFE8   0xE007             B.N      ??HAL_RCCEx_PeriphCLKConfig_360
   2298          
   2299                case RCC_OSPICLKSOURCE_PLL2R:  /* PLL2 is used as clock source for OCTOSPI*/
   2300                  /* PLL2 R input clock, parameters M, N & R configuration and clock output (PLL2ClockOut) */
   2301                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_356: (+1)
   \      0xFEA   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0xFEE   0x.... 0x....      BL       RCCEx_PLL2_Config
   \      0xFF2   0x0005             MOVS     R5,R0
   2302                  /* OCTOSPI clock source config set later after clock selection check */
   2303                  break;
   \      0xFF4   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_360
   2304          
   2305                case RCC_OSPICLKSOURCE_CLKP:  /* CLKP is used as source of OCTOSPI clock*/
   2306                  /* OCTOSPI clock source config set later after clock selection check */
   2307                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_358: (+1)
   \      0xFF6   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_360
   2308          
   2309                default:
   2310                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_359: (+1)
   \      0xFF8   0x2501             MOVS     R5,#+1
   2311                  break;
   2312              }
   2313          
   2314              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_360: (+1)
   \      0xFFA   0x0028             MOVS     R0,R5
   \      0xFFC   0xB2C0             UXTB     R0,R0
   \      0xFFE   0x2800             CMP      R0,#+0
   \     0x1000   0xD10C             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_361
   2315              {
   2316                /* Configure the OctoSPI clock source */
   2317                __HAL_RCC_OSPI_CONFIG(pPeriphClkInit->OspiClockSelection);
   \     0x1002   0x4905             LDR.N    R1,??HAL_RCCEx_PeriphCLKConfig_2+0x4
   \     0x1004   0x680A             LDR      R2,[R1, #+0]
   \     0x1006   0x0892             LSRS     R2,R2,#+2
   \     0x1008   0x0092             LSLS     R2,R2,#+2
   \     0x100A   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \     0x100E   0x4302             ORRS     R2,R0,R2
   \     0x1010   0x600A             STR      R2,[R1, #+0]
   \     0x1012   0xE004             B.N      ??HAL_RCCEx_PeriphCLKConfig_354
   \                     ??HAL_RCCEx_PeriphCLKConfig_2:
   \     0x1014   0x4402'0CE0        DC32     0x44020ce0
   \     0x1018   0x4402'0CE4        DC32     0x44020ce4
   2318              }
   2319              else
   2320              {
   2321                /* set overall return value */
   2322                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_361: (+1)
   \     0x101C   0x002E             MOVS     R6,R5
   2323              }
   2324              
   2325            }
   2326          #endif /* OCTOSPI1*/
   2327          
   2328            /*-------------------------- FDCAN kernel clock source configuration -------------*/
   2329            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
   \                     ??HAL_RCCEx_PeriphCLKConfig_354: (+1)
   \     0x101E   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \     0x1022   0xF010 0x0000      ANDS     R0,R0,#0x0
   \     0x1026   0xF011 0x0104      ANDS     R1,R1,#0x4
   \     0x102A   0x2900             CMP      R1,#+0
   \     0x102C   0xD101             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_362
   \     0x102E   0x2800             CMP      R0,#+0
   \     0x1030   0xD028             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_363
   2330            {
   2331              assert_param(IS_RCC_FDCANCLK(pPeriphClkInit->FdcanClockSelection));
   2332          
   2333              switch (pPeriphClkInit->FdcanClockSelection)
   \                     ??HAL_RCCEx_PeriphCLKConfig_362: (+1)
   \     0x1032   0xF8D4 0x00BC      LDR      R0,[R4, #+188]
   \     0x1036   0x2800             CMP      R0,#+0
   \     0x1038   0xD006             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_364
   \     0x103A   0xF5B0 0x7F80      CMP      R0,#+256
   \     0x103E   0xD004             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_365
   \     0x1040   0xF5B0 0x7F00      CMP      R0,#+512
   \     0x1044   0xD008             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_366
   \     0x1046   0xE00D             B.N      ??HAL_RCCEx_PeriphCLKConfig_367
   2334              {
   2335                case RCC_FDCANCLKSOURCE_HSE:      /* HSE is used as source of FDCAN kernel clock*/
   2336                  /* FDCAN kernel clock source config set later after clock selection check */
   2337                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_364: (+1)
   \     0x1048   0xE00D             B.N      ??HAL_RCCEx_PeriphCLKConfig_368
   2338          
   2339                case RCC_FDCANCLKSOURCE_PLL1Q:      /* PLL1 is used as clock source for FDCAN kernel clock*/
   2340                  /* Enable PLL1Q Clock output generated from System PLL . */
   2341                  __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
   \                     ??HAL_RCCEx_PeriphCLKConfig_365: (+1)
   \     0x104A   0x.... 0x....      LDR.W    R0,??DataTable1
   \     0x104E   0x6801             LDR      R1,[R0, #+0]
   \     0x1050   0xF451 0x3100      ORRS     R1,R1,#0x20000
   \     0x1054   0x6001             STR      R1,[R0, #+0]
   2342                  /* FDCAN kernel clock source config set later after clock selection check */
   2343                  break;
   \     0x1056   0xE006             B.N      ??HAL_RCCEx_PeriphCLKConfig_368
   2344          
   2345                case RCC_FDCANCLKSOURCE_PLL2Q:  /* PLL2 is used as clock source for FDCAN kernel clock*/
   2346                  /* PLL2Q input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
   2347                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   \                     ??HAL_RCCEx_PeriphCLKConfig_366: (+1)
   \     0x1058   0xF114 0x0008      ADDS     R0,R4,#+8
   \     0x105C   0x.... 0x....      BL       RCCEx_PLL2_Config
   \     0x1060   0x0005             MOVS     R5,R0
   2348                  /* FDCAN kernel clock source config set later after clock selection check */
   2349                  break;
   \     0x1062   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_368
   2350          
   2351                default:
   2352                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_367: (+1)
   \     0x1064   0x2501             MOVS     R5,#+1
   2353                  break;
   2354              }
   2355          
   2356              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_368: (+1)
   \     0x1066   0x0028             MOVS     R0,R5
   \     0x1068   0xB2C0             UXTB     R0,R0
   \     0x106A   0x2800             CMP      R0,#+0
   \     0x106C   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_369
   2357              {
   2358                /* Set the source of FDCAN kernel clock*/
   2359                __HAL_RCC_FDCAN_CONFIG(pPeriphClkInit->FdcanClockSelection);
   \     0x106E   0x.... 0x....      LDR.W    R1,??DataTable2
   \     0x1072   0x680A             LDR      R2,[R1, #+0]
   \     0x1074   0xF432 0x7240      BICS     R2,R2,#0x300
   \     0x1078   0xF8D4 0x00BC      LDR      R0,[R4, #+188]
   \     0x107C   0x4302             ORRS     R2,R0,R2
   \     0x107E   0x600A             STR      R2,[R1, #+0]
   \     0x1080   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_363
   2360              }
   2361              else
   2362              {
   2363                /* set overall return value */
   2364                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_369: (+1)
   \     0x1082   0x002E             MOVS     R6,R5
   2365              }
   2366            }
   2367          
   2368            /*------------------------------ USB Configuration -------------------------*/
   2369            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
   \                     ??HAL_RCCEx_PeriphCLKConfig_363: (+1)
   \     0x1084   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \     0x1088   0xF010 0x0000      ANDS     R0,R0,#0x0
   \     0x108C   0xF011 0x0110      ANDS     R1,R1,#0x10
   \     0x1090   0x2900             CMP      R1,#+0
   \     0x1092   0xD101             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_370
   \     0x1094   0x2800             CMP      R0,#+0
   \     0x1096   0xD026             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_371
   2370            {
   2371          
   2372              /* Check the parameters */
   2373              assert_param(IS_RCC_USBCLKSOURCE(pPeriphClkInit->UsbClockSelection));
   2374          
   2375              switch (pPeriphClkInit->UsbClockSelection)
   \                     ??HAL_RCCEx_PeriphCLKConfig_370: (+1)
   \     0x1098   0xF8D4 0x00FC      LDR      R0,[R4, #+252]
   \     0x109C   0x2810             CMP      R0,#+16
   \     0x109E   0xD004             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_372
   \     0x10A0   0x2820             CMP      R0,#+32
   \     0x10A2   0xD009             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_373
   \     0x10A4   0x2830             CMP      R0,#+48
   \     0x10A6   0xD00D             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_374
   \     0x10A8   0xE00D             B.N      ??HAL_RCCEx_PeriphCLKConfig_375
   2376              {
   2377                case RCC_USBCLKSOURCE_PLL1Q:      /* PLL is used as clock source for USB*/
   2378                  /* Enable USB Clock output generated form System USB . */
   2379                  __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVQ);
   \                     ??HAL_RCCEx_PeriphCLKConfig_372: (+1)
   \     0x10AA   0x.... 0x....      LDR.W    R0,??DataTable1
   \     0x10AE   0x6801             LDR      R1,[R0, #+0]
   \     0x10B0   0xF451 0x3100      ORRS     R1,R1,#0x20000
   \     0x10B4   0x6001             STR      R1,[R0, #+0]
   2380          
   2381                  /* USB clock source configuration done later after clock selection check */
   2382                  break;
   \     0x10B6   0xE007             B.N      ??HAL_RCCEx_PeriphCLKConfig_376
   2383          
   2384          #if defined(RCC_USBCLKSOURCE_PLL3Q)
   2385                case RCC_USBCLKSOURCE_PLL3Q: /* PLL3 is used as clock source for USB*/
   2386                  /* PLL3Q input clock, parameters M, N & Q configuration and clock output (PLL3ClockOut) */
   2387                  ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
   \                     ??HAL_RCCEx_PeriphCLKConfig_373: (+1)
   \     0x10B8   0xF114 0x0030      ADDS     R0,R4,#+48
   \     0x10BC   0x.... 0x....      BL       RCCEx_PLL3_Config
   \     0x10C0   0x0005             MOVS     R5,R0
   2388          #else
   2389                case RCC_USBCLKSOURCE_PLL2Q: /* PLL2 is used as clock source for USB*/
   2390                  /* PLL2Q input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
   2391                  ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
   2392          #endif /* RCC_USBCLKSOURCE_PLL3Q */
   2393                  /* USB clock source configuration done later after clock selection check */
   2394                  break;
   \     0x10C2   0xE001             B.N      ??HAL_RCCEx_PeriphCLKConfig_376
   2395          
   2396                case RCC_USBCLKSOURCE_HSI48:
   2397                  /* HSI48 oscillator is used as source of USB clock */
   2398                  /* USB clock source configuration done later after clock selection check */
   2399                  break;
   \                     ??HAL_RCCEx_PeriphCLKConfig_374: (+1)
   \     0x10C4   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_376
   2400          
   2401                default:
   2402                  ret = HAL_ERROR;
   \                     ??HAL_RCCEx_PeriphCLKConfig_375: (+1)
   \     0x10C6   0x2501             MOVS     R5,#+1
   2403                  break;
   2404              }
   2405          
   2406              if (ret == HAL_OK)
   \                     ??HAL_RCCEx_PeriphCLKConfig_376: (+1)
   \     0x10C8   0x0028             MOVS     R0,R5
   \     0x10CA   0xB2C0             UXTB     R0,R0
   \     0x10CC   0x2800             CMP      R0,#+0
   \     0x10CE   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_377
   2407              {
   2408                /* Set the source of USB clock*/
   2409                __HAL_RCC_USB_CONFIG(pPeriphClkInit->UsbClockSelection);
   \     0x10D0   0x.... 0x....      LDR.W    R1,??DataTable4_3
   \     0x10D4   0x680A             LDR      R2,[R1, #+0]
   \     0x10D6   0xF032 0x0230      BICS     R2,R2,#0x30
   \     0x10DA   0xF8D4 0x00FC      LDR      R0,[R4, #+252]
   \     0x10DE   0x4302             ORRS     R2,R0,R2
   \     0x10E0   0x600A             STR      R2,[R1, #+0]
   \     0x10E2   0xE000             B.N      ??HAL_RCCEx_PeriphCLKConfig_371
   2410              }
   2411              else
   2412              {
   2413                /* set overall return value */
   2414                status = ret;
   \                     ??HAL_RCCEx_PeriphCLKConfig_377: (+1)
   \     0x10E4   0x002E             MOVS     R6,R5
   2415              }
   2416          
   2417            }
   2418          
   2419          #if defined(CEC)
   2420            /*-------------------------- CEC clock source configuration ----------------*/
   2421            if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
   \                     ??HAL_RCCEx_PeriphCLKConfig_371: (+1)
   \     0x10E6   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \     0x10EA   0xF010 0x0000      ANDS     R0,R0,#0x0
   \     0x10EE   0xF011 0x0108      ANDS     R1,R1,#0x8
   \     0x10F2   0x2900             CMP      R1,#+0
   \     0x10F4   0xD101             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_378
   \     0x10F6   0x2800             CMP      R0,#+0
   \     0x10F8   0xD008             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_379
   2422            {
   2423          
   2424              /* Check the parameters */
   2425              assert_param(IS_RCC_CECCLKSOURCE(pPeriphClkInit->CecClockSelection));
   2426          
   2427              /* Configure the CEC clock source */
   2428              __HAL_RCC_CEC_CONFIG(pPeriphClkInit->CecClockSelection);
   \                     ??HAL_RCCEx_PeriphCLKConfig_378: (+1)
   \     0x10FA   0x.... 0x....      LDR.W    R1,??DataTable2
   \     0x10FE   0x680A             LDR      R2,[R1, #+0]
   \     0x1100   0xF032 0x02C0      BICS     R2,R2,#0xC0
   \     0x1104   0xF8D4 0x00F8      LDR      R0,[R4, #+248]
   \     0x1108   0x4302             ORRS     R2,R0,R2
   \     0x110A   0x600A             STR      R2,[R1, #+0]
   2429          
   2430            }
   2431          #endif /* CEC */
   2432            GPIO_Debug(10);
   \                     ??HAL_RCCEx_PeriphCLKConfig_379: (+1)
   \     0x110C   0x200A             MOVS     R0,#+10
   \     0x110E   0x.... 0x....      BL       GPIO_Debug
   2433            return status;
   \     0x1112   0x0030             MOVS     R0,R6
   \     0x1114   0xB2C0             UXTB     R0,R0
   \     0x1116   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2434          }
   2435          
   2436          
   2437          
   2438          /**
   2439            * @brief  Get the pPeriphClkInit according to the internal RCC configuration registers.
   2440            * @param  pPeriphClkInit  pointer to an RCC_PeriphCLKInitTypeDef structure that
   2441            *         returns the configuration information for the Extended Peripherals
   2442            *         clocks (ADC12, DAC, SDMMC1, SDMMC2, OCTOSPI1, TIM, LPTIM1, LPTIM2, LPTIM3, LPTIM4, LPTIM5, LPTIM6,
   2443            *         SPI1, SPI2, SPI3, SPI4, SPI5, SPI6, USART1, USART2, USART3, UART4, UART5, USART6, UART7, UART8,
   2444            *         UART9, USART10, USART11, UART12, LPUART1, I2C1, I2C2, I2C3, I2C4, I3C1, I3C2, CEC, FDCAN, SAI1,
   2445            *         SAI2, USB,), PLL2 and PLL3.
   2446            * @retval None
   2447            */

   \                                 In section .text, align 2, keep-with-next
   2448          void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *pPeriphClkInit)
   2449          {
   \                     HAL_RCCEx_GetPeriphCLKConfig: (+1)
   \        0x0   0xB410             PUSH     {R4}
   2450            /* Set all possible values for the extended clock type parameter------------*/
   2451            pPeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3  | \
   2452                                                   RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1 | RCC_PERIPHCLK_I2C2     | \
   2453                                                   RCC_PERIPHCLK_LPTIM1 | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_ADCDAC  | \
   2454                                                   RCC_PERIPHCLK_DAC_LP | RCC_PERIPHCLK_RTC  | RCC_PERIPHCLK_RNG | \
   2455                                                   RCC_PERIPHCLK_I3C1 | RCC_PERIPHCLK_SPI1 | RCC_PERIPHCLK_SPI2 | \
   2456                                                   RCC_PERIPHCLK_SPI3 | RCC_PERIPHCLK_CKPER | RCC_PERIPHCLK_USB;
   \        0x2   0x.... 0x....      LDR.W    R2,??DataTable4_4
   \        0x6   0xF44F 0x7304      MOV      R3,#+528
   \        0xA   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2457          
   2458          #if defined(UART4)
   2459            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_UART4;
   \        0xE   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0x12   0xF052 0x0208      ORRS     R2,R2,#0x8
   \       0x16   0xF053 0x0300      ORRS     R3,R3,#0x0
   \       0x1A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2460          #endif /* UART4 */
   2461          #if defined(UART5)
   2462            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_UART5;
   \       0x1E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0x22   0xF052 0x0210      ORRS     R2,R2,#0x10
   \       0x26   0xF053 0x0300      ORRS     R3,R3,#0x0
   \       0x2A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2463          #endif /* UART5 */
   2464          #if defined(USART6)
   2465            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USART6;
   \       0x2E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0x32   0xF052 0x0220      ORRS     R2,R2,#0x20
   \       0x36   0xF053 0x0300      ORRS     R3,R3,#0x0
   \       0x3A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2466          #endif /* UART6 */
   2467          #if defined(UART7)
   2468            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_UART7;
   \       0x3E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0x42   0xF052 0x0240      ORRS     R2,R2,#0x40
   \       0x46   0xF053 0x0300      ORRS     R3,R3,#0x0
   \       0x4A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2469          #endif /* UART7 */
   2470          #if defined(UART8)
   2471            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_UART8;
   \       0x4E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0x52   0xF052 0x0280      ORRS     R2,R2,#0x80
   \       0x56   0xF053 0x0300      ORRS     R3,R3,#0x0
   \       0x5A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2472          #endif /* UART8 */
   2473          #if defined(UART9)
   2474            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_UART9;
   \       0x5E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0x62   0xF452 0x7280      ORRS     R2,R2,#0x100
   \       0x66   0xF053 0x0300      ORRS     R3,R3,#0x0
   \       0x6A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2475          #endif /* UART9 */
   2476          #if defined(USART10)
   2477            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USART10;
   \       0x6E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0x72   0xF452 0x7200      ORRS     R2,R2,#0x200
   \       0x76   0xF053 0x0300      ORRS     R3,R3,#0x0
   \       0x7A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2478          #endif /* UART10 */
   2479          #if defined(USART11)
   2480            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USART11;
   \       0x7E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0x82   0xF452 0x6280      ORRS     R2,R2,#0x400
   \       0x86   0xF053 0x0300      ORRS     R3,R3,#0x0
   \       0x8A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2481          #endif /* UART11 */
   2482          #if defined(UART12)
   2483            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_UART12;
   \       0x8E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0x92   0xF452 0x6200      ORRS     R2,R2,#0x800
   \       0x96   0xF053 0x0300      ORRS     R3,R3,#0x0
   \       0x9A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2484          #endif /* UART12 */
   2485          #if defined(I2C3)
   2486            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2C3;
   \       0x9E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0xA2   0xF452 0x4200      ORRS     R2,R2,#0x8000
   \       0xA6   0xF053 0x0300      ORRS     R3,R3,#0x0
   \       0xAA   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2487          #endif /* I2C3 */
   2488          #if defined(I2C4)
   2489            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2C4;
   \       0xAE   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0xB2   0xF052 0x0200      ORRS     R2,R2,#0x0
   \       0xB6   0xF453 0x6380      ORRS     R3,R3,#0x400
   \       0xBA   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2490          #endif /* I2C4 */
   2491          #if defined(I3C2)
   2492            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I3C2;
   2493          #endif /* I3C2 */
   2494          #if defined(LPTIM3)
   2495            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LPTIM3;
   \       0xBE   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0xC2   0xF052 0x0200      ORRS     R2,R2,#0x0
   \       0xC6   0xF053 0x0320      ORRS     R3,R3,#0x20
   \       0xCA   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2496          #endif /* LPTIM3 */
   2497          #if defined(LPTIM4)
   2498            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LPTIM4;
   \       0xCE   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0xD2   0xF052 0x0200      ORRS     R2,R2,#0x0
   \       0xD6   0xF053 0x0340      ORRS     R3,R3,#0x40
   \       0xDA   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2499          #endif /* LPTIM4 */
   2500          #if defined(LPTIM5)
   2501            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LPTIM5;
   \       0xDE   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0xE2   0xF052 0x0200      ORRS     R2,R2,#0x0
   \       0xE6   0xF053 0x0380      ORRS     R3,R3,#0x80
   \       0xEA   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2502          #endif /* LPTIM5 */
   2503          #if defined(LPTIM6)
   2504            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LPTIM6;
   \       0xEE   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0xF2   0xF052 0x0200      ORRS     R2,R2,#0x0
   \       0xF6   0xF453 0x7380      ORRS     R3,R3,#0x100
   \       0xFA   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2505          #endif /* LPTIM6 */
   2506          #if defined(SPI4)
   2507            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SPI4;
   \       0xFE   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \      0x102   0xF052 0x4280      ORRS     R2,R2,#0x40000000
   \      0x106   0xF053 0x0300      ORRS     R3,R3,#0x0
   \      0x10A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2508          #endif /* SPI4 */
   2509          #if defined(SPI5)
   2510            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SPI5;
   \      0x10E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \      0x112   0xF052 0x4200      ORRS     R2,R2,#0x80000000
   \      0x116   0xF053 0x0300      ORRS     R3,R3,#0x0
   \      0x11A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2511          #endif /* SPI5 */
   2512          #if defined(SPI6)
   2513            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SPI6;
   \      0x11E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \      0x122   0xF052 0x0200      ORRS     R2,R2,#0x0
   \      0x126   0xF053 0x0301      ORRS     R3,R3,#0x1
   \      0x12A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2514          #endif /* SPI6 */
   2515          #if defined(SAI1)
   2516            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI1;
   \      0x12E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \      0x132   0xF452 0x2200      ORRS     R2,R2,#0x80000
   \      0x136   0xF053 0x0300      ORRS     R3,R3,#0x0
   \      0x13A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2517          #endif /* SAI1 */
   2518          #if defined(SAI2)
   2519            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI2;
   \      0x13E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \      0x142   0xF452 0x1280      ORRS     R2,R2,#0x100000
   \      0x146   0xF053 0x0300      ORRS     R3,R3,#0x0
   \      0x14A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2520          #endif /* SAI2 */
   2521            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_FDCAN;
   \      0x14E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \      0x152   0xF052 0x0200      ORRS     R2,R2,#0x0
   \      0x156   0xF053 0x0304      ORRS     R3,R3,#0x4
   \      0x15A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2522          #if defined(SDMMC1)
   2523            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SDMMC1;
   \      0x15E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \      0x162   0xF452 0x0280      ORRS     R2,R2,#0x400000
   \      0x166   0xF053 0x0300      ORRS     R3,R3,#0x0
   \      0x16A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2524          #endif /* SDMMC1*/
   2525          #if defined(SDMMC2)
   2526            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SDMMC2;
   2527          #endif /* SDMMC2*/
   2528          #if defined(OCTOSPI1)
   2529            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_OSPI;
   \      0x16E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \      0x172   0xF052 0x0200      ORRS     R2,R2,#0x0
   \      0x176   0xF053 0x0302      ORRS     R3,R3,#0x2
   \      0x17A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2530          #endif /* OCTOSPI1 */
   2531          #if defined(CEC)
   2532            pPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_CEC;
   \      0x17E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \      0x182   0xF052 0x0200      ORRS     R2,R2,#0x0
   \      0x186   0xF053 0x0308      ORRS     R3,R3,#0x8
   \      0x18A   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   2533          #endif /* CEC */
   2534          
   2535            /* Get the PLL2 Clock configuration -----------------------------------------------*/
   2536            pPeriphClkInit->PLL2.PLL2Source = (uint32_t)((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2SRC) >> RCC_PLL2CFGR_PLL2SRC_Pos);
   \      0x18E   0x.... 0x....      LDR.W    R1,??DataTable4_5
   \      0x192   0x680A             LDR      R2,[R1, #+0]
   \      0x194   0xF012 0x0203      ANDS     R2,R2,#0x3
   \      0x198   0x6082             STR      R2,[R0, #+8]
   2537            pPeriphClkInit->PLL2.PLL2M = (uint32_t)((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2M) >> RCC_PLL2CFGR_PLL2M_Pos);
   \      0x19A   0x680A             LDR      R2,[R1, #+0]
   \      0x19C   0xF3C2 0x2205      UBFX     R2,R2,#+8,#+6
   \      0x1A0   0x60C2             STR      R2,[R0, #+12]
   2538            pPeriphClkInit->PLL2.PLL2N = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) >> RCC_PLL2DIVR_PLL2N_Pos) + 1U;
   \      0x1A2   0x.... 0x....      LDR.W    R2,??DataTable4_6
   \      0x1A6   0x6813             LDR      R3,[R2, #+0]
   \      0x1A8   0x05DB             LSLS     R3,R3,#+23
   \      0x1AA   0x0DDB             LSRS     R3,R3,#+23
   \      0x1AC   0x1C5B             ADDS     R3,R3,#+1
   \      0x1AE   0x6103             STR      R3,[R0, #+16]
   2539            pPeriphClkInit->PLL2.PLL2P = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2P) >> RCC_PLL2DIVR_PLL2P_Pos) + 1U;
   \      0x1B0   0x6813             LDR      R3,[R2, #+0]
   \      0x1B2   0xF3C3 0x2346      UBFX     R3,R3,#+9,#+7
   \      0x1B6   0x1C5B             ADDS     R3,R3,#+1
   \      0x1B8   0x6143             STR      R3,[R0, #+20]
   2540            pPeriphClkInit->PLL2.PLL2Q = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2Q) >> RCC_PLL2DIVR_PLL2Q_Pos) + 1U;
   \      0x1BA   0x6813             LDR      R3,[R2, #+0]
   \      0x1BC   0xF3C3 0x4306      UBFX     R3,R3,#+16,#+7
   \      0x1C0   0x1C5B             ADDS     R3,R3,#+1
   \      0x1C2   0x6183             STR      R3,[R0, #+24]
   2541            pPeriphClkInit->PLL2.PLL2R = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2R) >> RCC_PLL2DIVR_PLL2R_Pos) + 1U;
   \      0x1C4   0x6812             LDR      R2,[R2, #+0]
   \      0x1C6   0xF3C2 0x6206      UBFX     R2,R2,#+24,#+7
   \      0x1CA   0x1C52             ADDS     R2,R2,#+1
   \      0x1CC   0x61C2             STR      R2,[R0, #+28]
   2542            pPeriphClkInit->PLL2.PLL2RGE = (uint32_t)((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2RGE) >> RCC_PLL2CFGR_PLL2RGE_Pos);
   \      0x1CE   0x6809             LDR      R1,[R1, #+0]
   \      0x1D0   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \      0x1D4   0x6201             STR      R1,[R0, #+32]
   2543            pPeriphClkInit->PLL2.PLL2FRACN = (uint32_t)((RCC->PLL2FRACR & RCC_PLL2FRACR_PLL2FRACN) >> \
   2544                                                        RCC_PLL2FRACR_PLL2FRACN_Pos);
   \      0x1D6   0x.... 0x....      LDR.W    R1,??DataTable4_7
   \      0x1DA   0x6809             LDR      R1,[R1, #+0]
   \      0x1DC   0xF3C1 0x01CC      UBFX     R1,R1,#+3,#+13
   \      0x1E0   0x6281             STR      R1,[R0, #+40]
   2545          
   2546          #if defined(RCC_CR_PLL3ON)
   2547            /* Get the PLL3 Clock configuration -----------------------------------------------*/
   2548            pPeriphClkInit->PLL3.PLL3Source = (uint32_t)((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3SRC) >> RCC_PLL3CFGR_PLL3SRC_Pos);
   \      0x1E2   0x.... 0x....      LDR.W    R1,??DataTable4_8
   \      0x1E6   0x680A             LDR      R2,[R1, #+0]
   \      0x1E8   0xF012 0x0203      ANDS     R2,R2,#0x3
   \      0x1EC   0x6302             STR      R2,[R0, #+48]
   2549            pPeriphClkInit->PLL3.PLL3M = (uint32_t)((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3M) >> RCC_PLL3CFGR_PLL3M_Pos);
   \      0x1EE   0x680A             LDR      R2,[R1, #+0]
   \      0x1F0   0xF3C2 0x2205      UBFX     R2,R2,#+8,#+6
   \      0x1F4   0x6342             STR      R2,[R0, #+52]
   2550            pPeriphClkInit->PLL3.PLL3N = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) >> RCC_PLL3DIVR_PLL3N_Pos) + 1U;
   \      0x1F6   0x.... 0x....      LDR.W    R2,??DataTable4_9
   \      0x1FA   0x6813             LDR      R3,[R2, #+0]
   \      0x1FC   0x05DB             LSLS     R3,R3,#+23
   \      0x1FE   0x0DDB             LSRS     R3,R3,#+23
   \      0x200   0x1C5B             ADDS     R3,R3,#+1
   \      0x202   0x6383             STR      R3,[R0, #+56]
   2551            pPeriphClkInit->PLL3.PLL3P = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3P) >> RCC_PLL3DIVR_PLL3P_Pos) + 1U;
   \      0x204   0x6813             LDR      R3,[R2, #+0]
   \      0x206   0xF3C3 0x2346      UBFX     R3,R3,#+9,#+7
   \      0x20A   0x1C5B             ADDS     R3,R3,#+1
   \      0x20C   0x63C3             STR      R3,[R0, #+60]
   2552            pPeriphClkInit->PLL3.PLL3Q = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3Q) >> RCC_PLL3DIVR_PLL3Q_Pos) + 1U;
   \      0x20E   0x6813             LDR      R3,[R2, #+0]
   \      0x210   0xF3C3 0x4306      UBFX     R3,R3,#+16,#+7
   \      0x214   0x1C5B             ADDS     R3,R3,#+1
   \      0x216   0x6403             STR      R3,[R0, #+64]
   2553            pPeriphClkInit->PLL3.PLL3R = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3R) >> RCC_PLL3DIVR_PLL3R_Pos) + 1U;
   \      0x218   0x6812             LDR      R2,[R2, #+0]
   \      0x21A   0xF3C2 0x6206      UBFX     R2,R2,#+24,#+7
   \      0x21E   0x1C52             ADDS     R2,R2,#+1
   \      0x220   0x6442             STR      R2,[R0, #+68]
   2554            pPeriphClkInit->PLL3.PLL3RGE = (uint32_t)((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3RGE) >> RCC_PLL3CFGR_PLL3RGE_Pos);
   \      0x222   0x6809             LDR      R1,[R1, #+0]
   \      0x224   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \      0x228   0x6481             STR      R1,[R0, #+72]
   2555            pPeriphClkInit->PLL3.PLL3FRACN = (uint32_t)((RCC->PLL3FRACR & RCC_PLL3FRACR_PLL3FRACN) >> \
   2556                                                        RCC_PLL3FRACR_PLL3FRACN_Pos);
   \      0x22A   0x.... 0x....      LDR.W    R1,??DataTable4_10
   \      0x22E   0x6809             LDR      R1,[R1, #+0]
   \      0x230   0xF3C1 0x01CC      UBFX     R1,R1,#+3,#+13
   \      0x234   0x6501             STR      R1,[R0, #+80]
   2557          #endif /* RCC_CR_PLL3ON */
   2558          
   2559            /* Get the USART1 clock source ---------------------------------------------*/
   2560            pPeriphClkInit->Usart1ClockSelection = __HAL_RCC_GET_USART1_SOURCE();
   \      0x236   0x.... 0x....      LDR.W    R1,??DataTable4_11
   \      0x23A   0x680A             LDR      R2,[R1, #+0]
   \      0x23C   0xF012 0x0207      ANDS     R2,R2,#0x7
   \      0x240   0x65C2             STR      R2,[R0, #+92]
   2561          
   2562            /* Get the USART2 clock source ---------------------------------------------*/
   2563            pPeriphClkInit->Usart2ClockSelection = __HAL_RCC_GET_USART2_SOURCE();
   \      0x242   0x680A             LDR      R2,[R1, #+0]
   \      0x244   0xF012 0x0238      ANDS     R2,R2,#0x38
   \      0x248   0x6602             STR      R2,[R0, #+96]
   2564          
   2565            /* Get the USART3 clock source ---------------------------------------------*/
   2566            pPeriphClkInit->Usart3ClockSelection = __HAL_RCC_GET_USART3_SOURCE();
   \      0x24A   0x680A             LDR      R2,[R1, #+0]
   \      0x24C   0xF412 0x72E0      ANDS     R2,R2,#0x1C0
   \      0x250   0x6642             STR      R2,[R0, #+100]
   2567          
   2568          #if defined(UART4)
   2569            /* Get the UART4 clock source ----------------------------------------------*/
   2570            pPeriphClkInit->Uart4ClockSelection = __HAL_RCC_GET_UART4_SOURCE();
   \      0x252   0x680A             LDR      R2,[R1, #+0]
   \      0x254   0xF412 0x6260      ANDS     R2,R2,#0xE00
   \      0x258   0x6682             STR      R2,[R0, #+104]
   2571          #endif /* UART4 */
   2572          
   2573          #if defined(UART5)
   2574            /* Get the UART5 clock source ----------------------------------------------*/
   2575            pPeriphClkInit->Uart5ClockSelection = __HAL_RCC_GET_UART5_SOURCE();
   \      0x25A   0x680A             LDR      R2,[R1, #+0]
   \      0x25C   0xF412 0x42E0      ANDS     R2,R2,#0x7000
   \      0x260   0x66C2             STR      R2,[R0, #+108]
   2576          #endif /* UART5 */
   2577          
   2578          #if defined(USART6)
   2579            /* Get the USART6 clock source ---------------------------------------------*/
   2580            pPeriphClkInit->Usart6ClockSelection = __HAL_RCC_GET_USART6_SOURCE();
   \      0x262   0x680A             LDR      R2,[R1, #+0]
   \      0x264   0xF412 0x3260      ANDS     R2,R2,#0x38000
   \      0x268   0x6702             STR      R2,[R0, #+112]
   2581          #endif /* USART6 */
   2582          
   2583          #if defined(UART7)
   2584            /* Get the UART7 clock source ---------------------------------------------*/
   2585            pPeriphClkInit->Uart7ClockSelection = __HAL_RCC_GET_UART7_SOURCE();
   \      0x26A   0x680A             LDR      R2,[R1, #+0]
   \      0x26C   0xF412 0x12E0      ANDS     R2,R2,#0x1C0000
   \      0x270   0x6742             STR      R2,[R0, #+116]
   2586          #endif /* UART7 */
   2587          
   2588          #if defined(UART8)
   2589            /* Get the UART8 clock source ---------------------------------------------*/
   2590            pPeriphClkInit->Uart8ClockSelection = __HAL_RCC_GET_UART8_SOURCE();
   \      0x272   0x680A             LDR      R2,[R1, #+0]
   \      0x274   0xF412 0x0260      ANDS     R2,R2,#0xE00000
   \      0x278   0x6782             STR      R2,[R0, #+120]
   2591          #endif /* UART8 */
   2592          
   2593          #if defined(UART9)
   2594            /* Get the UART9 clock source ---------------------------------------------*/
   2595            pPeriphClkInit->Uart9ClockSelection = __HAL_RCC_GET_UART9_SOURCE();
   \      0x27A   0x680A             LDR      R2,[R1, #+0]
   \      0x27C   0xF012 0x62E0      ANDS     R2,R2,#0x7000000
   \      0x280   0x67C2             STR      R2,[R0, #+124]
   2596          #endif /* UART9 */
   2597          
   2598          #if defined(USART10)
   2599            /* Get the USART10 clock source ---------------------------------------------*/
   2600            pPeriphClkInit->Usart10ClockSelection = __HAL_RCC_GET_USART10_SOURCE();
   \      0x282   0x6809             LDR      R1,[R1, #+0]
   \      0x284   0xF011 0x5160      ANDS     R1,R1,#0x38000000
   \      0x288   0xF8C0 0x1080      STR      R1,[R0, #+128]
   2601          #endif /* USART10 */
   2602          
   2603          #if defined(USART11)
   2604            /* Get the USART11 clock source ---------------------------------------------*/
   2605            pPeriphClkInit->Usart11ClockSelection = __HAL_RCC_GET_USART11_SOURCE();
   \      0x28C   0x.... 0x....      LDR.W    R1,??DataTable4_12
   \      0x290   0x680A             LDR      R2,[R1, #+0]
   \      0x292   0xF012 0x0207      ANDS     R2,R2,#0x7
   \      0x296   0xF8C0 0x2084      STR      R2,[R0, #+132]
   2606          #endif /* USART11 */
   2607          
   2608          #if defined(UART12)
   2609            /* Get the UART12 clock source ---------------------------------------------*/
   2610            pPeriphClkInit->Uart12ClockSelection = __HAL_RCC_GET_UART12_SOURCE();
   \      0x29A   0x680A             LDR      R2,[R1, #+0]
   \      0x29C   0xF012 0x0270      ANDS     R2,R2,#0x70
   \      0x2A0   0xF8C0 0x2088      STR      R2,[R0, #+136]
   2611          #endif /* UART12 */
   2612          
   2613            /* Get the LPUART1 clock source --------------------------------------------*/
   2614            pPeriphClkInit->Lpuart1ClockSelection = __HAL_RCC_GET_LPUART1_SOURCE();
   \      0x2A4   0x.... 0x....      LDR.W    R2,??DataTable4_13
   \      0x2A8   0x6813             LDR      R3,[R2, #+0]
   \      0x2AA   0xF013 0x63E0      ANDS     R3,R3,#0x7000000
   \      0x2AE   0xF8C0 0x308C      STR      R3,[R0, #+140]
   2615          
   2616            /* Get the I2C1 clock source -----------------------------------------------*/
   2617            pPeriphClkInit->I2c1ClockSelection = __HAL_RCC_GET_I2C1_SOURCE();
   \      0x2B2   0x.... 0x....      LDR.W    R3,??DataTable4_3
   \      0x2B6   0x681C             LDR      R4,[R3, #+0]
   \      0x2B8   0xF414 0x3440      ANDS     R4,R4,#0x30000
   \      0x2BC   0xF8C0 0x4090      STR      R4,[R0, #+144]
   2618          
   2619            /* Get the I2C2 clock source -----------------------------------------------*/
   2620            pPeriphClkInit->I2c2ClockSelection = __HAL_RCC_GET_I2C2_SOURCE();
   \      0x2C0   0x681C             LDR      R4,[R3, #+0]
   \      0x2C2   0xF414 0x2440      ANDS     R4,R4,#0xC0000
   \      0x2C6   0xF8C0 0x4094      STR      R4,[R0, #+148]
   2621          
   2622          #if defined(I2C3)
   2623            /* Get the I2C3 clock source -----------------------------------------------*/
   2624            pPeriphClkInit->I2c3ClockSelection = __HAL_RCC_GET_I2C3_SOURCE();
   \      0x2CA   0x681C             LDR      R4,[R3, #+0]
   \      0x2CC   0xF414 0x1440      ANDS     R4,R4,#0x300000
   \      0x2D0   0xF8C0 0x4098      STR      R4,[R0, #+152]
   2625          #endif /* I2C3 */
   2626          
   2627          #if defined(I2C4)
   2628            /* Get the I2C4 clock source -----------------------------------------------*/
   2629            pPeriphClkInit->I2c4ClockSelection = __HAL_RCC_GET_I2C4_SOURCE();
   \      0x2D4   0x681C             LDR      R4,[R3, #+0]
   \      0x2D6   0xF414 0x0440      ANDS     R4,R4,#0xC00000
   \      0x2DA   0xF8C0 0x409C      STR      R4,[R0, #+156]
   2630          #endif /* I2C4 */
   2631          
   2632            /* Get the I3C1 clock source -----------------------------------------------*/
   2633            pPeriphClkInit->I3c1ClockSelection = __HAL_RCC_GET_I3C1_SOURCE();
   \      0x2DE   0x681C             LDR      R4,[R3, #+0]
   \      0x2E0   0xF014 0x7440      ANDS     R4,R4,#0x3000000
   \      0x2E4   0xF8C0 0x40A0      STR      R4,[R0, #+160]
   2634          
   2635          #if defined(I3C2)
   2636            /* Get the I3C2 clock source -----------------------------------------------*/
   2637            pPeriphClkInit->I3c2ClockSelection = __HAL_RCC_GET_I3C2_SOURCE();
   2638          #endif /* I3C2 */
   2639          
   2640            /* Get the LPTIM1 clock source ---------------------------------------------*/
   2641            pPeriphClkInit->Lptim1ClockSelection = __HAL_RCC_GET_LPTIM1_SOURCE();
   \      0x2E8   0x680C             LDR      R4,[R1, #+0]
   \      0x2EA   0xF414 0x64E0      ANDS     R4,R4,#0x700
   \      0x2EE   0xF8C0 0x40A4      STR      R4,[R0, #+164]
   2642          
   2643            /* Get the LPTIM2 clock source ---------------------------------------------*/
   2644            pPeriphClkInit->Lptim2ClockSelection = __HAL_RCC_GET_LPTIM2_SOURCE();
   \      0x2F2   0x680C             LDR      R4,[R1, #+0]
   \      0x2F4   0xF414 0x44E0      ANDS     R4,R4,#0x7000
   \      0x2F8   0xF8C0 0x40A8      STR      R4,[R0, #+168]
   2645          
   2646          #if defined(LPTIM3)
   2647            /* Get the LPTIM3 clock source ---------------------------------------------*/
   2648            pPeriphClkInit->Lptim3ClockSelection = __HAL_RCC_GET_LPTIM3_SOURCE();
   \      0x2FC   0x680C             LDR      R4,[R1, #+0]
   \      0x2FE   0xF414 0x24E0      ANDS     R4,R4,#0x70000
   \      0x302   0xF8C0 0x40AC      STR      R4,[R0, #+172]
   2649          #endif /* LPTIM3 */
   2650          
   2651          #if defined(LPTIM4)
   2652            /* Get the LPTIM4 clock source ---------------------------------------------*/
   2653            pPeriphClkInit->Lptim4ClockSelection = __HAL_RCC_GET_LPTIM4_SOURCE();
   \      0x306   0x680C             LDR      R4,[R1, #+0]
   \      0x308   0xF414 0x04E0      ANDS     R4,R4,#0x700000
   \      0x30C   0xF8C0 0x40B0      STR      R4,[R0, #+176]
   2654          #endif /* LPTIM4 */
   2655          
   2656          #if defined(LPTIM5)
   2657            /* Get the LPTIM5 clock source ---------------------------------------------*/
   2658            pPeriphClkInit->Lptim5ClockSelection = __HAL_RCC_GET_LPTIM5_SOURCE();
   \      0x310   0x680C             LDR      R4,[R1, #+0]
   \      0x312   0xF014 0x64E0      ANDS     R4,R4,#0x7000000
   \      0x316   0xF8C0 0x40B4      STR      R4,[R0, #+180]
   2659          #endif /* LPTIM5 */
   2660          
   2661          #if defined(LPTIM6)
   2662            /* Get the LPTIM6 clock source ---------------------------------------------*/
   2663            pPeriphClkInit->Lptim6ClockSelection = __HAL_RCC_GET_LPTIM6_SOURCE();
   \      0x31A   0x6809             LDR      R1,[R1, #+0]
   \      0x31C   0xF011 0x41E0      ANDS     R1,R1,#0x70000000
   \      0x320   0xF8C0 0x10B8      STR      R1,[R0, #+184]
   2664          #endif /* LPTIM6 */
   2665          
   2666            /* Get the FDCAN clock source ---------------------------------------------*/
   2667            pPeriphClkInit->FdcanClockSelection = __HAL_RCC_GET_FDCAN_SOURCE();
   \      0x324   0x....             LDR.N    R1,??DataTable2
   \      0x326   0x680C             LDR      R4,[R1, #+0]
   \      0x328   0xF414 0x7440      ANDS     R4,R4,#0x300
   \      0x32C   0xF8C0 0x40BC      STR      R4,[R0, #+188]
   2668          
   2669          #if defined(SAI1)
   2670            /* Get the SAI1 clock source -----------------------------------------------*/
   2671            pPeriphClkInit->Sai1ClockSelection = __HAL_RCC_GET_SAI1_SOURCE();
   \      0x330   0x680C             LDR      R4,[R1, #+0]
   \      0x332   0xF414 0x24E0      ANDS     R4,R4,#0x70000
   \      0x336   0xF8C0 0x40C0      STR      R4,[R0, #+192]
   2672          #endif /* SAI1 */
   2673          
   2674          #if defined(SAI2)
   2675            /* Get the SAI2 clock source -----------------------------------------------*/
   2676            pPeriphClkInit->Sai2ClockSelection = __HAL_RCC_GET_SAI2_SOURCE();
   \      0x33A   0x680C             LDR      R4,[R1, #+0]
   \      0x33C   0xF414 0x1460      ANDS     R4,R4,#0x380000
   \      0x340   0xF8C0 0x40C4      STR      R4,[R0, #+196]
   2677          #endif /* SAI2 */
   2678          
   2679          #if defined(SDMMC1)
   2680            /* Get the SDMMC1 clock source ----------------------------------------------*/
   2681            pPeriphClkInit->Sdmmc1ClockSelection = __HAL_RCC_GET_SDMMC1_SOURCE();
   \      0x344   0x681C             LDR      R4,[R3, #+0]
   \      0x346   0xF014 0x0440      ANDS     R4,R4,#0x40
   \      0x34A   0xF8C0 0x40CC      STR      R4,[R0, #+204]
   2682          #endif /* SDMMC1 */
   2683          
   2684          #if defined(SDMMC2)
   2685            /* Get the SDMMC2 clock source ----------------------------------------------*/
   2686            pPeriphClkInit->Sdmmc2ClockSelection = __HAL_RCC_GET_SDMMC2_SOURCE();
   2687          #endif /* SDMMC2 */
   2688          
   2689            /* Get the ADCDAC clock source ---------------------------------------------*/
   2690            pPeriphClkInit->AdcDacClockSelection = __HAL_RCC_GET_ADCDAC_SOURCE();
   \      0x34E   0x680C             LDR      R4,[R1, #+0]
   \      0x350   0xF014 0x0407      ANDS     R4,R4,#0x7
   \      0x354   0xF8C0 0x40D0      STR      R4,[R0, #+208]
   2691          
   2692            /* Get the DAC low-power clock source ---------------------------------------------*/
   2693            pPeriphClkInit->DacLowPowerClockSelection = __HAL_RCC_GET_DAC_LP_SOURCE();
   \      0x358   0x680C             LDR      R4,[R1, #+0]
   \      0x35A   0xF014 0x0408      ANDS     R4,R4,#0x8
   \      0x35E   0xF8C0 0x40D4      STR      R4,[R0, #+212]
   2694          
   2695          #if defined(OCTOSPI1)
   2696            /* Get the OSPI clock source -----------------------------------------------*/
   2697            pPeriphClkInit->OspiClockSelection = __HAL_RCC_GET_OSPI_SOURCE();
   \      0x362   0x681C             LDR      R4,[R3, #+0]
   \      0x364   0xF014 0x0403      ANDS     R4,R4,#0x3
   \      0x368   0xF8C0 0x40D8      STR      R4,[R0, #+216]
   2698          #endif /* OCTOSPI1 */
   2699          
   2700            /* Get the SPI1 clock source -----------------------------------------------*/
   2701            pPeriphClkInit->Spi1ClockSelection = __HAL_RCC_GET_SPI1_SOURCE();
   \      0x36C   0x6814             LDR      R4,[R2, #+0]
   \      0x36E   0xF014 0x0407      ANDS     R4,R4,#0x7
   \      0x372   0xF8C0 0x40DC      STR      R4,[R0, #+220]
   2702          
   2703            /* Get the SPI2 clock source -----------------------------------------------*/
   2704            pPeriphClkInit->Spi2ClockSelection = __HAL_RCC_GET_SPI2_SOURCE();
   \      0x376   0x6814             LDR      R4,[R2, #+0]
   \      0x378   0xF014 0x0438      ANDS     R4,R4,#0x38
   \      0x37C   0xF8C0 0x40E0      STR      R4,[R0, #+224]
   2705          
   2706            /* Get the SPI3 clock source -----------------------------------------------*/
   2707            pPeriphClkInit->Spi3ClockSelection = __HAL_RCC_GET_SPI3_SOURCE();
   \      0x380   0x6814             LDR      R4,[R2, #+0]
   \      0x382   0xF414 0x74E0      ANDS     R4,R4,#0x1C0
   \      0x386   0xF8C0 0x40E4      STR      R4,[R0, #+228]
   2708          
   2709          #if defined(SPI4)
   2710            /* Get the SPI4 clock source -----------------------------------------------*/
   2711            pPeriphClkInit->Spi4ClockSelection = __HAL_RCC_GET_SPI4_SOURCE();
   \      0x38A   0x6814             LDR      R4,[R2, #+0]
   \      0x38C   0xF414 0x6460      ANDS     R4,R4,#0xE00
   \      0x390   0xF8C0 0x40E8      STR      R4,[R0, #+232]
   2712          #endif /* SPI4 */
   2713          
   2714          #if defined(SPI5)
   2715            /* Get the SPI5 clock source -----------------------------------------------*/
   2716            pPeriphClkInit->Spi5ClockSelection = __HAL_RCC_GET_SPI5_SOURCE();
   \      0x394   0x6814             LDR      R4,[R2, #+0]
   \      0x396   0xF414 0x44E0      ANDS     R4,R4,#0x7000
   \      0x39A   0xF8C0 0x40EC      STR      R4,[R0, #+236]
   2717          #endif /* SPI5 */
   2718          
   2719          #if defined(SPI6)
   2720            /* Get the SPI6 clock source -----------------------------------------------*/
   2721            pPeriphClkInit->Spi6ClockSelection = __HAL_RCC_GET_SPI6_SOURCE();
   \      0x39E   0x6812             LDR      R2,[R2, #+0]
   \      0x3A0   0xF412 0x3260      ANDS     R2,R2,#0x38000
   \      0x3A4   0xF8C0 0x20F0      STR      R2,[R0, #+240]
   2722          #endif /* SPI6 */
   2723          
   2724            /* Get the RTC clock source ------------------------------------------------*/
   2725            pPeriphClkInit->RTCClockSelection = __HAL_RCC_GET_RTC_SOURCE();
   \      0x3A8   0x....             LDR.N    R2,??DataTable2_2
   \      0x3AA   0x6812             LDR      R2,[R2, #+0]
   \      0x3AC   0xF412 0x7240      ANDS     R2,R2,#0x300
   \      0x3B0   0xF8C0 0x20F4      STR      R2,[R0, #+244]
   2726          
   2727            /* Get the RNG clock source ------------------------------------------------*/
   2728            pPeriphClkInit->RngClockSelection = __HAL_RCC_GET_RNG_SOURCE();
   \      0x3B4   0x680A             LDR      R2,[R1, #+0]
   \      0x3B6   0xF012 0x0230      ANDS     R2,R2,#0x30
   \      0x3BA   0xF8C0 0x20C8      STR      R2,[R0, #+200]
   2729          
   2730            /* Get the CKPER clock source ------------------------------------------------*/
   2731            pPeriphClkInit->CkperClockSelection = __HAL_RCC_GET_CLKP_SOURCE();
   \      0x3BE   0x680A             LDR      R2,[R1, #+0]
   \      0x3C0   0xF012 0x4240      ANDS     R2,R2,#0xC0000000
   \      0x3C4   0x6582             STR      R2,[R0, #+88]
   2732          
   2733          #if defined(CEC)
   2734            /* Get the CEC clock source ------------------------------------------------*/
   2735            pPeriphClkInit->CecClockSelection = __HAL_RCC_GET_CEC_SOURCE();
   \      0x3C6   0x6809             LDR      R1,[R1, #+0]
   \      0x3C8   0xF011 0x01C0      ANDS     R1,R1,#0xC0
   \      0x3CC   0xF8C0 0x10F8      STR      R1,[R0, #+248]
   2736          #endif /* CEC */
   2737          
   2738            /* Get the USB clock source ------------------------------------------------*/
   2739            pPeriphClkInit->UsbClockSelection = __HAL_RCC_GET_USB_SOURCE();
   \      0x3D0   0x6819             LDR      R1,[R3, #+0]
   \      0x3D2   0xF011 0x0130      ANDS     R1,R1,#0x30
   \      0x3D6   0xF8C0 0x10FC      STR      R1,[R0, #+252]
   2740          
   2741            /* Get the TIM Prescaler configuration -------------------------------------*/
   2742            if ((RCC->CFGR1 & RCC_CFGR1_TIMPRE) == 0U)
   \      0x3DA   0x.... 0x....      LDR.W    R1,??DataTable4_14
   \      0x3DE   0x6809             LDR      R1,[R1, #+0]
   \      0x3E0   0x0409             LSLS     R1,R1,#+16
   \      0x3E2   0xD403             BMI.N    ??HAL_RCCEx_GetPeriphCLKConfig_0
   2743            {
   2744              pPeriphClkInit->TimPresSelection = RCC_TIMPRES_DEACTIVATED;
   \      0x3E4   0x2100             MOVS     R1,#+0
   \      0x3E6   0xF8C0 0x1100      STR      R1,[R0, #+256]
   \      0x3EA   0xE003             B.N      ??HAL_RCCEx_GetPeriphCLKConfig_1
   2745            }
   2746            else
   2747            {
   2748              pPeriphClkInit->TimPresSelection = RCC_TIMPRES_ACTIVATED;
   \                     ??HAL_RCCEx_GetPeriphCLKConfig_0: (+1)
   \      0x3EC   0xF44F 0x4100      MOV      R1,#+32768
   \      0x3F0   0xF8C0 0x1100      STR      R1,[R0, #+256]
   2749            }
   2750          }
   \                     ??HAL_RCCEx_GetPeriphCLKConfig_1: (+1)
   \      0x3F4   0xBC10             POP      {R4}
   \      0x3F6   0x4770             BX       LR
   2751          
   2752          /**
   2753            * @brief  Returns the PLL1 clock frequencies : PLL1_P_Frequency, PLL1_R_Frequency and PLL1_Q_Frequency
   2754            * @note   The PLL1 clock frequencies computed by this function may not be the real
   2755            *         frequency in the chip. It is calculated based on the predefined
   2756            *         constant and the selected clock source:
   2757            * @note   The function returns values based on HSE_VALUE, HSI_VALUE or CSI Value multiplied/divided by
   2758                      the PLL factors.
   2759            * @note   This function can be used by the user application to compute the
   2760            *         baud-rate for the communication peripherals or configure other parameters.
   2761            *
   2762            * @note   Each time PLL1CLK changes, this function must be called to update the
   2763            *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
   2764            * @param  pPLL1_Clocks pointer to PLL1_ClocksTypeDef structure.
   2765            * @retval None
   2766            */

   \                                 In section .text, align 4, keep-with-next
   2767          void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef *pPLL1_Clocks)
   2768          {
   \                     HAL_RCCEx_GetPLL1ClockFreq: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2769            GPIO_Debug(7);
   \        0x4   0x2007             MOVS     R0,#+7
   \        0x6   0x.... 0x....      BL       GPIO_Debug
   2770          
   2771            uint32_t pll1source;
   2772            uint32_t pll1m;
   2773            uint32_t pll1n;
   2774            uint32_t pll1fracen;
   2775            uint32_t hsivalue;
   2776            float_t fracn1;
   2777            float_t pll1vco;
   2778          
   2779            /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL1M) * PLL1N
   2780            PLL1xCLK = PLL1_VCO / PLL1x
   2781            */
   2782          
   2783            pll1n = (RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N);
   \        0xA   0x.... 0x....      LDR.W    R2,??DataTable4_15
   \        0xE   0x6810             LDR      R0,[R2, #+0]
   \       0x10   0x05C0             LSLS     R0,R0,#+23
   \       0x12   0x0DC0             LSRS     R0,R0,#+23
   \       0x14   0xEE00 0x0A10      VMOV     S0,R0
   2784            pll1source = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
   \       0x18   0x.... 0x....      LDR.W    R3,??DataTable4_16
   \       0x1C   0x681D             LDR      R5,[R3, #+0]
   \       0x1E   0xF015 0x0503      ANDS     R5,R5,#0x3
   2785            pll1m = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos);
   \       0x22   0x6818             LDR      R0,[R3, #+0]
   \       0x24   0xF3C0 0x2005      UBFX     R0,R0,#+8,#+6
   2786            pll1fracen = RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN;
   \       0x28   0x681E             LDR      R6,[R3, #+0]
   \       0x2A   0xF016 0x0610      ANDS     R6,R6,#0x10
   2787            fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
   2788                                                       RCC_PLL1FRACR_PLL1FRACN_Pos));
   \       0x2E   0x.... 0x....      LDR.W    R1,??DataTable4_17
   \       0x32   0x6809             LDR      R1,[R1, #+0]
   \       0x34   0xF3C1 0x01CC      UBFX     R1,R1,#+3,#+13
   \       0x38   0x434E             MULS     R6,R1,R6
   \       0x3A   0xEE00 0x6A90      VMOV     S1,R6
   \       0x3E   0xEEB8 0x1A60      VCVT.F32.U32 S2,S1
   2789          
   2790            if (pll1m != 0U)
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xF000 0x80D0      BEQ.W    ??HAL_RCCEx_GetPLL1ClockFreq_0
   2791            {
   2792              switch (pll1source)
   \       0x48   0x2D01             CMP      R5,#+1
   \       0x4A   0xD004             BEQ.N    ??HAL_RCCEx_GetPLL1ClockFreq_1
   \       0x4C   0xD352             BCC.N    ??HAL_RCCEx_GetPLL1ClockFreq_2
   \       0x4E   0x2D03             CMP      R5,#+3
   \       0x50   0xD039             BEQ.N    ??HAL_RCCEx_GetPLL1ClockFreq_3
   \       0x52   0xD321             BCC.N    ??HAL_RCCEx_GetPLL1ClockFreq_4
   \       0x54   0xE04E             B.N      ??HAL_RCCEx_GetPLL1ClockFreq_2
   2793              {
   2794          
   2795                case RCC_PLL1_SOURCE_HSI:  /* HSI used as PLL1 clock source */
   2796                  hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_1: (+1)
   \       0x56   0x.... 0x....      LDR.W    R1,??DataTable4_18
   \       0x5A   0x.... 0x....      LDR.W    R5,??DataTable4_19
   \       0x5E   0x682D             LDR      R5,[R5, #+0]
   \       0x60   0xF3C5 0x05C1      UBFX     R5,R5,#+3,#+2
   \       0x64   0x40E9             LSRS     R1,R1,R5
   \       0x66   0xEE00 0x1A90      VMOV     S1,R1
   2797                  pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)pll1n + (fracn1 / (float_t)0x2000) + \
   2798                                                                    (float_t)1);
   \       0x6A   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \       0x6E   0xEE01 0x0A90      VMOV     S3,R0
   \       0x72   0xEEF8 0x1A61      VCVT.F32.U32 S3,S3
   \       0x76   0xEEC0 0x0AA1      VDIV.F32 S1,S1,S3
   \       0x7A   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \       0x7E   0xEDDF 0x....      VLDR.W   S3,??DataTable2_3
   \       0x82   0xEE81 0x1A21      VDIV.F32 S2,S2,S3
   \       0x86   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0x8A   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \       0x8E   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0x92   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   2799                  break;
   \       0x96   0xE04D             B.N      ??HAL_RCCEx_GetPLL1ClockFreq_5
   2800          
   2801                case RCC_PLL1_SOURCE_CSI:  /* CSI used as PLL1 clock source */
   2802                  pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)pll1n + (fracn1 / (float_t)0x2000) + \
   2803                                                                     (float_t)1);
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_4: (+1)
   \       0x98   0xEE00 0x0A90      VMOV     S1,R0
   \       0x9C   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \       0xA0   0xEDDF 0x....      VLDR.W   S3,??DataTable2_4
   \       0xA4   0xEEC1 0x0AA0      VDIV.F32 S1,S3,S1
   \       0xA8   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \       0xAC   0xEDDF 0x....      VLDR.W   S3,??DataTable2_3
   \       0xB0   0xEE81 0x1A21      VDIV.F32 S2,S2,S3
   \       0xB4   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0xB8   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \       0xBC   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0xC0   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   2804                  break;
   \       0xC4   0xE036             B.N      ??HAL_RCCEx_GetPLL1ClockFreq_5
   2805          
   2806                case RCC_PLL1_SOURCE_HSE:  /* HSE used as PLL1 clock source */
   2807                  pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)pll1n + (fracn1 / (float_t)0x2000) + \
   2808                                                                     (float_t)1);
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_3: (+1)
   \       0xC6   0xEE00 0x0A90      VMOV     S1,R0
   \       0xCA   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \       0xCE   0xEDDF 0x....      VLDR.W   S3,??DataTable2_5
   \       0xD2   0xEEC1 0x0AA0      VDIV.F32 S1,S3,S1
   \       0xD6   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \       0xDA   0xEDDF 0x....      VLDR.W   S3,??DataTable2_3
   \       0xDE   0xEE81 0x1A21      VDIV.F32 S2,S2,S3
   \       0xE2   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0xE6   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \       0xEA   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0xEE   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   2809                  break;
   \       0xF2   0xE01F             B.N      ??HAL_RCCEx_GetPLL1ClockFreq_5
   2810          
   2811                default:
   2812                  hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_2: (+1)
   \       0xF4   0x.... 0x....      LDR.W    R1,??DataTable4_18
   \       0xF8   0x.... 0x....      LDR.W    R5,??DataTable4_19
   \       0xFC   0x682D             LDR      R5,[R5, #+0]
   \       0xFE   0xF3C5 0x05C1      UBFX     R5,R5,#+3,#+2
   \      0x102   0x40E9             LSRS     R1,R1,R5
   \      0x104   0xEE00 0x1A90      VMOV     S1,R1
   2813                  pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)pll1n + (fracn1 / (float_t)0x2000) + \
   2814                                                                    (float_t)1);
   \      0x108   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \      0x10C   0xEE01 0x0A90      VMOV     S3,R0
   \      0x110   0xEEF8 0x1A61      VCVT.F32.U32 S3,S3
   \      0x114   0xEEC0 0x0AA1      VDIV.F32 S1,S1,S3
   \      0x118   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \      0x11C   0xEDDF 0x....      VLDR.W   S3,??DataTable2_3
   \      0x120   0xEE81 0x1A21      VDIV.F32 S2,S2,S3
   \      0x124   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \      0x128   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x12C   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \      0x130   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   2815                  break;
   2816              }
   2817          
   2818              if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_5: (+1)
   \      0x134   0x.... 0x....      LDR.W    R0,??DataTable4_19
   \      0x138   0x6801             LDR      R1,[R0, #+0]
   \      0x13A   0x0189             LSLS     R1,R1,#+6
   \      0x13C   0xD517             BPL.N    ??HAL_RCCEx_GetPLL1ClockFreq_6
   2819              {
   2820                if (__HAL_RCC_GET_PLL1_CLKOUT_CONFIG(RCC_PLL1_DIVP) != 0U)
   \      0x13E   0x6819             LDR      R1,[R3, #+0]
   \      0x140   0x03C9             LSLS     R1,R1,#+15
   \      0x142   0xD511             BPL.N    ??HAL_RCCEx_GetPLL1ClockFreq_7
   2821                {
   2822                  pPLL1_Clocks->PLL1_P_Frequency = \
   2823                                                   (uint32_t)(float_t)(pll1vco / \
   2824                                                                       ((float_t)(uint32_t)((RCC->PLL1DIVR & \
   2825                                                                                             RCC_PLL1DIVR_PLL1P) >> \
   2826                                                                                            RCC_PLL1DIVR_PLL1P_Pos) + \
   2827                                                                        (float_t)1));
   \      0x144   0x6811             LDR      R1,[R2, #+0]
   \      0x146   0xF3C1 0x2146      UBFX     R1,R1,#+9,#+7
   \      0x14A   0xEE00 0x1A90      VMOV     S1,R1
   \      0x14E   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \      0x152   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x156   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \      0x15A   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \      0x15E   0xEEFC 0x0AE0      VCVT.U32.F32 S1,S1
   \      0x162   0xEDC4 0x0A00      VSTR     S1,[R4, #0]
   \      0x166   0xE004             B.N      ??HAL_RCCEx_GetPLL1ClockFreq_8
   2828                }
   2829                else
   2830                {
   2831                  pPLL1_Clocks->PLL1_P_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_7: (+1)
   \      0x168   0x2100             MOVS     R1,#+0
   \      0x16A   0x6021             STR      R1,[R4, #+0]
   \      0x16C   0xE001             B.N      ??HAL_RCCEx_GetPLL1ClockFreq_8
   2832                }
   2833              }
   2834              else
   2835              {
   2836                pPLL1_Clocks->PLL1_P_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_6: (+1)
   \      0x16E   0x2100             MOVS     R1,#+0
   \      0x170   0x6021             STR      R1,[R4, #+0]
   2837              }
   2838          
   2839              if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_8: (+1)
   \      0x172   0x6801             LDR      R1,[R0, #+0]
   \      0x174   0x0189             LSLS     R1,R1,#+6
   \      0x176   0xD517             BPL.N    ??HAL_RCCEx_GetPLL1ClockFreq_9
   2840              {
   2841                if (__HAL_RCC_GET_PLL1_CLKOUT_CONFIG(RCC_PLL1_DIVQ) != 0U)
   \      0x178   0x6819             LDR      R1,[R3, #+0]
   \      0x17A   0x0389             LSLS     R1,R1,#+14
   \      0x17C   0xD511             BPL.N    ??HAL_RCCEx_GetPLL1ClockFreq_10
   2842                {
   2843                  pPLL1_Clocks->PLL1_Q_Frequency = \
   2844                                                   (uint32_t)(float_t)(pll1vco / \
   2845                                                                       ((float_t)(uint32_t)((RCC->PLL1DIVR & \
   2846                                                                                             RCC_PLL1DIVR_PLL1Q) >> \
   2847                                                                                            RCC_PLL1DIVR_PLL1Q_Pos) + \
   2848                                                                        (float_t)1));
   \      0x17E   0x6811             LDR      R1,[R2, #+0]
   \      0x180   0xF3C1 0x4106      UBFX     R1,R1,#+16,#+7
   \      0x184   0xEE00 0x1A90      VMOV     S1,R1
   \      0x188   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \      0x18C   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x190   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \      0x194   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \      0x198   0xEEFC 0x0AE0      VCVT.U32.F32 S1,S1
   \      0x19C   0xEDC4 0x0A01      VSTR     S1,[R4, #+4]
   \      0x1A0   0xE004             B.N      ??HAL_RCCEx_GetPLL1ClockFreq_11
   2849                }
   2850                else
   2851                {
   2852                  pPLL1_Clocks->PLL1_Q_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_10: (+1)
   \      0x1A2   0x2100             MOVS     R1,#+0
   \      0x1A4   0x6061             STR      R1,[R4, #+4]
   \      0x1A6   0xE001             B.N      ??HAL_RCCEx_GetPLL1ClockFreq_11
   2853                }
   2854              }
   2855              else
   2856              {
   2857                pPLL1_Clocks->PLL1_Q_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_9: (+1)
   \      0x1A8   0x2100             MOVS     R1,#+0
   \      0x1AA   0x6061             STR      R1,[R4, #+4]
   2858              }
   2859          
   2860              if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_11: (+1)
   \      0x1AC   0x6800             LDR      R0,[R0, #+0]
   \      0x1AE   0x0180             LSLS     R0,R0,#+6
   \      0x1B0   0xD517             BPL.N    ??HAL_RCCEx_GetPLL1ClockFreq_12
   2861              {
   2862                if (__HAL_RCC_GET_PLL1_CLKOUT_CONFIG(RCC_PLL1_DIVR) != 0U)
   \      0x1B2   0x6818             LDR      R0,[R3, #+0]
   \      0x1B4   0x0340             LSLS     R0,R0,#+13
   \      0x1B6   0xD511             BPL.N    ??HAL_RCCEx_GetPLL1ClockFreq_13
   2863                {
   2864                  pPLL1_Clocks->PLL1_R_Frequency = \
   2865                                                   (uint32_t)(float_t)(pll1vco / \
   2866                                                                       ((float_t)(uint32_t)((RCC->PLL1DIVR & \
   2867                                                                                             RCC_PLL1DIVR_PLL1R) >> \
   2868                                                                                            RCC_PLL1DIVR_PLL1R_Pos) + \
   2869                                                                        (float_t)1)) ;
   \      0x1B8   0x6810             LDR      R0,[R2, #+0]
   \      0x1BA   0xF3C0 0x6006      UBFX     R0,R0,#+24,#+7
   \      0x1BE   0xEE00 0x0A90      VMOV     S1,R0
   \      0x1C2   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \      0x1C6   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x1CA   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \      0x1CE   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \      0x1D2   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \      0x1D6   0xED84 0x0A02      VSTR     S0,[R4, #+8]
   \      0x1DA   0xE00B             B.N      ??HAL_RCCEx_GetPLL1ClockFreq_14
   2870                }
   2871                else
   2872                {
   2873                  pPLL1_Clocks->PLL1_R_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_13: (+1)
   \      0x1DC   0x2000             MOVS     R0,#+0
   \      0x1DE   0x60A0             STR      R0,[R4, #+8]
   \      0x1E0   0xE008             B.N      ??HAL_RCCEx_GetPLL1ClockFreq_14
   2874                }
   2875              }
   2876              else
   2877              {
   2878                pPLL1_Clocks->PLL1_R_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_12: (+1)
   \      0x1E2   0x2000             MOVS     R0,#+0
   \      0x1E4   0x60A0             STR      R0,[R4, #+8]
   \      0x1E6   0xE005             B.N      ??HAL_RCCEx_GetPLL1ClockFreq_14
   2879              }
   2880          
   2881            }
   2882            else
   2883            {
   2884              pPLL1_Clocks->PLL1_P_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_0: (+1)
   \      0x1E8   0x2000             MOVS     R0,#+0
   \      0x1EA   0x6020             STR      R0,[R4, #+0]
   2885              pPLL1_Clocks->PLL1_Q_Frequency = 0U;
   \      0x1EC   0x2000             MOVS     R0,#+0
   \      0x1EE   0x6060             STR      R0,[R4, #+4]
   2886              pPLL1_Clocks->PLL1_R_Frequency = 0U;
   \      0x1F0   0x2000             MOVS     R0,#+0
   \      0x1F2   0x60A0             STR      R0,[R4, #+8]
   2887            }
   2888          
   2889          }
   \                     ??HAL_RCCEx_GetPLL1ClockFreq_14: (+1)
   \      0x1F4   0xBD70             POP      {R4-R6,PC}
   2890          
   2891          /**
   2892            * @brief  Returns the PLL2 clock frequencies: PLL2_P_Frequency, PLL2_R_Frequency and PLL2_Q_Frequency
   2893            * @note   The PLL2 clock frequencies computed by this function may not be the real
   2894            *         frequency in the chip. It is calculated based on the predefined
   2895            *         constant and the selected clock source:
   2896            * @note   The function returns values based on HSE_VALUE, HSI_VALUE or CSI Value multiplied/divided by
   2897                      the PLL factors.
   2898            * @note   This function can be used by the user application to compute the
   2899            *         baud-rate for the communication peripherals or configure other parameters.
   2900            *
   2901            * @note   Each time PLL2CLK changes, this function must be called to update the
   2902            *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
   2903            * @param  pPLL2_Clocks pointer to PLL2_ClocksTypeDef structure.
   2904            * @retval None
   2905            */

   \                                 In section .text, align 4, keep-with-next
   2906          void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef *pPLL2_Clocks)
   2907          {
   \                     HAL_RCCEx_GetPLL2ClockFreq: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   2908            uint32_t  pll2source;
   2909            uint32_t  pll2m;
   2910            uint32_t  pll2n;
   2911            uint32_t  pll2fracen;
   2912            uint32_t  hsivalue;
   2913            float_t fracn2;
   2914            float_t pll2vco;
   2915          
   2916            /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
   2917            PLL2xCLK = PLL2_VCO / PLL2x
   2918            */
   2919            pll2n = (RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N);
   \        0x2   0x.... 0x....      LDR.W    R3,??DataTable4_6
   \        0x6   0x6819             LDR      R1,[R3, #+0]
   \        0x8   0x05C9             LSLS     R1,R1,#+23
   \        0xA   0x0DC9             LSRS     R1,R1,#+23
   \        0xC   0xEE00 0x1A10      VMOV     S0,R1
   2920            pll2source = (RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2SRC);
   \       0x10   0x.... 0x....      LDR.W    R4,??DataTable4_5
   \       0x14   0x6825             LDR      R5,[R4, #+0]
   \       0x16   0xF015 0x0503      ANDS     R5,R5,#0x3
   2921            pll2m = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2M) >> RCC_PLL2CFGR_PLL2M_Pos);
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0xF3C1 0x2105      UBFX     R1,R1,#+8,#+6
   2922            pll2fracen = RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2FRACEN;
   \       0x20   0x6826             LDR      R6,[R4, #+0]
   \       0x22   0xF016 0x0610      ANDS     R6,R6,#0x10
   2923            fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_PLL2FRACN) >> \
   2924                                                       RCC_PLL2FRACR_PLL2FRACN_Pos));
   \       0x26   0x.... 0x....      LDR.W    R2,??DataTable4_7
   \       0x2A   0x6812             LDR      R2,[R2, #+0]
   \       0x2C   0xF3C2 0x02CC      UBFX     R2,R2,#+3,#+13
   \       0x30   0x4356             MULS     R6,R2,R6
   \       0x32   0xEE00 0x6A90      VMOV     S1,R6
   \       0x36   0xEEB8 0x1A60      VCVT.F32.U32 S2,S1
   2925          
   2926            if (pll2m != 0U)
   \       0x3A   0x2900             CMP      R1,#+0
   \       0x3C   0xF000 0x80CD      BEQ.W    ??HAL_RCCEx_GetPLL2ClockFreq_0
   2927            {
   2928              switch (pll2source)
   \       0x40   0x2D01             CMP      R5,#+1
   \       0x42   0xD004             BEQ.N    ??HAL_RCCEx_GetPLL2ClockFreq_1
   \       0x44   0xD352             BCC.N    ??HAL_RCCEx_GetPLL2ClockFreq_2
   \       0x46   0x2D03             CMP      R5,#+3
   \       0x48   0xD039             BEQ.N    ??HAL_RCCEx_GetPLL2ClockFreq_3
   \       0x4A   0xD321             BCC.N    ??HAL_RCCEx_GetPLL2ClockFreq_4
   \       0x4C   0xE04E             B.N      ??HAL_RCCEx_GetPLL2ClockFreq_2
   2929              {
   2930                case RCC_PLL2_SOURCE_HSI:  /* HSI used as PLL clock source */
   2931                  hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_1: (+1)
   \       0x4E   0x.... 0x....      LDR.W    R2,??DataTable4_18
   \       0x52   0x.... 0x....      LDR.W    R5,??DataTable4_19
   \       0x56   0x682D             LDR      R5,[R5, #+0]
   \       0x58   0xF3C5 0x05C1      UBFX     R5,R5,#+3,#+2
   \       0x5C   0x40EA             LSRS     R2,R2,R5
   \       0x5E   0xEE00 0x2A90      VMOV     S1,R2
   2932                  pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)pll2n + (fracn2 / (float_t)0x2000) + \
   2933                                                                    (float_t)1);
   \       0x62   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \       0x66   0xEE01 0x1A90      VMOV     S3,R1
   \       0x6A   0xEEF8 0x1A61      VCVT.F32.U32 S3,S3
   \       0x6E   0xEEC0 0x0AA1      VDIV.F32 S1,S1,S3
   \       0x72   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \       0x76   0xEDDF 0x....      VLDR.W   S3,??DataTable3
   \       0x7A   0xEE81 0x1A21      VDIV.F32 S2,S2,S3
   \       0x7E   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0x82   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \       0x86   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0x8A   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   2934                  break;
   \       0x8E   0xE04B             B.N      ??HAL_RCCEx_GetPLL2ClockFreq_5
   2935          
   2936                case RCC_PLL2_SOURCE_CSI:  /* CSI used as PLL clock source */
   2937                  pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)pll2n + (fracn2 / (float_t)0x2000) + \
   2938                                                                     (float_t)1);
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_4: (+1)
   \       0x90   0xEE00 0x1A90      VMOV     S1,R1
   \       0x94   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \       0x98   0xEDDF 0x....      VLDR.W   S3,??DataTable3_1
   \       0x9C   0xEEC1 0x0AA0      VDIV.F32 S1,S3,S1
   \       0xA0   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \       0xA4   0xEDDF 0x....      VLDR.W   S3,??DataTable3
   \       0xA8   0xEE81 0x1A21      VDIV.F32 S2,S2,S3
   \       0xAC   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0xB0   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \       0xB4   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0xB8   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   2939                  break;
   \       0xBC   0xE034             B.N      ??HAL_RCCEx_GetPLL2ClockFreq_5
   2940          
   2941                case RCC_PLL2_SOURCE_HSE:  /* HSE used as PLL clock source */
   2942                  pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)pll2n + (fracn2 / (float_t)0x2000) + \
   2943                                                                     (float_t)1);
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_3: (+1)
   \       0xBE   0xEE00 0x1A90      VMOV     S1,R1
   \       0xC2   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \       0xC6   0xEDDF 0x....      VLDR.W   S3,??DataTable3_2
   \       0xCA   0xEEC1 0x0AA0      VDIV.F32 S1,S3,S1
   \       0xCE   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \       0xD2   0xEDDF 0x....      VLDR.W   S3,??DataTable3
   \       0xD6   0xEE81 0x1A21      VDIV.F32 S2,S2,S3
   \       0xDA   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0xDE   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \       0xE2   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0xE6   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   2944                  break;
   \       0xEA   0xE01D             B.N      ??HAL_RCCEx_GetPLL2ClockFreq_5
   2945          
   2946                default:
   2947                  hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_2: (+1)
   \       0xEC   0x....             LDR.N    R2,??DataTable4_18
   \       0xEE   0x....             LDR.N    R5,??DataTable4_19
   \       0xF0   0x682D             LDR      R5,[R5, #+0]
   \       0xF2   0xF3C5 0x05C1      UBFX     R5,R5,#+3,#+2
   \       0xF6   0x40EA             LSRS     R2,R2,R5
   \       0xF8   0xEE00 0x2A90      VMOV     S1,R2
   2948                  pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)pll2n + (fracn2 / (float_t)0x2000) + \
   2949                                                                    (float_t)1);
   \       0xFC   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \      0x100   0xEE01 0x1A90      VMOV     S3,R1
   \      0x104   0xEEF8 0x1A61      VCVT.F32.U32 S3,S3
   \      0x108   0xEEC0 0x0AA1      VDIV.F32 S1,S1,S3
   \      0x10C   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \      0x110   0xEDDF 0x....      VLDR.W   S3,??DataTable3
   \      0x114   0xEE81 0x1A21      VDIV.F32 S2,S2,S3
   \      0x118   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \      0x11C   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x120   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \      0x124   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   2950                  break;
   2951              }
   2952          
   2953              if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_5: (+1)
   \      0x128   0x....             LDR.N    R1,??DataTable4_19
   \      0x12A   0x680A             LDR      R2,[R1, #+0]
   \      0x12C   0x0112             LSLS     R2,R2,#+4
   \      0x12E   0xD517             BPL.N    ??HAL_RCCEx_GetPLL2ClockFreq_6
   2954              {
   2955                if (__HAL_RCC_GET_PLL2_CLKOUT_CONFIG(RCC_PLL2_DIVP) != 0U)
   \      0x130   0x6822             LDR      R2,[R4, #+0]
   \      0x132   0x03D2             LSLS     R2,R2,#+15
   \      0x134   0xD511             BPL.N    ??HAL_RCCEx_GetPLL2ClockFreq_7
   2956                {
   2957                  pPLL2_Clocks->PLL2_P_Frequency = \
   2958                                                   (uint32_t)(float_t)(pll2vco / \
   2959                                                                       ((float_t)(uint32_t)((RCC->PLL2DIVR & \
   2960                                                                                             RCC_PLL2DIVR_PLL2P) >> \
   2961                                                                                            RCC_PLL2DIVR_PLL2P_Pos) + \
   2962                                                                        (float_t)1));
   \      0x136   0x681A             LDR      R2,[R3, #+0]
   \      0x138   0xF3C2 0x2246      UBFX     R2,R2,#+9,#+7
   \      0x13C   0xEE00 0x2A90      VMOV     S1,R2
   \      0x140   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \      0x144   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x148   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \      0x14C   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \      0x150   0xEEFC 0x0AE0      VCVT.U32.F32 S1,S1
   \      0x154   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \      0x158   0xE004             B.N      ??HAL_RCCEx_GetPLL2ClockFreq_8
   2963                }
   2964                else
   2965                {
   2966                  pPLL2_Clocks->PLL2_P_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_7: (+1)
   \      0x15A   0x2200             MOVS     R2,#+0
   \      0x15C   0x6002             STR      R2,[R0, #+0]
   \      0x15E   0xE001             B.N      ??HAL_RCCEx_GetPLL2ClockFreq_8
   2967                }
   2968              }
   2969              else
   2970              {
   2971                pPLL2_Clocks->PLL2_P_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_6: (+1)
   \      0x160   0x2200             MOVS     R2,#+0
   \      0x162   0x6002             STR      R2,[R0, #+0]
   2972              }
   2973          
   2974              if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_8: (+1)
   \      0x164   0x680A             LDR      R2,[R1, #+0]
   \      0x166   0x0112             LSLS     R2,R2,#+4
   \      0x168   0xD517             BPL.N    ??HAL_RCCEx_GetPLL2ClockFreq_9
   2975              {
   2976                if (__HAL_RCC_GET_PLL2_CLKOUT_CONFIG(RCC_PLL2_DIVQ) != 0U)
   \      0x16A   0x6822             LDR      R2,[R4, #+0]
   \      0x16C   0x0392             LSLS     R2,R2,#+14
   \      0x16E   0xD511             BPL.N    ??HAL_RCCEx_GetPLL2ClockFreq_10
   2977                {
   2978                  pPLL2_Clocks->PLL2_Q_Frequency = \
   2979                                                   (uint32_t)(float_t)(pll2vco / \
   2980                                                                       ((float_t)(uint32_t)((RCC->PLL2DIVR & \
   2981                                                                                             RCC_PLL2DIVR_PLL2Q) >> \
   2982                                                                                            RCC_PLL2DIVR_PLL2Q_Pos) + \
   2983                                                                        (float_t)1));
   \      0x170   0x681A             LDR      R2,[R3, #+0]
   \      0x172   0xF3C2 0x4206      UBFX     R2,R2,#+16,#+7
   \      0x176   0xEE00 0x2A90      VMOV     S1,R2
   \      0x17A   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \      0x17E   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x182   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \      0x186   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \      0x18A   0xEEFC 0x0AE0      VCVT.U32.F32 S1,S1
   \      0x18E   0xEDC0 0x0A01      VSTR     S1,[R0, #+4]
   \      0x192   0xE004             B.N      ??HAL_RCCEx_GetPLL2ClockFreq_11
   2984                }
   2985                else
   2986                {
   2987                  pPLL2_Clocks->PLL2_Q_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_10: (+1)
   \      0x194   0x2200             MOVS     R2,#+0
   \      0x196   0x6042             STR      R2,[R0, #+4]
   \      0x198   0xE001             B.N      ??HAL_RCCEx_GetPLL2ClockFreq_11
   2988                }
   2989              }
   2990              else
   2991              {
   2992                pPLL2_Clocks->PLL2_Q_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_9: (+1)
   \      0x19A   0x2200             MOVS     R2,#+0
   \      0x19C   0x6042             STR      R2,[R0, #+4]
   2993              }
   2994          
   2995              if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_11: (+1)
   \      0x19E   0x6809             LDR      R1,[R1, #+0]
   \      0x1A0   0x0109             LSLS     R1,R1,#+4
   \      0x1A2   0xD517             BPL.N    ??HAL_RCCEx_GetPLL2ClockFreq_12
   2996              {
   2997                if (__HAL_RCC_GET_PLL2_CLKOUT_CONFIG(RCC_PLL2_DIVR) != 0U)
   \      0x1A4   0x6821             LDR      R1,[R4, #+0]
   \      0x1A6   0x0349             LSLS     R1,R1,#+13
   \      0x1A8   0xD511             BPL.N    ??HAL_RCCEx_GetPLL2ClockFreq_13
   2998                {
   2999                  pPLL2_Clocks->PLL2_R_Frequency = \
   3000                                                   (uint32_t)(float_t)(pll2vco / \
   3001                                                                       ((float_t)(uint32_t)((RCC->PLL2DIVR & \
   3002                                                                                             RCC_PLL2DIVR_PLL2R) >> \
   3003                                                                                            RCC_PLL2DIVR_PLL2R_Pos) + \
   3004                                                                        (float_t)1));
   \      0x1AA   0x6819             LDR      R1,[R3, #+0]
   \      0x1AC   0xF3C1 0x6106      UBFX     R1,R1,#+24,#+7
   \      0x1B0   0xEE00 0x1A90      VMOV     S1,R1
   \      0x1B4   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \      0x1B8   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x1BC   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \      0x1C0   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \      0x1C4   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \      0x1C8   0xED80 0x0A02      VSTR     S0,[R0, #+8]
   \      0x1CC   0xE00B             B.N      ??HAL_RCCEx_GetPLL2ClockFreq_14
   3005                }
   3006                else
   3007                {
   3008                  pPLL2_Clocks->PLL2_R_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_13: (+1)
   \      0x1CE   0x2100             MOVS     R1,#+0
   \      0x1D0   0x6081             STR      R1,[R0, #+8]
   \      0x1D2   0xE008             B.N      ??HAL_RCCEx_GetPLL2ClockFreq_14
   3009                }
   3010              }
   3011              else
   3012              {
   3013                pPLL2_Clocks->PLL2_R_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_12: (+1)
   \      0x1D4   0x2100             MOVS     R1,#+0
   \      0x1D6   0x6081             STR      R1,[R0, #+8]
   \      0x1D8   0xE005             B.N      ??HAL_RCCEx_GetPLL2ClockFreq_14
   3014              }
   3015            }
   3016            else
   3017            {
   3018              pPLL2_Clocks->PLL2_P_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_0: (+1)
   \      0x1DA   0x2100             MOVS     R1,#+0
   \      0x1DC   0x6001             STR      R1,[R0, #+0]
   3019              pPLL2_Clocks->PLL2_Q_Frequency = 0U;
   \      0x1DE   0x2100             MOVS     R1,#+0
   \      0x1E0   0x6041             STR      R1,[R0, #+4]
   3020              pPLL2_Clocks->PLL2_R_Frequency = 0U;
   \      0x1E2   0x2100             MOVS     R1,#+0
   \      0x1E4   0x6081             STR      R1,[R0, #+8]
   3021            }
   3022          }
   \                     ??HAL_RCCEx_GetPLL2ClockFreq_14: (+1)
   \      0x1E6   0xBC70             POP      {R4-R6}
   \      0x1E8   0x4770             BX       LR
   3023          
   3024          #if defined(RCC_CR_PLL3ON)
   3025          /**
   3026            * @brief  Returns the PLL3 clock frequencies: PLL3_P_Frequency, PLL3_R_Frequency and PLL3_Q_Frequency
   3027            * @note   The PLL3 clock frequencies computed by this function may not be the real
   3028            *         frequency in the chip. It is calculated based on the predefined
   3029            *         constant and the selected clock source:
   3030            * @note   The function returns values based on HSE_VALUE, HSI_VALUE or CSI Value multiplied/divided by
   3031                      the PLL factors.
   3032            * @note   This function can be used by the user application to compute the
   3033            *         baud-rate for the communication peripherals or configure other parameters.
   3034            *
   3035            * @note   Each time PLL3CLK changes, this function must be called to update the
   3036            *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
   3037            * @param  pPLL3_Clocks pointer to PLL3_ClocksTypeDef structure.
   3038            * @retval None
   3039            */

   \                                 In section .text, align 4, keep-with-next
   3040          void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef *pPLL3_Clocks)
   3041          {
   \                     HAL_RCCEx_GetPLL3ClockFreq: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   3042            uint32_t  pll3source;
   3043            uint32_t  pll3m;
   3044            uint32_t  pll3n;
   3045            uint32_t  pll3fracen;
   3046            uint32_t  hsivalue;
   3047            float_t fracn3;
   3048            float_t pll3vco;
   3049          
   3050            /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
   3051            PLL3xCLK = PLL3_VCO / PLL3x
   3052            */
   3053            pll3n = (RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N);
   \        0x2   0x....             LDR.N    R3,??DataTable4_9
   \        0x4   0x6819             LDR      R1,[R3, #+0]
   \        0x6   0x05C9             LSLS     R1,R1,#+23
   \        0x8   0x0DC9             LSRS     R1,R1,#+23
   \        0xA   0xEE00 0x1A10      VMOV     S0,R1
   3054            pll3source = (RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3SRC);
   \        0xE   0x....             LDR.N    R4,??DataTable4_8
   \       0x10   0x6825             LDR      R5,[R4, #+0]
   \       0x12   0xF015 0x0503      ANDS     R5,R5,#0x3
   3055            pll3m = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3M) >> RCC_PLL3CFGR_PLL3M_Pos);
   \       0x16   0x6821             LDR      R1,[R4, #+0]
   \       0x18   0xF3C1 0x2105      UBFX     R1,R1,#+8,#+6
   3056            pll3fracen = RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3FRACEN;
   \       0x1C   0x6826             LDR      R6,[R4, #+0]
   \       0x1E   0xF016 0x0610      ANDS     R6,R6,#0x10
   3057            fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_PLL3FRACN) >> \
   3058                                                       RCC_PLL3FRACR_PLL3FRACN_Pos));
   \       0x22   0x....             LDR.N    R2,??DataTable4_10
   \       0x24   0x6812             LDR      R2,[R2, #+0]
   \       0x26   0xF3C2 0x02CC      UBFX     R2,R2,#+3,#+13
   \       0x2A   0x4356             MULS     R6,R2,R6
   \       0x2C   0xEE00 0x6A90      VMOV     S1,R6
   \       0x30   0xEEB8 0x1A60      VCVT.F32.U32 S2,S1
   3059          
   3060            if (pll3m != 0U)
   \       0x34   0x2900             CMP      R1,#+0
   \       0x36   0xF000 0x80CB      BEQ.W    ??HAL_RCCEx_GetPLL3ClockFreq_0
   3061            {
   3062              switch (pll3source)
   \       0x3A   0x2D01             CMP      R5,#+1
   \       0x3C   0xD004             BEQ.N    ??HAL_RCCEx_GetPLL3ClockFreq_1
   \       0x3E   0xD350             BCC.N    ??HAL_RCCEx_GetPLL3ClockFreq_2
   \       0x40   0x2D03             CMP      R5,#+3
   \       0x42   0xD037             BEQ.N    ??HAL_RCCEx_GetPLL3ClockFreq_3
   \       0x44   0xD31F             BCC.N    ??HAL_RCCEx_GetPLL3ClockFreq_4
   \       0x46   0xE04C             B.N      ??HAL_RCCEx_GetPLL3ClockFreq_2
   3063              {
   3064                case RCC_PLL3_SOURCE_HSI:  /* HSI used as PLL clock source */
   3065                  hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_1: (+1)
   \       0x48   0x....             LDR.N    R2,??DataTable4_18
   \       0x4A   0x....             LDR.N    R5,??DataTable4_19
   \       0x4C   0x682D             LDR      R5,[R5, #+0]
   \       0x4E   0xF3C5 0x05C1      UBFX     R5,R5,#+3,#+2
   \       0x52   0x40EA             LSRS     R2,R2,R5
   \       0x54   0xEE00 0x2A90      VMOV     S1,R2
   3066                  pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)pll3n + (fracn3 / (float_t)0x2000) + \
   3067                                                                    (float_t)1);
   \       0x58   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \       0x5C   0xEE01 0x1A90      VMOV     S3,R1
   \       0x60   0xEEF8 0x1A61      VCVT.F32.U32 S3,S3
   \       0x64   0xEEC0 0x0AA1      VDIV.F32 S1,S1,S3
   \       0x68   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \       0x6C   0xEDDF 0x....      VLDR.W   S3,??DataTable4
   \       0x70   0xEE81 0x1A21      VDIV.F32 S2,S2,S3
   \       0x74   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0x78   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \       0x7C   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0x80   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   3068                  break;
   \       0x84   0xE04B             B.N      ??HAL_RCCEx_GetPLL3ClockFreq_5
   3069          
   3070                case RCC_PLL3_SOURCE_CSI:  /* CSI used as PLL clock source */
   3071                  pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)pll3n + (fracn3 / (float_t)0x2000) + \
   3072                                                                     (float_t)1);
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_4: (+1)
   \       0x86   0xEE00 0x1A90      VMOV     S1,R1
   \       0x8A   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \       0x8E   0xEDDF 0x....      VLDR.W   S3,??DataTable4_1
   \       0x92   0xEEC1 0x0AA0      VDIV.F32 S1,S3,S1
   \       0x96   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \       0x9A   0xEDDF 0x....      VLDR.W   S3,??DataTable4
   \       0x9E   0xEE81 0x1A21      VDIV.F32 S2,S2,S3
   \       0xA2   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0xA6   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \       0xAA   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0xAE   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   3073                  break;
   \       0xB2   0xE034             B.N      ??HAL_RCCEx_GetPLL3ClockFreq_5
   3074          
   3075                case RCC_PLL3_SOURCE_HSE:  /* HSE used as PLL clock source */
   3076                  pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)pll3n + (fracn3 / (float_t)0x2000) + \
   3077                                                                     (float_t)1);
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_3: (+1)
   \       0xB4   0xEE00 0x1A90      VMOV     S1,R1
   \       0xB8   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \       0xBC   0xEDDF 0x....      VLDR.W   S3,??DataTable4_2
   \       0xC0   0xEEC1 0x0AA0      VDIV.F32 S1,S3,S1
   \       0xC4   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \       0xC8   0xEDDF 0x....      VLDR.W   S3,??DataTable4
   \       0xCC   0xEE81 0x1A21      VDIV.F32 S2,S2,S3
   \       0xD0   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0xD4   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \       0xD8   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0xDC   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   3078                  break;
   \       0xE0   0xE01D             B.N      ??HAL_RCCEx_GetPLL3ClockFreq_5
   3079          
   3080                default:
   3081                  hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_2: (+1)
   \       0xE2   0x....             LDR.N    R2,??DataTable4_18
   \       0xE4   0x....             LDR.N    R5,??DataTable4_19
   \       0xE6   0x682D             LDR      R5,[R5, #+0]
   \       0xE8   0xF3C5 0x05C1      UBFX     R5,R5,#+3,#+2
   \       0xEC   0x40EA             LSRS     R2,R2,R5
   \       0xEE   0xEE00 0x2A90      VMOV     S1,R2
   3082                  pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)pll3n + (fracn3 / (float_t)0x2000) + \
   3083                                                                    (float_t)1);
   \       0xF2   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \       0xF6   0xEE01 0x1A90      VMOV     S3,R1
   \       0xFA   0xEEF8 0x1A61      VCVT.F32.U32 S3,S3
   \       0xFE   0xEEC0 0x0AA1      VDIV.F32 S1,S1,S3
   \      0x102   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \      0x106   0xEDDF 0x....      VLDR.W   S3,??DataTable4
   \      0x10A   0xEE81 0x1A21      VDIV.F32 S2,S2,S3
   \      0x10E   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \      0x112   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x116   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \      0x11A   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   3084                  break;
   3085              }
   3086          
   3087              if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_5: (+1)
   \      0x11E   0x....             LDR.N    R1,??DataTable4_19
   \      0x120   0x680A             LDR      R2,[R1, #+0]
   \      0x122   0x0092             LSLS     R2,R2,#+2
   \      0x124   0xD517             BPL.N    ??HAL_RCCEx_GetPLL3ClockFreq_6
   3088              {
   3089                if (__HAL_RCC_GET_PLL3_CLKOUT_CONFIG(RCC_PLL3_DIVP) != 0U)
   \      0x126   0x6822             LDR      R2,[R4, #+0]
   \      0x128   0x03D2             LSLS     R2,R2,#+15
   \      0x12A   0xD511             BPL.N    ??HAL_RCCEx_GetPLL3ClockFreq_7
   3090                {
   3091                  pPLL3_Clocks->PLL3_P_Frequency = \
   3092                                                   (uint32_t)(float_t)(pll3vco / \
   3093                                                                       ((float_t)(uint32_t)((RCC->PLL3DIVR & \
   3094                                                                                             RCC_PLL3DIVR_PLL3P) >> \
   3095                                                                                            RCC_PLL3DIVR_PLL3P_Pos) + \
   3096                                                                        (float_t)1));
   \      0x12C   0x681A             LDR      R2,[R3, #+0]
   \      0x12E   0xF3C2 0x2246      UBFX     R2,R2,#+9,#+7
   \      0x132   0xEE00 0x2A90      VMOV     S1,R2
   \      0x136   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \      0x13A   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x13E   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \      0x142   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \      0x146   0xEEFC 0x0AE0      VCVT.U32.F32 S1,S1
   \      0x14A   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \      0x14E   0xE004             B.N      ??HAL_RCCEx_GetPLL3ClockFreq_8
   3097                }
   3098                else
   3099                {
   3100                  pPLL3_Clocks->PLL3_P_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_7: (+1)
   \      0x150   0x2200             MOVS     R2,#+0
   \      0x152   0x6002             STR      R2,[R0, #+0]
   \      0x154   0xE001             B.N      ??HAL_RCCEx_GetPLL3ClockFreq_8
   3101                }
   3102              }
   3103              else
   3104              {
   3105                pPLL3_Clocks->PLL3_P_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_6: (+1)
   \      0x156   0x2200             MOVS     R2,#+0
   \      0x158   0x6002             STR      R2,[R0, #+0]
   3106              }
   3107          
   3108              if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_8: (+1)
   \      0x15A   0x680A             LDR      R2,[R1, #+0]
   \      0x15C   0x0092             LSLS     R2,R2,#+2
   \      0x15E   0xD517             BPL.N    ??HAL_RCCEx_GetPLL3ClockFreq_9
   3109              {
   3110                if (__HAL_RCC_GET_PLL3_CLKOUT_CONFIG(RCC_PLL3_DIVQ) != 0U)
   \      0x160   0x6822             LDR      R2,[R4, #+0]
   \      0x162   0x0392             LSLS     R2,R2,#+14
   \      0x164   0xD511             BPL.N    ??HAL_RCCEx_GetPLL3ClockFreq_10
   3111                {
   3112                  pPLL3_Clocks->PLL3_Q_Frequency = \
   3113                                                   (uint32_t)(float_t)(pll3vco / \
   3114                                                                       ((float_t)(uint32_t)((RCC->PLL3DIVR & \
   3115                                                                                             RCC_PLL3DIVR_PLL3Q) >> \
   3116                                                                                            RCC_PLL3DIVR_PLL3Q_Pos) + \
   3117                                                                        (float_t)1));
   \      0x166   0x681A             LDR      R2,[R3, #+0]
   \      0x168   0xF3C2 0x4206      UBFX     R2,R2,#+16,#+7
   \      0x16C   0xEE00 0x2A90      VMOV     S1,R2
   \      0x170   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \      0x174   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x178   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \      0x17C   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \      0x180   0xEEFC 0x0AE0      VCVT.U32.F32 S1,S1
   \      0x184   0xEDC0 0x0A01      VSTR     S1,[R0, #+4]
   \      0x188   0xE004             B.N      ??HAL_RCCEx_GetPLL3ClockFreq_11
   3118                }
   3119                else
   3120                {
   3121                  pPLL3_Clocks->PLL3_Q_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_10: (+1)
   \      0x18A   0x2200             MOVS     R2,#+0
   \      0x18C   0x6042             STR      R2,[R0, #+4]
   \      0x18E   0xE001             B.N      ??HAL_RCCEx_GetPLL3ClockFreq_11
   3122                }
   3123              }
   3124              else
   3125              {
   3126                pPLL3_Clocks->PLL3_Q_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_9: (+1)
   \      0x190   0x2200             MOVS     R2,#+0
   \      0x192   0x6042             STR      R2,[R0, #+4]
   3127              }
   3128          
   3129              if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_11: (+1)
   \      0x194   0x6809             LDR      R1,[R1, #+0]
   \      0x196   0x0089             LSLS     R1,R1,#+2
   \      0x198   0xD517             BPL.N    ??HAL_RCCEx_GetPLL3ClockFreq_12
   3130              {
   3131                if (__HAL_RCC_GET_PLL3_CLKOUT_CONFIG(RCC_PLL3_DIVR) != 0U)
   \      0x19A   0x6821             LDR      R1,[R4, #+0]
   \      0x19C   0x0349             LSLS     R1,R1,#+13
   \      0x19E   0xD511             BPL.N    ??HAL_RCCEx_GetPLL3ClockFreq_13
   3132                {
   3133                  pPLL3_Clocks->PLL3_R_Frequency = \
   3134                                                   (uint32_t)(float_t)(pll3vco / \
   3135                                                                       ((float_t)(uint32_t)((RCC->PLL3DIVR & \
   3136                                                                                             RCC_PLL3DIVR_PLL3R) >> \
   3137                                                                                            RCC_PLL3DIVR_PLL3R_Pos) + \
   3138                                                                        (float_t)1));
   \      0x1A0   0x6819             LDR      R1,[R3, #+0]
   \      0x1A2   0xF3C1 0x6106      UBFX     R1,R1,#+24,#+7
   \      0x1A6   0xEE00 0x1A90      VMOV     S1,R1
   \      0x1AA   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \      0x1AE   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x1B2   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \      0x1B6   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \      0x1BA   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \      0x1BE   0xED80 0x0A02      VSTR     S0,[R0, #+8]
   \      0x1C2   0xE00B             B.N      ??HAL_RCCEx_GetPLL3ClockFreq_14
   3139                }
   3140                else
   3141                {
   3142                  pPLL3_Clocks->PLL3_R_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_13: (+1)
   \      0x1C4   0x2100             MOVS     R1,#+0
   \      0x1C6   0x6081             STR      R1,[R0, #+8]
   \      0x1C8   0xE008             B.N      ??HAL_RCCEx_GetPLL3ClockFreq_14
   3143                }
   3144              }
   3145              else
   3146              {
   3147                pPLL3_Clocks->PLL3_R_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_12: (+1)
   \      0x1CA   0x2100             MOVS     R1,#+0
   \      0x1CC   0x6081             STR      R1,[R0, #+8]
   \      0x1CE   0xE005             B.N      ??HAL_RCCEx_GetPLL3ClockFreq_14
   3148              }
   3149            }
   3150            else
   3151            {
   3152              pPLL3_Clocks->PLL3_P_Frequency = 0U;
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_0: (+1)
   \      0x1D0   0x2100             MOVS     R1,#+0
   \      0x1D2   0x6001             STR      R1,[R0, #+0]
   3153              pPLL3_Clocks->PLL3_Q_Frequency = 0U;
   \      0x1D4   0x2100             MOVS     R1,#+0
   \      0x1D6   0x6041             STR      R1,[R0, #+4]
   3154              pPLL3_Clocks->PLL3_R_Frequency = 0U;
   \      0x1D8   0x2100             MOVS     R1,#+0
   \      0x1DA   0x6081             STR      R1,[R0, #+8]
   3155            }
   3156          }
   \                     ??HAL_RCCEx_GetPLL3ClockFreq_14: (+1)
   \      0x1DC   0xBC70             POP      {R4-R6}
   \      0x1DE   0x4770             BX       LR
   3157          #endif /* RCC_CR_PLL3ON */
   3158          
   3159          /**
   3160            * @brief  Return the peripheral clock frequency for peripherals
   3161            * @note   Return 0 if peripheral clock identifier not managed by this API
   3162            * @param  PeriphClk  Peripheral clock identifier
   3163            *         This parameter can be one of the following values:
   3164            *            @arg @ref RCC_PERIPHCLK_USART1  USART1 peripheral clock
   3165            *            @arg @ref RCC_PERIPHCLK_USART2  USART2 peripheral clock
   3166            *            @arg @ref RCC_PERIPHCLK_USART3  USART3 peripheral clock
   3167            *            @arg @ref RCC_PERIPHCLK_UART4   UART4 peripheral clock (*)
   3168            *            @arg @ref RCC_PERIPHCLK_UART5   UART5 peripheral clock (*)
   3169            *            @arg @ref RCC_PERIPHCLK_USART6  USART6 peripheral clock (*)
   3170            *            @arg @ref RCC_PERIPHCLK_UART7   UART7 peripheral clock (*)
   3171            *            @arg @ref RCC_PERIPHCLK_UART8   UART8 peripheral clock (*)
   3172            *            @arg @ref RCC_PERIPHCLK_UART9   UART9 peripheral clock (*)
   3173            *            @arg @ref RCC_PERIPHCLK_USART10 USART10 peripheral clock (*)
   3174            *            @arg @ref RCC_PERIPHCLK_USART11 USART11 peripheral clock (*)
   3175            *            @arg @ref RCC_PERIPHCLK_UART12  UART12 peripheral clock (*)
   3176            *            @arg @ref RCC_PERIPHCLK_LPUART1 LPUART1 peripheral clock
   3177            *            @arg @ref RCC_PERIPHCLK_I2C1    I2C1 peripheral clock
   3178            *            @arg @ref RCC_PERIPHCLK_I2C2    I2C2 peripheral clock
   3179            *            @arg @ref RCC_PERIPHCLK_I2C3    I2C3 peripheral clock (*)
   3180            *            @arg @ref RCC_PERIPHCLK_I2C4    I2C4 peripheral clock (*)
   3181            *            @arg @ref RCC_PERIPHCLK_I3C1    I3C1 peripheral clock
   3182            *            @arg @ref RCC_PERIPHCLK_I3C2    I3C2 peripheral clock (***)
   3183            *            @arg @ref RCC_PERIPHCLK_LPTIM1  LPTIM1 peripheral clock
   3184            *            @arg @ref RCC_PERIPHCLK_LPTIM2  LPTIM2 peripheral clock
   3185            *            @arg @ref RCC_PERIPHCLK_SAI1    SAI1 peripheral clock (*)
   3186            *            @arg @ref RCC_PERIPHCLK_SAI2    SAI2 peripheral clock (*)
   3187            *            @arg @ref RCC_PERIPHCLK_ADCDAC  ADCDAC peripheral clock
   3188            *            @arg @ref RCC_PERIPHCLK_ADC     ADC peripheral clock
   3189            *            @arg @ref RCC_PERIPHCLK_SDMMC1  SDMMC1 peripheral clock (*)
   3190            *            @arg @ref RCC_PERIPHCLK_SDMMC2  SDMMC2 peripheral clock (**)
   3191            *            @arg @ref RCC_PERIPHCLK_CKPER   CKPER peripheral clock
   3192            *            @arg @ref RCC_PERIPHCLK_RTC     RTC peripheral clock
   3193            *            @arg @ref RCC_PERIPHCLK_RNG     RNG peripheral clock
   3194            *            @arg @ref RCC_PERIPHCLK_SPI1    SPI1 peripheral clock
   3195            *            @arg @ref RCC_PERIPHCLK_SPI2    SPI2 peripheral clock
   3196            *            @arg @ref RCC_PERIPHCLK_SPI3    SPI3 peripheral clock
   3197            *            @arg @ref RCC_PERIPHCLK_SPI4    SPI4 peripheral clock (*)
   3198            *            @arg @ref RCC_PERIPHCLK_SPI5    SPI5 peripheral clock (*)
   3199            *            @arg @ref RCC_PERIPHCLK_SPI6    SPI6 peripheral clock (*)
   3200            *            @arg @ref RCC_PERIPHCLK_OSPI    OCTOSPI peripheral clock (*)
   3201            *            @arg @ref RCC_PERIPHCLK_FDCAN   FDCAN peripheral clock
   3202            *            @arg @ref RCC_PERIPHCLK_CEC     CEC peripheral clock (*)
   3203            *            @arg @ref RCC_PERIPHCLK_USB     USB peripheral clock
   3204            *            @arg @ref RCC_PERIPHCLK_LPTIM3  LPTIM3 peripheral clock (*)
   3205            *            @arg @ref RCC_PERIPHCLK_LPTIM4  LPTIM4 peripheral clock (*)
   3206            *            @arg @ref RCC_PERIPHCLK_LPTIM5  LPTIM5 peripheral clock (*)
   3207            *            @arg @ref RCC_PERIPHCLK_LPTIM6  LPTIM6 peripheral clock (*)
   3208            *            @arg @ref RCC_PERIPHCLK_DAC_LP  DAC low-power peripheral clock
   3209            *            @arg @ref RCC_PERIPHCLK_TIM     TIM peripheral clock
   3210            *
   3211            * @retval Frequency in Hz
   3212            *
   3213            *  (*)   : For stm32h56xxx and stm32h57xxx family lines only.
   3214            *  (**)  : For stm32h563xx and stm32h57xxx family lines only.
   3215            *  (***) : For stm32h503xx family line only.
   3216            */

   \                                 In section .text, align 4, keep-with-next
   3217          uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
   3218          {
   \                     HAL_RCCEx_GetPeriphCLKFreq: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   3219            PLL1_ClocksTypeDef pll1_clocks;
   3220            PLL2_ClocksTypeDef pll2_clocks;
   3221          #if defined(RCC_CR_PLL3ON)
   3222            PLL3_ClocksTypeDef pll3_clocks;
   3223          #endif /* RCC_CR_PLL3ON */
   3224          
   3225            uint32_t frequency;
   3226            uint32_t ckpclocksource;
   3227            uint32_t srcclk;
   3228          
   3229            /* Check the parameters */
   3230            assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
   3231          
   3232            if (PeriphClk == RCC_PERIPHCLK_RTC)
   \        0x4   0xF05F 0x7200      MOVS     R2,#+33554432
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x4299             CMP      R1,R3
   \        0xC   0xD139             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_5
   \        0xE   0x4290             CMP      R0,R2
   \       0x10   0xD137             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_5
   3233            {
   3234              /* Get the current RTC source */
   3235              srcclk = __HAL_RCC_GET_RTC_SOURCE();
   \       0x12   0xF8DF 0x1A90      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0
   \       0x16   0x6808             LDR      R0,[R1, #+0]
   \       0x18   0xF410 0x7040      ANDS     R0,R0,#0x300
   3236          
   3237              /* Check if LSE is ready and if RTC clock selection is LSE */
   3238              if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_RTCCLKSOURCE_LSE))
   \       0x1C   0x680A             LDR      R2,[R1, #+0]
   \       0x1E   0x0792             LSLS     R2,R2,#+30
   \       0x20   0xD506             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_6
   \       0x22   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x26   0xD103             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_6
   3239              {
   3240                frequency = LSE_VALUE;
   \       0x28   0xF44F 0x4000      MOV      R0,#+32768
   \       0x2C   0xF001 0xBB1B      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3241              }
   3242              /* Check if LSI is ready and if RTC clock selection is LSI */
   3243              else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_RTCCLKSOURCE_LSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_6: (+1)
   \       0x30   0x6809             LDR      R1,[R1, #+0]
   \       0x32   0x0109             LSLS     R1,R1,#+4
   \       0x34   0xD506             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_8
   \       0x36   0xF5B0 0x7F00      CMP      R0,#+512
   \       0x3A   0xD103             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_8
   3244              {
   3245                frequency = LSI_VALUE;
   \       0x3C   0xF44F 0x40FA      MOV      R0,#+32000
   \       0x40   0xF001 0xBB11      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3246              }
   3247              /* Check if HSE is ready and if RTC clock selection is HSE_DIVx*/
   3248              else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_RTCCLKSOURCE_HSE_DIVx))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_8: (+1)
   \       0x44   0xF8DF 0x1A60      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \       0x48   0x6809             LDR      R1,[R1, #+0]
   \       0x4A   0x0389             LSLS     R1,R1,#+14
   \       0x4C   0xD516             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_9
   \       0x4E   0xF5B0 0x7F40      CMP      R0,#+768
   \       0x52   0xD113             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_9
   3249              {
   3250                if (__HAL_RCC_GET_RTC_HSE_PRESCALER() >= RCC_RTC_HSE_DIV2)
   \       0x54   0xF8DF 0x0A54      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_0+0x8
   \       0x58   0x6801             LDR      R1,[R0, #+0]
   \       0x5A   0xF411 0x517C      ANDS     R1,R1,#0x3F00
   \       0x5E   0xF5B1 0x7F00      CMP      R1,#+512
   \       0x62   0xD308             BCC.N    ??HAL_RCCEx_GetPeriphCLKFreq_10
   3251                {
   3252                  frequency = (HSE_VALUE / ((uint32_t)(__HAL_RCC_GET_RTC_HSE_PRESCALER() >> RCC_CFGR1_RTCPRE_Pos)));
   \       0x64   0xF8DF 0x1A48      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0xC
   \       0x68   0x6800             LDR      R0,[R0, #+0]
   \       0x6A   0xF3C0 0x2005      UBFX     R0,R0,#+8,#+6
   \       0x6E   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \       0x72   0xF001 0xBAF8      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3253                }
   3254                else
   3255                {
   3256                  frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_10: (+1)
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xF001 0xBAF5      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3257                }
   3258          
   3259              }
   3260              /* Clock not enabled for RTC*/
   3261              else
   3262              {
   3263                frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_9: (+1)
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0xF001 0xBAF2      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3264              }
   3265            }
   3266            else
   3267            {
   3268              /* Other external peripheral clock source than RTC */
   3269              switch (PeriphClk)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_5: (+1)
   \       0x82   0x2228             MOVS     R2,#+40
   \       0x84   0x.... 0x....      BL       __iar_llswitch
   \                     `?<Jumptable for HAL_RCCEx_GetPeriphCLKFreq>_0`:
   \       0x88   0x0000'0001        DC32     0x1,0x0        
   \              0x0000'0000
   \       0x90   0x0000'033D        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_11-.+0xFFFFFFFFFFFFFFFC
   \       0x94   0x0000'0002        DC32     0x2,0x0        
   \              0x0000'0000
   \       0x9C   0x0000'03B3        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_12-.+0xFFFFFFFFFFFFFFFC
   \       0xA0   0x0000'0004        DC32     0x4,0x0        
   \              0x0000'0000
   \       0xA8   0x0000'0423        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_13-.+0xFFFFFFFFFFFFFFFC
   \       0xAC   0x0000'0008        DC32     0x8,0x0        
   \              0x0000'0000
   \       0xB4   0x0000'049D        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_14-.+0xFFFFFFFFFFFFFFFC
   \       0xB8   0x0000'0010        DC32     0x10,0x0       
   \              0x0000'0000
   \       0xC0   0x0000'051D        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_15-.+0xFFFFFFFFFFFFFFFC
   \       0xC4   0x0000'0020        DC32     0x20,0x0       
   \              0x0000'0000
   \       0xCC   0x0000'059D        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_16-.+0xFFFFFFFFFFFFFFFC
   \       0xD0   0x0000'0040        DC32     0x40,0x0       
   \              0x0000'0000
   \       0xD8   0x0000'061D        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_17-.+0xFFFFFFFFFFFFFFFC
   \       0xDC   0x0000'0080        DC32     0x80,0x0       
   \              0x0000'0000
   \       0xE4   0x0000'069D        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_18-.+0xFFFFFFFFFFFFFFFC
   \       0xE8   0x0000'0100        DC32     0x100,0x0      
   \              0x0000'0000
   \       0xF0   0x0000'071D        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_19-.+0xFFFFFFFFFFFFFFFC
   \       0xF4   0x0000'0200        DC32     0x200,0x0      
   \              0x0000'0000
   \       0xFC   0x0000'0799        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_20-.+0xFFFFFFFFFFFFFFFC
   \      0x100   0x0000'0400        DC32     0x400,0x0      
   \              0x0000'0000
   \      0x108   0x0000'0815        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_21-.+0xFFFFFFFFFFFFFFFC
   \      0x10C   0x0000'0800        DC32     0x800,0x0      
   \              0x0000'0000
   \      0x114   0x0000'0887        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_22-.+0xFFFFFFFFFFFFFFFC
   \      0x118   0x0000'1000        DC32     0x1000,0x0     
   \              0x0000'0000
   \      0x120   0x0000'08F7        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_23-.+0xFFFFFFFFFFFFFFFC
   \      0x124   0x0000'2000        DC32     0x2000,0x0     
   \              0x0000'0000
   \      0x12C   0x0000'0A0D        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_24-.+0xFFFFFFFFFFFFFFFC
   \      0x130   0x0000'4000        DC32     0x4000,0x0     
   \              0x0000'0000
   \      0x138   0x0000'0A55        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_25-.+0xFFFFFFFFFFFFFFFC
   \      0x13C   0x0000'8000        DC32     0x8000,0x0     
   \              0x0000'0000
   \      0x144   0x0000'0A9D        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_26-.+0xFFFFFFFFFFFFFFFC
   \      0x148   0x0001'0000        DC32     0x10000,0x0    
   \              0x0000'0000
   \      0x150   0x0000'0B39        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_27-.+0xFFFFFFFFFFFFFFFC
   \      0x154   0x0002'0000        DC32     0x20000,0x0    
   \              0x0000'0000
   \      0x15C   0x0000'0B8D        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_28-.+0xFFFFFFFFFFFFFFFC
   \      0x160   0x0004'0000        DC32     0x40000,0x0    
   \              0x0000'0000
   \      0x168   0x0000'0C45        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_29-.+0xFFFFFFFFFFFFFFFC
   \      0x16C   0x0008'0000        DC32     0x80000,0x0    
   \              0x0000'0000
   \      0x174   0x0000'00F5        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_30-.+0xFFFFFFFFFFFFFFFC
   \      0x178   0x0010'0000        DC32     0x100000,0x0   
   \              0x0000'0000
   \      0x180   0x0000'0185        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_31-.+0xFFFFFFFFFFFFFFFC
   \      0x184   0x0020'0000        DC32     0x200000,0x0   
   \              0x0000'0000
   \      0x18C   0x0000'0903        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_32-.+0xFFFFFFFFFFFFFFFC
   \      0x190   0x0040'0000        DC32     0x400000,0x0   
   \              0x0000'0000
   \      0x198   0x0000'0209        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_33-.+0xFFFFFFFFFFFFFFFC
   \      0x19C   0x0400'0000        DC32     0x4000000,0x0  
   \              0x0000'0000
   \      0x1A4   0x0000'1421        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_34-.+0xFFFFFFFFFFFFFFFC
   \      0x1A8   0x0800'0000        DC32     0x8000000,0x0  
   \              0x0000'0000
   \      0x1B0   0x0000'1007        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_35-.+0xFFFFFFFFFFFFFFFC
   \      0x1B4   0x1000'0000        DC32     0x10000000,0x0 
   \              0x0000'0000
   \      0x1BC   0x0000'108D        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_36-.+0xFFFFFFFFFFFFFFFC
   \      0x1C0   0x2000'0000        DC32     0x20000000,0x0 
   \              0x0000'0000
   \      0x1C8   0x0000'1115        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_37-.+0xFFFFFFFFFFFFFFFC
   \      0x1CC   0x4000'0000        DC32     0x40000000,0x0 
   \              0x0000'0000
   \      0x1D4   0x0000'11A1        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_38-.+0xFFFFFFFFFFFFFFFC
   \      0x1D8   0x8000'0000        DC32     0xFFFFFFFF80000000,0x0
   \              0x0000'0000
   \      0x1E0   0x0000'1215        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_39-.+0xFFFFFFFFFFFFFFFC
   \      0x1E4   0x0000'0000        DC32     0x0,0x1        
   \              0x0000'0001
   \      0x1EC   0x0000'1289        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_40-.+0xFFFFFFFFFFFFFFFC
   \      0x1F0   0x0000'0000        DC32     0x0,0x2        
   \              0x0000'0002
   \      0x1F8   0x0000'12FF        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_41-.+0xFFFFFFFFFFFFFFFC
   \      0x1FC   0x0000'0000        DC32     0x0,0x4        
   \              0x0000'0004
   \      0x204   0x0000'0F71        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_42-.+0xFFFFFFFFFFFFFFFC
   \      0x208   0x0000'0000        DC32     0x0,0x8        
   \              0x0000'0008
   \      0x210   0x0000'1371        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_43-.+0xFFFFFFFFFFFFFFFC
   \      0x214   0x0000'0000        DC32     0x0,0x10       
   \              0x0000'0010
   \      0x21C   0x0000'1401        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_44-.+0xFFFFFFFFFFFFFFFC
   \      0x220   0x0000'0000        DC32     0x0,0x20       
   \              0x0000'0020
   \      0x228   0x0000'0C47        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_45-.+0xFFFFFFFFFFFFFFFC
   \      0x22C   0x0000'0000        DC32     0x0,0x40       
   \              0x0000'0040
   \      0x234   0x0000'0CFD        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_46-.+0xFFFFFFFFFFFFFFFC
   \      0x238   0x0000'0000        DC32     0x0,0x80       
   \              0x0000'0080
   \      0x240   0x0000'0DB3        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_47-.+0xFFFFFFFFFFFFFFFC
   \      0x244   0x0000'0000        DC32     0x0,0x100      
   \              0x0000'0100
   \      0x24C   0x0000'0E69        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_48-.+0xFFFFFFFFFFFFFFFC
   \      0x250   0x0000'0000        DC32     0x0,0x200      
   \              0x0000'0200
   \      0x258   0x0000'08AF        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_49-.+0xFFFFFFFFFFFFFFFC
   \      0x25C   0x0000'0000        DC32     0x0,0x400      
   \              0x0000'0400
   \      0x264   0x0000'09D1        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_50-.+0xFFFFFFFFFFFFFFFC
   \      0x268   0x0000'13F9        DC32     ??HAL_RCCEx_GetPeriphCLKFreq_51-.+0xFFFFFFFFFFFFFFFC
   3270              {
   3271          #if defined (SAI1)
   3272                case RCC_PERIPHCLK_SAI1:
   3273          
   3274                  srcclk = __HAL_RCC_GET_SAI1_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_30: (+1)
   \      0x26C   0xF8DF 0x1A30      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_1
   \      0x270   0x6808             LDR      R0,[R1, #+0]
   \      0x272   0xF410 0x20E0      ANDS     R0,R0,#0x70000
   3275          
   3276                  switch (srcclk)
   \      0x276   0x2800             CMP      R0,#+0
   \      0x278   0xD00C             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_52
   \      0x27A   0xF5B0 0x3F80      CMP      R0,#+65536
   \      0x27E   0xD00E             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_53
   \      0x280   0xF5B0 0x3F00      CMP      R0,#+131072
   \      0x284   0xD010             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_54
   \      0x286   0xF5B0 0x3F40      CMP      R0,#+196608
   \      0x28A   0xD012             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_55
   \      0x28C   0xF5B0 0x2F80      CMP      R0,#+262144
   \      0x290   0xD012             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_56
   \      0x292   0xE036             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_57
   3277                  {
   3278                    case RCC_SAI1CLKSOURCE_PLL1Q: /* PLL1Q is the clock source for SAI1 */
   3279                    {
   3280                      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_52: (+1)
   \      0x294   0xA806             ADD      R0,SP,#+24
   \      0x296   0x.... 0x....      BL       HAL_RCCEx_GetPLL1ClockFreq
   3281                      frequency = pll1_clocks.PLL1_Q_Frequency;
   \      0x29A   0x9807             LDR      R0,[SP, #+28]
   3282                      break;
   \      0x29C   0xE032             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_58
   3283                    }
   3284                    case RCC_SAI1CLKSOURCE_PLL2P: /* PLL2P is the clock source for SAI1 */
   3285                    {
   3286                      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_53: (+1)
   \      0x29E   0xA803             ADD      R0,SP,#+12
   \      0x2A0   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3287                      frequency = pll2_clocks.PLL2_P_Frequency;
   \      0x2A4   0x9803             LDR      R0,[SP, #+12]
   3288                      break;
   \      0x2A6   0xE02D             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_58
   3289                    }
   3290                    case RCC_SAI1CLKSOURCE_PLL3P: /* PLLI3P is the clock source for SAI1 */
   3291                    {
   3292                      HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_54: (+1)
   \      0x2A8   0x4668             MOV      R0,SP
   \      0x2AA   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3293                      frequency = pll3_clocks.PLL3_P_Frequency;
   \      0x2AE   0x9800             LDR      R0,[SP, #+0]
   3294                      break;
   \      0x2B0   0xE028             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_58
   3295                    }
   3296                    case RCC_SAI1CLKSOURCE_PIN:
   3297                    {
   3298                      frequency = EXTERNAL_CLOCK_VALUE;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_55: (+1)
   \      0x2B2   0xF8DF 0x09F0      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x4
   3299                      break;
   \      0x2B6   0xE025             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_58
   3300                    }
   3301                    case RCC_SAI1CLKSOURCE_CLKP: /* CLKP is the clock source for SAI1 */
   3302                    {
   3303          
   3304                      ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_56: (+1)
   \      0x2B8   0x6808             LDR      R0,[R1, #+0]
   \      0x2BA   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   3305          
   3306                      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
   \      0x2BE   0xF8DF 0x17E8      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0x2C2   0x680A             LDR      R2,[R1, #+0]
   \      0x2C4   0x0792             LSLS     R2,R2,#+30
   \      0x2C6   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_59
   \      0x2C8   0x2800             CMP      R0,#+0
   \      0x2CA   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_59
   3307                      {
   3308                        /* In Case the CKPER Source is HSI */
   3309                        frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0x2CC   0xF8DF 0x09D8      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0x2D0   0x6809             LDR      R1,[R1, #+0]
   \      0x2D2   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x2D6   0x40C8             LSRS     R0,R0,R1
   \      0x2D8   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_60
   3310                      }
   3311          
   3312                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_59: (+1)
   \      0x2DA   0x680A             LDR      R2,[R1, #+0]
   \      0x2DC   0x0592             LSLS     R2,R2,#+22
   \      0x2DE   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_61
   \      0x2E0   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \      0x2E4   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_61
   3313                      {
   3314                        /* In Case the CKPER Source is CSI */
   3315                        frequency = CSI_VALUE;
   \      0x2E6   0xF8DF 0x09C4      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0x2EA   0xE009             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_60
   3316                      }
   3317          
   3318                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_61: (+1)
   \      0x2EC   0x6809             LDR      R1,[R1, #+0]
   \      0x2EE   0x0389             LSLS     R1,R1,#+14
   \      0x2F0   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_62
   \      0x2F2   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \      0x2F6   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_62
   3319                      {
   3320                        /* In Case the CKPER Source is HSE */
   3321                        frequency = HSE_VALUE;
   \      0x2F8   0xF8DF 0x07B4      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_0+0xC
   \      0x2FC   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_60
   3322                      }
   3323          
   3324                      else
   3325                      {
   3326                        /* In Case the CKPER is disabled*/
   3327                        frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_62: (+1)
   \      0x2FE   0x2000             MOVS     R0,#+0
   3328                      }
   3329          
   3330                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_60: (+1)
   \      0x300   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_58
   3331                    }
   3332                    default :
   3333                    {
   3334                      frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_57: (+1)
   \      0x302   0x2000             MOVS     R0,#+0
   3335                      break;
   3336                    }
   3337                  }
   3338                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_58: (+1)
   \      0x304   0xF001 0xB9AF      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3339          #endif /*SAI1*/
   3340          
   3341          #if defined(SAI2)
   3342                case RCC_PERIPHCLK_SAI2:
   3343          
   3344                  srcclk = __HAL_RCC_GET_SAI2_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_31: (+1)
   \      0x308   0xF8DF 0x1994      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_1
   \      0x30C   0x6808             LDR      R0,[R1, #+0]
   \      0x30E   0xF410 0x1060      ANDS     R0,R0,#0x380000
   3345          
   3346                  switch (srcclk)
   \      0x312   0x2800             CMP      R0,#+0
   \      0x314   0xD00C             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_63
   \      0x316   0xF5B0 0x2F00      CMP      R0,#+524288
   \      0x31A   0xD00E             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_64
   \      0x31C   0xF5B0 0x1F80      CMP      R0,#+1048576
   \      0x320   0xD010             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_65
   \      0x322   0xF5B0 0x1FC0      CMP      R0,#+1572864
   \      0x326   0xD012             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_66
   \      0x328   0xF5B0 0x1F00      CMP      R0,#+2097152
   \      0x32C   0xD012             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_67
   \      0x32E   0xE036             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_68
   3347                  {
   3348                    case RCC_SAI2CLKSOURCE_PLL1Q: /* PLL1Q is the clock source for SAI2 */
   3349                    {
   3350                      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_63: (+1)
   \      0x330   0xA806             ADD      R0,SP,#+24
   \      0x332   0x.... 0x....      BL       HAL_RCCEx_GetPLL1ClockFreq
   3351                      frequency = pll1_clocks.PLL1_Q_Frequency;
   \      0x336   0x9807             LDR      R0,[SP, #+28]
   3352                      break;
   \      0x338   0xE032             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_69
   3353                    }
   3354                    case RCC_SAI2CLKSOURCE_PLL2P: /* PLL2P is the clock source for SAI2 */
   3355                    {
   3356                      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_64: (+1)
   \      0x33A   0xA803             ADD      R0,SP,#+12
   \      0x33C   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3357                      frequency = pll2_clocks.PLL2_P_Frequency;
   \      0x340   0x9803             LDR      R0,[SP, #+12]
   3358                      break;
   \      0x342   0xE02D             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_69
   3359                    }
   3360                    case RCC_SAI2CLKSOURCE_PLL3P: /* PLLI3P is the clock source for SAI2 */
   3361                    {
   3362                      HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_65: (+1)
   \      0x344   0x4668             MOV      R0,SP
   \      0x346   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3363                      frequency = pll3_clocks.PLL3_P_Frequency;
   \      0x34A   0x9800             LDR      R0,[SP, #+0]
   3364                      break;
   \      0x34C   0xE028             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_69
   3365                    }
   3366                    case RCC_SAI2CLKSOURCE_PIN:
   3367                    {
   3368                      frequency = EXTERNAL_CLOCK_VALUE;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_66: (+1)
   \      0x34E   0xF8DF 0x0954      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x4
   3369                      break;
   \      0x352   0xE025             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_69
   3370                    }
   3371                    case RCC_SAI2CLKSOURCE_CLKP: /* CLKP is the clock source for SAI2 */
   3372                    {
   3373          
   3374                      ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_67: (+1)
   \      0x354   0x6808             LDR      R0,[R1, #+0]
   \      0x356   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   3375          
   3376                      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
   \      0x35A   0xF8DF 0x174C      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0x35E   0x680A             LDR      R2,[R1, #+0]
   \      0x360   0x0792             LSLS     R2,R2,#+30
   \      0x362   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_70
   \      0x364   0x2800             CMP      R0,#+0
   \      0x366   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_70
   3377                      {
   3378                        /* In Case the CKPER Source is HSI */
   3379                        frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0x368   0xF8DF 0x093C      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0x36C   0x6809             LDR      R1,[R1, #+0]
   \      0x36E   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x372   0x40C8             LSRS     R0,R0,R1
   \      0x374   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_71
   3380                      }
   3381          
   3382                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_70: (+1)
   \      0x376   0x680A             LDR      R2,[R1, #+0]
   \      0x378   0x0592             LSLS     R2,R2,#+22
   \      0x37A   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_72
   \      0x37C   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \      0x380   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_72
   3383                      {
   3384                        /* In Case the CKPER Source is CSI */
   3385                        frequency = CSI_VALUE;
   \      0x382   0xF8DF 0x0928      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0x386   0xE009             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_71
   3386                      }
   3387          
   3388                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_72: (+1)
   \      0x388   0x6809             LDR      R1,[R1, #+0]
   \      0x38A   0x0389             LSLS     R1,R1,#+14
   \      0x38C   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_73
   \      0x38E   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \      0x392   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_73
   3389                      {
   3390                        /* In Case the CKPER Source is HSE */
   3391                        frequency = HSE_VALUE;
   \      0x394   0xF8DF 0x0718      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_0+0xC
   \      0x398   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_71
   3392                      }
   3393          
   3394                      else
   3395                      {
   3396                        /* In Case the CKPER is disabled*/
   3397                        frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_73: (+1)
   \      0x39A   0x2000             MOVS     R0,#+0
   3398                      }
   3399          
   3400                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_71: (+1)
   \      0x39C   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_69
   3401                    }
   3402                    default :
   3403                    {
   3404                      frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_68: (+1)
   \      0x39E   0x2000             MOVS     R0,#+0
   3405                      break;
   3406                    }
   3407                  }
   3408                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_69: (+1)
   \      0x3A0   0xF001 0xB961      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3409          #endif /* SAI2 */
   3410          
   3411          #if defined(SDMMC1)
   3412                case RCC_PERIPHCLK_SDMMC1:
   3413                  srcclk = __HAL_RCC_GET_SDMMC1_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_33: (+1)
   \      0x3A4   0xF8DF 0x0908      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x10
   \      0x3A8   0x6800             LDR      R0,[R0, #+0]
   \      0x3AA   0xF010 0x0040      ANDS     R0,R0,#0x40
   3414                  if (srcclk == RCC_SDMMC1CLKSOURCE_PLL1Q)
   \      0x3AE   0x2800             CMP      R0,#+0
   \      0x3B0   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_74
   3415                  {
   3416                    HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
   \      0x3B2   0xA806             ADD      R0,SP,#+24
   \      0x3B4   0x.... 0x....      BL       HAL_RCCEx_GetPLL1ClockFreq
   3417                    frequency = pll1_clocks.PLL1_Q_Frequency;
   \      0x3B8   0x9807             LDR      R0,[SP, #+28]
   \      0x3BA   0xE007             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_75
   3418                  }
   3419                  else if (srcclk == RCC_SDMMC1CLKSOURCE_PLL2R)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_74: (+1)
   \      0x3BC   0x2840             CMP      R0,#+64
   \      0x3BE   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_76
   3420                  {
   3421                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0x3C0   0xA803             ADD      R0,SP,#+12
   \      0x3C2   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3422                    frequency = pll2_clocks.PLL2_R_Frequency;
   \      0x3C6   0x9805             LDR      R0,[SP, #+20]
   \      0x3C8   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_75
   3423                  }
   3424                  else
   3425                  {
   3426                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_76: (+1)
   \      0x3CA   0x2000             MOVS     R0,#+0
   3427                  }
   3428                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_75: (+1)
   \      0x3CC   0xF001 0xB94B      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3429          #endif /* SDMMC1 */
   3430          
   3431          #if defined(SDMMC2)
   3432                case RCC_PERIPHCLK_SDMMC2:
   3433                  srcclk = __HAL_RCC_GET_SDMMC2_SOURCE();
   3434                  if (srcclk == RCC_SDMMC2CLKSOURCE_PLL1Q)
   3435                  {
   3436                    HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
   3437                    frequency = pll1_clocks.PLL1_Q_Frequency;
   3438                  }
   3439                  else if (srcclk == RCC_SDMMC2CLKSOURCE_PLL2R)
   3440                  {
   3441                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   3442                    frequency = pll2_clocks.PLL2_R_Frequency;
   3443                  }
   3444                  else
   3445                  {
   3446                    frequency = 0U;
   3447                  }
   3448                  break;
   3449          #endif /* SDMMC2 */
   3450          
   3451                case RCC_PERIPHCLK_USART1:
   3452                  /* Get the current USART1 source */
   3453                  srcclk = __HAL_RCC_GET_USART1_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_11: (+1)
   \      0x3D0   0xF8DF 0x08E0      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x14
   \      0x3D4   0x6800             LDR      R0,[R0, #+0]
   \      0x3D6   0xF010 0x0007      ANDS     R0,R0,#0x7
   3454          
   3455                  if (srcclk == RCC_USART1CLKSOURCE_PCLK2)
   \      0x3DA   0x2800             CMP      R0,#+0
   \      0x3DC   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_77
   3456                  {
   3457                    frequency = HAL_RCC_GetPCLK2Freq();
   \      0x3DE   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \      0x3E2   0xE034             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_78
   3458                  }
   3459                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_USART1CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_77: (+1)
   \      0x3E4   0xF8DF 0x16C0      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0x3E8   0x680A             LDR      R2,[R1, #+0]
   \      0x3EA   0x0112             LSLS     R2,R2,#+4
   \      0x3EC   0xD506             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_79
   \      0x3EE   0x2801             CMP      R0,#+1
   \      0x3F0   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_79
   3460                  {
   3461                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0x3F2   0xA803             ADD      R0,SP,#+12
   \      0x3F4   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3462                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \      0x3F8   0x9804             LDR      R0,[SP, #+16]
   \      0x3FA   0xE028             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_78
   3463                  }
   3464          #if defined(RCC_USART1CLKSOURCE_PLL3Q)
   3465                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_USART1CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_79: (+1)
   \      0x3FC   0x680A             LDR      R2,[R1, #+0]
   \      0x3FE   0x0092             LSLS     R2,R2,#+2
   \      0x400   0xD506             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_80
   \      0x402   0x2802             CMP      R0,#+2
   \      0x404   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_80
   3466                  {
   3467                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0x406   0x4668             MOV      R0,SP
   \      0x408   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3468                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \      0x40C   0x9801             LDR      R0,[SP, #+4]
   \      0x40E   0xE01E             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_78
   3469                  }
   3470          #endif /* RCC_USART1CLKSOURCE_PLL3Q */
   3471                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART1CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_80: (+1)
   \      0x410   0x680A             LDR      R2,[R1, #+0]
   \      0x412   0x0792             LSLS     R2,R2,#+30
   \      0x414   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_81
   \      0x416   0x2803             CMP      R0,#+3
   \      0x418   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_81
   3472                  {
   3473                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0x41A   0xF8DF 0x088C      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0x41E   0x6809             LDR      R1,[R1, #+0]
   \      0x420   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x424   0x40C8             LSRS     R0,R0,R1
   \      0x426   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_78
   3474                  }
   3475                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_USART1CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_81: (+1)
   \      0x428   0x6809             LDR      R1,[R1, #+0]
   \      0x42A   0x0589             LSLS     R1,R1,#+22
   \      0x42C   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_82
   \      0x42E   0x2804             CMP      R0,#+4
   \      0x430   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_82
   3476                  {
   3477                    frequency = CSI_VALUE;
   \      0x432   0xF8DF 0x0878      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0x436   0xE00A             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_78
   3478                  }
   3479                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART1CLKSOURCE_LSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_82: (+1)
   \      0x438   0xF8DF 0x1668      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0
   \      0x43C   0x6809             LDR      R1,[R1, #+0]
   \      0x43E   0x0789             LSLS     R1,R1,#+30
   \      0x440   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_83
   \      0x442   0x2805             CMP      R0,#+5
   \      0x444   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_83
   3480                  {
   3481                    frequency = LSE_VALUE;
   \      0x446   0xF44F 0x4000      MOV      R0,#+32768
   \      0x44A   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_78
   3482                  }
   3483                  /* Clock not enabled for USART1 */
   3484                  else
   3485                  {
   3486                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_83: (+1)
   \      0x44C   0x2000             MOVS     R0,#+0
   3487                  }
   3488                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_78: (+1)
   \      0x44E   0xF001 0xB90A      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3489          
   3490                case RCC_PERIPHCLK_USART2:
   3491                  /* Get the current USART2 source */
   3492                  srcclk = __HAL_RCC_GET_USART2_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_12: (+1)
   \      0x452   0xF8DF 0x0860      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x14
   \      0x456   0x6800             LDR      R0,[R0, #+0]
   \      0x458   0xF010 0x0038      ANDS     R0,R0,#0x38
   3493          
   3494                  if (srcclk == RCC_USART2CLKSOURCE_PCLK1)
   \      0x45C   0x2800             CMP      R0,#+0
   \      0x45E   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_84
   3495                  {
   3496                    frequency = HAL_RCC_GetPCLK1Freq();
   \      0x460   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0x464   0xE031             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_85
   3497                  }
   3498                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_USART2CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_84: (+1)
   \      0x466   0xF8DF 0x1640      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0x46A   0x680A             LDR      R2,[R1, #+0]
   \      0x46C   0x0112             LSLS     R2,R2,#+4
   \      0x46E   0xD506             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_86
   \      0x470   0x2808             CMP      R0,#+8
   \      0x472   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_86
   3499                  {
   3500                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0x474   0xA803             ADD      R0,SP,#+12
   \      0x476   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3501                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \      0x47A   0x9804             LDR      R0,[SP, #+16]
   \      0x47C   0xE025             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_85
   3502                  }
   3503          #if defined(RCC_USART2CLKSOURCE_PLL3Q)
   3504                  else if ((srcclk == RCC_USART2CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_86: (+1)
   \      0x47E   0x2810             CMP      R0,#+16
   \      0x480   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_87
   3505                  {
   3506                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0x482   0x4668             MOV      R0,SP
   \      0x484   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3507                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \      0x488   0x9801             LDR      R0,[SP, #+4]
   \      0x48A   0xE01E             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_85
   3508                  }
   3509          #endif /* RCC_USART2CLKSOURCE_PLL3Q */
   3510                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART2CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_87: (+1)
   \      0x48C   0x680A             LDR      R2,[R1, #+0]
   \      0x48E   0x0792             LSLS     R2,R2,#+30
   \      0x490   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_88
   \      0x492   0x2818             CMP      R0,#+24
   \      0x494   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_88
   3511                  {
   3512                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0x496   0xF8DF 0x0810      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0x49A   0x6809             LDR      R1,[R1, #+0]
   \      0x49C   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x4A0   0x40C8             LSRS     R0,R0,R1
   \      0x4A2   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_85
   3513                  }
   3514                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_USART2CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_88: (+1)
   \      0x4A4   0x6809             LDR      R1,[R1, #+0]
   \      0x4A6   0x0589             LSLS     R1,R1,#+22
   \      0x4A8   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_89
   \      0x4AA   0x2820             CMP      R0,#+32
   \      0x4AC   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_89
   3515                  {
   3516                    frequency = CSI_VALUE;
   \      0x4AE   0xF8DF 0x07FC      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0x4B2   0xE00A             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_85
   3517                  }
   3518                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART2CLKSOURCE_LSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_89: (+1)
   \      0x4B4   0xF8DF 0x15EC      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0
   \      0x4B8   0x6809             LDR      R1,[R1, #+0]
   \      0x4BA   0x0789             LSLS     R1,R1,#+30
   \      0x4BC   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_90
   \      0x4BE   0x2828             CMP      R0,#+40
   \      0x4C0   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_90
   3519                  {
   3520                    frequency = LSE_VALUE;
   \      0x4C2   0xF44F 0x4000      MOV      R0,#+32768
   \      0x4C6   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_85
   3521                  }
   3522                  /* Clock not enabled for USART2 */
   3523                  else
   3524                  {
   3525                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_90: (+1)
   \      0x4C8   0x2000             MOVS     R0,#+0
   3526                  }
   3527                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_85: (+1)
   \      0x4CA   0xF001 0xB8CC      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3528          
   3529                case RCC_PERIPHCLK_USART3:
   3530                  /* Get the current USART3 source */
   3531                  srcclk = __HAL_RCC_GET_USART3_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_13: (+1)
   \      0x4CE   0xF8DF 0x07E4      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x14
   \      0x4D2   0x6800             LDR      R0,[R0, #+0]
   \      0x4D4   0xF410 0x70E0      ANDS     R0,R0,#0x1C0
   3532          
   3533                  if (srcclk == RCC_USART3CLKSOURCE_PCLK1)
   \      0x4D8   0x2800             CMP      R0,#+0
   \      0x4DA   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_91
   3534                  {
   3535                    frequency = HAL_RCC_GetPCLK1Freq();
   \      0x4DC   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0x4E0   0xE036             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_92
   3536                  }
   3537                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_USART3CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_91: (+1)
   \      0x4E2   0xF8DF 0x15C4      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0x4E6   0x680A             LDR      R2,[R1, #+0]
   \      0x4E8   0x0112             LSLS     R2,R2,#+4
   \      0x4EA   0xD506             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_93
   \      0x4EC   0x2840             CMP      R0,#+64
   \      0x4EE   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_93
   3538                  {
   3539                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0x4F0   0xA803             ADD      R0,SP,#+12
   \      0x4F2   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3540                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \      0x4F6   0x9804             LDR      R0,[SP, #+16]
   \      0x4F8   0xE02A             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_92
   3541                  }
   3542          #if defined(RCC_USART3CLKSOURCE_PLL3Q)
   3543                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_USART3CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_93: (+1)
   \      0x4FA   0x680A             LDR      R2,[R1, #+0]
   \      0x4FC   0x0092             LSLS     R2,R2,#+2
   \      0x4FE   0xD506             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_94
   \      0x500   0x2880             CMP      R0,#+128
   \      0x502   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_94
   3544                  {
   3545                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0x504   0x4668             MOV      R0,SP
   \      0x506   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3546                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \      0x50A   0x9801             LDR      R0,[SP, #+4]
   \      0x50C   0xE020             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_92
   3547                  }
   3548          #endif /* RCC_USART3CLKSOURCE_PLL3S */
   3549                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART3CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_94: (+1)
   \      0x50E   0x680A             LDR      R2,[R1, #+0]
   \      0x510   0x0792             LSLS     R2,R2,#+30
   \      0x512   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_95
   \      0x514   0x28C0             CMP      R0,#+192
   \      0x516   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_95
   3550                  {
   3551                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0x518   0xF8DF 0x078C      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0x51C   0x6809             LDR      R1,[R1, #+0]
   \      0x51E   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x522   0x40C8             LSRS     R0,R0,R1
   \      0x524   0xE014             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_92
   3552                  }
   3553                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_USART3CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_95: (+1)
   \      0x526   0x6809             LDR      R1,[R1, #+0]
   \      0x528   0x0589             LSLS     R1,R1,#+22
   \      0x52A   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_96
   \      0x52C   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x530   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_96
   3554                  {
   3555                    frequency = CSI_VALUE;
   \      0x532   0xF8DF 0x0778      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0x536   0xE00B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_92
   3556                  }
   3557                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART3CLKSOURCE_LSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_96: (+1)
   \      0x538   0xF8DF 0x1568      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0
   \      0x53C   0x6809             LDR      R1,[R1, #+0]
   \      0x53E   0x0789             LSLS     R1,R1,#+30
   \      0x540   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_97
   \      0x542   0xF5B0 0x7FA0      CMP      R0,#+320
   \      0x546   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_97
   3558                  {
   3559                    frequency = LSE_VALUE;
   \      0x548   0xF44F 0x4000      MOV      R0,#+32768
   \      0x54C   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_92
   3560                  }
   3561                  /* Clock not enabled for USART3 */
   3562                  else
   3563                  {
   3564                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_97: (+1)
   \      0x54E   0x2000             MOVS     R0,#+0
   3565                  }
   3566                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_92: (+1)
   \      0x550   0xF001 0xB889      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3567          
   3568          #if defined(UART4)
   3569                case RCC_PERIPHCLK_UART4:
   3570                  /* Get the current UART4 source */
   3571                  srcclk = __HAL_RCC_GET_UART4_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_14: (+1)
   \      0x554   0xF8DF 0x075C      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x14
   \      0x558   0x6800             LDR      R0,[R0, #+0]
   \      0x55A   0xF410 0x6060      ANDS     R0,R0,#0xE00
   3572          
   3573                  if (srcclk == RCC_UART4CLKSOURCE_PCLK1)
   \      0x55E   0x2800             CMP      R0,#+0
   \      0x560   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_98
   3574                  {
   3575                    frequency = HAL_RCC_GetPCLK1Freq();
   \      0x562   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0x566   0xE039             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_99
   3576                  }
   3577                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_UART4CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_98: (+1)
   \      0x568   0xF8DF 0x153C      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0x56C   0x680A             LDR      R2,[R1, #+0]
   \      0x56E   0x0112             LSLS     R2,R2,#+4
   \      0x570   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_100
   \      0x572   0xF5B0 0x7F00      CMP      R0,#+512
   \      0x576   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_100
   3578                  {
   3579                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0x578   0xA803             ADD      R0,SP,#+12
   \      0x57A   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3580                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \      0x57E   0x9804             LDR      R0,[SP, #+16]
   \      0x580   0xE02C             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_99
   3581                  }
   3582                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_UART4CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_100: (+1)
   \      0x582   0x680A             LDR      R2,[R1, #+0]
   \      0x584   0x0092             LSLS     R2,R2,#+2
   \      0x586   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_101
   \      0x588   0xF5B0 0x6F80      CMP      R0,#+1024
   \      0x58C   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_101
   3583                  {
   3584                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0x58E   0x4668             MOV      R0,SP
   \      0x590   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3585                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \      0x594   0x9801             LDR      R0,[SP, #+4]
   \      0x596   0xE021             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_99
   3586                  }
   3587                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART4CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_101: (+1)
   \      0x598   0x680A             LDR      R2,[R1, #+0]
   \      0x59A   0x0792             LSLS     R2,R2,#+30
   \      0x59C   0xD509             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_102
   \      0x59E   0xF5B0 0x6FC0      CMP      R0,#+1536
   \      0x5A2   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_102
   3588                  {
   3589                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0x5A4   0xF8DF 0x0700      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0x5A8   0x6809             LDR      R1,[R1, #+0]
   \      0x5AA   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x5AE   0x40C8             LSRS     R0,R0,R1
   \      0x5B0   0xE014             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_99
   3590                  }
   3591                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_UART4CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_102: (+1)
   \      0x5B2   0x6809             LDR      R1,[R1, #+0]
   \      0x5B4   0x0589             LSLS     R1,R1,#+22
   \      0x5B6   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_103
   \      0x5B8   0xF5B0 0x6F00      CMP      R0,#+2048
   \      0x5BC   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_103
   3592                  {
   3593                    frequency = CSI_VALUE;
   \      0x5BE   0xF8DF 0x06EC      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0x5C2   0xE00B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_99
   3594                  }
   3595                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART4CLKSOURCE_LSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_103: (+1)
   \      0x5C4   0xF8DF 0x14DC      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0
   \      0x5C8   0x6809             LDR      R1,[R1, #+0]
   \      0x5CA   0x0789             LSLS     R1,R1,#+30
   \      0x5CC   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_104
   \      0x5CE   0xF5B0 0x6F20      CMP      R0,#+2560
   \      0x5D2   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_104
   3596                  {
   3597                    frequency = LSE_VALUE;
   \      0x5D4   0xF44F 0x4000      MOV      R0,#+32768
   \      0x5D8   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_99
   3598                  }
   3599                  /* Clock not enabled for UART4 */
   3600                  else
   3601                  {
   3602                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_104: (+1)
   \      0x5DA   0x2000             MOVS     R0,#+0
   3603                  }
   3604                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_99: (+1)
   \      0x5DC   0xF001 0xB843      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3605          #endif /* UART4 */
   3606          
   3607          #if defined(UART5)
   3608                case RCC_PERIPHCLK_UART5:
   3609                  /* Get the current UART5 source */
   3610                  srcclk = __HAL_RCC_GET_UART5_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_15: (+1)
   \      0x5E0   0xF8DF 0x06D0      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x14
   \      0x5E4   0x6800             LDR      R0,[R0, #+0]
   \      0x5E6   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   3611          
   3612                  if (srcclk == RCC_UART5CLKSOURCE_PCLK1)
   \      0x5EA   0x2800             CMP      R0,#+0
   \      0x5EC   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_105
   3613                  {
   3614                    frequency = HAL_RCC_GetPCLK1Freq();
   \      0x5EE   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0x5F2   0xE039             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_106
   3615                  }
   3616                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_UART5CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_105: (+1)
   \      0x5F4   0xF8DF 0x14B0      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0x5F8   0x680A             LDR      R2,[R1, #+0]
   \      0x5FA   0x0112             LSLS     R2,R2,#+4
   \      0x5FC   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_107
   \      0x5FE   0xF5B0 0x5F80      CMP      R0,#+4096
   \      0x602   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_107
   3617                  {
   3618                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0x604   0xA803             ADD      R0,SP,#+12
   \      0x606   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3619                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \      0x60A   0x9804             LDR      R0,[SP, #+16]
   \      0x60C   0xE02C             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_106
   3620                  }
   3621                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_UART5CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_107: (+1)
   \      0x60E   0x680A             LDR      R2,[R1, #+0]
   \      0x610   0x0092             LSLS     R2,R2,#+2
   \      0x612   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_108
   \      0x614   0xF5B0 0x5F00      CMP      R0,#+8192
   \      0x618   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_108
   3622                  {
   3623                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0x61A   0x4668             MOV      R0,SP
   \      0x61C   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3624                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \      0x620   0x9801             LDR      R0,[SP, #+4]
   \      0x622   0xE021             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_106
   3625                  }
   3626                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART5CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_108: (+1)
   \      0x624   0x680A             LDR      R2,[R1, #+0]
   \      0x626   0x0792             LSLS     R2,R2,#+30
   \      0x628   0xD509             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_109
   \      0x62A   0xF5B0 0x5F40      CMP      R0,#+12288
   \      0x62E   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_109
   3627                  {
   3628                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0x630   0xF8DF 0x0674      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0x634   0x6809             LDR      R1,[R1, #+0]
   \      0x636   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x63A   0x40C8             LSRS     R0,R0,R1
   \      0x63C   0xE014             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_106
   3629                  }
   3630                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_UART5CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_109: (+1)
   \      0x63E   0x6809             LDR      R1,[R1, #+0]
   \      0x640   0x0589             LSLS     R1,R1,#+22
   \      0x642   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_110
   \      0x644   0xF5B0 0x4F80      CMP      R0,#+16384
   \      0x648   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_110
   3631                  {
   3632                    frequency = CSI_VALUE;
   \      0x64A   0xF8DF 0x0660      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0x64E   0xE00B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_106
   3633                  }
   3634                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART5CLKSOURCE_LSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_110: (+1)
   \      0x650   0xF8DF 0x1450      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0
   \      0x654   0x6809             LDR      R1,[R1, #+0]
   \      0x656   0x0789             LSLS     R1,R1,#+30
   \      0x658   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_111
   \      0x65A   0xF5B0 0x4FA0      CMP      R0,#+20480
   \      0x65E   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_111
   3635                  {
   3636                    frequency = LSE_VALUE;
   \      0x660   0xF44F 0x4000      MOV      R0,#+32768
   \      0x664   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_106
   3637                  }
   3638                  /* Clock not enabled for UART5 */
   3639                  else
   3640                  {
   3641                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_111: (+1)
   \      0x666   0x2000             MOVS     R0,#+0
   3642                  }
   3643                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_106: (+1)
   \      0x668   0xF000 0xBFFD      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3644          #endif /* UART5 */
   3645          
   3646          #if defined(USART6)
   3647                case RCC_PERIPHCLK_USART6:
   3648                  /* Get the current USART6 source */
   3649                  srcclk = __HAL_RCC_GET_USART6_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_16: (+1)
   \      0x66C   0xF8DF 0x0644      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x14
   \      0x670   0x6800             LDR      R0,[R0, #+0]
   \      0x672   0xF410 0x3060      ANDS     R0,R0,#0x38000
   3650          
   3651                  if (srcclk == RCC_USART6CLKSOURCE_PCLK1)
   \      0x676   0x2800             CMP      R0,#+0
   \      0x678   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_112
   3652                  {
   3653                    frequency = HAL_RCC_GetPCLK1Freq();
   \      0x67A   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0x67E   0xE039             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_113
   3654                  }
   3655                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_USART6CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_112: (+1)
   \      0x680   0xF8DF 0x1424      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0x684   0x680A             LDR      R2,[R1, #+0]
   \      0x686   0x0112             LSLS     R2,R2,#+4
   \      0x688   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_114
   \      0x68A   0xF5B0 0x4F00      CMP      R0,#+32768
   \      0x68E   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_114
   3656                  {
   3657                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0x690   0xA803             ADD      R0,SP,#+12
   \      0x692   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3658                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \      0x696   0x9804             LDR      R0,[SP, #+16]
   \      0x698   0xE02C             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_113
   3659                  }
   3660                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_USART6CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_114: (+1)
   \      0x69A   0x680A             LDR      R2,[R1, #+0]
   \      0x69C   0x0092             LSLS     R2,R2,#+2
   \      0x69E   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_115
   \      0x6A0   0xF5B0 0x3F80      CMP      R0,#+65536
   \      0x6A4   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_115
   3661                  {
   3662                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0x6A6   0x4668             MOV      R0,SP
   \      0x6A8   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3663                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \      0x6AC   0x9801             LDR      R0,[SP, #+4]
   \      0x6AE   0xE021             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_113
   3664                  }
   3665                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART6CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_115: (+1)
   \      0x6B0   0x680A             LDR      R2,[R1, #+0]
   \      0x6B2   0x0792             LSLS     R2,R2,#+30
   \      0x6B4   0xD509             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_116
   \      0x6B6   0xF5B0 0x3FC0      CMP      R0,#+98304
   \      0x6BA   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_116
   3666                  {
   3667                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0x6BC   0xF8DF 0x05E8      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0x6C0   0x6809             LDR      R1,[R1, #+0]
   \      0x6C2   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x6C6   0x40C8             LSRS     R0,R0,R1
   \      0x6C8   0xE014             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_113
   3668                  }
   3669                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_USART6CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_116: (+1)
   \      0x6CA   0x6809             LDR      R1,[R1, #+0]
   \      0x6CC   0x0589             LSLS     R1,R1,#+22
   \      0x6CE   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_117
   \      0x6D0   0xF5B0 0x3F00      CMP      R0,#+131072
   \      0x6D4   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_117
   3670                  {
   3671                    frequency = CSI_VALUE;
   \      0x6D6   0xF8DF 0x05D4      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0x6DA   0xE00B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_113
   3672                  }
   3673                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART6CLKSOURCE_LSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_117: (+1)
   \      0x6DC   0xF8DF 0x13C4      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0
   \      0x6E0   0x6809             LDR      R1,[R1, #+0]
   \      0x6E2   0x0789             LSLS     R1,R1,#+30
   \      0x6E4   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_118
   \      0x6E6   0xF5B0 0x3F20      CMP      R0,#+163840
   \      0x6EA   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_118
   3674                  {
   3675                    frequency = LSE_VALUE;
   \      0x6EC   0xF44F 0x4000      MOV      R0,#+32768
   \      0x6F0   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_113
   3676                  }
   3677                  /* Clock not enabled for USART6 */
   3678                  else
   3679                  {
   3680                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_118: (+1)
   \      0x6F2   0x2000             MOVS     R0,#+0
   3681                  }
   3682                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_113: (+1)
   \      0x6F4   0xF000 0xBFB7      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3683          #endif /* USART6 */
   3684          
   3685          #if defined(UART7)
   3686                case RCC_PERIPHCLK_UART7:
   3687                  /* Get the current UART7 source */
   3688                  srcclk = __HAL_RCC_GET_UART7_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_17: (+1)
   \      0x6F8   0xF8DF 0x05B8      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x14
   \      0x6FC   0x6800             LDR      R0,[R0, #+0]
   \      0x6FE   0xF410 0x10E0      ANDS     R0,R0,#0x1C0000
   3689          
   3690                  if (srcclk == RCC_UART7CLKSOURCE_PCLK1)
   \      0x702   0x2800             CMP      R0,#+0
   \      0x704   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_119
   3691                  {
   3692                    frequency = HAL_RCC_GetPCLK1Freq();
   \      0x706   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0x70A   0xE039             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_120
   3693                  }
   3694                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_UART7CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_119: (+1)
   \      0x70C   0xF8DF 0x1398      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0x710   0x680A             LDR      R2,[R1, #+0]
   \      0x712   0x0112             LSLS     R2,R2,#+4
   \      0x714   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_121
   \      0x716   0xF5B0 0x2F80      CMP      R0,#+262144
   \      0x71A   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_121
   3695                  {
   3696                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0x71C   0xA803             ADD      R0,SP,#+12
   \      0x71E   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3697                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \      0x722   0x9804             LDR      R0,[SP, #+16]
   \      0x724   0xE02C             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_120
   3698                  }
   3699                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_UART7CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_121: (+1)
   \      0x726   0x680A             LDR      R2,[R1, #+0]
   \      0x728   0x0092             LSLS     R2,R2,#+2
   \      0x72A   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_122
   \      0x72C   0xF5B0 0x2F00      CMP      R0,#+524288
   \      0x730   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_122
   3700                  {
   3701                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0x732   0x4668             MOV      R0,SP
   \      0x734   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3702                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \      0x738   0x9801             LDR      R0,[SP, #+4]
   \      0x73A   0xE021             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_120
   3703                  }
   3704                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART7CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_122: (+1)
   \      0x73C   0x680A             LDR      R2,[R1, #+0]
   \      0x73E   0x0792             LSLS     R2,R2,#+30
   \      0x740   0xD509             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_123
   \      0x742   0xF5B0 0x2F40      CMP      R0,#+786432
   \      0x746   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_123
   3705                  {
   3706                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0x748   0xF8DF 0x055C      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0x74C   0x6809             LDR      R1,[R1, #+0]
   \      0x74E   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x752   0x40C8             LSRS     R0,R0,R1
   \      0x754   0xE014             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_120
   3707                  }
   3708                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_UART7CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_123: (+1)
   \      0x756   0x6809             LDR      R1,[R1, #+0]
   \      0x758   0x0589             LSLS     R1,R1,#+22
   \      0x75A   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_124
   \      0x75C   0xF5B0 0x1F80      CMP      R0,#+1048576
   \      0x760   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_124
   3709                  {
   3710                    frequency = CSI_VALUE;
   \      0x762   0xF8DF 0x0548      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0x766   0xE00B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_120
   3711                  }
   3712                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART7CLKSOURCE_LSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_124: (+1)
   \      0x768   0xF8DF 0x1338      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0
   \      0x76C   0x6809             LDR      R1,[R1, #+0]
   \      0x76E   0x0789             LSLS     R1,R1,#+30
   \      0x770   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_125
   \      0x772   0xF5B0 0x1FA0      CMP      R0,#+1310720
   \      0x776   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_125
   3713                  {
   3714                    frequency = LSE_VALUE;
   \      0x778   0xF44F 0x4000      MOV      R0,#+32768
   \      0x77C   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_120
   3715                  }
   3716                  /* Clock not enabled for UART7 */
   3717                  else
   3718                  {
   3719                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_125: (+1)
   \      0x77E   0x2000             MOVS     R0,#+0
   3720                  }
   3721                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_120: (+1)
   \      0x780   0xF000 0xBF71      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3722          #endif /* UART7 */
   3723          
   3724          #if defined(UART8)
   3725                case RCC_PERIPHCLK_UART8:
   3726                  /* Get the current UART8 source */
   3727                  srcclk = __HAL_RCC_GET_UART8_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_18: (+1)
   \      0x784   0xF8DF 0x052C      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x14
   \      0x788   0x6800             LDR      R0,[R0, #+0]
   \      0x78A   0xF410 0x0060      ANDS     R0,R0,#0xE00000
   3728          
   3729                  if (srcclk == RCC_UART8CLKSOURCE_PCLK1)
   \      0x78E   0x2800             CMP      R0,#+0
   \      0x790   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_126
   3730                  {
   3731                    frequency = HAL_RCC_GetPCLK1Freq();
   \      0x792   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0x796   0xE039             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_127
   3732                  }
   3733                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_UART8CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_126: (+1)
   \      0x798   0xF8DF 0x130C      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0x79C   0x680A             LDR      R2,[R1, #+0]
   \      0x79E   0x0112             LSLS     R2,R2,#+4
   \      0x7A0   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_128
   \      0x7A2   0xF5B0 0x1F00      CMP      R0,#+2097152
   \      0x7A6   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_128
   3734                  {
   3735                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0x7A8   0xA803             ADD      R0,SP,#+12
   \      0x7AA   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3736                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \      0x7AE   0x9804             LDR      R0,[SP, #+16]
   \      0x7B0   0xE02C             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_127
   3737                  }
   3738                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_UART8CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_128: (+1)
   \      0x7B2   0x680A             LDR      R2,[R1, #+0]
   \      0x7B4   0x0092             LSLS     R2,R2,#+2
   \      0x7B6   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_129
   \      0x7B8   0xF5B0 0x0F80      CMP      R0,#+4194304
   \      0x7BC   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_129
   3739                  {
   3740                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0x7BE   0x4668             MOV      R0,SP
   \      0x7C0   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3741                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \      0x7C4   0x9801             LDR      R0,[SP, #+4]
   \      0x7C6   0xE021             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_127
   3742                  }
   3743                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART8CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_129: (+1)
   \      0x7C8   0x680A             LDR      R2,[R1, #+0]
   \      0x7CA   0x0792             LSLS     R2,R2,#+30
   \      0x7CC   0xD509             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_130
   \      0x7CE   0xF5B0 0x0FC0      CMP      R0,#+6291456
   \      0x7D2   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_130
   3744                  {
   3745                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0x7D4   0xF8DF 0x04D0      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0x7D8   0x6809             LDR      R1,[R1, #+0]
   \      0x7DA   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x7DE   0x40C8             LSRS     R0,R0,R1
   \      0x7E0   0xE014             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_127
   3746                  }
   3747                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_UART8CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_130: (+1)
   \      0x7E2   0x6809             LDR      R1,[R1, #+0]
   \      0x7E4   0x0589             LSLS     R1,R1,#+22
   \      0x7E6   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_131
   \      0x7E8   0xF5B0 0x0F00      CMP      R0,#+8388608
   \      0x7EC   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_131
   3748                  {
   3749                    frequency = CSI_VALUE;
   \      0x7EE   0xF8DF 0x04BC      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0x7F2   0xE00B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_127
   3750                  }
   3751                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART8CLKSOURCE_LSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_131: (+1)
   \      0x7F4   0xF8DF 0x12AC      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_0
   \      0x7F8   0x6809             LDR      R1,[R1, #+0]
   \      0x7FA   0x0789             LSLS     R1,R1,#+30
   \      0x7FC   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_132
   \      0x7FE   0xF5B0 0x0F20      CMP      R0,#+10485760
   \      0x802   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_132
   3752                  {
   3753                    frequency = LSE_VALUE;
   \      0x804   0xF44F 0x4000      MOV      R0,#+32768
   \      0x808   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_127
   3754                  }
   3755                  /* Clock not enabled for UART8 */
   3756                  else
   3757                  {
   3758                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_132: (+1)
   \      0x80A   0x2000             MOVS     R0,#+0
   3759                  }
   3760                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_127: (+1)
   \      0x80C   0xF000 0xBF2B      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3761          #endif /* UART8 */
   3762          
   3763          #if defined(UART9)
   3764                case RCC_PERIPHCLK_UART9:
   3765                  /* Get the current UART9 source */
   3766                  srcclk = __HAL_RCC_GET_UART9_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_19: (+1)
   \      0x810   0xF8DF 0x04A0      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x14
   \      0x814   0x6800             LDR      R0,[R0, #+0]
   \      0x816   0xF010 0x60E0      ANDS     R0,R0,#0x7000000
   3767          
   3768                  if (srcclk == RCC_UART9CLKSOURCE_PCLK1)
   \      0x81A   0x2800             CMP      R0,#+0
   \      0x81C   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_133
   3769                  {
   3770                    frequency = HAL_RCC_GetPCLK1Freq();
   \      0x81E   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0x822   0xE037             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_134
   3771                  }
   3772                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_UART9CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_133: (+1)
   \      0x824   0x49A0             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0x826   0x680A             LDR      R2,[R1, #+0]
   \      0x828   0x0112             LSLS     R2,R2,#+4
   \      0x82A   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_135
   \      0x82C   0xF1B0 0x7F80      CMP      R0,#+16777216
   \      0x830   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_135
   3773                  {
   3774                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0x832   0xA803             ADD      R0,SP,#+12
   \      0x834   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3775                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \      0x838   0x9804             LDR      R0,[SP, #+16]
   \      0x83A   0xE02B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_134
   3776                  }
   3777                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_UART9CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_135: (+1)
   \      0x83C   0x680A             LDR      R2,[R1, #+0]
   \      0x83E   0x0092             LSLS     R2,R2,#+2
   \      0x840   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_136
   \      0x842   0xF1B0 0x7F00      CMP      R0,#+33554432
   \      0x846   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_136
   3778                  {
   3779                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0x848   0x4668             MOV      R0,SP
   \      0x84A   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3780                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \      0x84E   0x9801             LDR      R0,[SP, #+4]
   \      0x850   0xE020             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_134
   3781                  }
   3782                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART9CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_136: (+1)
   \      0x852   0x680A             LDR      R2,[R1, #+0]
   \      0x854   0x0792             LSLS     R2,R2,#+30
   \      0x856   0xD509             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_137
   \      0x858   0xF1B0 0x7F40      CMP      R0,#+50331648
   \      0x85C   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_137
   3783                  {
   3784                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0x85E   0xF8DF 0x0448      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0x862   0x6809             LDR      R1,[R1, #+0]
   \      0x864   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x868   0x40C8             LSRS     R0,R0,R1
   \      0x86A   0xE013             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_134
   3785                  }
   3786                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_UART9CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_137: (+1)
   \      0x86C   0x6809             LDR      R1,[R1, #+0]
   \      0x86E   0x0589             LSLS     R1,R1,#+22
   \      0x870   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_138
   \      0x872   0xF1B0 0x6F80      CMP      R0,#+67108864
   \      0x876   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_138
   3787                  {
   3788                    frequency = CSI_VALUE;
   \      0x878   0xF8DF 0x0430      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0x87C   0xE00A             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_134
   3789                  }
   3790                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART9CLKSOURCE_LSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_138: (+1)
   \      0x87E   0x4989             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_0
   \      0x880   0x6809             LDR      R1,[R1, #+0]
   \      0x882   0x0789             LSLS     R1,R1,#+30
   \      0x884   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_139
   \      0x886   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \      0x88A   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_139
   3791                  {
   3792                    frequency = LSE_VALUE;
   \      0x88C   0xF44F 0x4000      MOV      R0,#+32768
   \      0x890   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_134
   3793                  }
   3794                  /* Clock not enabled for UART9 */
   3795                  else
   3796                  {
   3797                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_139: (+1)
   \      0x892   0x2000             MOVS     R0,#+0
   3798                  }
   3799                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_134: (+1)
   \      0x894   0xF000 0xBEE7      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3800          #endif /* UART9 */
   3801          
   3802          #if defined(USART10)
   3803                case RCC_PERIPHCLK_USART10:
   3804                  /* Get the current USART10 source */
   3805                  srcclk = __HAL_RCC_GET_USART10_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_20: (+1)
   \      0x898   0xF8DF 0x0418      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x14
   \      0x89C   0x6800             LDR      R0,[R0, #+0]
   \      0x89E   0xF010 0x5060      ANDS     R0,R0,#0x38000000
   3806          
   3807                  if (srcclk == RCC_USART10CLKSOURCE_PCLK1)
   \      0x8A2   0x2800             CMP      R0,#+0
   \      0x8A4   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_140
   3808                  {
   3809                    frequency = HAL_RCC_GetPCLK1Freq();
   \      0x8A6   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0x8AA   0xE037             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_141
   3810                  }
   3811                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_USART10CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_140: (+1)
   \      0x8AC   0x497E             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0x8AE   0x680A             LDR      R2,[R1, #+0]
   \      0x8B0   0x0112             LSLS     R2,R2,#+4
   \      0x8B2   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_142
   \      0x8B4   0xF1B0 0x6F00      CMP      R0,#+134217728
   \      0x8B8   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_142
   3812                  {
   3813                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0x8BA   0xA803             ADD      R0,SP,#+12
   \      0x8BC   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3814                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \      0x8C0   0x9804             LDR      R0,[SP, #+16]
   \      0x8C2   0xE02B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_141
   3815                  }
   3816                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_USART10CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_142: (+1)
   \      0x8C4   0x680A             LDR      R2,[R1, #+0]
   \      0x8C6   0x0092             LSLS     R2,R2,#+2
   \      0x8C8   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_143
   \      0x8CA   0xF1B0 0x5F80      CMP      R0,#+268435456
   \      0x8CE   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_143
   3817                  {
   3818                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0x8D0   0x4668             MOV      R0,SP
   \      0x8D2   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3819                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \      0x8D6   0x9801             LDR      R0,[SP, #+4]
   \      0x8D8   0xE020             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_141
   3820                  }
   3821                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART10CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_143: (+1)
   \      0x8DA   0x680A             LDR      R2,[R1, #+0]
   \      0x8DC   0x0792             LSLS     R2,R2,#+30
   \      0x8DE   0xD509             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_144
   \      0x8E0   0xF1B0 0x5FC0      CMP      R0,#+402653184
   \      0x8E4   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_144
   3822                  {
   3823                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0x8E6   0xF8DF 0x03C0      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0x8EA   0x6809             LDR      R1,[R1, #+0]
   \      0x8EC   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x8F0   0x40C8             LSRS     R0,R0,R1
   \      0x8F2   0xE013             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_141
   3824                  }
   3825                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_USART10CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_144: (+1)
   \      0x8F4   0x6809             LDR      R1,[R1, #+0]
   \      0x8F6   0x0589             LSLS     R1,R1,#+22
   \      0x8F8   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_145
   \      0x8FA   0xF1B0 0x5F00      CMP      R0,#+536870912
   \      0x8FE   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_145
   3826                  {
   3827                    frequency = CSI_VALUE;
   \      0x900   0xF8DF 0x03A8      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0x904   0xE00A             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_141
   3828                  }
   3829                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART10CLKSOURCE_LSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_145: (+1)
   \      0x906   0x4967             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_0
   \      0x908   0x6809             LDR      R1,[R1, #+0]
   \      0x90A   0x0789             LSLS     R1,R1,#+30
   \      0x90C   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_146
   \      0x90E   0xF1B0 0x5F20      CMP      R0,#+671088640
   \      0x912   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_146
   3830                  {
   3831                    frequency = LSE_VALUE;
   \      0x914   0xF44F 0x4000      MOV      R0,#+32768
   \      0x918   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_141
   3832                  }
   3833                  /* Clock not enabled for USART10 */
   3834                  else
   3835                  {
   3836                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_146: (+1)
   \      0x91A   0x2000             MOVS     R0,#+0
   3837                  }
   3838                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_141: (+1)
   \      0x91C   0xF000 0xBEA3      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3839          #endif /* USART10 */
   3840          
   3841          #if defined(USART11)
   3842                case RCC_PERIPHCLK_USART11:
   3843                  /* Get the current USART11 source */
   3844                  srcclk = __HAL_RCC_GET_USART11_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_21: (+1)
   \      0x920   0xF8DF 0x0A48      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_2
   \      0x924   0x6800             LDR      R0,[R0, #+0]
   \      0x926   0xF010 0x0007      ANDS     R0,R0,#0x7
   3845          
   3846                  if (srcclk == RCC_USART11CLKSOURCE_PCLK1)
   \      0x92A   0x2800             CMP      R0,#+0
   \      0x92C   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_147
   3847                  {
   3848                    frequency = HAL_RCC_GetPCLK1Freq();
   \      0x92E   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0x932   0xE032             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_148
   3849                  }
   3850                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_USART11CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_147: (+1)
   \      0x934   0x495C             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0x936   0x680A             LDR      R2,[R1, #+0]
   \      0x938   0x0112             LSLS     R2,R2,#+4
   \      0x93A   0xD506             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_149
   \      0x93C   0x2801             CMP      R0,#+1
   \      0x93E   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_149
   3851                  {
   3852                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0x940   0xA803             ADD      R0,SP,#+12
   \      0x942   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3853                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \      0x946   0x9804             LDR      R0,[SP, #+16]
   \      0x948   0xE027             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_148
   3854                  }
   3855                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_USART11CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_149: (+1)
   \      0x94A   0x680A             LDR      R2,[R1, #+0]
   \      0x94C   0x0092             LSLS     R2,R2,#+2
   \      0x94E   0xD506             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_150
   \      0x950   0x2802             CMP      R0,#+2
   \      0x952   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_150
   3856                  {
   3857                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0x954   0x4668             MOV      R0,SP
   \      0x956   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3858                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \      0x95A   0x9801             LDR      R0,[SP, #+4]
   \      0x95C   0xE01D             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_148
   3859                  }
   3860                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART11CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_150: (+1)
   \      0x95E   0x680A             LDR      R2,[R1, #+0]
   \      0x960   0x0792             LSLS     R2,R2,#+30
   \      0x962   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_151
   \      0x964   0x2803             CMP      R0,#+3
   \      0x966   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_151
   3861                  {
   3862                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0x968   0xF8DF 0x033C      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0x96C   0x6809             LDR      R1,[R1, #+0]
   \      0x96E   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x972   0x40C8             LSRS     R0,R0,R1
   \      0x974   0xE011             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_148
   3863                  }
   3864                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_USART11CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_151: (+1)
   \      0x976   0x6809             LDR      R1,[R1, #+0]
   \      0x978   0x0589             LSLS     R1,R1,#+22
   \      0x97A   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_152
   \      0x97C   0x2804             CMP      R0,#+4
   \      0x97E   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_152
   3865                  {
   3866                    frequency = CSI_VALUE;
   \      0x980   0xF8DF 0x0328      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0x984   0xE009             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_148
   3867                  }
   3868                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART11CLKSOURCE_LSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_152: (+1)
   \      0x986   0x4947             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_0
   \      0x988   0x6809             LDR      R1,[R1, #+0]
   \      0x98A   0x0789             LSLS     R1,R1,#+30
   \      0x98C   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_153
   \      0x98E   0x2805             CMP      R0,#+5
   \      0x990   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_153
   3869                  {
   3870                    frequency = LSE_VALUE;
   \      0x992   0xF44F 0x4000      MOV      R0,#+32768
   \      0x996   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_148
   3871                  }
   3872                  /* Clock not enabled for USART11 */
   3873                  else
   3874                  {
   3875                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_153: (+1)
   \      0x998   0x2000             MOVS     R0,#+0
   3876                  }
   3877                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_148: (+1)
   \      0x99A   0xF000 0xBE64      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3878          #endif /* USART11 */
   3879          
   3880          #if defined(UART12)
   3881                case RCC_PERIPHCLK_UART12:
   3882                  /* Get the current UART12 source */
   3883                  srcclk = __HAL_RCC_GET_UART12_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_22: (+1)
   \      0x99E   0xF8DF 0x09CC      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_2
   \      0x9A2   0x6800             LDR      R0,[R0, #+0]
   \      0x9A4   0xF010 0x0070      ANDS     R0,R0,#0x70
   3884          
   3885                  if (srcclk == RCC_UART12CLKSOURCE_PCLK1)
   \      0x9A8   0x2800             CMP      R0,#+0
   \      0x9AA   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_154
   3886                  {
   3887                    frequency = HAL_RCC_GetPCLK1Freq();
   \      0x9AC   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0x9B0   0xE031             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_155
   3888                  }
   3889                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_UART12CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_154: (+1)
   \      0x9B2   0x493D             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0x9B4   0x680A             LDR      R2,[R1, #+0]
   \      0x9B6   0x0112             LSLS     R2,R2,#+4
   \      0x9B8   0xD506             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_156
   \      0x9BA   0x2810             CMP      R0,#+16
   \      0x9BC   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_156
   3890                  {
   3891                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0x9BE   0xA803             ADD      R0,SP,#+12
   \      0x9C0   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3892                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \      0x9C4   0x9804             LDR      R0,[SP, #+16]
   \      0x9C6   0xE026             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_155
   3893                  }
   3894                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_UART12CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_156: (+1)
   \      0x9C8   0x680A             LDR      R2,[R1, #+0]
   \      0x9CA   0x0092             LSLS     R2,R2,#+2
   \      0x9CC   0xD506             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_157
   \      0x9CE   0x2820             CMP      R0,#+32
   \      0x9D0   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_157
   3895                  {
   3896                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0x9D2   0x4668             MOV      R0,SP
   \      0x9D4   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3897                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \      0x9D8   0x9801             LDR      R0,[SP, #+4]
   \      0x9DA   0xE01C             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_155
   3898                  }
   3899                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART12CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_157: (+1)
   \      0x9DC   0x680A             LDR      R2,[R1, #+0]
   \      0x9DE   0x0792             LSLS     R2,R2,#+30
   \      0x9E0   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_158
   \      0x9E2   0x2830             CMP      R0,#+48
   \      0x9E4   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_158
   3900                  {
   3901                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0x9E6   0xF8DF 0x02C0      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0x9EA   0x6809             LDR      R1,[R1, #+0]
   \      0x9EC   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x9F0   0x40C8             LSRS     R0,R0,R1
   \      0x9F2   0xE010             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_155
   3902                  }
   3903                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_UART12CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_158: (+1)
   \      0x9F4   0x6809             LDR      R1,[R1, #+0]
   \      0x9F6   0x0589             LSLS     R1,R1,#+22
   \      0x9F8   0xD503             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_159
   \      0x9FA   0x2840             CMP      R0,#+64
   \      0x9FC   0xD101             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_159
   3904                  {
   3905                    frequency = CSI_VALUE;
   \      0x9FE   0x48AB             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0xA00   0xE009             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_155
   3906                  }
   3907                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART12CLKSOURCE_LSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_159: (+1)
   \      0xA02   0x4928             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_0
   \      0xA04   0x6809             LDR      R1,[R1, #+0]
   \      0xA06   0x0789             LSLS     R1,R1,#+30
   \      0xA08   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_160
   \      0xA0A   0x2850             CMP      R0,#+80
   \      0xA0C   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_160
   3908                  {
   3909                    frequency = LSE_VALUE;
   \      0xA0E   0xF44F 0x4000      MOV      R0,#+32768
   \      0xA12   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_155
   3910                  }
   3911                  /* Clock not enabled for UART12 */
   3912                  else
   3913                  {
   3914                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_160: (+1)
   \      0xA14   0x2000             MOVS     R0,#+0
   3915                  }
   3916                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_155: (+1)
   \      0xA16   0xF000 0xBE26      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3917          #endif /* UART12 */
   3918          
   3919                case RCC_PERIPHCLK_LPUART1:
   3920                  /* Get the current LPUART1 source */
   3921                  srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_23: (+1)
   \      0xA1A   0xF8DF 0x0A70      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_3
   \      0xA1E   0x6800             LDR      R0,[R0, #+0]
   \      0xA20   0xF010 0x60E0      ANDS     R0,R0,#0x7000000
   3922          
   3923                  if (srcclk == RCC_LPUART1CLKSOURCE_PCLK3)
   \      0xA24   0x2800             CMP      R0,#+0
   \      0xA26   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_161
   3924                  {
   3925                    frequency = HAL_RCC_GetPCLK3Freq();
   \      0xA28   0x.... 0x....      BL       HAL_RCC_GetPCLK3Freq
   \      0xA2C   0xE02F             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_162
   3926                  }
   3927                  else if (srcclk == RCC_LPUART1CLKSOURCE_PLL2Q)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_161: (+1)
   \      0xA2E   0xF1B0 0x7F80      CMP      R0,#+16777216
   \      0xA32   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_163
   3928                  {
   3929                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0xA34   0xA803             ADD      R0,SP,#+12
   \      0xA36   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3930                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \      0xA3A   0x9804             LDR      R0,[SP, #+16]
   \      0xA3C   0xE027             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_162
   3931                  }
   3932          #if defined(RCC_LPUART1CLKSOURCE_PLL3Q)
   3933                  else if (srcclk == RCC_LPUART1CLKSOURCE_PLL3Q)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_163: (+1)
   \      0xA3E   0xF1B0 0x7F00      CMP      R0,#+33554432
   \      0xA42   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_164
   3934                  {
   3935                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0xA44   0x4668             MOV      R0,SP
   \      0xA46   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3936                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \      0xA4A   0x9801             LDR      R0,[SP, #+4]
   \      0xA4C   0xE01F             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_162
   3937                  }
   3938          #endif /* RCC_LPUART1CLKSOURCE_PLL3Q */
   3939                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_164: (+1)
   \      0xA4E   0x4916             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_0+0x4
   \      0xA50   0x680A             LDR      R2,[R1, #+0]
   \      0xA52   0x0792             LSLS     R2,R2,#+30
   \      0xA54   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_165
   \      0xA56   0xF1B0 0x7F40      CMP      R0,#+50331648
   \      0xA5A   0xD105             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_165
   3940                  {
   3941                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0xA5C   0x4892             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0xA5E   0x6809             LDR      R1,[R1, #+0]
   \      0xA60   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0xA64   0x40C8             LSRS     R0,R0,R1
   \      0xA66   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_162
   3942                  }
   3943                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_165: (+1)
   \      0xA68   0x6809             LDR      R1,[R1, #+0]
   \      0xA6A   0x0589             LSLS     R1,R1,#+22
   \      0xA6C   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_166
   \      0xA6E   0xF1B0 0x6F80      CMP      R0,#+67108864
   \      0xA72   0xD101             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_166
   3944                  {
   3945                    frequency = CSI_VALUE;
   \      0xA74   0x488D             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0xA76   0xE00A             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_162
   3946                  }
   3947                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPUART1CLKSOURCE_LSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_166: (+1)
   \      0xA78   0x490A             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_0
   \      0xA7A   0x6809             LDR      R1,[R1, #+0]
   \      0xA7C   0x0789             LSLS     R1,R1,#+30
   \      0xA7E   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_167
   \      0xA80   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \      0xA84   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_167
   3948                  {
   3949                    frequency = LSE_VALUE;
   \      0xA86   0xF44F 0x4000      MOV      R0,#+32768
   \      0xA8A   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_162
   3950                  }
   3951                  /* Clock not enabled for LPUART1 */
   3952                  else
   3953                  {
   3954                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_167: (+1)
   \      0xA8C   0x2000             MOVS     R0,#+0
   3955                  }
   3956                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_162: (+1)
   \      0xA8E   0xF000 0xBDEA      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3957          
   3958                case RCC_PERIPHCLK_ADCDAC:
   3959                  /* Get the current ADCDAC source */
   3960                  srcclk = __HAL_RCC_GET_ADCDAC_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_32: (+1)
   \      0xA92   0x4883             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1
   \      0xA94   0x6800             LDR      R0,[R0, #+0]
   \      0xA96   0xF010 0x0007      ANDS     R0,R0,#0x7
   3961          
   3962                  if (srcclk == RCC_ADCDACCLKSOURCE_HCLK)
   \      0xA9A   0x2800             CMP      R0,#+0
   \      0xA9C   0xD10A             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_168
   3963                  {
   3964                    frequency = HAL_RCC_GetHCLKFreq();
   \      0xA9E   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \      0xAA2   0xE030             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_169
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_0:
   \      0xAA4   0x4402'0CF0        DC32     0x44020cf0
   \      0xAA8   0x4402'0C00        DC32     0x44020c00
   \      0xAAC   0x4402'0C1C        DC32     0x44020c1c
   \      0xAB0   0x017D'7840        DC32     0x17d7840
   3965                  }
   3966                  else if (srcclk == RCC_ADCDACCLKSOURCE_SYSCLK)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_168: (+1)
   \      0xAB4   0x2801             CMP      R0,#+1
   \      0xAB6   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_170
   3967                  {
   3968                    frequency = HAL_RCC_GetSysClockFreq();
   \      0xAB8   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \      0xABC   0xE023             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_169
   3969                  }
   3970                  else if (srcclk == RCC_ADCDACCLKSOURCE_PLL2R)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_170: (+1)
   \      0xABE   0x2802             CMP      R0,#+2
   \      0xAC0   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_171
   3971                  {
   3972                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \      0xAC2   0xA803             ADD      R0,SP,#+12
   \      0xAC4   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3973                    frequency = pll2_clocks.PLL2_R_Frequency;
   \      0xAC8   0x9805             LDR      R0,[SP, #+20]
   \      0xACA   0xE01C             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_169
   3974                  }
   3975                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_ADCDACCLKSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_171: (+1)
   \      0xACC   0xF8DF 0x1AA0      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \      0xAD0   0x680A             LDR      R2,[R1, #+0]
   \      0xAD2   0x0392             LSLS     R2,R2,#+14
   \      0xAD4   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_172
   \      0xAD6   0x2803             CMP      R0,#+3
   \      0xAD8   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_172
   3976                  {
   3977                    frequency = HSE_VALUE;
   \      0xADA   0xF8DF 0x0A98      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \      0xADE   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_169
   3978                  }
   3979                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_ADCDACCLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_172: (+1)
   \      0xAE0   0x680A             LDR      R2,[R1, #+0]
   \      0xAE2   0x0792             LSLS     R2,R2,#+30
   \      0xAE4   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_173
   \      0xAE6   0x2804             CMP      R0,#+4
   \      0xAE8   0xD105             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_173
   3980                  {
   3981                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0xAEA   0x486F             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0xAEC   0x6809             LDR      R1,[R1, #+0]
   \      0xAEE   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0xAF2   0x40C8             LSRS     R0,R0,R1
   \      0xAF4   0xE007             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_169
   3982                  }
   3983                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_ADCDACCLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_173: (+1)
   \      0xAF6   0x6809             LDR      R1,[R1, #+0]
   \      0xAF8   0x0589             LSLS     R1,R1,#+22
   \      0xAFA   0xD503             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_174
   \      0xAFC   0x2805             CMP      R0,#+5
   \      0xAFE   0xD101             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_174
   3984                  {
   3985                    frequency = CSI_VALUE;
   \      0xB00   0x486A             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0xB02   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_169
   3986                  }
   3987                  /* Clock not enabled for ADCDAC */
   3988                  else
   3989                  {
   3990                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_174: (+1)
   \      0xB04   0x2000             MOVS     R0,#+0
   3991                  }
   3992                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_169: (+1)
   \      0xB06   0xF000 0xBDAE      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   3993          
   3994          
   3995                case RCC_PERIPHCLK_DAC_LP:
   3996                  /* Get the current DAC low-power source */
   3997                  srcclk = __HAL_RCC_GET_DAC_LP_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_49: (+1)
   \      0xB0A   0x4865             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1
   \      0xB0C   0x6800             LDR      R0,[R0, #+0]
   \      0xB0E   0xF010 0x0008      ANDS     R0,R0,#0x8
   3998          
   3999                  if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_DACLPCLKSOURCE_LSE))
   \      0xB12   0xF8DF 0x1A64      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4+0x8
   \      0xB16   0x680A             LDR      R2,[R1, #+0]
   \      0xB18   0x0792             LSLS     R2,R2,#+30
   \      0xB1A   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_175
   \      0xB1C   0x2800             CMP      R0,#+0
   \      0xB1E   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_175
   4000                  {
   4001                    frequency = LSE_VALUE;
   \      0xB20   0xF44F 0x4000      MOV      R0,#+32768
   \      0xB24   0xE008             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_176
   4002                  }
   4003                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_DACLPCLKSOURCE_LSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_175: (+1)
   \      0xB26   0x6809             LDR      R1,[R1, #+0]
   \      0xB28   0x0109             LSLS     R1,R1,#+4
   \      0xB2A   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_177
   \      0xB2C   0x2808             CMP      R0,#+8
   \      0xB2E   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_177
   4004                  {
   4005                    frequency = LSI_VALUE;
   \      0xB30   0xF44F 0x40FA      MOV      R0,#+32000
   \      0xB34   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_176
   4006                  }
   4007          
   4008                  /* Clock not enabled for DAC */
   4009                  else
   4010                  {
   4011                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_177: (+1)
   \      0xB36   0x2000             MOVS     R0,#+0
   4012                  }
   4013                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_176: (+1)
   \      0xB38   0xF000 0xBD95      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4014          
   4015                case RCC_PERIPHCLK_I2C1:
   4016                  /* Get the current I2C1 source */
   4017                  srcclk = __HAL_RCC_GET_I2C1_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_24: (+1)
   \      0xB3C   0x485C             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x10
   \      0xB3E   0x6800             LDR      R0,[R0, #+0]
   \      0xB40   0xF410 0x3040      ANDS     R0,R0,#0x30000
   4018          
   4019                  if (srcclk == RCC_I2C1CLKSOURCE_PCLK1)
   \      0xB44   0x2800             CMP      R0,#+0
   \      0xB46   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_178
   4020                  {
   4021                    frequency = HAL_RCC_GetPCLK1Freq();
   \      0xB48   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0xB4C   0xE01E             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_179
   4022                  }
   4023          #if defined(RCC_I2C1CLKSOURCE_PLL3R)
   4024                  else if (srcclk ==  RCC_I2C1CLKSOURCE_PLL3R)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_178: (+1)
   \      0xB4E   0xF5B0 0x3F80      CMP      R0,#+65536
   \      0xB52   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_180
   4025                  {
   4026                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0xB54   0x4668             MOV      R0,SP
   \      0xB56   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4027                    frequency = pll3_clocks.PLL3_R_Frequency;
   \      0xB5A   0x9802             LDR      R0,[SP, #+8]
   \      0xB5C   0xE016             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_179
   4028                  }
   4029          #else
   4030                  else if (srcclk ==  RCC_I2C1CLKSOURCE_PLL2R)
   4031                  {
   4032                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   4033                    frequency = pll2_clocks.PLL2_R_Frequency;
   4034                  }
   4035          #endif /* RCC_I2C1CLKSOURCE_PLL3R */
   4036                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C1CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_180: (+1)
   \      0xB5E   0xF8DF 0x1A10      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \      0xB62   0x680A             LDR      R2,[R1, #+0]
   \      0xB64   0x0792             LSLS     R2,R2,#+30
   \      0xB66   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_181
   \      0xB68   0xF5B0 0x3F00      CMP      R0,#+131072
   \      0xB6C   0xD105             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_181
   4037                  {
   4038                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0xB6E   0x484E             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0xB70   0x6809             LDR      R1,[R1, #+0]
   \      0xB72   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0xB76   0x40C8             LSRS     R0,R0,R1
   \      0xB78   0xE008             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_179
   4039                  }
   4040                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk ==  RCC_I2C1CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_181: (+1)
   \      0xB7A   0x6809             LDR      R1,[R1, #+0]
   \      0xB7C   0x0589             LSLS     R1,R1,#+22
   \      0xB7E   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_182
   \      0xB80   0xF5B0 0x3F40      CMP      R0,#+196608
   \      0xB84   0xD101             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_182
   4041                  {
   4042                    frequency = CSI_VALUE;
   \      0xB86   0x4849             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0xB88   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_179
   4043                  }
   4044                  /* Clock not enabled for I2C1 */
   4045                  else
   4046                  {
   4047                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_182: (+1)
   \      0xB8A   0x2000             MOVS     R0,#+0
   4048                  }
   4049                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_179: (+1)
   \      0xB8C   0xF000 0xBD6B      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4050          
   4051                case RCC_PERIPHCLK_I2C2:
   4052                  /* Get the current I2C2 source */
   4053                  srcclk = __HAL_RCC_GET_I2C2_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_25: (+1)
   \      0xB90   0x4847             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x10
   \      0xB92   0x6800             LDR      R0,[R0, #+0]
   \      0xB94   0xF410 0x2040      ANDS     R0,R0,#0xC0000
   4054          
   4055                  if (srcclk == RCC_I2C2CLKSOURCE_PCLK1)
   \      0xB98   0x2800             CMP      R0,#+0
   \      0xB9A   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_183
   4056                  {
   4057                    frequency = HAL_RCC_GetPCLK1Freq();
   \      0xB9C   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0xBA0   0xE01E             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_184
   4058                  }
   4059          #if defined(RCC_I2C2CLKSOURCE_PLL3R)
   4060                  else if (srcclk ==  RCC_I2C2CLKSOURCE_PLL3R)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_183: (+1)
   \      0xBA2   0xF5B0 0x2F80      CMP      R0,#+262144
   \      0xBA6   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_185
   4061                  {
   4062                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0xBA8   0x4668             MOV      R0,SP
   \      0xBAA   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4063                    frequency = pll3_clocks.PLL3_R_Frequency;
   \      0xBAE   0x9802             LDR      R0,[SP, #+8]
   \      0xBB0   0xE016             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_184
   4064                  }
   4065          #else
   4066                  else if (srcclk ==  RCC_I2C2CLKSOURCE_PLL2R)
   4067                  {
   4068                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   4069                    frequency = pll2_clocks.PLL2_R_Frequency;
   4070                  }
   4071          #endif /* RCC_I2C2CLKSOURCE_PLL3R */
   4072                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C2CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_185: (+1)
   \      0xBB2   0xF8DF 0x19BC      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \      0xBB6   0x680A             LDR      R2,[R1, #+0]
   \      0xBB8   0x0792             LSLS     R2,R2,#+30
   \      0xBBA   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_186
   \      0xBBC   0xF5B0 0x2F00      CMP      R0,#+524288
   \      0xBC0   0xD105             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_186
   4073                  {
   4074                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0xBC2   0x4839             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0xBC4   0x6809             LDR      R1,[R1, #+0]
   \      0xBC6   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0xBCA   0x40C8             LSRS     R0,R0,R1
   \      0xBCC   0xE008             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_184
   4075                  }
   4076                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk ==  RCC_I2C2CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_186: (+1)
   \      0xBCE   0x6809             LDR      R1,[R1, #+0]
   \      0xBD0   0x0589             LSLS     R1,R1,#+22
   \      0xBD2   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_187
   \      0xBD4   0xF5B0 0x2F40      CMP      R0,#+786432
   \      0xBD8   0xD101             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_187
   4077                  {
   4078                    frequency = CSI_VALUE;
   \      0xBDA   0x4834             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0xBDC   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_184
   4079                  }
   4080                  /* Clock not enabled for I2C2 */
   4081                  else
   4082                  {
   4083                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_187: (+1)
   \      0xBDE   0x2000             MOVS     R0,#+0
   4084                  }
   4085                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_184: (+1)
   \      0xBE0   0xF000 0xBD41      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4086          
   4087          #if defined(I2C3)
   4088                case RCC_PERIPHCLK_I2C3:
   4089                  /* Get the current I2C3 source */
   4090                  srcclk = __HAL_RCC_GET_I2C3_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_26: (+1)
   \      0xBE4   0x4832             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x10
   \      0xBE6   0x6800             LDR      R0,[R0, #+0]
   \      0xBE8   0xF410 0x1040      ANDS     R0,R0,#0x300000
   4091          
   4092                  if (srcclk == RCC_I2C3CLKSOURCE_PCLK3)
   \      0xBEC   0x2800             CMP      R0,#+0
   \      0xBEE   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_188
   4093                  {
   4094                    frequency = HAL_RCC_GetPCLK3Freq();
   \      0xBF0   0x.... 0x....      BL       HAL_RCC_GetPCLK3Freq
   \      0xBF4   0xE01E             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_189
   4095                  }
   4096                  else if (srcclk ==  RCC_I2C3CLKSOURCE_PLL3R)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_188: (+1)
   \      0xBF6   0xF5B0 0x1F80      CMP      R0,#+1048576
   \      0xBFA   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_190
   4097                  {
   4098                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0xBFC   0x4668             MOV      R0,SP
   \      0xBFE   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4099                    frequency = pll3_clocks.PLL3_R_Frequency;
   \      0xC02   0x9802             LDR      R0,[SP, #+8]
   \      0xC04   0xE016             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_189
   4100                  }
   4101                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C3CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_190: (+1)
   \      0xC06   0xF8DF 0x1968      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \      0xC0A   0x680A             LDR      R2,[R1, #+0]
   \      0xC0C   0x0792             LSLS     R2,R2,#+30
   \      0xC0E   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_191
   \      0xC10   0xF5B0 0x1F00      CMP      R0,#+2097152
   \      0xC14   0xD105             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_191
   4102                  {
   4103                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0xC16   0x4824             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0xC18   0x6809             LDR      R1,[R1, #+0]
   \      0xC1A   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0xC1E   0x40C8             LSRS     R0,R0,R1
   \      0xC20   0xE008             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_189
   4104                  }
   4105                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk ==  RCC_I2C3CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_191: (+1)
   \      0xC22   0x6809             LDR      R1,[R1, #+0]
   \      0xC24   0x0589             LSLS     R1,R1,#+22
   \      0xC26   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_192
   \      0xC28   0xF5B0 0x1F40      CMP      R0,#+3145728
   \      0xC2C   0xD101             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_192
   4106                  {
   4107                    frequency = CSI_VALUE;
   \      0xC2E   0x481F             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0xC30   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_189
   4108                  }
   4109                  /* Clock not enabled for I2C3 */
   4110                  else
   4111                  {
   4112                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_192: (+1)
   \      0xC32   0x2000             MOVS     R0,#+0
   4113                  }
   4114                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_189: (+1)
   \      0xC34   0xF000 0xBD17      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4115          #endif /* I2C3 */
   4116          
   4117          #if defined(I2C4)
   4118                case RCC_PERIPHCLK_I2C4:
   4119                  /* Get the current I2C4 source */
   4120                  srcclk = __HAL_RCC_GET_I2C4_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_50: (+1)
   \      0xC38   0x481D             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x10
   \      0xC3A   0x6800             LDR      R0,[R0, #+0]
   \      0xC3C   0xF410 0x0040      ANDS     R0,R0,#0xC00000
   4121          
   4122                  if (srcclk == RCC_I2C4CLKSOURCE_PCLK3)
   \      0xC40   0x2800             CMP      R0,#+0
   \      0xC42   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_193
   4123                  {
   4124                    frequency = HAL_RCC_GetPCLK3Freq();
   \      0xC44   0x.... 0x....      BL       HAL_RCC_GetPCLK3Freq
   \      0xC48   0xE01E             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_194
   4125                  }
   4126                  else if (srcclk ==  RCC_I2C4CLKSOURCE_PLL3R)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_193: (+1)
   \      0xC4A   0xF5B0 0x0F80      CMP      R0,#+4194304
   \      0xC4E   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_195
   4127                  {
   4128                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0xC50   0x4668             MOV      R0,SP
   \      0xC52   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4129                    frequency = pll3_clocks.PLL3_R_Frequency;
   \      0xC56   0x9802             LDR      R0,[SP, #+8]
   \      0xC58   0xE016             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_194
   4130                  }
   4131                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C4CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_195: (+1)
   \      0xC5A   0xF8DF 0x1914      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \      0xC5E   0x680A             LDR      R2,[R1, #+0]
   \      0xC60   0x0792             LSLS     R2,R2,#+30
   \      0xC62   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_196
   \      0xC64   0xF5B0 0x0F00      CMP      R0,#+8388608
   \      0xC68   0xD105             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_196
   4132                  {
   4133                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0xC6A   0x480F             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x8
   \      0xC6C   0x6809             LDR      R1,[R1, #+0]
   \      0xC6E   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0xC72   0x40C8             LSRS     R0,R0,R1
   \      0xC74   0xE008             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_194
   4134                  }
   4135                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk ==  RCC_I2C4CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_196: (+1)
   \      0xC76   0x6809             LDR      R1,[R1, #+0]
   \      0xC78   0x0589             LSLS     R1,R1,#+22
   \      0xC7A   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_197
   \      0xC7C   0xF5B0 0x0F40      CMP      R0,#+12582912
   \      0xC80   0xD101             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_197
   4136                  {
   4137                    frequency = CSI_VALUE;
   \      0xC82   0x480A             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0xC
   \      0xC84   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_194
   4138                  }
   4139                  /* Clock not enabled for I2C4 */
   4140                  else
   4141                  {
   4142                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_197: (+1)
   \      0xC86   0x2000             MOVS     R0,#+0
   4143                  }
   4144                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_194: (+1)
   \      0xC88   0xF000 0xBCED      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4145          #endif /* I2C4 */
   4146          
   4147                case RCC_PERIPHCLK_I3C1:
   4148                  /* Get the current I3C1 source */
   4149                  srcclk = __HAL_RCC_GET_I3C1_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_27: (+1)
   \      0xC8C   0x4808             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_1+0x10
   \      0xC8E   0x6800             LDR      R0,[R0, #+0]
   \      0xC90   0xF010 0x7040      ANDS     R0,R0,#0x3000000
   4150          
   4151                  if (srcclk == RCC_I3C1CLKSOURCE_PCLK1)
   \      0xC94   0x2800             CMP      R0,#+0
   \      0xC96   0xD10F             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_198
   4152                  {
   4153                    frequency = HAL_RCC_GetPCLK1Freq();
   \      0xC98   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0xC9C   0xE024             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_199
   \      0xC9E   0xBF00             Nop
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_1:
   \      0xCA0   0x4402'0CE8        DC32     0x44020ce8
   \      0xCA4   0x00BB'8000        DC32     0xbb8000
   \      0xCA8   0x03D0'9000        DC32     0x3d09000
   \      0xCAC   0x003D'0900        DC32     0x3d0900
   \      0xCB0   0x4402'0CE4        DC32     0x44020ce4
   \      0xCB4   0x4402'0CD8        DC32     0x44020cd8
   4154                  }
   4155          #if defined(RCC_I3C1CLKSOURCE_PLL3R)
   4156                  else if (srcclk ==  RCC_I3C1CLKSOURCE_PLL3R)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_198: (+1)
   \      0xCB8   0xF1B0 0x7F80      CMP      R0,#+16777216
   \      0xCBC   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_200
   4157                  {
   4158                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \      0xCBE   0x4668             MOV      R0,SP
   \      0xCC0   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4159                    frequency = pll3_clocks.PLL3_R_Frequency;
   \      0xCC4   0x9802             LDR      R0,[SP, #+8]
   \      0xCC6   0xE00F             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_199
   4160                  }
   4161          #else
   4162                  else if (srcclk ==  RCC_I3C1CLKSOURCE_PLL2R)
   4163                  {
   4164                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   4165                    frequency = pll2_clocks.PLL2_R_Frequency;
   4166                  }
   4167          #endif /* RCC_I3C1CLKSOURCE_PLL3R */
   4168                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I3C1CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_200: (+1)
   \      0xCC8   0xF8DF 0x18A4      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \      0xCCC   0x680A             LDR      R2,[R1, #+0]
   \      0xCCE   0x0792             LSLS     R2,R2,#+30
   \      0xCD0   0xD509             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_201
   \      0xCD2   0xF1B0 0x7F00      CMP      R0,#+33554432
   \      0xCD6   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_201
   4169                  {
   4170                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0xCD8   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0xCDC   0x6809             LDR      R1,[R1, #+0]
   \      0xCDE   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0xCE2   0x40C8             LSRS     R0,R0,R1
   \      0xCE4   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_199
   4171                  }
   4172                  /* Clock not enabled for I3C1 */
   4173                  else
   4174                  {
   4175                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_201: (+1)
   \      0xCE6   0x2000             MOVS     R0,#+0
   4176                  }
   4177                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_199: (+1)
   \      0xCE8   0xF000 0xBCBD      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4178          
   4179          #if defined(I3C2)
   4180                case RCC_PERIPHCLK_I3C2:
   4181                  /* Get the current I3C2 source */
   4182                  srcclk = __HAL_RCC_GET_I3C2_SOURCE();
   4183          
   4184                  if (srcclk == RCC_I3C2CLKSOURCE_PCLK3)
   4185                  {
   4186                    frequency = HAL_RCC_GetPCLK3Freq();
   4187                  }
   4188                  else if (srcclk ==  RCC_I3C2CLKSOURCE_PLL2R)
   4189                  {
   4190                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   4191                    frequency = pll2_clocks.PLL2_R_Frequency;
   4192                  }
   4193                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I3C2CLKSOURCE_HSI))
   4194                  {
   4195                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   4196                  }
   4197                  /* Clock not enabled for I3C2 */
   4198                  else
   4199                  {
   4200                    frequency = 0U;
   4201                  }
   4202                  break;
   4203          #endif /* I3C2*/
   4204          
   4205                case RCC_PERIPHCLK_LPTIM1:
   4206                  /* Get the current LPTIM1 source */
   4207                  srcclk = __HAL_RCC_GET_LPTIM1_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_28: (+1)
   \      0xCEC   0xF8DF 0x067C      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_2
   \      0xCF0   0x6800             LDR      R0,[R0, #+0]
   \      0xCF2   0xF410 0x60E0      ANDS     R0,R0,#0x700
   4208          
   4209                  switch (srcclk)
   \      0xCF6   0x2800             CMP      R0,#+0
   \      0xCF8   0xD00F             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_202
   \      0xCFA   0xF5B0 0x7F80      CMP      R0,#+256
   \      0xCFE   0xD00F             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_203
   \      0xD00   0xF5B0 0x7F00      CMP      R0,#+512
   \      0xD04   0xD011             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_204
   \      0xD06   0xF5B0 0x7F40      CMP      R0,#+768
   \      0xD0A   0xD013             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_205
   \      0xD0C   0xF5B0 0x6F80      CMP      R0,#+1024
   \      0xD10   0xD01A             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_206
   \      0xD12   0xF5B0 0x6FA0      CMP      R0,#+1280
   \      0xD16   0xD021             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_207
   \      0xD18   0xE047             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_208
   4210                  {
   4211                    case RCC_LPTIM1CLKSOURCE_PCLK3:
   4212                    {
   4213                      frequency = HAL_RCC_GetPCLK3Freq();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_202: (+1)
   \      0xD1A   0x.... 0x....      BL       HAL_RCC_GetPCLK3Freq
   4214                      break;
   \      0xD1E   0xE045             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_209
   4215                    }
   4216                    case RCC_LPTIM1CLKSOURCE_PLL2P:
   4217                    {
   4218                      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_203: (+1)
   \      0xD20   0xA803             ADD      R0,SP,#+12
   \      0xD22   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   4219                      frequency = pll2_clocks.PLL2_P_Frequency;
   \      0xD26   0x9803             LDR      R0,[SP, #+12]
   4220                      break;
   \      0xD28   0xE040             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_209
   4221                    }
   4222          #if defined(RCC_LPTIM1CLKSOURCE_PLL3R)
   4223                    case RCC_LPTIM1CLKSOURCE_PLL3R:
   4224                    {
   4225                      HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_204: (+1)
   \      0xD2A   0x4668             MOV      R0,SP
   \      0xD2C   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4226                      frequency = pll3_clocks.PLL3_R_Frequency;
   \      0xD30   0x9802             LDR      R0,[SP, #+8]
   4227                      break;
   \      0xD32   0xE03B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_209
   4228                    }
   4229          #endif /* RCC_LPTIM1CLKSOURCE_PLL3R */
   4230                    case RCC_LPTIM1CLKSOURCE_LSE:
   4231                    {
   4232                      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_205: (+1)
   \      0xD34   0xF8DF 0x0840      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x8
   \      0xD38   0x6800             LDR      R0,[R0, #+0]
   \      0xD3A   0x0780             LSLS     R0,R0,#+30
   \      0xD3C   0xD502             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_210
   4233                      {
   4234                        frequency = LSE_VALUE;
   \      0xD3E   0xF44F 0x4000      MOV      R0,#+32768
   \      0xD42   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_211
   4235                      }
   4236                      else
   4237                      {
   4238                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_210: (+1)
   \      0xD44   0x2000             MOVS     R0,#+0
   4239                      }
   4240                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_211: (+1)
   \      0xD46   0xE031             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_209
   4241                    }
   4242                    case RCC_LPTIM1CLKSOURCE_LSI:
   4243                    {
   4244                      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_206: (+1)
   \      0xD48   0xF8DF 0x082C      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x8
   \      0xD4C   0x6800             LDR      R0,[R0, #+0]
   \      0xD4E   0x0100             LSLS     R0,R0,#+4
   \      0xD50   0xD502             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_212
   4245                      {
   4246                        frequency = LSI_VALUE;
   \      0xD52   0xF44F 0x40FA      MOV      R0,#+32000
   \      0xD56   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_213
   4247                      }
   4248                      else
   4249                      {
   4250                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_212: (+1)
   \      0xD58   0x2000             MOVS     R0,#+0
   4251                      }
   4252                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_213: (+1)
   \      0xD5A   0xE027             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_209
   4253                    }
   4254                    case RCC_LPTIM1CLKSOURCE_CLKP: /* CLKP is the clock source for LPTIM1 */
   4255                    {
   4256                      ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_207: (+1)
   \      0xD5C   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \      0xD60   0x6800             LDR      R0,[R0, #+0]
   \      0xD62   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   4257          
   4258                      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
   \      0xD66   0xF8DF 0x1808      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \      0xD6A   0x680A             LDR      R2,[R1, #+0]
   \      0xD6C   0x0792             LSLS     R2,R2,#+30
   \      0xD6E   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_214
   \      0xD70   0x2800             CMP      R0,#+0
   \      0xD72   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_214
   4259                      {
   4260                        /* In Case the CKPER Source is HSI */
   4261                        frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0xD74   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0xD78   0x6809             LDR      R1,[R1, #+0]
   \      0xD7A   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0xD7E   0x40C8             LSRS     R0,R0,R1
   \      0xD80   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_215
   4262                      }
   4263          
   4264                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_214: (+1)
   \      0xD82   0x680A             LDR      R2,[R1, #+0]
   \      0xD84   0x0592             LSLS     R2,R2,#+22
   \      0xD86   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_216
   \      0xD88   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \      0xD8C   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_216
   4265                      {
   4266                        /* In Case the CKPER Source is CSI */
   4267                        frequency = CSI_VALUE;
   \      0xD8E   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \      0xD92   0xE009             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_215
   4268                      }
   4269          
   4270                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_216: (+1)
   \      0xD94   0x6809             LDR      R1,[R1, #+0]
   \      0xD96   0x0389             LSLS     R1,R1,#+14
   \      0xD98   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_217
   \      0xD9A   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \      0xD9E   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_217
   4271                      {
   4272                        /* In Case the CKPER Source is HSE */
   4273                        frequency = HSE_VALUE;
   \      0xDA0   0xF8DF 0x07D0      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \      0xDA4   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_215
   4274                      }
   4275          
   4276                      else
   4277                      {
   4278                        /* In Case the CKPER is disabled*/
   4279                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_217: (+1)
   \      0xDA6   0x2000             MOVS     R0,#+0
   4280                      }
   4281          
   4282                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_215: (+1)
   \      0xDA8   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_209
   4283                    }
   4284                    default :
   4285                    {
   4286                      frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_208: (+1)
   \      0xDAA   0x2000             MOVS     R0,#+0
   4287                      break;
   4288                    }
   4289                  }
   4290                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_209: (+1)
   \      0xDAC   0xF000 0xBC5B      B.W      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4291          
   4292                case RCC_PERIPHCLK_LPTIM2:
   4293                  /* Get the current LPTIM2 source */
   4294                  srcclk = __HAL_RCC_GET_LPTIM2_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_29: (+1)
   \      0xDB0   0xF8DF 0x05B8      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_2
   \      0xDB4   0x6800             LDR      R0,[R0, #+0]
   \      0xDB6   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   4295          
   4296                  switch (srcclk)
   \      0xDBA   0x2800             CMP      R0,#+0
   \      0xDBC   0xD00F             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_218
   \      0xDBE   0xF5B0 0x5F80      CMP      R0,#+4096
   \      0xDC2   0xD00F             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_219
   \      0xDC4   0xF5B0 0x5F00      CMP      R0,#+8192
   \      0xDC8   0xD011             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_220
   \      0xDCA   0xF5B0 0x5F40      CMP      R0,#+12288
   \      0xDCE   0xD013             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_221
   \      0xDD0   0xF5B0 0x4F80      CMP      R0,#+16384
   \      0xDD4   0xD01A             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_222
   \      0xDD6   0xF5B0 0x4FA0      CMP      R0,#+20480
   \      0xDDA   0xD021             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_223
   \      0xDDC   0xE047             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_224
   4297                  {
   4298                    case RCC_LPTIM2CLKSOURCE_PCLK1:
   4299                    {
   4300                      frequency = HAL_RCC_GetPCLK1Freq();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_218: (+1)
   \      0xDDE   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   4301                      break;
   \      0xDE2   0xE045             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_225
   4302                    }
   4303                    case RCC_LPTIM2CLKSOURCE_PLL2P:
   4304                    {
   4305                      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_219: (+1)
   \      0xDE4   0xA803             ADD      R0,SP,#+12
   \      0xDE6   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   4306                      frequency = pll2_clocks.PLL2_P_Frequency;
   \      0xDEA   0x9803             LDR      R0,[SP, #+12]
   4307                      break;
   \      0xDEC   0xE040             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_225
   4308                    }
   4309          #if defined(RCC_LPTIM2CLKSOURCE_PLL3R)
   4310                    case RCC_LPTIM2CLKSOURCE_PLL3R:
   4311                    {
   4312                      HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_220: (+1)
   \      0xDEE   0x4668             MOV      R0,SP
   \      0xDF0   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4313                      frequency = pll3_clocks.PLL3_R_Frequency;
   \      0xDF4   0x9802             LDR      R0,[SP, #+8]
   4314                      break;
   \      0xDF6   0xE03B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_225
   4315                    }
   4316          #endif /* RCC_LPTIM2CLKSOURCE_PLL3R */
   4317                    case RCC_LPTIM2CLKSOURCE_LSE:
   4318                    {
   4319                      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_221: (+1)
   \      0xDF8   0xF8DF 0x077C      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x8
   \      0xDFC   0x6800             LDR      R0,[R0, #+0]
   \      0xDFE   0x0780             LSLS     R0,R0,#+30
   \      0xE00   0xD502             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_226
   4320                      {
   4321                        frequency = LSE_VALUE;
   \      0xE02   0xF44F 0x4000      MOV      R0,#+32768
   \      0xE06   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_227
   4322                      }
   4323                      else
   4324                      {
   4325                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_226: (+1)
   \      0xE08   0x2000             MOVS     R0,#+0
   4326                      }
   4327                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_227: (+1)
   \      0xE0A   0xE031             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_225
   4328                    }
   4329                    case RCC_LPTIM2CLKSOURCE_LSI:
   4330                    {
   4331                      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_222: (+1)
   \      0xE0C   0xF8DF 0x0768      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x8
   \      0xE10   0x6800             LDR      R0,[R0, #+0]
   \      0xE12   0x0100             LSLS     R0,R0,#+4
   \      0xE14   0xD502             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_228
   4332                      {
   4333                        frequency = LSI_VALUE;
   \      0xE16   0xF44F 0x40FA      MOV      R0,#+32000
   \      0xE1A   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_229
   4334                      }
   4335                      else
   4336                      {
   4337                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_228: (+1)
   \      0xE1C   0x2000             MOVS     R0,#+0
   4338                      }
   4339                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_229: (+1)
   \      0xE1E   0xE027             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_225
   4340                    }
   4341                    case RCC_LPTIM2CLKSOURCE_CLKP: /* CLKP is the clock source for LPTIM2 */
   4342                    {
   4343                      ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_223: (+1)
   \      0xE20   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \      0xE24   0x6800             LDR      R0,[R0, #+0]
   \      0xE26   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   4344          
   4345                      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
   \      0xE2A   0xF8DF 0x1744      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \      0xE2E   0x680A             LDR      R2,[R1, #+0]
   \      0xE30   0x0792             LSLS     R2,R2,#+30
   \      0xE32   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_230
   \      0xE34   0x2800             CMP      R0,#+0
   \      0xE36   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_230
   4346                      {
   4347                        /* In Case the CKPER Source is HSI */
   4348                        frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0xE38   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0xE3C   0x6809             LDR      R1,[R1, #+0]
   \      0xE3E   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0xE42   0x40C8             LSRS     R0,R0,R1
   \      0xE44   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_231
   4349                      }
   4350          
   4351                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_230: (+1)
   \      0xE46   0x680A             LDR      R2,[R1, #+0]
   \      0xE48   0x0592             LSLS     R2,R2,#+22
   \      0xE4A   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_232
   \      0xE4C   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \      0xE50   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_232
   4352                      {
   4353                        /* In Case the CKPER Source is CSI */
   4354                        frequency = CSI_VALUE;
   \      0xE52   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \      0xE56   0xE009             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_231
   4355                      }
   4356          
   4357                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_232: (+1)
   \      0xE58   0x6809             LDR      R1,[R1, #+0]
   \      0xE5A   0x0389             LSLS     R1,R1,#+14
   \      0xE5C   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_233
   \      0xE5E   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \      0xE62   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_233
   4358                      {
   4359                        /* In Case the CKPER Source is HSE */
   4360                        frequency = HSE_VALUE;
   \      0xE64   0xF8DF 0x070C      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \      0xE68   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_231
   4361                      }
   4362          
   4363                      else
   4364                      {
   4365                        /* In Case the CKPER is disabled*/
   4366                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_233: (+1)
   \      0xE6A   0x2000             MOVS     R0,#+0
   4367                      }
   4368          
   4369                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_231: (+1)
   \      0xE6C   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_225
   4370                    }
   4371                    default :
   4372                    {
   4373                      frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_224: (+1)
   \      0xE6E   0x2000             MOVS     R0,#+0
   4374                      break;
   4375                    }
   4376                  }
   4377                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_225: (+1)
   \      0xE70   0xE3F9             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4378          
   4379          #if defined(LPTIM3)
   4380                case RCC_PERIPHCLK_LPTIM3:
   4381                  /* Get the current LPTIM3 source */
   4382                  srcclk = __HAL_RCC_GET_LPTIM3_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_45: (+1)
   \      0xE72   0xF8DF 0x04F8      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_2
   \      0xE76   0x6800             LDR      R0,[R0, #+0]
   \      0xE78   0xF410 0x20E0      ANDS     R0,R0,#0x70000
   4383          
   4384                  switch (srcclk)
   \      0xE7C   0x2800             CMP      R0,#+0
   \      0xE7E   0xD00F             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_234
   \      0xE80   0xF5B0 0x3F80      CMP      R0,#+65536
   \      0xE84   0xD00F             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_235
   \      0xE86   0xF5B0 0x3F00      CMP      R0,#+131072
   \      0xE8A   0xD011             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_236
   \      0xE8C   0xF5B0 0x3F40      CMP      R0,#+196608
   \      0xE90   0xD013             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_237
   \      0xE92   0xF5B0 0x2F80      CMP      R0,#+262144
   \      0xE96   0xD01A             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_238
   \      0xE98   0xF5B0 0x2FA0      CMP      R0,#+327680
   \      0xE9C   0xD021             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_239
   \      0xE9E   0xE047             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_240
   4385                  {
   4386                    case RCC_LPTIM3CLKSOURCE_PCLK3:
   4387                    {
   4388                      frequency = HAL_RCC_GetPCLK3Freq();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_234: (+1)
   \      0xEA0   0x.... 0x....      BL       HAL_RCC_GetPCLK3Freq
   4389                      break;
   \      0xEA4   0xE045             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_241
   4390                    }
   4391                    case RCC_LPTIM3CLKSOURCE_PLL2P:
   4392                    {
   4393                      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_235: (+1)
   \      0xEA6   0xA803             ADD      R0,SP,#+12
   \      0xEA8   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   4394                      frequency = pll2_clocks.PLL2_P_Frequency;
   \      0xEAC   0x9803             LDR      R0,[SP, #+12]
   4395                      break;
   \      0xEAE   0xE040             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_241
   4396                    }
   4397                    case RCC_LPTIM3CLKSOURCE_PLL3R:
   4398                    {
   4399                      HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_236: (+1)
   \      0xEB0   0x4668             MOV      R0,SP
   \      0xEB2   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4400                      frequency = pll3_clocks.PLL3_R_Frequency;
   \      0xEB6   0x9802             LDR      R0,[SP, #+8]
   4401                      break;
   \      0xEB8   0xE03B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_241
   4402                    }
   4403                    case RCC_LPTIM3CLKSOURCE_LSE:
   4404                    {
   4405                      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_237: (+1)
   \      0xEBA   0xF8DF 0x06BC      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x8
   \      0xEBE   0x6800             LDR      R0,[R0, #+0]
   \      0xEC0   0x0780             LSLS     R0,R0,#+30
   \      0xEC2   0xD502             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_242
   4406                      {
   4407                        frequency = LSE_VALUE;
   \      0xEC4   0xF44F 0x4000      MOV      R0,#+32768
   \      0xEC8   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_243
   4408                      }
   4409                      else
   4410                      {
   4411                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_242: (+1)
   \      0xECA   0x2000             MOVS     R0,#+0
   4412                      }
   4413                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_243: (+1)
   \      0xECC   0xE031             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_241
   4414                    }
   4415                    case RCC_LPTIM3CLKSOURCE_LSI:
   4416                    {
   4417                      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_238: (+1)
   \      0xECE   0xF8DF 0x06A8      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x8
   \      0xED2   0x6800             LDR      R0,[R0, #+0]
   \      0xED4   0x0100             LSLS     R0,R0,#+4
   \      0xED6   0xD502             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_244
   4418                      {
   4419                        frequency = LSI_VALUE;
   \      0xED8   0xF44F 0x40FA      MOV      R0,#+32000
   \      0xEDC   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_245
   4420                      }
   4421                      else
   4422                      {
   4423                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_244: (+1)
   \      0xEDE   0x2000             MOVS     R0,#+0
   4424                      }
   4425                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_245: (+1)
   \      0xEE0   0xE027             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_241
   4426                    }
   4427                    case RCC_LPTIM3CLKSOURCE_CLKP: /* CLKP is the clock source for LPTIM3 */
   4428                    {
   4429                      ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_239: (+1)
   \      0xEE2   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \      0xEE6   0x6800             LDR      R0,[R0, #+0]
   \      0xEE8   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   4430          
   4431                      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
   \      0xEEC   0xF8DF 0x1680      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \      0xEF0   0x680A             LDR      R2,[R1, #+0]
   \      0xEF2   0x0792             LSLS     R2,R2,#+30
   \      0xEF4   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_246
   \      0xEF6   0x2800             CMP      R0,#+0
   \      0xEF8   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_246
   4432                      {
   4433                        /* In Case the CKPER Source is HSI */
   4434                        frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0xEFA   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0xEFE   0x6809             LDR      R1,[R1, #+0]
   \      0xF00   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0xF04   0x40C8             LSRS     R0,R0,R1
   \      0xF06   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_247
   4435                      }
   4436          
   4437                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_246: (+1)
   \      0xF08   0x680A             LDR      R2,[R1, #+0]
   \      0xF0A   0x0592             LSLS     R2,R2,#+22
   \      0xF0C   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_248
   \      0xF0E   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \      0xF12   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_248
   4438                      {
   4439                        /* In Case the CKPER Source is CSI */
   4440                        frequency = CSI_VALUE;
   \      0xF14   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \      0xF18   0xE009             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_247
   4441                      }
   4442          
   4443                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_248: (+1)
   \      0xF1A   0x6809             LDR      R1,[R1, #+0]
   \      0xF1C   0x0389             LSLS     R1,R1,#+14
   \      0xF1E   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_249
   \      0xF20   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \      0xF24   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_249
   4444                      {
   4445                        /* In Case the CKPER Source is HSE */
   4446                        frequency = HSE_VALUE;
   \      0xF26   0xF8DF 0x064C      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \      0xF2A   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_247
   4447                      }
   4448          
   4449                      else
   4450                      {
   4451                        /* In Case the CKPER is disabled*/
   4452                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_249: (+1)
   \      0xF2C   0x2000             MOVS     R0,#+0
   4453                      }
   4454          
   4455                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_247: (+1)
   \      0xF2E   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_241
   4456                    }
   4457                    default :
   4458                    {
   4459                      frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_240: (+1)
   \      0xF30   0x2000             MOVS     R0,#+0
   4460                      break;
   4461                    }
   4462                  }
   4463                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_241: (+1)
   \      0xF32   0xE398             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4464          #endif /* LPTIM3 */
   4465          
   4466          #if defined(LPTIM4)
   4467                case RCC_PERIPHCLK_LPTIM4:
   4468                  /* Get the current LPTIM4 source */
   4469                  srcclk = __HAL_RCC_GET_LPTIM4_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_46: (+1)
   \      0xF34   0xF8DF 0x0434      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_2
   \      0xF38   0x6800             LDR      R0,[R0, #+0]
   \      0xF3A   0xF410 0x00E0      ANDS     R0,R0,#0x700000
   4470          
   4471                  switch (srcclk)
   \      0xF3E   0x2800             CMP      R0,#+0
   \      0xF40   0xD00F             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_250
   \      0xF42   0xF5B0 0x1F80      CMP      R0,#+1048576
   \      0xF46   0xD00F             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_251
   \      0xF48   0xF5B0 0x1F00      CMP      R0,#+2097152
   \      0xF4C   0xD011             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_252
   \      0xF4E   0xF5B0 0x1F40      CMP      R0,#+3145728
   \      0xF52   0xD013             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_253
   \      0xF54   0xF5B0 0x0F80      CMP      R0,#+4194304
   \      0xF58   0xD01A             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_254
   \      0xF5A   0xF5B0 0x0FA0      CMP      R0,#+5242880
   \      0xF5E   0xD021             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_255
   \      0xF60   0xE047             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_256
   4472                  {
   4473                    case RCC_LPTIM4CLKSOURCE_PCLK3:
   4474                    {
   4475                      frequency = HAL_RCC_GetPCLK3Freq();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_250: (+1)
   \      0xF62   0x.... 0x....      BL       HAL_RCC_GetPCLK3Freq
   4476                      break;
   \      0xF66   0xE045             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_257
   4477                    }
   4478                    case RCC_LPTIM4CLKSOURCE_PLL2P:
   4479                    {
   4480                      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_251: (+1)
   \      0xF68   0xA803             ADD      R0,SP,#+12
   \      0xF6A   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   4481                      frequency = pll2_clocks.PLL2_P_Frequency;
   \      0xF6E   0x9803             LDR      R0,[SP, #+12]
   4482                      break;
   \      0xF70   0xE040             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_257
   4483                    }
   4484                    case RCC_LPTIM4CLKSOURCE_PLL3R:
   4485                    {
   4486                      HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_252: (+1)
   \      0xF72   0x4668             MOV      R0,SP
   \      0xF74   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4487                      frequency = pll3_clocks.PLL3_R_Frequency;
   \      0xF78   0x9802             LDR      R0,[SP, #+8]
   4488                      break;
   \      0xF7A   0xE03B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_257
   4489                    }
   4490                    case RCC_LPTIM4CLKSOURCE_LSE:
   4491                    {
   4492                      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_253: (+1)
   \      0xF7C   0xF8DF 0x05F8      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x8
   \      0xF80   0x6800             LDR      R0,[R0, #+0]
   \      0xF82   0x0780             LSLS     R0,R0,#+30
   \      0xF84   0xD502             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_258
   4493                      {
   4494                        frequency = LSE_VALUE;
   \      0xF86   0xF44F 0x4000      MOV      R0,#+32768
   \      0xF8A   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_259
   4495                      }
   4496                      else
   4497                      {
   4498                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_258: (+1)
   \      0xF8C   0x2000             MOVS     R0,#+0
   4499                      }
   4500                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_259: (+1)
   \      0xF8E   0xE031             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_257
   4501                    }
   4502                    case RCC_LPTIM4CLKSOURCE_LSI:
   4503                    {
   4504                      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_254: (+1)
   \      0xF90   0xF8DF 0x05E4      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x8
   \      0xF94   0x6800             LDR      R0,[R0, #+0]
   \      0xF96   0x0100             LSLS     R0,R0,#+4
   \      0xF98   0xD502             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_260
   4505                      {
   4506                        frequency = LSI_VALUE;
   \      0xF9A   0xF44F 0x40FA      MOV      R0,#+32000
   \      0xF9E   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_261
   4507                      }
   4508                      else
   4509                      {
   4510                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_260: (+1)
   \      0xFA0   0x2000             MOVS     R0,#+0
   4511                      }
   4512                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_261: (+1)
   \      0xFA2   0xE027             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_257
   4513                    }
   4514                    case RCC_LPTIM4CLKSOURCE_CLKP: /* CLKP is the clock source for LPTIM4 */
   4515                    {
   4516                      ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_255: (+1)
   \      0xFA4   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \      0xFA8   0x6800             LDR      R0,[R0, #+0]
   \      0xFAA   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   4517          
   4518                      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
   \      0xFAE   0xF8DF 0x15C0      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \      0xFB2   0x680A             LDR      R2,[R1, #+0]
   \      0xFB4   0x0792             LSLS     R2,R2,#+30
   \      0xFB6   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_262
   \      0xFB8   0x2800             CMP      R0,#+0
   \      0xFBA   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_262
   4519                      {
   4520                        /* In Case the CKPER Source is HSI */
   4521                        frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \      0xFBC   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0xFC0   0x6809             LDR      R1,[R1, #+0]
   \      0xFC2   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0xFC6   0x40C8             LSRS     R0,R0,R1
   \      0xFC8   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_263
   4522                      }
   4523          
   4524                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_262: (+1)
   \      0xFCA   0x680A             LDR      R2,[R1, #+0]
   \      0xFCC   0x0592             LSLS     R2,R2,#+22
   \      0xFCE   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_264
   \      0xFD0   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \      0xFD4   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_264
   4525                      {
   4526                        /* In Case the CKPER Source is CSI */
   4527                        frequency = CSI_VALUE;
   \      0xFD6   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \      0xFDA   0xE009             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_263
   4528                      }
   4529          
   4530                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_264: (+1)
   \      0xFDC   0x6809             LDR      R1,[R1, #+0]
   \      0xFDE   0x0389             LSLS     R1,R1,#+14
   \      0xFE0   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_265
   \      0xFE2   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \      0xFE6   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_265
   4531                      {
   4532                        /* In Case the CKPER Source is HSE */
   4533                        frequency = HSE_VALUE;
   \      0xFE8   0xF8DF 0x0588      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \      0xFEC   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_263
   4534                      }
   4535          
   4536                      else
   4537                      {
   4538                        /* In Case the CKPER is disabled*/
   4539                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_265: (+1)
   \      0xFEE   0x2000             MOVS     R0,#+0
   4540                      }
   4541          
   4542                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_263: (+1)
   \      0xFF0   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_257
   4543                    }
   4544                    default :
   4545                    {
   4546                      frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_256: (+1)
   \      0xFF2   0x2000             MOVS     R0,#+0
   4547                      break;
   4548                    }
   4549                  }
   4550                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_257: (+1)
   \      0xFF4   0xE337             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4551          #endif /* LPTIM4 */
   4552          
   4553          #if defined(LPTIM5)
   4554                case RCC_PERIPHCLK_LPTIM5:
   4555                  /* Get the current LPTIM5 source */
   4556                  srcclk = __HAL_RCC_GET_LPTIM5_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_47: (+1)
   \      0xFF6   0xF8DF 0x0374      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_2
   \      0xFFA   0x6800             LDR      R0,[R0, #+0]
   \      0xFFC   0xF010 0x60E0      ANDS     R0,R0,#0x7000000
   4557          
   4558                  switch (srcclk)
   \     0x1000   0x2800             CMP      R0,#+0
   \     0x1002   0xD00F             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_266
   \     0x1004   0xF1B0 0x7F80      CMP      R0,#+16777216
   \     0x1008   0xD00F             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_267
   \     0x100A   0xF1B0 0x7F00      CMP      R0,#+33554432
   \     0x100E   0xD011             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_268
   \     0x1010   0xF1B0 0x7F40      CMP      R0,#+50331648
   \     0x1014   0xD013             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_269
   \     0x1016   0xF1B0 0x6F80      CMP      R0,#+67108864
   \     0x101A   0xD01A             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_270
   \     0x101C   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \     0x1020   0xD021             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_271
   \     0x1022   0xE047             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_272
   4559                  {
   4560                    case RCC_LPTIM5CLKSOURCE_PCLK3:
   4561                    {
   4562                      frequency = HAL_RCC_GetPCLK3Freq();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_266: (+1)
   \     0x1024   0x.... 0x....      BL       HAL_RCC_GetPCLK3Freq
   4563                      break;
   \     0x1028   0xE045             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_273
   4564                    }
   4565                    case RCC_LPTIM5CLKSOURCE_PLL2P:
   4566                    {
   4567                      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_267: (+1)
   \     0x102A   0xA803             ADD      R0,SP,#+12
   \     0x102C   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   4568                      frequency = pll2_clocks.PLL2_P_Frequency;
   \     0x1030   0x9803             LDR      R0,[SP, #+12]
   4569                      break;
   \     0x1032   0xE040             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_273
   4570                    }
   4571                    case RCC_LPTIM5CLKSOURCE_PLL3R:
   4572                    {
   4573                      HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_268: (+1)
   \     0x1034   0x4668             MOV      R0,SP
   \     0x1036   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4574                      frequency = pll3_clocks.PLL3_R_Frequency;
   \     0x103A   0x9802             LDR      R0,[SP, #+8]
   4575                      break;
   \     0x103C   0xE03B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_273
   4576                    }
   4577                    case RCC_LPTIM5CLKSOURCE_LSE:
   4578                    {
   4579                      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_269: (+1)
   \     0x103E   0xF8DF 0x0538      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x8
   \     0x1042   0x6800             LDR      R0,[R0, #+0]
   \     0x1044   0x0780             LSLS     R0,R0,#+30
   \     0x1046   0xD502             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_274
   4580                      {
   4581                        frequency = LSE_VALUE;
   \     0x1048   0xF44F 0x4000      MOV      R0,#+32768
   \     0x104C   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_275
   4582                      }
   4583                      else
   4584                      {
   4585                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_274: (+1)
   \     0x104E   0x2000             MOVS     R0,#+0
   4586                      }
   4587                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_275: (+1)
   \     0x1050   0xE031             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_273
   4588                    }
   4589                    case RCC_LPTIM5CLKSOURCE_LSI:
   4590                    {
   4591                      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_270: (+1)
   \     0x1052   0xF8DF 0x0524      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x8
   \     0x1056   0x6800             LDR      R0,[R0, #+0]
   \     0x1058   0x0100             LSLS     R0,R0,#+4
   \     0x105A   0xD502             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_276
   4592                      {
   4593                        frequency = LSI_VALUE;
   \     0x105C   0xF44F 0x40FA      MOV      R0,#+32000
   \     0x1060   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_277
   4594                      }
   4595                      else
   4596                      {
   4597                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_276: (+1)
   \     0x1062   0x2000             MOVS     R0,#+0
   4598                      }
   4599                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_277: (+1)
   \     0x1064   0xE027             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_273
   4600                    }
   4601                    case RCC_LPTIM5CLKSOURCE_CLKP: /* CLKP is the clock source for LPTIM5 */
   4602                    {
   4603                      ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_271: (+1)
   \     0x1066   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \     0x106A   0x6800             LDR      R0,[R0, #+0]
   \     0x106C   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   4604          
   4605                      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
   \     0x1070   0xF8DF 0x14FC      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \     0x1074   0x680A             LDR      R2,[R1, #+0]
   \     0x1076   0x0792             LSLS     R2,R2,#+30
   \     0x1078   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_278
   \     0x107A   0x2800             CMP      R0,#+0
   \     0x107C   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_278
   4606                      {
   4607                        /* In Case the CKPER Source is HSI */
   4608                        frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \     0x107E   0x.... 0x....      LDR.W    R0,??DataTable7
   \     0x1082   0x6809             LDR      R1,[R1, #+0]
   \     0x1084   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \     0x1088   0x40C8             LSRS     R0,R0,R1
   \     0x108A   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_279
   4609                      }
   4610          
   4611                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_278: (+1)
   \     0x108C   0x680A             LDR      R2,[R1, #+0]
   \     0x108E   0x0592             LSLS     R2,R2,#+22
   \     0x1090   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_280
   \     0x1092   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \     0x1096   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_280
   4612                      {
   4613                        /* In Case the CKPER Source is CSI */
   4614                        frequency = CSI_VALUE;
   \     0x1098   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \     0x109C   0xE009             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_279
   4615                      }
   4616          
   4617                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_280: (+1)
   \     0x109E   0x6809             LDR      R1,[R1, #+0]
   \     0x10A0   0x0389             LSLS     R1,R1,#+14
   \     0x10A2   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_281
   \     0x10A4   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \     0x10A8   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_281
   4618                      {
   4619                        /* In Case the CKPER Source is HSE */
   4620                        frequency = HSE_VALUE;
   \     0x10AA   0xF8DF 0x04C8      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \     0x10AE   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_279
   4621                      }
   4622          
   4623                      else
   4624                      {
   4625                        /* In Case the CKPER is disabled*/
   4626                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_281: (+1)
   \     0x10B0   0x2000             MOVS     R0,#+0
   4627                      }
   4628          
   4629                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_279: (+1)
   \     0x10B2   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_273
   4630                    }
   4631                    default :
   4632                    {
   4633                      frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_272: (+1)
   \     0x10B4   0x2000             MOVS     R0,#+0
   4634                      break;
   4635                    }
   4636                  }
   4637                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_273: (+1)
   \     0x10B6   0xE2D6             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4638          #endif /* LPTIM5 */
   4639          
   4640          #if defined(LPTIM6)
   4641                case RCC_PERIPHCLK_LPTIM6:
   4642                  /* Get the current LPTIM6 source */
   4643                  srcclk = __HAL_RCC_GET_LPTIM6_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_48: (+1)
   \     0x10B8   0x48AC             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_2
   \     0x10BA   0x6800             LDR      R0,[R0, #+0]
   \     0x10BC   0xF010 0x40E0      ANDS     R0,R0,#0x70000000
   4644          
   4645                  switch (srcclk)
   \     0x10C0   0x2800             CMP      R0,#+0
   \     0x10C2   0xD00F             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_282
   \     0x10C4   0xF1B0 0x5F80      CMP      R0,#+268435456
   \     0x10C8   0xD00F             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_283
   \     0x10CA   0xF1B0 0x5F00      CMP      R0,#+536870912
   \     0x10CE   0xD011             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_284
   \     0x10D0   0xF1B0 0x5F40      CMP      R0,#+805306368
   \     0x10D4   0xD013             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_285
   \     0x10D6   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \     0x10DA   0xD01A             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_286
   \     0x10DC   0xF1B0 0x4FA0      CMP      R0,#+1342177280
   \     0x10E0   0xD021             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_287
   \     0x10E2   0xE047             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_288
   4646                  {
   4647                    case RCC_LPTIM6CLKSOURCE_PCLK3:
   4648                    {
   4649                      frequency = HAL_RCC_GetPCLK3Freq();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_282: (+1)
   \     0x10E4   0x.... 0x....      BL       HAL_RCC_GetPCLK3Freq
   4650                      break;
   \     0x10E8   0xE045             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_289
   4651                    }
   4652                    case RCC_LPTIM6CLKSOURCE_PLL2P:
   4653                    {
   4654                      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_283: (+1)
   \     0x10EA   0xA803             ADD      R0,SP,#+12
   \     0x10EC   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   4655                      frequency = pll2_clocks.PLL2_P_Frequency;
   \     0x10F0   0x9803             LDR      R0,[SP, #+12]
   4656                      break;
   \     0x10F2   0xE040             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_289
   4657                    }
   4658                    case RCC_LPTIM6CLKSOURCE_PLL3R:
   4659                    {
   4660                      HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_284: (+1)
   \     0x10F4   0x4668             MOV      R0,SP
   \     0x10F6   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4661                      frequency = pll3_clocks.PLL3_R_Frequency;
   \     0x10FA   0x9802             LDR      R0,[SP, #+8]
   4662                      break;
   \     0x10FC   0xE03B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_289
   4663                    }
   4664                    case RCC_LPTIM6CLKSOURCE_LSE:
   4665                    {
   4666                      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_285: (+1)
   \     0x10FE   0xF8DF 0x0478      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x8
   \     0x1102   0x6800             LDR      R0,[R0, #+0]
   \     0x1104   0x0780             LSLS     R0,R0,#+30
   \     0x1106   0xD502             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_290
   4667                      {
   4668                        frequency = LSE_VALUE;
   \     0x1108   0xF44F 0x4000      MOV      R0,#+32768
   \     0x110C   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_291
   4669                      }
   4670                      else
   4671                      {
   4672                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_290: (+1)
   \     0x110E   0x2000             MOVS     R0,#+0
   4673                      }
   4674                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_291: (+1)
   \     0x1110   0xE031             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_289
   4675                    }
   4676                    case RCC_LPTIM6CLKSOURCE_LSI:
   4677                    {
   4678                      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_286: (+1)
   \     0x1112   0xF8DF 0x0464      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x8
   \     0x1116   0x6800             LDR      R0,[R0, #+0]
   \     0x1118   0x0100             LSLS     R0,R0,#+4
   \     0x111A   0xD502             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_292
   4679                      {
   4680                        frequency = LSI_VALUE;
   \     0x111C   0xF44F 0x40FA      MOV      R0,#+32000
   \     0x1120   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_293
   4681                      }
   4682                      else
   4683                      {
   4684                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_292: (+1)
   \     0x1122   0x2000             MOVS     R0,#+0
   4685                      }
   4686                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_293: (+1)
   \     0x1124   0xE027             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_289
   4687                    }
   4688                    case RCC_LPTIM6CLKSOURCE_CLKP: /* CLKP is the clock source for LPTIM6 */
   4689                    {
   4690                      ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_287: (+1)
   \     0x1126   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \     0x112A   0x6800             LDR      R0,[R0, #+0]
   \     0x112C   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   4691          
   4692                      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
   \     0x1130   0xF8DF 0x143C      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \     0x1134   0x680A             LDR      R2,[R1, #+0]
   \     0x1136   0x0792             LSLS     R2,R2,#+30
   \     0x1138   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_294
   \     0x113A   0x2800             CMP      R0,#+0
   \     0x113C   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_294
   4693                      {
   4694                        /* In Case the CKPER Source is HSI */
   4695                        frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \     0x113E   0x.... 0x....      LDR.W    R0,??DataTable7
   \     0x1142   0x6809             LDR      R1,[R1, #+0]
   \     0x1144   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \     0x1148   0x40C8             LSRS     R0,R0,R1
   \     0x114A   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_295
   4696                      }
   4697          
   4698                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_294: (+1)
   \     0x114C   0x680A             LDR      R2,[R1, #+0]
   \     0x114E   0x0592             LSLS     R2,R2,#+22
   \     0x1150   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_296
   \     0x1152   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \     0x1156   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_296
   4699                      {
   4700                        /* In Case the CKPER Source is CSI */
   4701                        frequency = CSI_VALUE;
   \     0x1158   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \     0x115C   0xE009             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_295
   4702                      }
   4703          
   4704                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_296: (+1)
   \     0x115E   0x6809             LDR      R1,[R1, #+0]
   \     0x1160   0x0389             LSLS     R1,R1,#+14
   \     0x1162   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_297
   \     0x1164   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \     0x1168   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_297
   4705                      {
   4706                        /* In Case the CKPER Source is HSE */
   4707                        frequency = HSE_VALUE;
   \     0x116A   0xF8DF 0x0408      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \     0x116E   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_295
   4708                      }
   4709          
   4710                      else
   4711                      {
   4712                        /* In Case the CKPER is disabled*/
   4713                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_297: (+1)
   \     0x1170   0x2000             MOVS     R0,#+0
   4714                      }
   4715          
   4716                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_295: (+1)
   \     0x1172   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_289
   4717                    }
   4718                    default :
   4719                    {
   4720                      frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_288: (+1)
   \     0x1174   0x2000             MOVS     R0,#+0
   4721                      break;
   4722                    }
   4723                  }
   4724                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_289: (+1)
   \     0x1176   0xE276             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4725          #endif /* LPTIM6 */
   4726          
   4727                case RCC_PERIPHCLK_FDCAN:
   4728                  /* Get the current FDCAN kernel source */
   4729                  srcclk = __HAL_RCC_GET_FDCAN_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_42: (+1)
   \     0x1178   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \     0x117C   0x6800             LDR      R0,[R0, #+0]
   \     0x117E   0xF410 0x7040      ANDS     R0,R0,#0x300
   4730          
   4731                  if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_FDCANCLKSOURCE_HSE))
   \     0x1182   0xF8DF 0x13EC      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \     0x1186   0x6809             LDR      R1,[R1, #+0]
   \     0x1188   0x0389             LSLS     R1,R1,#+14
   \     0x118A   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_298
   \     0x118C   0x2800             CMP      R0,#+0
   \     0x118E   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_298
   4732                  {
   4733                    frequency = HSE_VALUE;
   \     0x1190   0xF8DF 0x03E0      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \     0x1194   0xE010             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_299
   4734                  }
   4735                  else if (srcclk == RCC_FDCANCLKSOURCE_PLL1Q)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_298: (+1)
   \     0x1196   0xF5B0 0x7F80      CMP      R0,#+256
   \     0x119A   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_300
   4736                  {
   4737                    HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
   \     0x119C   0xA806             ADD      R0,SP,#+24
   \     0x119E   0x.... 0x....      BL       HAL_RCCEx_GetPLL1ClockFreq
   4738                    frequency = pll1_clocks.PLL1_Q_Frequency;
   \     0x11A2   0x9807             LDR      R0,[SP, #+28]
   \     0x11A4   0xE008             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_299
   4739                  }
   4740                  else if (srcclk == RCC_FDCANCLKSOURCE_PLL2Q)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_300: (+1)
   \     0x11A6   0xF5B0 0x7F00      CMP      R0,#+512
   \     0x11AA   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_301
   4741                  {
   4742                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \     0x11AC   0xA803             ADD      R0,SP,#+12
   \     0x11AE   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   4743                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \     0x11B2   0x9804             LDR      R0,[SP, #+16]
   \     0x11B4   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_299
   4744                  }
   4745                  /* Clock not enabled for FDCAN */
   4746                  else
   4747                  {
   4748                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_301: (+1)
   \     0x11B6   0x2000             MOVS     R0,#+0
   4749                  }
   4750                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_299: (+1)
   \     0x11B8   0xE255             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4751          
   4752                case RCC_PERIPHCLK_SPI1:
   4753                  /* Get the current SPI1 kernel source */
   4754                  srcclk = __HAL_RCC_GET_SPI1_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_35: (+1)
   \     0x11BA   0xF8DF 0x02D0      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_3
   \     0x11BE   0x6800             LDR      R0,[R0, #+0]
   \     0x11C0   0xF010 0x0007      ANDS     R0,R0,#0x7
   4755                  switch (srcclk)
   \     0x11C4   0x2800             CMP      R0,#+0
   \     0x11C6   0xD006             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_302
   \     0x11C8   0x2802             CMP      R0,#+2
   \     0x11CA   0xD00E             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_303
   \     0x11CC   0xD308             BCC.N    ??HAL_RCCEx_GetPeriphCLKFreq_304
   \     0x11CE   0x2804             CMP      R0,#+4
   \     0x11D0   0xD013             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_305
   \     0x11D2   0xD30F             BCC.N    ??HAL_RCCEx_GetPeriphCLKFreq_306
   \     0x11D4   0xE038             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_307
   4756                  {
   4757                    case RCC_SPI1CLKSOURCE_PLL1Q:
   4758                    {
   4759                      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_302: (+1)
   \     0x11D6   0xA806             ADD      R0,SP,#+24
   \     0x11D8   0x.... 0x....      BL       HAL_RCCEx_GetPLL1ClockFreq
   4760                      frequency = pll1_clocks.PLL1_Q_Frequency;
   \     0x11DC   0x9807             LDR      R0,[SP, #+28]
   4761                      break;
   \     0x11DE   0xE034             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_308
   4762                    }
   4763                    case RCC_SPI1CLKSOURCE_PLL2P:
   4764                    {
   4765                      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_304: (+1)
   \     0x11E0   0xA803             ADD      R0,SP,#+12
   \     0x11E2   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   4766                      frequency = pll2_clocks.PLL2_P_Frequency;
   \     0x11E6   0x9803             LDR      R0,[SP, #+12]
   4767                      break;
   \     0x11E8   0xE02F             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_308
   4768                    }
   4769          #if defined(RCC_SPI1CLKSOURCE_PLL3P)
   4770                    case RCC_SPI1CLKSOURCE_PLL3P:
   4771                    {
   4772                      HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_303: (+1)
   \     0x11EA   0x4668             MOV      R0,SP
   \     0x11EC   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4773                      frequency = pll3_clocks.PLL3_P_Frequency;
   \     0x11F0   0x9800             LDR      R0,[SP, #+0]
   4774                      break;
   \     0x11F2   0xE02A             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_308
   4775                    }
   4776          #endif /* RCC_SPI1CLKSOURCE_PLL3P */
   4777                    case RCC_SPI1CLKSOURCE_PIN:
   4778                    {
   4779                      frequency = EXTERNAL_CLOCK_VALUE;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_306: (+1)
   \     0x11F4   0x.... 0x....      LDR.W    R0,??DataTable23
   4780                      break;
   \     0x11F8   0xE027             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_308
   4781                    }
   4782                    case RCC_SPI1CLKSOURCE_CLKP:
   4783                    {
   4784                      ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_305: (+1)
   \     0x11FA   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \     0x11FE   0x6800             LDR      R0,[R0, #+0]
   \     0x1200   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   4785          
   4786                      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
   \     0x1204   0xF8DF 0x1368      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \     0x1208   0x680A             LDR      R2,[R1, #+0]
   \     0x120A   0x0792             LSLS     R2,R2,#+30
   \     0x120C   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_309
   \     0x120E   0x2800             CMP      R0,#+0
   \     0x1210   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_309
   4787                      {
   4788                        /* In Case the CKPER Source is HSI */
   4789                        frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \     0x1212   0x.... 0x....      LDR.W    R0,??DataTable7
   \     0x1216   0x6809             LDR      R1,[R1, #+0]
   \     0x1218   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \     0x121C   0x40C8             LSRS     R0,R0,R1
   \     0x121E   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_310
   4790                      }
   4791          
   4792                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_309: (+1)
   \     0x1220   0x680A             LDR      R2,[R1, #+0]
   \     0x1222   0x0592             LSLS     R2,R2,#+22
   \     0x1224   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_311
   \     0x1226   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \     0x122A   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_311
   4793                      {
   4794                        /* In Case the CKPER Source is CSI */
   4795                        frequency = CSI_VALUE;
   \     0x122C   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \     0x1230   0xE009             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_310
   4796                      }
   4797          
   4798                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_311: (+1)
   \     0x1232   0x6809             LDR      R1,[R1, #+0]
   \     0x1234   0x0389             LSLS     R1,R1,#+14
   \     0x1236   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_312
   \     0x1238   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \     0x123C   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_312
   4799                      {
   4800                        /* In Case the CKPER Source is HSE */
   4801                        frequency = HSE_VALUE;
   \     0x123E   0xF8DF 0x0334      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \     0x1242   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_310
   4802                      }
   4803          
   4804                      else
   4805                      {
   4806                        /* In Case the CKPER is disabled*/
   4807                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_312: (+1)
   \     0x1244   0x2000             MOVS     R0,#+0
   4808                      }
   4809          
   4810                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_310: (+1)
   \     0x1246   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_308
   4811                    }
   4812                    default:
   4813                    {
   4814                      frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_307: (+1)
   \     0x1248   0x2000             MOVS     R0,#+0
   4815                      break;
   4816                    }
   4817                  }
   4818                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_308: (+1)
   \     0x124A   0xE20C             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4819          
   4820                case RCC_PERIPHCLK_SPI2:
   4821                  /* Get the current SPI2 kernel source */
   4822                  srcclk = __HAL_RCC_GET_SPI2_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_36: (+1)
   \     0x124C   0x488F             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_3
   \     0x124E   0x6800             LDR      R0,[R0, #+0]
   \     0x1250   0xF010 0x0038      ANDS     R0,R0,#0x38
   4823                  switch (srcclk)
   \     0x1254   0x2800             CMP      R0,#+0
   \     0x1256   0xD008             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_313
   \     0x1258   0x2808             CMP      R0,#+8
   \     0x125A   0xD00B             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_314
   \     0x125C   0x2810             CMP      R0,#+16
   \     0x125E   0xD00E             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_315
   \     0x1260   0x2818             CMP      R0,#+24
   \     0x1262   0xD011             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_316
   \     0x1264   0x2820             CMP      R0,#+32
   \     0x1266   0xD012             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_317
   \     0x1268   0xE038             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_318
   4824                  {
   4825                    case RCC_SPI2CLKSOURCE_PLL1Q:
   4826                    {
   4827                      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_313: (+1)
   \     0x126A   0xA806             ADD      R0,SP,#+24
   \     0x126C   0x.... 0x....      BL       HAL_RCCEx_GetPLL1ClockFreq
   4828                      frequency = pll1_clocks.PLL1_Q_Frequency;
   \     0x1270   0x9807             LDR      R0,[SP, #+28]
   4829                      break;
   \     0x1272   0xE034             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_319
   4830                    }
   4831                    case RCC_SPI2CLKSOURCE_PLL2P:
   4832                    {
   4833                      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_314: (+1)
   \     0x1274   0xA803             ADD      R0,SP,#+12
   \     0x1276   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   4834                      frequency = pll2_clocks.PLL2_P_Frequency;
   \     0x127A   0x9803             LDR      R0,[SP, #+12]
   4835                      break;
   \     0x127C   0xE02F             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_319
   4836                    }
   4837          #if defined(RCC_SPI2CLKSOURCE_PLL3P)
   4838                    case RCC_SPI2CLKSOURCE_PLL3P:
   4839                    {
   4840                      HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_315: (+1)
   \     0x127E   0x4668             MOV      R0,SP
   \     0x1280   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4841                      frequency = pll3_clocks.PLL3_P_Frequency;
   \     0x1284   0x9800             LDR      R0,[SP, #+0]
   4842                      break;
   \     0x1286   0xE02A             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_319
   4843                    }
   4844          #endif /* RCC_SPI2CLKSOURCE_PLL3P */
   4845                    case RCC_SPI2CLKSOURCE_PIN:
   4846                    {
   4847                      frequency = EXTERNAL_CLOCK_VALUE;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_316: (+1)
   \     0x1288   0x.... 0x....      LDR.W    R0,??DataTable23
   4848                      break;
   \     0x128C   0xE027             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_319
   4849                    }
   4850                    case RCC_SPI2CLKSOURCE_CLKP:
   4851                    {
   4852                      ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_317: (+1)
   \     0x128E   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \     0x1292   0x6800             LDR      R0,[R0, #+0]
   \     0x1294   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   4853          
   4854                      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
   \     0x1298   0xF8DF 0x12D4      LDR.W    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \     0x129C   0x680A             LDR      R2,[R1, #+0]
   \     0x129E   0x0792             LSLS     R2,R2,#+30
   \     0x12A0   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_320
   \     0x12A2   0x2800             CMP      R0,#+0
   \     0x12A4   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_320
   4855                      {
   4856                        /* In Case the CKPER Source is HSI */
   4857                        frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \     0x12A6   0x.... 0x....      LDR.W    R0,??DataTable7
   \     0x12AA   0x6809             LDR      R1,[R1, #+0]
   \     0x12AC   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \     0x12B0   0x40C8             LSRS     R0,R0,R1
   \     0x12B2   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_321
   4858                      }
   4859          
   4860                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_320: (+1)
   \     0x12B4   0x680A             LDR      R2,[R1, #+0]
   \     0x12B6   0x0592             LSLS     R2,R2,#+22
   \     0x12B8   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_322
   \     0x12BA   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \     0x12BE   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_322
   4861                      {
   4862                        /* In Case the CKPER Source is CSI */
   4863                        frequency = CSI_VALUE;
   \     0x12C0   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \     0x12C4   0xE009             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_321
   4864                      }
   4865          
   4866                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_322: (+1)
   \     0x12C6   0x6809             LDR      R1,[R1, #+0]
   \     0x12C8   0x0389             LSLS     R1,R1,#+14
   \     0x12CA   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_323
   \     0x12CC   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \     0x12D0   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_323
   4867                      {
   4868                        /* In Case the CKPER Source is HSE */
   4869                        frequency = HSE_VALUE;
   \     0x12D2   0xF8DF 0x02A0      LDR.W    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \     0x12D6   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_321
   4870                      }
   4871          
   4872                      else
   4873                      {
   4874                        /* In Case the CKPER is disabled*/
   4875                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_323: (+1)
   \     0x12D8   0x2000             MOVS     R0,#+0
   4876                      }
   4877          
   4878                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_321: (+1)
   \     0x12DA   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_319
   4879                    }
   4880                    default:
   4881                    {
   4882                      frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_318: (+1)
   \     0x12DC   0x2000             MOVS     R0,#+0
   4883                      break;
   4884                    }
   4885                  }
   4886                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_319: (+1)
   \     0x12DE   0xE1C2             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4887          
   4888                case RCC_PERIPHCLK_SPI3:
   4889                  /* Get the current SPI3 kernel source */
   4890                  srcclk = __HAL_RCC_GET_SPI3_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_37: (+1)
   \     0x12E0   0x486A             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_3
   \     0x12E2   0x6800             LDR      R0,[R0, #+0]
   \     0x12E4   0xF410 0x70E0      ANDS     R0,R0,#0x1C0
   4891                  switch (srcclk)
   \     0x12E8   0x2800             CMP      R0,#+0
   \     0x12EA   0xD009             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_324
   \     0x12EC   0x2840             CMP      R0,#+64
   \     0x12EE   0xD00C             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_325
   \     0x12F0   0x2880             CMP      R0,#+128
   \     0x12F2   0xD00F             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_326
   \     0x12F4   0x28C0             CMP      R0,#+192
   \     0x12F6   0xD012             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_327
   \     0x12F8   0xF5B0 0x7F80      CMP      R0,#+256
   \     0x12FC   0xD012             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_328
   \     0x12FE   0xE039             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_329
   4892                  {
   4893                    case RCC_SPI3CLKSOURCE_PLL1Q:
   4894                    {
   4895                      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_324: (+1)
   \     0x1300   0xA806             ADD      R0,SP,#+24
   \     0x1302   0x.... 0x....      BL       HAL_RCCEx_GetPLL1ClockFreq
   4896                      frequency = pll1_clocks.PLL1_Q_Frequency;
   \     0x1306   0x9807             LDR      R0,[SP, #+28]
   4897                      break;
   \     0x1308   0xE035             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_330
   4898                    }
   4899                    case RCC_SPI3CLKSOURCE_PLL2P:
   4900                    {
   4901                      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_325: (+1)
   \     0x130A   0xA803             ADD      R0,SP,#+12
   \     0x130C   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   4902                      frequency = pll2_clocks.PLL2_P_Frequency;
   \     0x1310   0x9803             LDR      R0,[SP, #+12]
   4903                      break;
   \     0x1312   0xE030             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_330
   4904                    }
   4905          #if defined(RCC_SPI3CLKSOURCE_PLL3P)
   4906                    case RCC_SPI3CLKSOURCE_PLL3P:
   4907                    {
   4908                      HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_326: (+1)
   \     0x1314   0x4668             MOV      R0,SP
   \     0x1316   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4909                      frequency = pll3_clocks.PLL3_P_Frequency;
   \     0x131A   0x9800             LDR      R0,[SP, #+0]
   4910                      break;
   \     0x131C   0xE02B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_330
   4911                    }
   4912          #endif /* RCC_SPI3CLKSOURCE_PLL3P */
   4913                    case RCC_SPI3CLKSOURCE_PIN:
   4914                    {
   4915                      frequency = EXTERNAL_CLOCK_VALUE;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_327: (+1)
   \     0x131E   0x.... 0x....      LDR.W    R0,??DataTable23
   4916                      break;
   \     0x1322   0xE028             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_330
   4917                    }
   4918                    case RCC_SPI3CLKSOURCE_CLKP:
   4919                    {
   4920                      ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_328: (+1)
   \     0x1324   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \     0x1328   0x6800             LDR      R0,[R0, #+0]
   \     0x132A   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   4921          
   4922                      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
   \     0x132E   0x4990             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \     0x1330   0x680A             LDR      R2,[R1, #+0]
   \     0x1332   0x0792             LSLS     R2,R2,#+30
   \     0x1334   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_331
   \     0x1336   0x2800             CMP      R0,#+0
   \     0x1338   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_331
   4923                      {
   4924                        /* In Case the CKPER Source is HSI */
   4925                        frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \     0x133A   0x.... 0x....      LDR.W    R0,??DataTable7
   \     0x133E   0x6809             LDR      R1,[R1, #+0]
   \     0x1340   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \     0x1344   0x40C8             LSRS     R0,R0,R1
   \     0x1346   0xE014             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_332
   4926                      }
   4927          
   4928                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_331: (+1)
   \     0x1348   0x680A             LDR      R2,[R1, #+0]
   \     0x134A   0x0592             LSLS     R2,R2,#+22
   \     0x134C   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_333
   \     0x134E   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \     0x1352   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_333
   4929                      {
   4930                        /* In Case the CKPER Source is CSI */
   4931                        frequency = CSI_VALUE;
   \     0x1354   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \     0x1358   0xE00B             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_332
   4932                      }
   4933          
   4934                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_333: (+1)
   \     0x135A   0x6809             LDR      R1,[R1, #+0]
   \     0x135C   0x0389             LSLS     R1,R1,#+14
   \     0x135E   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_334
   \     0x1360   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \     0x1364   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_334
   4935                      {
   4936                        /* In Case the CKPER Source is HSE */
   4937                        frequency = HSE_VALUE;
   \     0x1366   0x4883             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \     0x1368   0xE003             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_332
   \     0x136A   0xBF00             Nop
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_2:
   \     0x136C   0x4402'0CDC        DC32     0x44020cdc
   4938                      }
   4939          
   4940                      else
   4941                      {
   4942                        /* In Case the CKPER is disabled*/
   4943                        frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_334: (+1)
   \     0x1370   0x2000             MOVS     R0,#+0
   4944                      }
   4945          
   4946                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_332: (+1)
   \     0x1372   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_330
   4947                    }
   4948                    default:
   4949                    {
   4950                      frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_329: (+1)
   \     0x1374   0x2000             MOVS     R0,#+0
   4951                      break;
   4952                    }
   4953                  }
   4954                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_330: (+1)
   \     0x1376   0xE176             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4955          
   4956          #if defined(SPI4)
   4957                case RCC_PERIPHCLK_SPI4:
   4958                  /* Get the current SPI4 kernel source */
   4959                  srcclk = __HAL_RCC_GET_SPI4_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_38: (+1)
   \     0x1378   0x4844             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_3
   \     0x137A   0x6800             LDR      R0,[R0, #+0]
   \     0x137C   0xF410 0x6060      ANDS     R0,R0,#0xE00
   4960          
   4961                  if (srcclk == RCC_SPI4CLKSOURCE_PCLK2)
   \     0x1380   0x2800             CMP      R0,#+0
   \     0x1382   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_335
   4962                  {
   4963                    frequency = HAL_RCC_GetPCLK2Freq();
   \     0x1384   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \     0x1388   0xE035             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_336
   4964                  }
   4965                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_SPI4CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_335: (+1)
   \     0x138A   0x4979             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \     0x138C   0x680A             LDR      R2,[R1, #+0]
   \     0x138E   0x0112             LSLS     R2,R2,#+4
   \     0x1390   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_337
   \     0x1392   0xF5B0 0x7F00      CMP      R0,#+512
   \     0x1396   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_337
   4966                  {
   4967                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \     0x1398   0xA803             ADD      R0,SP,#+12
   \     0x139A   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   4968                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \     0x139E   0x9804             LDR      R0,[SP, #+16]
   \     0x13A0   0xE029             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_336
   4969                  }
   4970                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_SPI4CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_337: (+1)
   \     0x13A2   0x680A             LDR      R2,[R1, #+0]
   \     0x13A4   0x0092             LSLS     R2,R2,#+2
   \     0x13A6   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_338
   \     0x13A8   0xF5B0 0x6F80      CMP      R0,#+1024
   \     0x13AC   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_338
   4971                  {
   4972                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \     0x13AE   0x4668             MOV      R0,SP
   \     0x13B0   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   4973                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \     0x13B4   0x9801             LDR      R0,[SP, #+4]
   \     0x13B6   0xE01E             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_336
   4974                  }
   4975                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_SPI4CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_338: (+1)
   \     0x13B8   0x680A             LDR      R2,[R1, #+0]
   \     0x13BA   0x0792             LSLS     R2,R2,#+30
   \     0x13BC   0xD509             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_339
   \     0x13BE   0xF5B0 0x6FC0      CMP      R0,#+1536
   \     0x13C2   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_339
   4976                  {
   4977                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \     0x13C4   0x.... 0x....      LDR.W    R0,??DataTable7
   \     0x13C8   0x6809             LDR      R1,[R1, #+0]
   \     0x13CA   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \     0x13CE   0x40C8             LSRS     R0,R0,R1
   \     0x13D0   0xE011             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_336
   4978                  }
   4979                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_SPI4CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_339: (+1)
   \     0x13D2   0x680A             LDR      R2,[R1, #+0]
   \     0x13D4   0x0592             LSLS     R2,R2,#+22
   \     0x13D6   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_340
   \     0x13D8   0xF5B0 0x6F00      CMP      R0,#+2048
   \     0x13DC   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_340
   4980                  {
   4981                    frequency = CSI_VALUE;
   \     0x13DE   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \     0x13E2   0xE008             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_336
   4982                  }
   4983                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_SPI4CLKSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_340: (+1)
   \     0x13E4   0x6809             LDR      R1,[R1, #+0]
   \     0x13E6   0x0389             LSLS     R1,R1,#+14
   \     0x13E8   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_341
   \     0x13EA   0xF5B0 0x6F20      CMP      R0,#+2560
   \     0x13EE   0xD101             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_341
   4984                  {
   4985                    frequency = HSE_VALUE;
   \     0x13F0   0x4860             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \     0x13F2   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_336
   4986                  }
   4987                  /* Clock not enabled for SPI4 */
   4988                  else
   4989                  {
   4990                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_341: (+1)
   \     0x13F4   0x2000             MOVS     R0,#+0
   4991                  }
   4992          
   4993                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_336: (+1)
   \     0x13F6   0xE136             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   4994          #endif /* SPI4 */
   4995          
   4996          #if defined(SPI5)
   4997                case RCC_PERIPHCLK_SPI5:
   4998                  /* Get the current SPI5 kernel source */
   4999                  srcclk = __HAL_RCC_GET_SPI5_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_39: (+1)
   \     0x13F8   0x4824             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_3
   \     0x13FA   0x6800             LDR      R0,[R0, #+0]
   \     0x13FC   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   5000          
   5001                  if (srcclk == RCC_SPI5CLKSOURCE_PCLK3)
   \     0x1400   0x2800             CMP      R0,#+0
   \     0x1402   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_342
   5002                  {
   5003                    frequency = HAL_RCC_GetPCLK3Freq();
   \     0x1404   0x.... 0x....      BL       HAL_RCC_GetPCLK3Freq
   \     0x1408   0xE035             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_343
   5004                  }
   5005                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_SPI5CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_342: (+1)
   \     0x140A   0x4959             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \     0x140C   0x680A             LDR      R2,[R1, #+0]
   \     0x140E   0x0112             LSLS     R2,R2,#+4
   \     0x1410   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_344
   \     0x1412   0xF5B0 0x5F80      CMP      R0,#+4096
   \     0x1416   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_344
   5006                  {
   5007                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \     0x1418   0xA803             ADD      R0,SP,#+12
   \     0x141A   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   5008                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \     0x141E   0x9804             LDR      R0,[SP, #+16]
   \     0x1420   0xE029             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_343
   5009                  }
   5010                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_SPI5CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_344: (+1)
   \     0x1422   0x680A             LDR      R2,[R1, #+0]
   \     0x1424   0x0092             LSLS     R2,R2,#+2
   \     0x1426   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_345
   \     0x1428   0xF5B0 0x5F00      CMP      R0,#+8192
   \     0x142C   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_345
   5011                  {
   5012                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \     0x142E   0x4668             MOV      R0,SP
   \     0x1430   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   5013                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \     0x1434   0x9801             LDR      R0,[SP, #+4]
   \     0x1436   0xE01E             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_343
   5014                  }
   5015                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_SPI5CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_345: (+1)
   \     0x1438   0x680A             LDR      R2,[R1, #+0]
   \     0x143A   0x0792             LSLS     R2,R2,#+30
   \     0x143C   0xD509             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_346
   \     0x143E   0xF5B0 0x5F40      CMP      R0,#+12288
   \     0x1442   0xD106             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_346
   5016                  {
   5017                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \     0x1444   0x.... 0x....      LDR.W    R0,??DataTable7
   \     0x1448   0x6809             LDR      R1,[R1, #+0]
   \     0x144A   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \     0x144E   0x40C8             LSRS     R0,R0,R1
   \     0x1450   0xE011             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_343
   5018                  }
   5019                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_SPI5CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_346: (+1)
   \     0x1452   0x680A             LDR      R2,[R1, #+0]
   \     0x1454   0x0592             LSLS     R2,R2,#+22
   \     0x1456   0xD505             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_347
   \     0x1458   0xF5B0 0x4F80      CMP      R0,#+16384
   \     0x145C   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_347
   5020                  {
   5021                    frequency = CSI_VALUE;
   \     0x145E   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \     0x1462   0xE008             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_343
   5022                  }
   5023                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_SPI5CLKSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_347: (+1)
   \     0x1464   0x6809             LDR      R1,[R1, #+0]
   \     0x1466   0x0389             LSLS     R1,R1,#+14
   \     0x1468   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_348
   \     0x146A   0xF5B0 0x4FA0      CMP      R0,#+20480
   \     0x146E   0xD101             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_348
   5024                  {
   5025                    frequency = HSE_VALUE;
   \     0x1470   0x4840             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \     0x1472   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_343
   5026                  }
   5027                  /* Clock not enabled for SPI5 */
   5028                  else
   5029                  {
   5030                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_348: (+1)
   \     0x1474   0x2000             MOVS     R0,#+0
   5031                  }
   5032          
   5033                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_343: (+1)
   \     0x1476   0xE0F6             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   5034          #endif /* SPI5 */
   5035          
   5036          #if defined(SPI6)
   5037                case RCC_PERIPHCLK_SPI6:
   5038                  /* Get the current SPI6 kernel source */
   5039                  srcclk = __HAL_RCC_GET_SPI6_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_40: (+1)
   \     0x1478   0x4804             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_3
   \     0x147A   0x6800             LDR      R0,[R0, #+0]
   \     0x147C   0xF410 0x3060      ANDS     R0,R0,#0x38000
   5040          
   5041                  if (srcclk == RCC_SPI6CLKSOURCE_PCLK2)
   \     0x1480   0x2800             CMP      R0,#+0
   \     0x1482   0xD105             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_349
   5042                  {
   5043                    frequency = HAL_RCC_GetPCLK2Freq();
   \     0x1484   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \     0x1488   0xE036             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_350
   \     0x148A   0xBF00             Nop
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_3:
   \     0x148C   0x4402'0CE0        DC32     0x44020ce0
   5044                  }
   5045                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_SPI6CLKSOURCE_PLL2Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_349: (+1)
   \     0x1490   0x4937             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \     0x1492   0x680A             LDR      R2,[R1, #+0]
   \     0x1494   0x0112             LSLS     R2,R2,#+4
   \     0x1496   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_351
   \     0x1498   0xF5B0 0x4F00      CMP      R0,#+32768
   \     0x149C   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_351
   5046                  {
   5047                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \     0x149E   0xA803             ADD      R0,SP,#+12
   \     0x14A0   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   5048                    frequency = pll2_clocks.PLL2_Q_Frequency;
   \     0x14A4   0x9804             LDR      R0,[SP, #+16]
   \     0x14A6   0xE027             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_350
   5049                  }
   5050                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_SPI6CLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_351: (+1)
   \     0x14A8   0x680A             LDR      R2,[R1, #+0]
   \     0x14AA   0x0092             LSLS     R2,R2,#+2
   \     0x14AC   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_352
   \     0x14AE   0xF5B0 0x3F80      CMP      R0,#+65536
   \     0x14B2   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_352
   5051                  {
   5052                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \     0x14B4   0x4668             MOV      R0,SP
   \     0x14B6   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   5053                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \     0x14BA   0x9801             LDR      R0,[SP, #+4]
   \     0x14BC   0xE01C             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_350
   5054                  }
   5055                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_SPI6CLKSOURCE_HSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_352: (+1)
   \     0x14BE   0x680A             LDR      R2,[R1, #+0]
   \     0x14C0   0x0792             LSLS     R2,R2,#+30
   \     0x14C2   0xD508             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_353
   \     0x14C4   0xF5B0 0x3FC0      CMP      R0,#+98304
   \     0x14C8   0xD105             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_353
   5056                  {
   5057                    frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \     0x14CA   0x....             LDR.N    R0,??DataTable7
   \     0x14CC   0x6809             LDR      R1,[R1, #+0]
   \     0x14CE   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \     0x14D2   0x40C8             LSRS     R0,R0,R1
   \     0x14D4   0xE010             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_350
   5058                  }
   5059                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_SPI6CLKSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_353: (+1)
   \     0x14D6   0x680A             LDR      R2,[R1, #+0]
   \     0x14D8   0x0592             LSLS     R2,R2,#+22
   \     0x14DA   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_354
   \     0x14DC   0xF5B0 0x3F00      CMP      R0,#+131072
   \     0x14E0   0xD101             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_354
   5060                  {
   5061                    frequency = CSI_VALUE;
   \     0x14E2   0x....             LDR.N    R0,??DataTable7_2
   \     0x14E4   0xE008             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_350
   5062                  }
   5063                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_SPI6CLKSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_354: (+1)
   \     0x14E6   0x6809             LDR      R1,[R1, #+0]
   \     0x14E8   0x0389             LSLS     R1,R1,#+14
   \     0x14EA   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_355
   \     0x14EC   0xF5B0 0x3F20      CMP      R0,#+163840
   \     0x14F0   0xD101             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_355
   5064                  {
   5065                    frequency = HSE_VALUE;
   \     0x14F2   0x4820             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \     0x14F4   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_350
   5066                  }
   5067                  /* Clock not enabled for SPI6 */
   5068                  else
   5069                  {
   5070                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_355: (+1)
   \     0x14F6   0x2000             MOVS     R0,#+0
   5071                  }
   5072          
   5073                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_350: (+1)
   \     0x14F8   0xE0B5             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   5074          #endif /* SPI6 */
   5075          
   5076          #if defined(OCTOSPI1)
   5077                case RCC_PERIPHCLK_OSPI:
   5078                  /* Get the current OSPI kernel source */
   5079                  srcclk = __HAL_RCC_GET_OSPI_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_41: (+1)
   \     0x14FA   0x.... 0x....      LDR.W    R0,??DataTable24
   \     0x14FE   0x6800             LDR      R0,[R0, #+0]
   \     0x1500   0xF010 0x0003      ANDS     R0,R0,#0x3
   5080          
   5081                  switch (srcclk)
   \     0x1504   0x2800             CMP      R0,#+0
   \     0x1506   0xD005             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_356
   \     0x1508   0x2802             CMP      R0,#+2
   \     0x150A   0xD00B             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_357
   \     0x150C   0xD305             BCC.N    ??HAL_RCCEx_GetPeriphCLKFreq_358
   \     0x150E   0x2803             CMP      R0,#+3
   \     0x1510   0xD00D             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_359
   \     0x1512   0xE035             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_360
   5082                  {
   5083                    case RCC_OSPICLKSOURCE_HCLK:
   5084                    {
   5085                      frequency = HAL_RCC_GetHCLKFreq();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_356: (+1)
   \     0x1514   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   5086                      break;
   \     0x1518   0xE033             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_361
   5087                    }
   5088                    case RCC_OSPICLKSOURCE_PLL1Q:
   5089                    {
   5090                      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_358: (+1)
   \     0x151A   0xA806             ADD      R0,SP,#+24
   \     0x151C   0x.... 0x....      BL       HAL_RCCEx_GetPLL1ClockFreq
   5091                      frequency = pll1_clocks.PLL1_Q_Frequency;
   \     0x1520   0x9807             LDR      R0,[SP, #+28]
   5092                      break;
   \     0x1522   0xE02E             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_361
   5093                    }
   5094                    case RCC_OSPICLKSOURCE_PLL2R:
   5095                    {
   5096                      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_357: (+1)
   \     0x1524   0xA803             ADD      R0,SP,#+12
   \     0x1526   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   5097                      frequency = pll2_clocks.PLL2_R_Frequency;
   \     0x152A   0x9805             LDR      R0,[SP, #+20]
   5098                      break;
   \     0x152C   0xE029             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_361
   5099                    }
   5100                    case RCC_OSPICLKSOURCE_CLKP:
   5101                    {
   5102                      ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_359: (+1)
   \     0x152E   0x....             LDR.N    R0,??DataTable7_1
   \     0x1530   0x6800             LDR      R0,[R0, #+0]
   \     0x1532   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   5103          
   5104                      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
   \     0x1536   0x490E             LDR.N    R1,??HAL_RCCEx_GetPeriphCLKFreq_4
   \     0x1538   0x680A             LDR      R2,[R1, #+0]
   \     0x153A   0x0792             LSLS     R2,R2,#+30
   \     0x153C   0xD507             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_362
   \     0x153E   0x2800             CMP      R0,#+0
   \     0x1540   0xD105             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_362
   5105                      {
   5106                        /* In Case the CKPER Source is HSI */
   5107                        frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \     0x1542   0x....             LDR.N    R0,??DataTable7
   \     0x1544   0x6809             LDR      R1,[R1, #+0]
   \     0x1546   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \     0x154A   0x40C8             LSRS     R0,R0,R1
   \     0x154C   0xE017             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_363
   5108                      }
   5109          
   5110                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_362: (+1)
   \     0x154E   0x680A             LDR      R2,[R1, #+0]
   \     0x1550   0x0592             LSLS     R2,R2,#+22
   \     0x1552   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_364
   \     0x1554   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \     0x1558   0xD101             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_364
   5111                      {
   5112                        /* In Case the CKPER Source is CSI */
   5113                        frequency = CSI_VALUE;
   \     0x155A   0x....             LDR.N    R0,??DataTable7_2
   \     0x155C   0xE00F             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_363
   5114                      }
   5115          
   5116                      else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_364: (+1)
   \     0x155E   0x6809             LDR      R1,[R1, #+0]
   \     0x1560   0x0389             LSLS     R1,R1,#+14
   \     0x1562   0xD50B             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_365
   \     0x1564   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \     0x1568   0xD108             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_365
   5117                      {
   5118                        /* In Case the CKPER Source is HSE */
   5119                        frequency = HSE_VALUE;
   \     0x156A   0x4802             LDR.N    R0,??HAL_RCCEx_GetPeriphCLKFreq_4+0x4
   \     0x156C   0xE007             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_363
   \     0x156E   0xBF00             Nop
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_4:
   \     0x1570   0x4402'0C00        DC32     0x44020c00
   \     0x1574   0x017D'7840        DC32     0x17d7840
   \     0x1578   0x4402'0CF0        DC32     0x44020cf0
   5120                      }
   5121          
   5122                      else
   5123                      {
   5124                        /* In Case the CKPER is disabled*/
   5125                        frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_365: (+1)
   \     0x157C   0x2000             MOVS     R0,#+0
   5126                      }
   5127          
   5128                      break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_363: (+1)
   \     0x157E   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_361
   5129                    }
   5130                    default:
   5131                    {
   5132                      frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_360: (+1)
   \     0x1580   0x2000             MOVS     R0,#+0
   5133                      break;
   5134                    }
   5135                  }
   5136                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_361: (+1)
   \     0x1582   0xE070             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   5137          #endif /* OCTOSPI1*/
   5138          
   5139          #if defined(CEC)
   5140                case RCC_PERIPHCLK_CEC:
   5141                  /* Get the current CEC source */
   5142                  srcclk = __HAL_RCC_GET_CEC_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_43: (+1)
   \     0x1584   0x....             LDR.N    R0,??DataTable7_1
   \     0x1586   0x6800             LDR      R0,[R0, #+0]
   \     0x1588   0xF010 0x00C0      ANDS     R0,R0,#0xC0
   5143          
   5144                  if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_CECCLKSOURCE_LSE))
   \     0x158C   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \     0x1590   0x680A             LDR      R2,[R1, #+0]
   \     0x1592   0x0792             LSLS     R2,R2,#+30
   \     0x1594   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_366
   \     0x1596   0x2800             CMP      R0,#+0
   \     0x1598   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_366
   5145                  {
   5146                    frequency = LSE_VALUE;
   \     0x159A   0xF44F 0x4000      MOV      R0,#+32768
   \     0x159E   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_367
   5147                  }
   5148                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_CECCLKSOURCE_LSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_366: (+1)
   \     0x15A0   0x6809             LDR      R1,[R1, #+0]
   \     0x15A2   0x0109             LSLS     R1,R1,#+4
   \     0x15A4   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_368
   \     0x15A6   0x2840             CMP      R0,#+64
   \     0x15A8   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_368
   5149                  {
   5150                    frequency = LSI_VALUE;
   \     0x15AA   0xF44F 0x40FA      MOV      R0,#+32000
   \     0x15AE   0xE00A             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_367
   5151                  }
   5152                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (srcclk == RCC_CECCLKSOURCE_CSI_DIV122))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_368: (+1)
   \     0x15B0   0x.... 0x....      LDR.W    R1,??DataTable24_2
   \     0x15B4   0x6809             LDR      R1,[R1, #+0]
   \     0x15B6   0x0589             LSLS     R1,R1,#+22
   \     0x15B8   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_369
   \     0x15BA   0x2880             CMP      R0,#+128
   \     0x15BC   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_369
   5153                  {
   5154                    frequency = CSI_VALUE / 122U;
   \     0x15BE   0xF248 0x0012      MOVW     R0,#+32786
   \     0x15C2   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_367
   5155                  }
   5156          
   5157                  /* Clock not enabled for CEC */
   5158                  else
   5159                  {
   5160                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_369: (+1)
   \     0x15C4   0x2000             MOVS     R0,#+0
   5161                  }
   5162                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_367: (+1)
   \     0x15C6   0xE04E             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   5163          #endif /* CEC */
   5164          
   5165                case RCC_PERIPHCLK_RNG:
   5166                  /* Get the current RNG source */
   5167                  srcclk = __HAL_RCC_GET_RNG_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_34: (+1)
   \     0x15C8   0x....             LDR.N    R0,??DataTable7_1
   \     0x15CA   0x6800             LDR      R0,[R0, #+0]
   \     0x15CC   0xF010 0x0030      ANDS     R0,R0,#0x30
   5168          
   5169                  if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48))
   \     0x15D0   0x.... 0x....      LDR.W    R1,??DataTable24_2
   \     0x15D4   0x680A             LDR      R2,[R1, #+0]
   \     0x15D6   0x0492             LSLS     R2,R2,#+18
   \     0x15D8   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_370
   \     0x15DA   0x2800             CMP      R0,#+0
   \     0x15DC   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_370
   5170                  {
   5171                    frequency = HSI48_VALUE;
   \     0x15DE   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \     0x15E2   0xE01C             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_371
   5172                  }
   5173                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY)) && (srcclk == RCC_RNGCLKSOURCE_PLL1Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_370: (+1)
   \     0x15E4   0x6809             LDR      R1,[R1, #+0]
   \     0x15E6   0x0189             LSLS     R1,R1,#+6
   \     0x15E8   0xD506             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_372
   \     0x15EA   0x2810             CMP      R0,#+16
   \     0x15EC   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_372
   5174                  {
   5175                    HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
   \     0x15EE   0xA806             ADD      R0,SP,#+24
   \     0x15F0   0x.... 0x....      BL       HAL_RCCEx_GetPLL1ClockFreq
   5176                    frequency = pll1_clocks.PLL1_Q_Frequency;
   \     0x15F4   0x9807             LDR      R0,[SP, #+28]
   \     0x15F6   0xE012             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_371
   5177                  }
   5178                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_RNGCLKSOURCE_LSE))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_372: (+1)
   \     0x15F8   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \     0x15FC   0x680A             LDR      R2,[R1, #+0]
   \     0x15FE   0x0792             LSLS     R2,R2,#+30
   \     0x1600   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_373
   \     0x1602   0x2820             CMP      R0,#+32
   \     0x1604   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_373
   5179                  {
   5180                    frequency = LSE_VALUE;
   \     0x1606   0xF44F 0x4000      MOV      R0,#+32768
   \     0x160A   0xE008             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_371
   5181                  }
   5182                  else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_RNGCLKSOURCE_LSI))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_373: (+1)
   \     0x160C   0x6809             LDR      R1,[R1, #+0]
   \     0x160E   0x0109             LSLS     R1,R1,#+4
   \     0x1610   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_374
   \     0x1612   0x2830             CMP      R0,#+48
   \     0x1614   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_374
   5183                  {
   5184                    frequency = LSI_VALUE;
   \     0x1616   0xF44F 0x40FA      MOV      R0,#+32000
   \     0x161A   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_371
   5185                  }
   5186          
   5187                  /* Clock not enabled for RNG */
   5188                  else
   5189                  {
   5190                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_374: (+1)
   \     0x161C   0x2000             MOVS     R0,#+0
   5191                  }
   5192                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_371: (+1)
   \     0x161E   0xE022             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   5193          
   5194                case RCC_PERIPHCLK_USB:
   5195                  /* Get the current USB kernel source */
   5196                  srcclk = __HAL_RCC_GET_USB_SOURCE();
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_44: (+1)
   \     0x1620   0x.... 0x....      LDR.W    R0,??DataTable24
   \     0x1624   0x6800             LDR      R0,[R0, #+0]
   \     0x1626   0xF010 0x0030      ANDS     R0,R0,#0x30
   5197          
   5198                  if (srcclk == RCC_USBCLKSOURCE_PLL1Q)
   \     0x162A   0x2810             CMP      R0,#+16
   \     0x162C   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_375
   5199                  {
   5200                    HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
   \     0x162E   0xA806             ADD      R0,SP,#+24
   \     0x1630   0x.... 0x....      BL       HAL_RCCEx_GetPLL1ClockFreq
   5201                    frequency = pll1_clocks.PLL1_Q_Frequency;
   \     0x1634   0x9807             LDR      R0,[SP, #+28]
   5202                    break;
   \     0x1636   0xE016             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   5203                  }
   5204          #if defined(RCC_USBCLKSOURCE_PLL3Q)
   5205                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY)) && (srcclk == RCC_USBCLKSOURCE_PLL3Q))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_375: (+1)
   \     0x1638   0x.... 0x....      LDR.W    R1,??DataTable24_2
   \     0x163C   0x680A             LDR      R2,[R1, #+0]
   \     0x163E   0x0092             LSLS     R2,R2,#+2
   \     0x1640   0xD506             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_376
   \     0x1642   0x2820             CMP      R0,#+32
   \     0x1644   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_376
   5206                  {
   5207                    HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \     0x1646   0x4668             MOV      R0,SP
   \     0x1648   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   5208                    frequency = pll3_clocks.PLL3_Q_Frequency;
   \     0x164C   0x9801             LDR      R0,[SP, #+4]
   \     0x164E   0xE008             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_377
   5209                  }
   5210          #else
   5211                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY)) && (srcclk == RCC_USBCLKSOURCE_PLL2Q))
   5212                  {
   5213                    HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   5214                    frequency = pll2_clocks.PLL2_Q_Frequency;
   5215                  }
   5216          #endif /* RCC_USBCLKSOURCE_PLL3 */
   5217                  else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_USBCLKSOURCE_HSI48))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_376: (+1)
   \     0x1650   0x6809             LDR      R1,[R1, #+0]
   \     0x1652   0x0489             LSLS     R1,R1,#+18
   \     0x1654   0xD504             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_378
   \     0x1656   0x2830             CMP      R0,#+48
   \     0x1658   0xD102             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_378
   5218                  {
   5219                    frequency = HSI48_VALUE;
   \     0x165A   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \     0x165E   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_377
   5220                  }
   5221                  /* Clock not enabled for USB */
   5222                  else
   5223                  {
   5224                    frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_378: (+1)
   \     0x1660   0x2000             MOVS     R0,#+0
   5225                  }
   5226          
   5227                  break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_377: (+1)
   \     0x1662   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_7
   5228          
   5229          
   5230                default:
   5231                  frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_51: (+1)
   \     0x1664   0x2000             MOVS     R0,#+0
   5232                  break;
   5233              }
   5234            }
   5235          
   5236            return (frequency);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_7: (+1)
   \     0x1666   0xB009             ADD      SP,SP,#+36
   \     0x1668   0xBD00             POP      {PC}
   5237          }
   5238          
   5239          /**
   5240            * @}
   5241            */
   5242          
   5243          /** @defgroup RCCEx_Exported_Functions_Group2 Extended Clock management functions
   5244            *  @brief  Extended Clock management functions
   5245            *
   5246          @verbatim
   5247           ===============================================================================
   5248                          ##### Extended clock management functions  #####
   5249           ===============================================================================
   5250              [..]
   5251              This subsection provides a set of functions allowing to control the
   5252              activation or deactivation of PLL2, PLL3, LSE CSS,
   5253              Low speed clock output and clock after wake-up from STOP mode.
   5254          @endverbatim
   5255            * @{
   5256            */
   5257          
   5258          /**
   5259            * @brief  Initialize and Enable the PLL2  according to the specified
   5260            *         parameters in the RCC_PLL2InitTypeDef.
   5261            * @param  pPLL2Init  pointer to an RCC_PLL2InitTypeDef structure that
   5262            *         contains the configuration information for the PLL2
   5263            * @retval HAL status
   5264            */

   \                                 In section .text, align 2, keep-with-next
   5265          HAL_StatusTypeDef HAL_RCCEx_EnablePLL2(RCC_PLL2InitTypeDef  *pPLL2Init)
   5266          {
   \                     HAL_RCCEx_EnablePLL2: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0006             MOVS     R6,R0
   5267            uint32_t tickstart;
   5268            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
   5269          
   5270            /* check for PLL2 Parameters used to output PLL2CLK */
   5271            assert_param(IS_RCC_PLL2_SOURCE(pPLL2Init->PLL2Source));
   5272            assert_param(IS_RCC_PLL2_DIVM_VALUE(pPLL2Init->PLL2M));
   5273            assert_param(IS_RCC_PLL2_MULN_VALUE(pPLL2Init->PLL2N));
   5274            assert_param(IS_RCC_PLL2_DIVP_VALUE(pPLL2Init->PLL2P));
   5275            assert_param(IS_RCC_PLL2_DIVQ_VALUE(pPLL2Init->PLL2Q));
   5276            assert_param(IS_RCC_PLL2_DIVR_VALUE(pPLL2Init->PLL2R));
   5277            assert_param(IS_RCC_PLL2_CLOCKOUT_VALUE(pPLL2Init->PLL2ClockOut));
   5278            assert_param(IS_RCC_PLL2_VCIRGE_VALUE(pPLL2Init->PLL2RGE));
   5279            assert_param(IS_RCC_PLL2_VCORGE_VALUE(pPLL2Init->PLL2VCOSEL));
   5280            assert_param(IS_RCC_PLL2_FRACN_VALUE(pPLL2Init->PLL2FRACN));
   5281          
   5282            /* Disable the PLL2 */
   5283            __HAL_RCC_PLL2_DISABLE();
   \        0x6   0x.... 0x....      LDR.W    R4,??DataTable24_2
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \       0x10   0x6020             STR      R0,[R4, #+0]
   5284          
   5285            /* Get Start Tick*/
   5286            tickstart = HAL_GetTick();
   \       0x12   0x.... 0x....      BL       HAL_GetTick
   \       0x16   0x0007             MOVS     R7,R0
   5287          
   5288            /* Wait till PLL2 is ready to be updated */
   5289            while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
   \                     ??HAL_RCCEx_EnablePLL2_0: (+1)
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x0100             LSLS     R0,R0,#+4
   \       0x1C   0xD505             BPL.N    ??HAL_RCCEx_EnablePLL2_1
   5290            {
   5291              if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
   \       0x1E   0x.... 0x....      BL       HAL_GetTick
   \       0x22   0x1BC0             SUBS     R0,R0,R7
   \       0x24   0x2803             CMP      R0,#+3
   \       0x26   0xD3F7             BCC.N    ??HAL_RCCEx_EnablePLL2_0
   5292              {
   5293                status = HAL_TIMEOUT;
   \       0x28   0x2503             MOVS     R5,#+3
   5294                break;
   5295              }
   5296            }
   5297          
   5298            if (status == HAL_OK)
   \                     ??HAL_RCCEx_EnablePLL2_1: (+1)
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD15D             BNE.N    ??HAL_RCCEx_EnablePLL2_2
   5299            {
   5300              /* Make sure PLL2Source is ready */
   5301              status = RCCEx_PLLSource_Enable(pPLL2Init->PLL2Source);
   \       0x32   0x6830             LDR      R0,[R6, #+0]
   \       0x34   0x.... 0x....      BL       RCCEx_PLLSource_Enable
   \       0x38   0x0005             MOVS     R5,R0
   5302          
   5303              if (status == HAL_OK)
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0xB2C0             UXTB     R0,R0
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD155             BNE.N    ??HAL_RCCEx_EnablePLL2_2
   5304              {
   5305                /* Configure the PLL2 clock source, multiplication factor N, */
   5306                /* and division factors M, P, Q and R */
   5307                __HAL_RCC_PLL2_CONFIG(pPLL2Init->PLL2Source, pPLL2Init->PLL2M, pPLL2Init->PLL2N,
   5308                                      pPLL2Init->PLL2P, pPLL2Init->PLL2Q, pPLL2Init->PLL2R);
   \       0x42   0x.... 0x....      LDR.W    R1,??DataTable24_4
   \       0x46   0x680A             LDR      R2,[R1, #+0]
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable24_5
   \       0x4C   0x4002             ANDS     R2,R0,R2
   \       0x4E   0x6830             LDR      R0,[R6, #+0]
   \       0x50   0x4302             ORRS     R2,R0,R2
   \       0x52   0x6870             LDR      R0,[R6, #+4]
   \       0x54   0xEA52 0x2200      ORRS     R2,R2,R0, LSL #+8
   \       0x58   0x600A             STR      R2,[R1, #+0]
   \       0x5A   0x68B0             LDR      R0,[R6, #+8]
   \       0x5C   0x1E40             SUBS     R0,R0,#+1
   \       0x5E   0x05C0             LSLS     R0,R0,#+23
   \       0x60   0x0DC0             LSRS     R0,R0,#+23
   \       0x62   0x68F2             LDR      R2,[R6, #+12]
   \       0x64   0x1E52             SUBS     R2,R2,#+1
   \       0x66   0x0252             LSLS     R2,R2,#+9
   \       0x68   0xF412 0x427E      ANDS     R2,R2,#0xFE00
   \       0x6C   0x4310             ORRS     R0,R2,R0
   \       0x6E   0x6932             LDR      R2,[R6, #+16]
   \       0x70   0x1E52             SUBS     R2,R2,#+1
   \       0x72   0x0412             LSLS     R2,R2,#+16
   \       0x74   0xF412 0x02FE      ANDS     R2,R2,#0x7F0000
   \       0x78   0x4310             ORRS     R0,R2,R0
   \       0x7A   0x6972             LDR      R2,[R6, #+20]
   \       0x7C   0x1E52             SUBS     R2,R2,#+1
   \       0x7E   0x0612             LSLS     R2,R2,#+24
   \       0x80   0xF012 0x42FE      ANDS     R2,R2,#0x7F000000
   \       0x84   0x4310             ORRS     R0,R2,R0
   \       0x86   0x.... 0x....      LDR.W    R2,??DataTable24_6
   \       0x8A   0x6010             STR      R0,[R2, #+0]
   5309          
   5310                /* Disable PLL2FRACN . */
   5311                __HAL_RCC_PLL2_FRACN_DISABLE();
   \       0x8C   0x6808             LDR      R0,[R1, #+0]
   \       0x8E   0xF030 0x0010      BICS     R0,R0,#0x10
   \       0x92   0x6008             STR      R0,[R1, #+0]
   5312          
   5313                /* Configure PLL2 FRACN */
   5314                __HAL_RCC_PLL2_FRACN_CONFIG(pPLL2Init->PLL2FRACN);
   \       0x94   0x.... 0x....      LDR.W    R0,??DataTable24_7
   \       0x98   0x6802             LDR      R2,[R0, #+0]
   \       0x9A   0xF36F 0x02CF      BFC      R2,#+3,#+13
   \       0x9E   0x6A33             LDR      R3,[R6, #+32]
   \       0xA0   0xEA52 0x02C3      ORRS     R2,R2,R3, LSL #+3
   \       0xA4   0x6002             STR      R2,[R0, #+0]
   5315          
   5316                /* Enable PLL2FRACN */
   5317                __HAL_RCC_PLL2_FRACN_ENABLE();
   \       0xA6   0x6808             LDR      R0,[R1, #+0]
   \       0xA8   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xAC   0x6008             STR      R0,[R1, #+0]
   5318          
   5319                /* Select PLL2 input reference frequency range: VCI */
   5320                __HAL_RCC_PLL2_VCIRANGE(pPLL2Init->PLL2RGE);
   \       0xAE   0x680A             LDR      R2,[R1, #+0]
   \       0xB0   0xF032 0x020C      BICS     R2,R2,#0xC
   \       0xB4   0x69B0             LDR      R0,[R6, #+24]
   \       0xB6   0x4302             ORRS     R2,R0,R2
   \       0xB8   0x600A             STR      R2,[R1, #+0]
   5321          
   5322                /* Select PLL2 output frequency range : VCO */
   5323                __HAL_RCC_PLL2_VCORANGE(pPLL2Init->PLL2VCOSEL);
   \       0xBA   0x680A             LDR      R2,[R1, #+0]
   \       0xBC   0xF032 0x0220      BICS     R2,R2,#0x20
   \       0xC0   0x69F0             LDR      R0,[R6, #+28]
   \       0xC2   0x4302             ORRS     R2,R0,R2
   \       0xC4   0x600A             STR      R2,[R1, #+0]
   5324          
   5325                /* Configure the PLL2 Clock output(s) */
   5326                __HAL_RCC_PLL2_CLKOUT_ENABLE(pPLL2Init->PLL2ClockOut);
   \       0xC6   0x680A             LDR      R2,[R1, #+0]
   \       0xC8   0x6A70             LDR      R0,[R6, #+36]
   \       0xCA   0x4302             ORRS     R2,R0,R2
   \       0xCC   0x600A             STR      R2,[R1, #+0]
   5327          
   5328                /* Enable the PLL2 again by setting PLL2ON to 1*/
   5329                __HAL_RCC_PLL2_ENABLE();
   \       0xCE   0x6820             LDR      R0,[R4, #+0]
   \       0xD0   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \       0xD4   0x6020             STR      R0,[R4, #+0]
   5330          
   5331                /* Get Start Tick*/
   5332                tickstart = HAL_GetTick();
   \       0xD6   0x.... 0x....      BL       HAL_GetTick
   \       0xDA   0x0006             MOVS     R6,R0
   5333          
   5334                /* Wait till PLL2 is ready */
   5335                while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) == 0U)
   \                     ??HAL_RCCEx_EnablePLL2_3: (+1)
   \       0xDC   0x6820             LDR      R0,[R4, #+0]
   \       0xDE   0x0100             LSLS     R0,R0,#+4
   \       0xE0   0xD405             BMI.N    ??HAL_RCCEx_EnablePLL2_2
   5336                {
   5337                  if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
   \       0xE2   0x.... 0x....      BL       HAL_GetTick
   \       0xE6   0x1B80             SUBS     R0,R0,R6
   \       0xE8   0x2803             CMP      R0,#+3
   \       0xEA   0xD3F7             BCC.N    ??HAL_RCCEx_EnablePLL2_3
   5338                  {
   5339                    status = HAL_TIMEOUT;
   \       0xEC   0x2503             MOVS     R5,#+3
   5340                    break;
   5341                  }
   5342                }
   5343              }
   5344            }
   5345          
   5346            return status;
   \                     ??HAL_RCCEx_EnablePLL2_2: (+1)
   \       0xEE   0x0028             MOVS     R0,R5
   \       0xF0   0xB2C0             UXTB     R0,R0
   \       0xF2   0xBDF2             POP      {R1,R4-R7,PC}
   5347          }
   5348          
   5349          /**
   5350            * @brief  Disable PLL2.
   5351            * @retval HAL status
   5352            */

   \                                 In section .text, align 2, keep-with-next
   5353          HAL_StatusTypeDef HAL_RCCEx_DisablePLL2(void)
   5354          {
   \                     HAL_RCCEx_DisablePLL2: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   5355            uint32_t tickstart;
   5356            HAL_StatusTypeDef status = HAL_OK;
   \        0x2   0x2400             MOVS     R4,#+0
   5357          
   5358            /* Disable the PLL2 */
   5359            __HAL_RCC_PLL2_DISABLE();
   \        0x4   0x.... 0x....      LDR.W    R6,??DataTable24_2
   \        0x8   0x6830             LDR      R0,[R6, #+0]
   \        0xA   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \        0xE   0x6030             STR      R0,[R6, #+0]
   5360          
   5361            /* Get Start Tick*/
   5362            tickstart = HAL_GetTick();
   \       0x10   0x.... 0x....      BL       HAL_GetTick
   \       0x14   0x0005             MOVS     R5,R0
   5363          
   5364            /* Wait till PLL2 is disabled */
   5365            while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
   \                     ??HAL_RCCEx_DisablePLL2_0: (+1)
   \       0x16   0x6830             LDR      R0,[R6, #+0]
   \       0x18   0x0100             LSLS     R0,R0,#+4
   \       0x1A   0xD505             BPL.N    ??HAL_RCCEx_DisablePLL2_1
   5366            {
   5367              if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
   \       0x1C   0x.... 0x....      BL       HAL_GetTick
   \       0x20   0x1B40             SUBS     R0,R0,R5
   \       0x22   0x2803             CMP      R0,#+3
   \       0x24   0xD3F7             BCC.N    ??HAL_RCCEx_DisablePLL2_0
   5368              {
   5369                status = HAL_TIMEOUT;
   \       0x26   0x2403             MOVS     R4,#+3
   5370                break;
   5371              }
   5372            }
   5373          
   5374            /* To save power, disable the PLL2 Source, FRACN and Clock outputs */
   5375            CLEAR_BIT(RCC->PLL2CFGR, RCC_PLL2CFGR_PLL2PEN | RCC_PLL2CFGR_PLL2QEN | RCC_PLL2CFGR_PLL2REN | RCC_PLL2CFGR_PLL2SRC |
   5376                      RCC_PLL2CFGR_PLL2FRACEN);
   \                     ??HAL_RCCEx_DisablePLL2_1: (+1)
   \       0x28   0x.... 0x....      LDR.W    R1,??DataTable24_4
   \       0x2C   0x680A             LDR      R2,[R1, #+0]
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable24_8
   \       0x32   0x4002             ANDS     R2,R0,R2
   \       0x34   0x600A             STR      R2,[R1, #+0]
   5377          
   5378            return status;
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0xBD70             POP      {R4-R6,PC}
   5379          }
   5380          
   5381          #if defined(RCC_CR_PLL3ON)
   5382          /**
   5383            * @brief  Initialize and Enable the PLL3  according to the specified
   5384            *         parameters in the RCC_PLL3InitTypeDef.
   5385            * @param  pPLL3Init  pointer to an RCC_PLL3InitTypeDef structure that
   5386            *         contains the configuration information for the PLL3
   5387            * @retval HAL status.
   5388            */

   \                                 In section .text, align 2, keep-with-next
   5389          HAL_StatusTypeDef HAL_RCCEx_EnablePLL3(RCC_PLL3InitTypeDef  *pPLL3Init)
   5390          {
   \                     HAL_RCCEx_EnablePLL3: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0006             MOVS     R6,R0
   5391            uint32_t tickstart;
   5392            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
   5393          
   5394            /* check for PLL3 Parameters used to output PLL3CLK */
   5395            assert_param(IS_RCC_PLL3_SOURCE(pPLL3Init->PLL3Source));
   5396            assert_param(IS_RCC_PLL3_DIVM_VALUE(pPLL3Init->PLL3M));
   5397            assert_param(IS_RCC_PLL3_MULN_VALUE(pPLL3Init->PLL3N));
   5398            assert_param(IS_RCC_PLL3_DIVP_VALUE(pPLL3Init->PLL3P));
   5399            assert_param(IS_RCC_PLL3_DIVQ_VALUE(pPLL3Init->PLL3Q));
   5400            assert_param(IS_RCC_PLL3_DIVR_VALUE(pPLL3Init->PLL3R));
   5401            assert_param(IS_RCC_PLL3_CLOCKOUT_VALUE(pPLL3Init->PLL3ClockOut));
   5402            assert_param(IS_RCC_PLL3_VCIRGE_VALUE(pPLL3Init->PLL3RGE));
   5403            assert_param(IS_RCC_PLL3_VCORGE_VALUE(pPLL3Init->PLL3VCOSEL));
   5404            assert_param(IS_RCC_PLL3_FRACN_VALUE(pPLL3Init->PLL3FRACN));
   5405          
   5406            /* Disable the PLL3 */
   5407            __HAL_RCC_PLL3_DISABLE();
   \        0x6   0x.... 0x....      LDR.W    R4,??DataTable24_2
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \       0x10   0x6020             STR      R0,[R4, #+0]
   5408          
   5409            /* Get Start Tick*/
   5410            tickstart = HAL_GetTick();
   \       0x12   0x.... 0x....      BL       HAL_GetTick
   \       0x16   0x0007             MOVS     R7,R0
   5411          
   5412            /* Wait till PLL3 is ready to be updated */
   5413            while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
   \                     ??HAL_RCCEx_EnablePLL3_0: (+1)
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x0080             LSLS     R0,R0,#+2
   \       0x1C   0xD505             BPL.N    ??HAL_RCCEx_EnablePLL3_1
   5414            {
   5415              if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
   \       0x1E   0x.... 0x....      BL       HAL_GetTick
   \       0x22   0x1BC0             SUBS     R0,R0,R7
   \       0x24   0x2803             CMP      R0,#+3
   \       0x26   0xD3F7             BCC.N    ??HAL_RCCEx_EnablePLL3_0
   5416              {
   5417                status = HAL_TIMEOUT;
   \       0x28   0x2503             MOVS     R5,#+3
   5418                break;
   5419              }
   5420            }
   5421          
   5422            if (status == HAL_OK)
   \                     ??HAL_RCCEx_EnablePLL3_1: (+1)
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD15D             BNE.N    ??HAL_RCCEx_EnablePLL3_2
   5423            {
   5424              /* Make sure PLL3Source is ready */
   5425              status = RCCEx_PLLSource_Enable(pPLL3Init->PLL3Source);
   \       0x32   0x6830             LDR      R0,[R6, #+0]
   \       0x34   0x.... 0x....      BL       RCCEx_PLLSource_Enable
   \       0x38   0x0005             MOVS     R5,R0
   5426          
   5427              if (status == HAL_OK)
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0xB2C0             UXTB     R0,R0
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD155             BNE.N    ??HAL_RCCEx_EnablePLL3_2
   5428              {
   5429                /* Configure the PLL3 clock source, multiplication factor N, */
   5430                /* and division factors M and P */
   5431                __HAL_RCC_PLL3_CONFIG(pPLL3Init->PLL3Source, pPLL3Init->PLL3M, pPLL3Init->PLL3N,  pPLL3Init->PLL3P,
   5432                                      pPLL3Init->PLL3Q, pPLL3Init->PLL3R);
   \       0x42   0x.... 0x....      LDR.W    R1,??DataTable24_9
   \       0x46   0x680A             LDR      R2,[R1, #+0]
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable24_5
   \       0x4C   0x4002             ANDS     R2,R0,R2
   \       0x4E   0x6830             LDR      R0,[R6, #+0]
   \       0x50   0x4302             ORRS     R2,R0,R2
   \       0x52   0x6870             LDR      R0,[R6, #+4]
   \       0x54   0xEA52 0x2200      ORRS     R2,R2,R0, LSL #+8
   \       0x58   0x600A             STR      R2,[R1, #+0]
   \       0x5A   0x68B0             LDR      R0,[R6, #+8]
   \       0x5C   0x1E40             SUBS     R0,R0,#+1
   \       0x5E   0x05C0             LSLS     R0,R0,#+23
   \       0x60   0x0DC0             LSRS     R0,R0,#+23
   \       0x62   0x68F2             LDR      R2,[R6, #+12]
   \       0x64   0x1E52             SUBS     R2,R2,#+1
   \       0x66   0x0252             LSLS     R2,R2,#+9
   \       0x68   0xF412 0x427E      ANDS     R2,R2,#0xFE00
   \       0x6C   0x4310             ORRS     R0,R2,R0
   \       0x6E   0x6932             LDR      R2,[R6, #+16]
   \       0x70   0x1E52             SUBS     R2,R2,#+1
   \       0x72   0x0412             LSLS     R2,R2,#+16
   \       0x74   0xF412 0x02FE      ANDS     R2,R2,#0x7F0000
   \       0x78   0x4310             ORRS     R0,R2,R0
   \       0x7A   0x6972             LDR      R2,[R6, #+20]
   \       0x7C   0x1E52             SUBS     R2,R2,#+1
   \       0x7E   0x0612             LSLS     R2,R2,#+24
   \       0x80   0xF012 0x42FE      ANDS     R2,R2,#0x7F000000
   \       0x84   0x4310             ORRS     R0,R2,R0
   \       0x86   0x.... 0x....      LDR.W    R2,??DataTable24_10
   \       0x8A   0x6010             STR      R0,[R2, #+0]
   5433          
   5434                /* Disable PLL3FRACN . */
   5435                __HAL_RCC_PLL3_FRACN_DISABLE();
   \       0x8C   0x6808             LDR      R0,[R1, #+0]
   \       0x8E   0xF030 0x0010      BICS     R0,R0,#0x10
   \       0x92   0x6008             STR      R0,[R1, #+0]
   5436          
   5437                /* Configure PLL3 FRACN */
   5438                __HAL_RCC_PLL3_FRACN_CONFIG(pPLL3Init->PLL3FRACN);
   \       0x94   0x.... 0x....      LDR.W    R0,??DataTable24_11
   \       0x98   0x6802             LDR      R2,[R0, #+0]
   \       0x9A   0xF36F 0x02CF      BFC      R2,#+3,#+13
   \       0x9E   0x6A33             LDR      R3,[R6, #+32]
   \       0xA0   0xEA52 0x02C3      ORRS     R2,R2,R3, LSL #+3
   \       0xA4   0x6002             STR      R2,[R0, #+0]
   5439          
   5440                /* Enable PLL3FRACN . */
   5441                __HAL_RCC_PLL3_FRACN_ENABLE();
   \       0xA6   0x6808             LDR      R0,[R1, #+0]
   \       0xA8   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xAC   0x6008             STR      R0,[R1, #+0]
   5442          
   5443                /* Select PLL3 input reference frequency range: VCI */
   5444                __HAL_RCC_PLL3_VCIRANGE(pPLL3Init->PLL3RGE);
   \       0xAE   0x680A             LDR      R2,[R1, #+0]
   \       0xB0   0xF032 0x020C      BICS     R2,R2,#0xC
   \       0xB4   0x69B0             LDR      R0,[R6, #+24]
   \       0xB6   0x4302             ORRS     R2,R0,R2
   \       0xB8   0x600A             STR      R2,[R1, #+0]
   5445          
   5446                /* Select PLL3 output frequency range : VCO */
   5447                __HAL_RCC_PLL3_VCORANGE(pPLL3Init->PLL3VCOSEL);
   \       0xBA   0x680A             LDR      R2,[R1, #+0]
   \       0xBC   0xF032 0x0220      BICS     R2,R2,#0x20
   \       0xC0   0x69F0             LDR      R0,[R6, #+28]
   \       0xC2   0x4302             ORRS     R2,R0,R2
   \       0xC4   0x600A             STR      R2,[R1, #+0]
   5448          
   5449                /* Configure the PLL3 Clock output(s) */
   5450                __HAL_RCC_PLL3_CLKOUT_ENABLE(pPLL3Init->PLL3ClockOut);
   \       0xC6   0x680A             LDR      R2,[R1, #+0]
   \       0xC8   0x6A70             LDR      R0,[R6, #+36]
   \       0xCA   0x4302             ORRS     R2,R0,R2
   \       0xCC   0x600A             STR      R2,[R1, #+0]
   5451          
   5452                /* Enable the PLL3 again by setting PLL3ON to 1*/
   5453                __HAL_RCC_PLL3_ENABLE();
   \       0xCE   0x6820             LDR      R0,[R4, #+0]
   \       0xD0   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \       0xD4   0x6020             STR      R0,[R4, #+0]
   5454          
   5455                /* Get Start Tick*/
   5456                tickstart = HAL_GetTick();
   \       0xD6   0x.... 0x....      BL       HAL_GetTick
   \       0xDA   0x0006             MOVS     R6,R0
   5457          
   5458                /* Wait till PLL3 is ready */
   5459                while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) == 0U)
   \                     ??HAL_RCCEx_EnablePLL3_3: (+1)
   \       0xDC   0x6820             LDR      R0,[R4, #+0]
   \       0xDE   0x0080             LSLS     R0,R0,#+2
   \       0xE0   0xD405             BMI.N    ??HAL_RCCEx_EnablePLL3_2
   5460                {
   5461                  if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
   \       0xE2   0x.... 0x....      BL       HAL_GetTick
   \       0xE6   0x1B80             SUBS     R0,R0,R6
   \       0xE8   0x2803             CMP      R0,#+3
   \       0xEA   0xD3F7             BCC.N    ??HAL_RCCEx_EnablePLL3_3
   5462                  {
   5463                    status = HAL_TIMEOUT;
   \       0xEC   0x2503             MOVS     R5,#+3
   5464                    break;
   5465                  }
   5466                }
   5467              }
   5468            }
   5469          
   5470            return status;
   \                     ??HAL_RCCEx_EnablePLL3_2: (+1)
   \       0xEE   0x0028             MOVS     R0,R5
   \       0xF0   0xB2C0             UXTB     R0,R0
   \       0xF2   0xBDF2             POP      {R1,R4-R7,PC}
   5471          }
   5472          
   5473          
   5474          /**
   5475            * @brief  Disable PLL3.
   5476            * @retval HAL status.
   5477            */

   \                                 In section .text, align 2, keep-with-next
   5478          HAL_StatusTypeDef HAL_RCCEx_DisablePLL3(void)
   5479          {
   \                     HAL_RCCEx_DisablePLL3: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   5480            uint32_t tickstart;
   5481            HAL_StatusTypeDef status = HAL_OK;
   \        0x2   0x2400             MOVS     R4,#+0
   5482          
   5483            /* Disable the PLL3 */
   5484            __HAL_RCC_PLL3_DISABLE();
   \        0x4   0x.... 0x....      LDR.W    R6,??DataTable24_2
   \        0x8   0x6830             LDR      R0,[R6, #+0]
   \        0xA   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \        0xE   0x6030             STR      R0,[R6, #+0]
   5485          
   5486            /* Get Start Tick*/
   5487            tickstart = HAL_GetTick();
   \       0x10   0x.... 0x....      BL       HAL_GetTick
   \       0x14   0x0005             MOVS     R5,R0
   5488          
   5489            /* Wait till PLL3 is ready */
   5490            while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
   \                     ??HAL_RCCEx_DisablePLL3_0: (+1)
   \       0x16   0x6830             LDR      R0,[R6, #+0]
   \       0x18   0x0080             LSLS     R0,R0,#+2
   \       0x1A   0xD505             BPL.N    ??HAL_RCCEx_DisablePLL3_1
   5491            {
   5492              if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
   \       0x1C   0x.... 0x....      BL       HAL_GetTick
   \       0x20   0x1B40             SUBS     R0,R0,R5
   \       0x22   0x2803             CMP      R0,#+3
   \       0x24   0xD3F7             BCC.N    ??HAL_RCCEx_DisablePLL3_0
   5493              {
   5494                status = HAL_TIMEOUT;
   \       0x26   0x2403             MOVS     R4,#+3
   5495                break;
   5496              }
   5497            }
   5498          
   5499            /* To save power, disable the PLL3 Source and Clock outputs */
   5500            CLEAR_BIT(RCC->PLL3CFGR, RCC_PLL3CFGR_PLL3PEN | RCC_PLL3CFGR_PLL3QEN | RCC_PLL3CFGR_PLL3REN | RCC_PLL3CFGR_PLL3SRC |
   5501                      RCC_PLL3CFGR_PLL3FRACEN);
   \                     ??HAL_RCCEx_DisablePLL3_1: (+1)
   \       0x28   0x.... 0x....      LDR.W    R1,??DataTable24_9
   \       0x2C   0x680A             LDR      R2,[R1, #+0]
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable24_8
   \       0x32   0x4002             ANDS     R2,R0,R2
   \       0x34   0x600A             STR      R2,[R1, #+0]
   5502          
   5503            return status;
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0xBD70             POP      {R4-R6,PC}
   5504          }
   5505          #endif /* RCC_CR_PLL3ON */
   5506          
   5507          /**
   5508            * @brief  Configure the oscillator clock source for wakeup from Stop and HSE CSS backup clock.
   5509            * @param  WakeUpClk  Wakeup clock
   5510            *         This parameter can be one of the following values:
   5511            *            @arg @ref RCC_STOP_WAKEUPCLOCK_HSI  HSI oscillator selection
   5512            *            @arg @ref RCC_STOP_WAKEUPCLOCK_CSI  CSI oscillator selection
   5513            * @note   This function shall not be called after the Clock Security System on HSE has been
   5514            *         enabled.
   5515            * @retval None
   5516            */

   \                                 In section .text, align 2, keep-with-next
   5517          void HAL_RCCEx_WakeUpStopCLKConfig(uint32_t WakeUpClk)
   5518          {
   5519            assert_param(IS_RCC_STOP_WAKEUPCLOCK(WakeUpClk));
   5520          
   5521            __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(WakeUpClk);
   \                     HAL_RCCEx_WakeUpStopCLKConfig: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable24_12
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0xF032 0x0240      BICS     R2,R2,#0x40
   \        0xA   0x4310             ORRS     R0,R0,R2
   \        0xC   0x6008             STR      R0,[R1, #+0]
   5522          }
   \        0xE   0x4770             BX       LR
   5523          
   5524          /**
   5525            * @brief  Configure the oscillator Kernel clock source for wakeup from Stop
   5526            * @param  WakeUpClk: Kernel Wakeup clock
   5527            *         This parameter can be one of the following values:
   5528            *            @arg RCC_STOP_KERWAKEUPCLOCK_HSI: HSI oscillator selection
   5529            *            @arg RCC_STOP_KERWAKEUPCLOCK_CSI: CSI oscillator selection
   5530            * @retval None
   5531            */

   \                                 In section .text, align 2, keep-with-next
   5532          void HAL_RCCEx_KerWakeUpStopCLKConfig(uint32_t WakeUpClk)
   5533          {
   5534            assert_param(IS_RCC_STOP_KERWAKEUPCLOCK(WakeUpClk));
   5535          
   5536            __HAL_RCC_KERWAKEUPSTOP_CLK_CONFIG(WakeUpClk);
   \                     HAL_RCCEx_KerWakeUpStopCLKConfig: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable24_12
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0xF032 0x0280      BICS     R2,R2,#0x80
   \        0xA   0x4310             ORRS     R0,R0,R2
   \        0xC   0x6008             STR      R0,[R1, #+0]
   5537          }
   \        0xE   0x4770             BX       LR
   5538          
   5539          /**
   5540            * @brief  Enable the LSE Clock Security System.
   5541            * @note   Prior to enable the LSE Clock Security System, LSE oscillator is to be enabled
   5542            *         with HAL_RCC_OscConfig() and the LSE oscillator clock is to be selected as RTC
   5543            *         clock with HAL_RCCEx_PeriphCLKConfig().
   5544            * @retval None
   5545            */

   \                                 In section .text, align 2, keep-with-next
   5546          void HAL_RCCEx_EnableLSECSS(void)
   5547          {
   5548            SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON);
   \                     HAL_RCCEx_EnableLSECSS: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF051 0x0120      ORRS     R1,R1,#0x20
   \        0xA   0x6001             STR      R1,[R0, #+0]
   5549          }
   \        0xC   0x4770             BX       LR
   5550          
   5551          /**
   5552            * @brief  Disable the LSE Clock Security System.
   5553            * @note   LSE Clock Security System can only be disabled after a LSE failure detection.
   5554            * @retval None
   5555            */

   \                                 In section .text, align 2, keep-with-next
   5556          void HAL_RCCEx_DisableLSECSS(void)
   5557          {
   5558            CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON);
   \                     HAL_RCCEx_DisableLSECSS: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF031 0x0120      BICS     R1,R1,#0x20
   \        0xA   0x6001             STR      R1,[R0, #+0]
   5559          }
   \        0xC   0x4770             BX       LR
   5560          
   5561          /**
   5562            * @brief Handle the RCC LSE Clock Security System interrupt request.
   5563            * @retval None
   5564            */

   \                                 In section .text, align 2, keep-with-next
   5565          void HAL_RCCEx_LSECSS_IRQHandler(void)
   5566          {
   \                     HAL_RCCEx_LSECSS_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   5567            if (READ_BIT(RCC->BDCR, RCC_BDCR_LSECSSD) != 0U)
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x0640             LSLS     R0,R0,#+25
   \        0xA   0xD501             BPL.N    ??HAL_RCCEx_LSECSS_IRQHandler_0
   5568            {
   5569              /* RCC LSE Clock Security System interrupt user callback */
   5570              HAL_RCCEx_LSECSS_Callback();
   \        0xC   0x.... 0x....      BL       HAL_RCCEx_LSECSS_Callback
   5571            }
   5572          }
   \                     ??HAL_RCCEx_LSECSS_IRQHandler_0: (+1)
   \       0x10   0xBD01             POP      {R0,PC}
   5573          
   5574          /**
   5575            * @brief  RCCEx LSE Clock Security System interrupt callback.
   5576            * @retval none
   5577            */

   \                                 In section .text, align 2
   5578          __weak void HAL_RCCEx_LSECSS_Callback(void)
   5579          {
   5580            /* NOTE : This function should not be modified, when the callback is needed,
   5581                      the @ref HAL_RCCEx_LSECSS_Callback should be implemented in the user file
   5582             */
   5583          }
   \                     HAL_RCCEx_LSECSS_Callback: (+1)
   \        0x0   0x4770             BX       LR
   5584          
   5585          /**
   5586            * @brief  Select the Low Speed Microcontroller Clock source to output on LSCO pin (PB2).
   5587            * @param  LSCOSource  specifies the Low Speed clock source to output.
   5588            *          This parameter can be one of the following values:
   5589            *            @arg @ref RCC_LSCOSOURCE_LSI  LSI clock selected as LSCO source
   5590            *            @arg @ref RCC_LSCOSOURCE_LSE  LSE clock selected as LSCO source
   5591            * @retval None
   5592            */

   \                                 In section .text, align 2, keep-with-next
   5593          void HAL_RCCEx_EnableLSCO(uint32_t LSCOSource)
   5594          {
   \                     HAL_RCCEx_EnableLSCO: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5595            FlagStatus       backupchanged = RESET;
   \        0x4   0x2000             MOVS     R0,#+0
   5596          
   5597            /* Check the parameters */
   5598            assert_param(IS_RCC_LSCOSOURCE(LSCOSource));
   5599          
   5600            /* Update LSCOSEL clock source in Backup Domain control register */
   5601            if (HAL_IS_BIT_CLR(PWR->DBPCR, PWR_DBPCR_DBP))
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable24_13
   \        0xA   0x6809             LDR      R1,[R1, #+0]
   \        0xC   0x07C9             LSLS     R1,R1,#+31
   \        0xE   0xD402             BMI.N    ??HAL_RCCEx_EnableLSCO_0
   5602            {
   5603              HAL_PWR_EnableBkUpAccess();
   \       0x10   0x.... 0x....      BL       HAL_PWR_EnableBkUpAccess
   5604              backupchanged = SET;
   \       0x14   0x2001             MOVS     R0,#+1
   5605            }
   5606          
   5607            MODIFY_REG(RCC->BDCR, RCC_BDCR_LSCOSEL | RCC_BDCR_LSCOEN, LSCOSource | RCC_BDCR_LSCOEN);
   \                     ??HAL_RCCEx_EnableLSCO_0: (+1)
   \       0x16   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \       0x1A   0x680A             LDR      R2,[R1, #+0]
   \       0x1C   0xF032 0x7240      BICS     R2,R2,#0x3000000
   \       0x20   0x4314             ORRS     R4,R4,R2
   \       0x22   0xF054 0x7480      ORRS     R4,R4,#0x1000000
   \       0x26   0x600C             STR      R4,[R1, #+0]
   5608          
   5609            if (backupchanged == SET)
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD101             BNE.N    ??HAL_RCCEx_EnableLSCO_1
   5610            {
   5611              HAL_PWR_DisableBkUpAccess();
   \       0x2E   0x.... 0x....      BL       HAL_PWR_DisableBkUpAccess
   5612            }
   5613          }
   \                     ??HAL_RCCEx_EnableLSCO_1: (+1)
   \       0x32   0xBD10             POP      {R4,PC}
   5614          
   5615          /**
   5616            * @brief  Disable the Low Speed Microcontroller Clock Output.
   5617            * @retval None
   5618            */

   \                                 In section .text, align 2, keep-with-next
   5619          void HAL_RCCEx_DisableLSCO(void)
   5620          {
   \                     HAL_RCCEx_DisableLSCO: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   5621            FlagStatus       backupchanged = RESET;
   \        0x2   0x2000             MOVS     R0,#+0
   5622          
   5623            /* Update LSCOEN bit in Backup Domain control register */
   5624            if (HAL_IS_BIT_CLR(PWR->DBPCR, PWR_DBPCR_DBP))
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable24_13
   \        0x8   0x6809             LDR      R1,[R1, #+0]
   \        0xA   0x07C9             LSLS     R1,R1,#+31
   \        0xC   0xD402             BMI.N    ??HAL_RCCEx_DisableLSCO_0
   5625            {
   5626              /* Enable access to the backup domain */
   5627              HAL_PWR_EnableBkUpAccess();
   \        0xE   0x.... 0x....      BL       HAL_PWR_EnableBkUpAccess
   5628              backupchanged = SET;
   \       0x12   0x2001             MOVS     R0,#+1
   5629            }
   5630          
   5631            CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSCOEN);
   \                     ??HAL_RCCEx_DisableLSCO_0: (+1)
   \       0x14   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \       0x18   0x680A             LDR      R2,[R1, #+0]
   \       0x1A   0xF032 0x7280      BICS     R2,R2,#0x1000000
   \       0x1E   0x600A             STR      R2,[R1, #+0]
   5632          
   5633            /* Restore previous configuration */
   5634            if (backupchanged == SET)
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xD101             BNE.N    ??HAL_RCCEx_DisableLSCO_1
   5635            {
   5636              /* Disable access to the backup domain */
   5637              HAL_PWR_DisableBkUpAccess();
   \       0x26   0x.... 0x....      BL       HAL_PWR_DisableBkUpAccess
   5638            }
   5639          }
   \                     ??HAL_RCCEx_DisableLSCO_1: (+1)
   \       0x2A   0xBD01             POP      {R0,PC}
   5640          
   5641          /**
   5642            * @}
   5643            */
   5644          
   5645          #if defined(CRS)
   5646          
   5647          /** @defgroup RCCEx_Exported_Functions_Group3 Extended Clock Recovery System Control functions
   5648            *  @brief  Extended Clock Recovery System Control functions
   5649            *
   5650          @verbatim
   5651           ===============================================================================
   5652                          ##### Extended Clock Recovery System Control functions  #####
   5653           ===============================================================================
   5654              [..]
   5655                For devices with Clock Recovery System feature (CRS), RCC Extension HAL driver can be used as follows:
   5656          
   5657                (#) In System clock config, HSI48 needs to be enabled
   5658          
   5659                (#) Enable CRS clock in IP MSP init which will use CRS functions
   5660          
   5661                (#) Call CRS functions as follows:
   5662                    (##) Prepare synchronization configuration necessary for HSI48 calibration
   5663                        (+++) Default values can be set for frequency Error Measurement (reload and error limit)
   5664                                  and also HSI48 oscillator smooth trimming.
   5665                        (+++) Macro __HAL_RCC_CRS_RELOADVALUE_CALCULATE can be also used to calculate
   5666                                  directly reload value with target and synchronization frequencies values
   5667                    (##) Call function HAL_RCCEx_CRSConfig which
   5668                        (+++) Resets CRS registers to their default values.
   5669                        (+++) Configures CRS registers with synchronization configuration
   5670                        (+++) Enables automatic calibration and frequency error counter feature
   5671                     Note: When using USB LPM (Link Power Management) and the device is in Sleep mode, the
   5672                     periodic USB SOF will not be generated by the host. No SYNC signal will therefore be
   5673                     provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock
   5674                     precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs
   5675                     should be used as SYNC signal.
   5676          
   5677                    (##) A polling function is provided to wait for complete synchronization
   5678                        (+++) Call function HAL_RCCEx_CRSWaitSynchronization()
   5679                        (+++) According to CRS status, user can decide to adjust again the calibration or continue
   5680                                  application if synchronization is OK
   5681          
   5682                (#) User can retrieve information related to synchronization in calling function
   5683                      HAL_RCCEx_CRSGetSynchronizationInfo()
   5684          
   5685                (#) Regarding synchronization status and synchronization information, user can try a new calibration
   5686                     in changing synchronization configuration and call again HAL_RCCEx_CRSConfig.
   5687                     Note: When the SYNC event is detected during the downcounting phase (before reaching the zero value),
   5688                     it means that the actual frequency is lower than the target (and so, that the TRIM value should be
   5689                     incremented), while when it is detected during the upcounting phase it means that the actual frequency
   5690                     is higher (and that the TRIM value should be decremented).
   5691          
   5692                (#) In interrupt mode, user can resort to the available macros (__HAL_RCC_CRS_XXX_IT). Interrupts will go
   5693                    through CRS Handler (CRS_IRQn/CRS_IRQHandler)
   5694                        (++) Call function HAL_RCCEx_CRSConfig()
   5695                        (++) Enable CRS_IRQn (thanks to NVIC functions)
   5696                        (++) Enable CRS interrupt (__HAL_RCC_CRS_ENABLE_IT)
   5697                        (++) Implement CRS status management in the following user callbacks called from
   5698                             HAL_RCCEx_CRS_IRQHandler():
   5699                             (+++) HAL_RCCEx_CRS_SyncOkCallback()
   5700                             (+++) HAL_RCCEx_CRS_SyncWarnCallback()
   5701                             (+++) HAL_RCCEx_CRS_ExpectedSyncCallback()
   5702                             (+++) HAL_RCCEx_CRS_ErrorCallback()
   5703          
   5704                (#) To force a SYNC EVENT, user can use the function HAL_RCCEx_CRSSoftwareSynchronizationGenerate().
   5705                    This function can be called before calling HAL_RCCEx_CRSConfig (for instance in Systick handler)
   5706          
   5707          @endverbatim
   5708            * @{
   5709            */
   5710          
   5711          /**
   5712            * @brief  Start automatic synchronization for polling mode
   5713            * @param  pInit Pointer on RCC_CRSInitTypeDef structure
   5714            * @retval None
   5715            */

   \                                 In section .text, align 2, keep-with-next
   5716          void HAL_RCCEx_CRSConfig(const RCC_CRSInitTypeDef *pInit)
   5717          {
   5718            uint32_t value;
   5719          
   5720            /* Check the parameters */
   5721            assert_param(IS_RCC_CRS_SYNC_DIV(pInit->Prescaler));
   5722            assert_param(IS_RCC_CRS_SYNC_SOURCE(pInit->Source));
   5723            assert_param(IS_RCC_CRS_SYNC_POLARITY(pInit->Polarity));
   5724            assert_param(IS_RCC_CRS_RELOADVALUE(pInit->ReloadValue));
   5725            assert_param(IS_RCC_CRS_ERRORLIMIT(pInit->ErrorLimitValue));
   5726            assert_param(IS_RCC_CRS_HSI48CALIBRATION(pInit->HSI48CalibrationValue));
   5727          
   5728            /* CONFIGURATION */
   5729          
   5730            /* Before configuration, reset CRS registers to their default values*/
   5731            __HAL_RCC_CRS_FORCE_RESET();
   \                     HAL_RCCEx_CRSConfig: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0xF052 0x7280      ORRS     R2,R2,#0x1000000
   \        0xA   0x600A             STR      R2,[R1, #+0]
   5732            __HAL_RCC_CRS_RELEASE_RESET();
   \        0xC   0x680A             LDR      R2,[R1, #+0]
   \        0xE   0xF032 0x7280      BICS     R2,R2,#0x1000000
   \       0x12   0x600A             STR      R2,[R1, #+0]
   5733          
   5734            /* Set the SYNCDIV[2:0] bits according to Prescaler value */
   5735            /* Set the SYNCSRC[1:0] bits according to Source value */
   5736            /* Set the SYNCSPOL bit according to Polarity value */
   5737            value = (pInit->Prescaler | pInit->Source | pInit->Polarity);
   \       0x14   0x6803             LDR      R3,[R0, #+0]
   \       0x16   0x6841             LDR      R1,[R0, #+4]
   \       0x18   0x430B             ORRS     R3,R1,R3
   \       0x1A   0x6882             LDR      R2,[R0, #+8]
   \       0x1C   0x431A             ORRS     R2,R2,R3
   5738            /* Set the RELOAD[15:0] bits according to ReloadValue value */
   5739            value |= pInit->ReloadValue;
   \       0x1E   0x68C1             LDR      R1,[R0, #+12]
   \       0x20   0x430A             ORRS     R2,R1,R2
   5740            /* Set the FELIM[7:0] bits according to ErrorLimitValue value */
   5741            value |= (pInit->ErrorLimitValue << CRS_CFGR_FELIM_Pos);
   \       0x22   0x6901             LDR      R1,[R0, #+16]
   \       0x24   0xEA52 0x4201      ORRS     R2,R2,R1, LSL #+16
   5742            WRITE_REG(CRS->CFGR, value);
   \       0x28   0x.... 0x....      LDR.W    R1,??DataTable24_15
   \       0x2C   0x600A             STR      R2,[R1, #+0]
   5743          
   5744            /* Adjust HSI48 oscillator smooth trimming */
   5745            /* Set the TRIM[5:0] bits according to RCC_CRS_HSI48CalibrationValue value */
   5746            MODIFY_REG(CRS->CR, CRS_CR_TRIM, (pInit->HSI48CalibrationValue << CRS_CR_TRIM_Pos));
   \       0x2E   0x.... 0x....      LDR.W    R1,??DataTable24_16
   \       0x32   0x680A             LDR      R2,[R1, #+0]
   \       0x34   0xF432 0x527C      BICS     R2,R2,#0x3F00
   \       0x38   0x6940             LDR      R0,[R0, #+20]
   \       0x3A   0xEA52 0x2200      ORRS     R2,R2,R0, LSL #+8
   \       0x3E   0x600A             STR      R2,[R1, #+0]
   5747          
   5748            /* START AUTOMATIC SYNCHRONIZATION*/
   5749          
   5750            /* Enable Automatic trimming & Frequency error counter */
   5751            SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN | CRS_CR_CEN);
   \       0x40   0x6808             LDR      R0,[R1, #+0]
   \       0x42   0xF050 0x0060      ORRS     R0,R0,#0x60
   \       0x46   0x6008             STR      R0,[R1, #+0]
   5752          }
   \       0x48   0x4770             BX       LR
   5753          
   5754          /**
   5755            * @brief  Generate the software synchronization event
   5756            * @retval None
   5757            */

   \                                 In section .text, align 2, keep-with-next
   5758          void HAL_RCCEx_CRSSoftwareSynchronizationGenerate(void)
   5759          {
   5760            SET_BIT(CRS->CR, CRS_CR_SWSYNC);
   \                     HAL_RCCEx_CRSSoftwareSynchronizationGenerate: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable24_16
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF051 0x0180      ORRS     R1,R1,#0x80
   \        0xA   0x6001             STR      R1,[R0, #+0]
   5761          }
   \        0xC   0x4770             BX       LR
   5762          
   5763          /**
   5764            * @brief  Return synchronization info
   5765            * @param  pSynchroInfo Pointer on RCC_CRSSynchroInfoTypeDef structure
   5766            * @retval None
   5767            */

   \                                 In section .text, align 2, keep-with-next
   5768          void HAL_RCCEx_CRSGetSynchronizationInfo(RCC_CRSSynchroInfoTypeDef *pSynchroInfo)
   5769          {
   5770            /* Check the parameter */
   5771            assert_param(pSynchroInfo != (void *)NULL);
   5772          
   5773            /* Get the reload value */
   5774            pSynchroInfo->ReloadValue = (uint32_t)(READ_BIT(CRS->CFGR, CRS_CFGR_RELOAD));
   \                     HAL_RCCEx_CRSGetSynchronizationInfo: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable24_15
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0xB289             UXTH     R1,R1
   \        0x8   0x6001             STR      R1,[R0, #+0]
   5775          
   5776            /* Get HSI48 oscillator smooth trimming */
   5777            pSynchroInfo->HSI48CalibrationValue = (uint32_t)(READ_BIT(CRS->CR, CRS_CR_TRIM) >> CRS_CR_TRIM_Pos);
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable24_16
   \        0xE   0x6809             LDR      R1,[R1, #+0]
   \       0x10   0xF3C1 0x2105      UBFX     R1,R1,#+8,#+6
   \       0x14   0x6041             STR      R1,[R0, #+4]
   5778          
   5779            /* Get Frequency error capture */
   5780            pSynchroInfo->FreqErrorCapture = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FECAP) >> CRS_ISR_FECAP_Pos);
   \       0x16   0x.... 0x....      LDR.W    R1,??DataTable24_17
   \       0x1A   0x680A             LDR      R2,[R1, #+0]
   \       0x1C   0x0C12             LSRS     R2,R2,#+16
   \       0x1E   0x6082             STR      R2,[R0, #+8]
   5781          
   5782            /* Get Frequency error direction */
   5783            pSynchroInfo->FreqErrorDirection = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FEDIR));
   \       0x20   0x6809             LDR      R1,[R1, #+0]
   \       0x22   0xF411 0x4100      ANDS     R1,R1,#0x8000
   \       0x26   0x60C1             STR      R1,[R0, #+12]
   5784          }
   \       0x28   0x4770             BX       LR
   5785          
   5786          /**
   5787            * @brief Wait for CRS Synchronization status.
   5788            * @param Timeout  Duration of the timeout
   5789            * @note  Timeout is based on the maximum time to receive a SYNC event based on synchronization
   5790            *        frequency.
   5791            * @note    If Timeout set to HAL_MAX_DELAY, HAL_TIMEOUT will be never returned.
   5792            * @retval Combination of Synchronization status
   5793            *          This parameter can be a combination of the following values:
   5794            *            @arg @ref RCC_CRS_TIMEOUT
   5795            *            @arg @ref RCC_CRS_SYNCOK
   5796            *            @arg @ref RCC_CRS_SYNCWARN
   5797            *            @arg @ref RCC_CRS_SYNCERR
   5798            *            @arg @ref RCC_CRS_SYNCMISS
   5799            *            @arg @ref RCC_CRS_TRIMOVF
   5800            */

   \                                 In section .text, align 2, keep-with-next
   5801          uint32_t HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout)
   5802          {
   \                     HAL_RCCEx_CRSWaitSynchronization: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5803            uint32_t crsstatus = RCC_CRS_NONE;
   \        0x4   0x2500             MOVS     R5,#+0
   5804            uint32_t tickstart;
   5805          
   5806            /* Get timeout */
   5807            tickstart = HAL_GetTick();
   \        0x6   0x.... 0x....      BL       HAL_GetTick
   \        0xA   0x0006             MOVS     R6,R0
   5808          
   5809            /* Wait for CRS flag or timeout detection */
   5810            do
   5811            {
   5812              if (Timeout != HAL_MAX_DELAY)
   \                     ??HAL_RCCEx_CRSWaitSynchronization_0: (+1)
   \        0xC   0xF114 0x0F01      CMN      R4,#+1
   \       0x10   0xD007             BEQ.N    ??HAL_RCCEx_CRSWaitSynchronization_1
   5813              {
   5814                if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \       0x12   0x.... 0x....      BL       HAL_GetTick
   \       0x16   0x1B80             SUBS     R0,R0,R6
   \       0x18   0x4284             CMP      R4,R0
   \       0x1A   0xD301             BCC.N    ??HAL_RCCEx_CRSWaitSynchronization_2
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD100             BNE.N    ??HAL_RCCEx_CRSWaitSynchronization_1
   5815                {
   5816                  crsstatus = RCC_CRS_TIMEOUT;
   \                     ??HAL_RCCEx_CRSWaitSynchronization_2: (+1)
   \       0x20   0x2501             MOVS     R5,#+1
   5817                }
   5818              }
   5819              /* Check CRS SYNCOK flag  */
   5820              if (__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
   \                     ??HAL_RCCEx_CRSWaitSynchronization_1: (+1)
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable24_17
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0x07C9             LSLS     R1,R1,#+31
   \       0x2A   0xD505             BPL.N    ??HAL_RCCEx_CRSWaitSynchronization_3
   5821              {
   5822                /* CRS SYNC event OK */
   5823                crsstatus |= RCC_CRS_SYNCOK;
   \       0x2C   0xF055 0x0502      ORRS     R5,R5,#0x2
   5824          
   5825                /* Clear CRS SYNC event OK bit */
   5826                __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
   \       0x30   0x2101             MOVS     R1,#+1
   \       0x32   0x.... 0x....      LDR.W    R2,??DataTable24_18
   \       0x36   0x6011             STR      R1,[R2, #+0]
   5827              }
   5828          
   5829              /* Check CRS SYNCWARN flag  */
   5830              if (__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
   \                     ??HAL_RCCEx_CRSWaitSynchronization_3: (+1)
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0x0789             LSLS     R1,R1,#+30
   \       0x3C   0xD505             BPL.N    ??HAL_RCCEx_CRSWaitSynchronization_4
   5831              {
   5832                /* CRS SYNC warning */
   5833                crsstatus |= RCC_CRS_SYNCWARN;
   \       0x3E   0xF055 0x0504      ORRS     R5,R5,#0x4
   5834          
   5835                /* Clear CRS SYNCWARN bit */
   5836                __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
   \       0x42   0x2102             MOVS     R1,#+2
   \       0x44   0x.... 0x....      LDR.W    R2,??DataTable24_18
   \       0x48   0x6011             STR      R1,[R2, #+0]
   5837              }
   5838          
   5839              /* Check CRS TRIM overflow flag  */
   5840              if (__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
   \                     ??HAL_RCCEx_CRSWaitSynchronization_4: (+1)
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0x0549             LSLS     R1,R1,#+21
   \       0x4E   0xD505             BPL.N    ??HAL_RCCEx_CRSWaitSynchronization_5
   5841              {
   5842                /* CRS SYNC Error */
   5843                crsstatus |= RCC_CRS_TRIMOVF;
   \       0x50   0xF055 0x0520      ORRS     R5,R5,#0x20
   5844          
   5845                /* Clear CRS Error bit */
   5846                __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
   \       0x54   0x2104             MOVS     R1,#+4
   \       0x56   0x.... 0x....      LDR.W    R2,??DataTable24_18
   \       0x5A   0x6011             STR      R1,[R2, #+0]
   5847              }
   5848          
   5849              /* Check CRS Error flag  */
   5850              if (__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
   \                     ??HAL_RCCEx_CRSWaitSynchronization_5: (+1)
   \       0x5C   0x6801             LDR      R1,[R0, #+0]
   \       0x5E   0x05C9             LSLS     R1,R1,#+23
   \       0x60   0xD505             BPL.N    ??HAL_RCCEx_CRSWaitSynchronization_6
   5851              {
   5852                /* CRS SYNC Error */
   5853                crsstatus |= RCC_CRS_SYNCERR;
   \       0x62   0xF055 0x0508      ORRS     R5,R5,#0x8
   5854          
   5855                /* Clear CRS Error bit */
   5856                __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
   \       0x66   0x2104             MOVS     R1,#+4
   \       0x68   0x.... 0x....      LDR.W    R2,??DataTable24_18
   \       0x6C   0x6011             STR      R1,[R2, #+0]
   5857              }
   5858          
   5859              /* Check CRS SYNC Missed flag  */
   5860              if (__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
   \                     ??HAL_RCCEx_CRSWaitSynchronization_6: (+1)
   \       0x6E   0x6801             LDR      R1,[R0, #+0]
   \       0x70   0x0589             LSLS     R1,R1,#+22
   \       0x72   0xD504             BPL.N    ??HAL_RCCEx_CRSWaitSynchronization_7
   5861              {
   5862                /* CRS SYNC Missed */
   5863                crsstatus |= RCC_CRS_SYNCMISS;
   \       0x74   0xF055 0x0510      ORRS     R5,R5,#0x10
   5864          
   5865                /* Clear CRS SYNC Missed bit */
   5866                __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
   \       0x78   0x2104             MOVS     R1,#+4
   \       0x7A   0x....             LDR.N    R2,??DataTable24_18
   \       0x7C   0x6011             STR      R1,[R2, #+0]
   5867              }
   5868          
   5869              /* Check CRS Expected SYNC flag  */
   5870              if (__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))
   \                     ??HAL_RCCEx_CRSWaitSynchronization_7: (+1)
   \       0x7E   0x6800             LDR      R0,[R0, #+0]
   \       0x80   0x0700             LSLS     R0,R0,#+28
   \       0x82   0xD502             BPL.N    ??HAL_RCCEx_CRSWaitSynchronization_8
   5871              {
   5872                /* frequency error counter reached a zero value */
   5873                __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_ESYNC);
   \       0x84   0x2008             MOVS     R0,#+8
   \       0x86   0x....             LDR.N    R1,??DataTable24_18
   \       0x88   0x6008             STR      R0,[R1, #+0]
   5874              }
   5875            } while (RCC_CRS_NONE == crsstatus);
   \                     ??HAL_RCCEx_CRSWaitSynchronization_8: (+1)
   \       0x8A   0x2D00             CMP      R5,#+0
   \       0x8C   0xD0BE             BEQ.N    ??HAL_RCCEx_CRSWaitSynchronization_0
   5876          
   5877            return crsstatus;
   \       0x8E   0x0028             MOVS     R0,R5
   \       0x90   0xBD70             POP      {R4-R6,PC}
   5878          }
   5879          
   5880          /**
   5881            * @brief Handle the Clock Recovery System interrupt request.
   5882            * @retval None
   5883            */

   \                                 In section .text, align 2, keep-with-next
   5884          void HAL_RCCEx_CRS_IRQHandler(void)
   5885          {
   \                     HAL_RCCEx_CRS_IRQHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5886            uint32_t crserror = RCC_CRS_NONE;
   \        0x2   0x2000             MOVS     R0,#+0
   5887            /* Get current IT flags and IT sources values */
   5888            uint32_t itflags = READ_REG(CRS->ISR);
   \        0x4   0x....             LDR.N    R1,??DataTable24_17
   \        0x6   0x6809             LDR      R1,[R1, #+0]
   5889            uint32_t itsources = READ_REG(CRS->CR);
   \        0x8   0x....             LDR.N    R2,??DataTable24_16
   \        0xA   0x6812             LDR      R2,[R2, #+0]
   5890          
   5891            /* Check CRS SYNCOK flag  */
   5892            if (((itflags & RCC_CRS_FLAG_SYNCOK) != 0U) && ((itsources & RCC_CRS_IT_SYNCOK) != 0U))
   \        0xC   0xF011 0x0301      ANDS     R3,R1,#0x1
   \       0x10   0xF012 0x0401      ANDS     R4,R2,#0x1
   \       0x14   0x4223             TST      R3,R4
   \       0x16   0xD005             BEQ.N    ??HAL_RCCEx_CRS_IRQHandler_0
   5893            {
   5894              /* Clear CRS SYNC event OK flag */
   5895              WRITE_REG(CRS->ICR, CRS_ICR_SYNCOKC);
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x....             LDR.N    R1,??DataTable24_18
   \       0x1C   0x6008             STR      R0,[R1, #+0]
   5896          
   5897              /* user callback */
   5898              HAL_RCCEx_CRS_SyncOkCallback();
   \       0x1E   0x.... 0x....      BL       HAL_RCCEx_CRS_SyncOkCallback
   \       0x22   0xE028             B.N      ??HAL_RCCEx_CRS_IRQHandler_1
   5899            }
   5900            /* Check CRS SYNCWARN flag  */
   5901            else if (((itflags & RCC_CRS_FLAG_SYNCWARN) != 0U) && ((itsources & RCC_CRS_IT_SYNCWARN) != 0U))
   \                     ??HAL_RCCEx_CRS_IRQHandler_0: (+1)
   \       0x24   0x078B             LSLS     R3,R1,#+30
   \       0x26   0xD507             BPL.N    ??HAL_RCCEx_CRS_IRQHandler_2
   \       0x28   0x0793             LSLS     R3,R2,#+30
   \       0x2A   0xD505             BPL.N    ??HAL_RCCEx_CRS_IRQHandler_2
   5902            {
   5903              /* Clear CRS SYNCWARN flag */
   5904              WRITE_REG(CRS->ICR, CRS_ICR_SYNCWARNC);
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0x....             LDR.N    R1,??DataTable24_18
   \       0x30   0x6008             STR      R0,[R1, #+0]
   5905          
   5906              /* user callback */
   5907              HAL_RCCEx_CRS_SyncWarnCallback();
   \       0x32   0x.... 0x....      BL       HAL_RCCEx_CRS_SyncWarnCallback
   \       0x36   0xE01E             B.N      ??HAL_RCCEx_CRS_IRQHandler_1
   5908            }
   5909            /* Check CRS Expected SYNC flag  */
   5910            else if (((itflags & RCC_CRS_FLAG_ESYNC) != 0U) && ((itsources & RCC_CRS_IT_ESYNC) != 0U))
   \                     ??HAL_RCCEx_CRS_IRQHandler_2: (+1)
   \       0x38   0x070B             LSLS     R3,R1,#+28
   \       0x3A   0xD507             BPL.N    ??HAL_RCCEx_CRS_IRQHandler_3
   \       0x3C   0x0713             LSLS     R3,R2,#+28
   \       0x3E   0xD505             BPL.N    ??HAL_RCCEx_CRS_IRQHandler_3
   5911            {
   5912              /* frequency error counter reached a zero value */
   5913              WRITE_REG(CRS->ICR, CRS_ICR_ESYNCC);
   \       0x40   0x2008             MOVS     R0,#+8
   \       0x42   0x....             LDR.N    R1,??DataTable24_18
   \       0x44   0x6008             STR      R0,[R1, #+0]
   5914          
   5915              /* user callback */
   5916              HAL_RCCEx_CRS_ExpectedSyncCallback();
   \       0x46   0x.... 0x....      BL       HAL_RCCEx_CRS_ExpectedSyncCallback
   \       0x4A   0xE014             B.N      ??HAL_RCCEx_CRS_IRQHandler_1
   5917            }
   5918            /* Check CRS Error flags  */
   5919            else
   5920            {
   5921              if (((itflags & RCC_CRS_FLAG_ERR) != 0U) && ((itsources & RCC_CRS_IT_ERR) != 0U))
   \                     ??HAL_RCCEx_CRS_IRQHandler_3: (+1)
   \       0x4C   0x074B             LSLS     R3,R1,#+29
   \       0x4E   0xD512             BPL.N    ??HAL_RCCEx_CRS_IRQHandler_1
   \       0x50   0x0752             LSLS     R2,R2,#+29
   \       0x52   0xD510             BPL.N    ??HAL_RCCEx_CRS_IRQHandler_1
   5922              {
   5923                if ((itflags & RCC_CRS_FLAG_SYNCERR) != 0U)
   \       0x54   0x05CA             LSLS     R2,R1,#+23
   \       0x56   0xD501             BPL.N    ??HAL_RCCEx_CRS_IRQHandler_4
   5924                {
   5925                  crserror |= RCC_CRS_SYNCERR;
   \       0x58   0xF050 0x0008      ORRS     R0,R0,#0x8
   5926                }
   5927                if ((itflags & RCC_CRS_FLAG_SYNCMISS) != 0U)
   \                     ??HAL_RCCEx_CRS_IRQHandler_4: (+1)
   \       0x5C   0x058A             LSLS     R2,R1,#+22
   \       0x5E   0xD501             BPL.N    ??HAL_RCCEx_CRS_IRQHandler_5
   5928                {
   5929                  crserror |= RCC_CRS_SYNCMISS;
   \       0x60   0xF050 0x0010      ORRS     R0,R0,#0x10
   5930                }
   5931                if ((itflags & RCC_CRS_FLAG_TRIMOVF) != 0U)
   \                     ??HAL_RCCEx_CRS_IRQHandler_5: (+1)
   \       0x64   0x0549             LSLS     R1,R1,#+21
   \       0x66   0xD501             BPL.N    ??HAL_RCCEx_CRS_IRQHandler_6
   5932                {
   5933                  crserror |= RCC_CRS_TRIMOVF;
   \       0x68   0xF050 0x0020      ORRS     R0,R0,#0x20
   5934                }
   5935          
   5936                /* Clear CRS Error flags */
   5937                WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
   \                     ??HAL_RCCEx_CRS_IRQHandler_6: (+1)
   \       0x6C   0x2104             MOVS     R1,#+4
   \       0x6E   0x....             LDR.N    R2,??DataTable24_18
   \       0x70   0x6011             STR      R1,[R2, #+0]
   5938          
   5939                /* user error callback */
   5940                HAL_RCCEx_CRS_ErrorCallback(crserror);
   \       0x72   0x.... 0x....      BL       HAL_RCCEx_CRS_ErrorCallback
   5941              }
   5942            }
   5943          }
   \                     ??HAL_RCCEx_CRS_IRQHandler_1: (+1)
   \       0x76   0xBD10             POP      {R4,PC}
   5944          
   5945          /**
   5946            * @brief  RCCEx Clock Recovery System SYNCOK interrupt callback.
   5947            * @retval none
   5948            */

   \                                 In section .text, align 2
   5949          __weak void HAL_RCCEx_CRS_SyncOkCallback(void)
   5950          {
   5951            /* NOTE : This function should not be modified, when the callback is needed,
   5952                      the @ref HAL_RCCEx_CRS_SyncOkCallback should be implemented in the user file
   5953             */
   5954          }
   \                     HAL_RCCEx_CRS_SyncOkCallback: (+1)
   \        0x0   0x4770             BX       LR
   5955          
   5956          /**
   5957            * @brief  RCCEx Clock Recovery System SYNCWARN interrupt callback.
   5958            * @retval none
   5959            */

   \                                 In section .text, align 2
   5960          __weak void HAL_RCCEx_CRS_SyncWarnCallback(void)
   5961          {
   5962            /* NOTE : This function should not be modified, when the callback is needed,
   5963                      the @ref HAL_RCCEx_CRS_SyncWarnCallback should be implemented in the user file
   5964             */
   5965          }
   \                     HAL_RCCEx_CRS_SyncWarnCallback: (+1)
   \        0x0   0x4770             BX       LR
   5966          
   5967          /**
   5968            * @brief  RCCEx Clock Recovery System Expected SYNC interrupt callback.
   5969            * @retval none
   5970            */

   \                                 In section .text, align 2
   5971          __weak void HAL_RCCEx_CRS_ExpectedSyncCallback(void)
   5972          {
   5973            /* NOTE : This function should not be modified, when the callback is needed,
   5974                      the @ref HAL_RCCEx_CRS_ExpectedSyncCallback should be implemented in the user file
   5975             */
   5976          }
   \                     HAL_RCCEx_CRS_ExpectedSyncCallback: (+1)
   \        0x0   0x4770             BX       LR
   5977          
   5978          /**
   5979            * @brief  RCCEx Clock Recovery System Error interrupt callback.
   5980            * @param  Error Combination of Error status.
   5981            *         This parameter can be a combination of the following values:
   5982            *           @arg @ref RCC_CRS_SYNCERR
   5983            *           @arg @ref RCC_CRS_SYNCMISS
   5984            *           @arg @ref RCC_CRS_TRIMOVF
   5985            * @retval none
   5986            */

   \                                 In section .text, align 2
   5987          __weak void HAL_RCCEx_CRS_ErrorCallback(uint32_t Error)
   5988          {
   5989            /* Prevent unused argument(s) compilation warning */
   5990            UNUSED(Error);
   5991          
   5992            /* NOTE : This function should not be modified, when the callback is needed,
   5993                      the @ref HAL_RCCEx_CRS_ErrorCallback should be implemented in the user file
   5994             */
   5995          }
   \                     HAL_RCCEx_CRS_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR
   5996          
   5997          /**
   5998            * @}
   5999            */
   6000          
   6001          #endif /* CRS */
   6002          
   6003          /**
   6004            * @}
   6005            */
   6006          
   6007          /** @addtogroup RCCEx_Private_Functions
   6008            * @{
   6009            */
   6010          
   6011          /**
   6012            * @brief  Enable PLLx source clock and check ready flag
   6013            * @param  PllSource contains the selected PLLx source clock (HSE, HSI or CSI)
   6014            * @retval HAL status
   6015            */

   \                                 In section .text, align 2, keep-with-next
   6016          static HAL_StatusTypeDef RCCEx_PLLSource_Enable(uint32_t PllSource)
   6017          {
   \                     RCCEx_PLLSource_Enable: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   6018            uint32_t tickstart;
   6019            HAL_StatusTypeDef status = HAL_OK;
   \        0x2   0x2400             MOVS     R4,#+0
   6020          
   6021            switch (PllSource)
   \        0x4   0x2801             CMP      R0,#+1
   \        0x6   0xD018             BEQ.N    ??RCCEx_PLLSource_Enable_0
   \        0x8   0xD341             BCC.N    ??RCCEx_PLLSource_Enable_1
   \        0xA   0x2803             CMP      R0,#+3
   \        0xC   0xD02A             BEQ.N    ??RCCEx_PLLSource_Enable_2
   \        0xE   0xD23E             BCS.N    ??RCCEx_PLLSource_Enable_1
   6022            {
   6023              case RCC_PLL1_SOURCE_CSI:
   6024                /* Check whether CSI in not ready and enable it */
   6025                if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) == 0U)
   \                     ??RCCEx_PLLSource_Enable_3: (+1)
   \       0x10   0x....             LDR.N    R6,??DataTable24_2
   \       0x12   0x6830             LDR      R0,[R6, #+0]
   \       0x14   0x0580             LSLS     R0,R0,#+22
   \       0x16   0xD40F             BMI.N    ??RCCEx_PLLSource_Enable_4
   6026                {
   6027                  /* Enable the Internal Low power oscillator (CSI). */
   6028                  __HAL_RCC_CSI_ENABLE();
   \       0x18   0x6830             LDR      R0,[R6, #+0]
   \       0x1A   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x1E   0x6030             STR      R0,[R6, #+0]
   6029          
   6030                  /* Get timeout */
   6031                  tickstart = HAL_GetTick();
   \       0x20   0x.... 0x....      BL       HAL_GetTick
   \       0x24   0x0005             MOVS     R5,R0
   6032          
   6033                  /* Wait till CSI is ready */
   6034                  while (READ_BIT(RCC->CR, RCC_CR_CSIRDY) == 0U)
   \                     ??RCCEx_PLLSource_Enable_5: (+1)
   \       0x26   0x6830             LDR      R0,[R6, #+0]
   \       0x28   0x0580             LSLS     R0,R0,#+22
   \       0x2A   0xD405             BMI.N    ??RCCEx_PLLSource_Enable_4
   6035                  {
   6036                    if ((HAL_GetTick() - tickstart) > RCC_CSI_TIMEOUT_VALUE)
   \       0x2C   0x.... 0x....      BL       HAL_GetTick
   \       0x30   0x1B40             SUBS     R0,R0,R5
   \       0x32   0x2803             CMP      R0,#+3
   \       0x34   0xD3F7             BCC.N    ??RCCEx_PLLSource_Enable_5
   6037                    {
   6038                      status = HAL_TIMEOUT;
   \       0x36   0x2403             MOVS     R4,#+3
   6039                      break;
   6040                    }
   6041                  }
   6042                }
   6043                break;
   \                     ??RCCEx_PLLSource_Enable_4: (+1)
   \       0x38   0xE02A             B.N      ??RCCEx_PLLSource_Enable_6
   6044          
   6045              case RCC_PLL1_SOURCE_HSI:
   6046                /* Check whether HSI in not ready and enable it */
   6047                if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
   \                     ??RCCEx_PLLSource_Enable_0: (+1)
   \       0x3A   0x....             LDR.N    R6,??DataTable24_2
   \       0x3C   0x6830             LDR      R0,[R6, #+0]
   \       0x3E   0x0780             LSLS     R0,R0,#+30
   \       0x40   0xD40F             BMI.N    ??RCCEx_PLLSource_Enable_7
   6048                {
   6049                  /* Enable the Internal High Speed oscillator (HSI). */
   6050                  __HAL_RCC_HSI_ENABLE();
   \       0x42   0x6830             LDR      R0,[R6, #+0]
   \       0x44   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x48   0x6030             STR      R0,[R6, #+0]
   6051          
   6052                  /* Get timeout */
   6053                  tickstart = HAL_GetTick();
   \       0x4A   0x.... 0x....      BL       HAL_GetTick
   \       0x4E   0x0005             MOVS     R5,R0
   6054          
   6055                  /* Wait till HSI is ready */
   6056                  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
   \                     ??RCCEx_PLLSource_Enable_8: (+1)
   \       0x50   0x6830             LDR      R0,[R6, #+0]
   \       0x52   0x0780             LSLS     R0,R0,#+30
   \       0x54   0xD405             BMI.N    ??RCCEx_PLLSource_Enable_7
   6057                  {
   6058                    if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
   \       0x56   0x.... 0x....      BL       HAL_GetTick
   \       0x5A   0x1B40             SUBS     R0,R0,R5
   \       0x5C   0x2803             CMP      R0,#+3
   \       0x5E   0xD3F7             BCC.N    ??RCCEx_PLLSource_Enable_8
   6059                    {
   6060                      status = HAL_TIMEOUT;
   \       0x60   0x2403             MOVS     R4,#+3
   6061                      break;
   6062                    }
   6063                  }
   6064                }
   6065                break;
   \                     ??RCCEx_PLLSource_Enable_7: (+1)
   \       0x62   0xE015             B.N      ??RCCEx_PLLSource_Enable_6
   6066          
   6067              case RCC_PLL1_SOURCE_HSE:
   6068                /* Check whether HSE in not ready and enable it */
   6069                if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
   \                     ??RCCEx_PLLSource_Enable_2: (+1)
   \       0x64   0x....             LDR.N    R6,??DataTable24_2
   \       0x66   0x6830             LDR      R0,[R6, #+0]
   \       0x68   0x0380             LSLS     R0,R0,#+14
   \       0x6A   0xD40F             BMI.N    ??RCCEx_PLLSource_Enable_9
   6070                {
   6071                  /* Enable the External High Speed oscillator (HSE). */
   6072                  SET_BIT(RCC->CR, RCC_CR_HSEON);
   \       0x6C   0x6830             LDR      R0,[R6, #+0]
   \       0x6E   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \       0x72   0x6030             STR      R0,[R6, #+0]
   6073          
   6074                  /* Get Start Tick*/
   6075                  tickstart = HAL_GetTick();
   \       0x74   0x.... 0x....      BL       HAL_GetTick
   \       0x78   0x0005             MOVS     R5,R0
   6076          
   6077                  /* Wait till HSE is ready */
   6078                  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
   \                     ??RCCEx_PLLSource_Enable_10: (+1)
   \       0x7A   0x6830             LDR      R0,[R6, #+0]
   \       0x7C   0x0380             LSLS     R0,R0,#+14
   \       0x7E   0xD405             BMI.N    ??RCCEx_PLLSource_Enable_9
   6079                  {
   6080                    if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
   \       0x80   0x.... 0x....      BL       HAL_GetTick
   \       0x84   0x1B40             SUBS     R0,R0,R5
   \       0x86   0x2865             CMP      R0,#+101
   \       0x88   0xD3F7             BCC.N    ??RCCEx_PLLSource_Enable_10
   6081                    {
   6082                      status = HAL_TIMEOUT;
   \       0x8A   0x2403             MOVS     R4,#+3
   6083                      break;
   6084                    }
   6085                  }
   6086                }
   6087                break;
   \                     ??RCCEx_PLLSource_Enable_9: (+1)
   \       0x8C   0xE000             B.N      ??RCCEx_PLLSource_Enable_6
   6088          
   6089              default:
   6090                status = HAL_ERROR;
   \                     ??RCCEx_PLLSource_Enable_1: (+1)
   \       0x8E   0x2401             MOVS     R4,#+1
   6091                break;
   6092            }
   6093          
   6094            return status;
   \                     ??RCCEx_PLLSource_Enable_6: (+1)
   \       0x90   0x0020             MOVS     R0,R4
   \       0x92   0xB2C0             UXTB     R0,R0
   \       0x94   0xBD70             POP      {R4-R6,PC}
   6095          }
   6096          
   6097          /**
   6098            * @brief  Configure the PLL2 VCI/VCO ranges, multiplication and division factors and its output clock(s)
   6099            * @param  pll2  pointer to an RCC_PLL2InitTypeDef structure that
   6100            *         contains the configuration parameters M, N, FRACN, VCI/VCO ranges as well as PLL2 output clocks dividers
   6101            * @note   PLL2 is temporary disabled to apply new parameters
   6102            * @retval HAL status
   6103            */

   \                                 In section .text, align 2, keep-with-next
   6104          static HAL_StatusTypeDef RCCEx_PLL2_Config(const RCC_PLL2InitTypeDef *pll2)
   6105          {
   \                     RCCEx_PLL2_Config: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   6106          
   6107            uint32_t tickstart;
   6108            assert_param(IS_RCC_PLL2_SOURCE(pll2->PLL2Source));
   6109            assert_param(IS_RCC_PLL2_DIVM_VALUE(pll2->PLL2M));
   6110            assert_param(IS_RCC_PLL2_MULN_VALUE(pll2->PLL2N));
   6111            assert_param(IS_RCC_PLL2_DIVP_VALUE(pll2->PLL2P));
   6112            assert_param(IS_RCC_PLL2_DIVQ_VALUE(pll2->PLL2Q));
   6113            assert_param(IS_RCC_PLL2_DIVR_VALUE(pll2->PLL2R));
   6114            assert_param(IS_RCC_PLL2_CLOCKOUT_VALUE(pll2->PLL2ClockOut));
   6115            assert_param(IS_RCC_PLL2_VCIRGE_VALUE(pll2->PLL2RGE));
   6116            assert_param(IS_RCC_PLL2_VCORGE_VALUE(pll2->PLL2VCOSEL));
   6117            assert_param(IS_RCC_PLL2_FRACN_VALUE(pll2->PLL2FRACN));
   6118          
   6119            /* Disable  PLL2. */
   6120            __HAL_RCC_PLL2_DISABLE();
   \        0x4   0x....             LDR.N    R5,??DataTable24_2
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \        0xC   0x6028             STR      R0,[R5, #+0]
   6121          
   6122            /* Get Start Tick*/
   6123            tickstart = HAL_GetTick();
   \        0xE   0x.... 0x....      BL       HAL_GetTick
   \       0x12   0x0006             MOVS     R6,R0
   6124          
   6125            /* Wait till PLL2 is disabled */
   6126            while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
   \                     ??RCCEx_PLL2_Config_0: (+1)
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x0100             LSLS     R0,R0,#+4
   \       0x18   0xD506             BPL.N    ??RCCEx_PLL2_Config_1
   6127            {
   6128              if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
   \       0x1A   0x.... 0x....      BL       HAL_GetTick
   \       0x1E   0x1B80             SUBS     R0,R0,R6
   \       0x20   0x2803             CMP      R0,#+3
   \       0x22   0xD3F7             BCC.N    ??RCCEx_PLL2_Config_0
   6129              {
   6130                return HAL_TIMEOUT;
   \       0x24   0x2003             MOVS     R0,#+3
   \       0x26   0xE053             B.N      ??RCCEx_PLL2_Config_2
   6131              }
   6132            }
   6133          
   6134            /* Configure PLL2 multiplication and division factors. */
   6135            __HAL_RCC_PLL2_CONFIG(pll2->PLL2Source,
   6136                                  pll2->PLL2M,
   6137                                  pll2->PLL2N,
   6138                                  pll2->PLL2P,
   6139                                  pll2->PLL2Q,
   6140                                  pll2->PLL2R);
   \                     ??RCCEx_PLL2_Config_1: (+1)
   \       0x28   0x....             LDR.N    R1,??DataTable24_4
   \       0x2A   0x680A             LDR      R2,[R1, #+0]
   \       0x2C   0x....             LDR.N    R0,??DataTable24_5
   \       0x2E   0x4002             ANDS     R2,R0,R2
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x4302             ORRS     R2,R0,R2
   \       0x34   0x6860             LDR      R0,[R4, #+4]
   \       0x36   0xEA52 0x2200      ORRS     R2,R2,R0, LSL #+8
   \       0x3A   0x600A             STR      R2,[R1, #+0]
   \       0x3C   0x68A0             LDR      R0,[R4, #+8]
   \       0x3E   0x1E40             SUBS     R0,R0,#+1
   \       0x40   0x05C0             LSLS     R0,R0,#+23
   \       0x42   0x0DC0             LSRS     R0,R0,#+23
   \       0x44   0x68E2             LDR      R2,[R4, #+12]
   \       0x46   0x1E52             SUBS     R2,R2,#+1
   \       0x48   0x0252             LSLS     R2,R2,#+9
   \       0x4A   0xF412 0x427E      ANDS     R2,R2,#0xFE00
   \       0x4E   0x4310             ORRS     R0,R2,R0
   \       0x50   0x6922             LDR      R2,[R4, #+16]
   \       0x52   0x1E52             SUBS     R2,R2,#+1
   \       0x54   0x0412             LSLS     R2,R2,#+16
   \       0x56   0xF412 0x02FE      ANDS     R2,R2,#0x7F0000
   \       0x5A   0x4310             ORRS     R0,R2,R0
   \       0x5C   0x6962             LDR      R2,[R4, #+20]
   \       0x5E   0x1E52             SUBS     R2,R2,#+1
   \       0x60   0x0612             LSLS     R2,R2,#+24
   \       0x62   0xF012 0x42FE      ANDS     R2,R2,#0x7F000000
   \       0x66   0x4310             ORRS     R0,R2,R0
   \       0x68   0x....             LDR.N    R2,??DataTable24_6
   \       0x6A   0x6010             STR      R0,[R2, #+0]
   6141          
   6142            /* Select PLL2 input reference frequency range: VCI */
   6143            __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE);
   \       0x6C   0x680A             LDR      R2,[R1, #+0]
   \       0x6E   0xF032 0x020C      BICS     R2,R2,#0xC
   \       0x72   0x69A0             LDR      R0,[R4, #+24]
   \       0x74   0x4302             ORRS     R2,R0,R2
   \       0x76   0x600A             STR      R2,[R1, #+0]
   6144          
   6145            /* Select PLL2 output frequency range : VCO */
   6146            __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL);
   \       0x78   0x680A             LDR      R2,[R1, #+0]
   \       0x7A   0xF032 0x0220      BICS     R2,R2,#0x20
   \       0x7E   0x69E0             LDR      R0,[R4, #+28]
   \       0x80   0x4302             ORRS     R2,R0,R2
   \       0x82   0x600A             STR      R2,[R1, #+0]
   6147          
   6148            /* Configure the PLL2 Clock output(s) */
   6149            __HAL_RCC_PLL2_CLKOUT_ENABLE(pll2->PLL2ClockOut);
   \       0x84   0x680A             LDR      R2,[R1, #+0]
   \       0x86   0x6A60             LDR      R0,[R4, #+36]
   \       0x88   0x4302             ORRS     R2,R0,R2
   \       0x8A   0x600A             STR      R2,[R1, #+0]
   6150          
   6151            /* Disable PLL2FRACN . */
   6152            __HAL_RCC_PLL2_FRACN_DISABLE();
   \       0x8C   0x6808             LDR      R0,[R1, #+0]
   \       0x8E   0xF030 0x0010      BICS     R0,R0,#0x10
   \       0x92   0x6008             STR      R0,[R1, #+0]
   6153          
   6154            /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
   6155            __HAL_RCC_PLL2_FRACN_CONFIG(pll2->PLL2FRACN);
   \       0x94   0x....             LDR.N    R0,??DataTable24_7
   \       0x96   0x6802             LDR      R2,[R0, #+0]
   \       0x98   0xF36F 0x02CF      BFC      R2,#+3,#+13
   \       0x9C   0x6A23             LDR      R3,[R4, #+32]
   \       0x9E   0xEA52 0x02C3      ORRS     R2,R2,R3, LSL #+3
   \       0xA2   0x6002             STR      R2,[R0, #+0]
   6156          
   6157            /* Enable PLL2FRACN . */
   6158            __HAL_RCC_PLL2_FRACN_ENABLE();
   \       0xA4   0x6808             LDR      R0,[R1, #+0]
   \       0xA6   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xAA   0x6008             STR      R0,[R1, #+0]
   6159          
   6160            /* Enable  PLL2. */
   6161            __HAL_RCC_PLL2_ENABLE();
   \       0xAC   0x6828             LDR      R0,[R5, #+0]
   \       0xAE   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \       0xB2   0x6028             STR      R0,[R5, #+0]
   6162          
   6163            /* Get Start Tick*/
   6164            tickstart = HAL_GetTick();
   \       0xB4   0x.... 0x....      BL       HAL_GetTick
   \       0xB8   0x0004             MOVS     R4,R0
   6165          
   6166            /* Wait till PLL2 is ready */
   6167            while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
   \                     ??RCCEx_PLL2_Config_3: (+1)
   \       0xBA   0x6828             LDR      R0,[R5, #+0]
   \       0xBC   0x0100             LSLS     R0,R0,#+4
   \       0xBE   0xD406             BMI.N    ??RCCEx_PLL2_Config_4
   6168            {
   6169              if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
   \       0xC0   0x.... 0x....      BL       HAL_GetTick
   \       0xC4   0x1B00             SUBS     R0,R0,R4
   \       0xC6   0x2803             CMP      R0,#+3
   \       0xC8   0xD3F7             BCC.N    ??RCCEx_PLL2_Config_3
   6170              {
   6171                return HAL_TIMEOUT;
   \       0xCA   0x2003             MOVS     R0,#+3
   \       0xCC   0xE000             B.N      ??RCCEx_PLL2_Config_2
   6172              }
   6173            }
   6174            return HAL_OK;
   \                     ??RCCEx_PLL2_Config_4: (+1)
   \       0xCE   0x2000             MOVS     R0,#+0
   \                     ??RCCEx_PLL2_Config_2: (+1)
   \       0xD0   0xBD70             POP      {R4-R6,PC}
   6175          
   6176          }
   6177          
   6178          #if defined(RCC_CR_PLL3ON)
   6179          /**
   6180            * @brief  Configure the PLL3 VCI/VCO ranges, multiplication and division factors and its output clock(s)
   6181            * @param  pll3  pointer to an RCC_PLL3InitTypeDef structure that
   6182            *         contains the configuration parameters M, N, FRACN, VCI/VCO ranges as well as PLL3 output clocks dividers
   6183            * @note   PLL3 is temporary disabled to apply new parameters
   6184            * @retval HAL status.
   6185            */

   \                                 In section .text, align 2, keep-with-next
   6186          static HAL_StatusTypeDef RCCEx_PLL3_Config(const RCC_PLL3InitTypeDef *pll3)
   6187          {
   \                     RCCEx_PLL3_Config: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   6188          
   6189            uint32_t tickstart;
   6190            assert_param(IS_RCC_PLL3_SOURCE(pll3->PLL3Source));
   6191            assert_param(IS_RCC_PLL3_DIVM_VALUE(pll3->PLL3M));
   6192            assert_param(IS_RCC_PLL3_MULN_VALUE(pll3->PLL3N));
   6193            assert_param(IS_RCC_PLL3_DIVP_VALUE(pll3->PLL3P));
   6194            assert_param(IS_RCC_PLL3_DIVQ_VALUE(pll3->PLL3Q));
   6195            assert_param(IS_RCC_PLL3_DIVR_VALUE(pll3->PLL3R));
   6196            assert_param(IS_RCC_PLL3_CLOCKOUT_VALUE(pll3->PLL3ClockOut));
   6197            assert_param(IS_RCC_PLL3_VCIRGE_VALUE(pll3->PLL3RGE));
   6198            assert_param(IS_RCC_PLL3_VCORGE_VALUE(pll3->PLL3VCOSEL));
   6199            assert_param(IS_RCC_PLL3_FRACN_VALUE(pll3->PLL3FRACN));
   6200          
   6201            /* Disable  PLL3. */
   6202            __HAL_RCC_PLL3_DISABLE();
   \        0x4   0x....             LDR.N    R5,??DataTable24_2
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \        0xC   0x6028             STR      R0,[R5, #+0]
   6203          
   6204            /* Get Start Tick*/
   6205            tickstart = HAL_GetTick();
   \        0xE   0x.... 0x....      BL       HAL_GetTick
   \       0x12   0x0006             MOVS     R6,R0
   6206          
   6207            /* Wait till PLL3 is disabled */
   6208            while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
   \                     ??RCCEx_PLL3_Config_0: (+1)
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x0080             LSLS     R0,R0,#+2
   \       0x18   0xD506             BPL.N    ??RCCEx_PLL3_Config_1
   6209            {
   6210              if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
   \       0x1A   0x.... 0x....      BL       HAL_GetTick
   \       0x1E   0x1B80             SUBS     R0,R0,R6
   \       0x20   0x2803             CMP      R0,#+3
   \       0x22   0xD3F7             BCC.N    ??RCCEx_PLL3_Config_0
   6211              {
   6212                return HAL_TIMEOUT;
   \       0x24   0x2003             MOVS     R0,#+3
   \       0x26   0xE053             B.N      ??RCCEx_PLL3_Config_2
   6213              }
   6214            }
   6215          
   6216            /* Configure PLL3 multiplication and division factors. */
   6217            __HAL_RCC_PLL3_CONFIG(pll3->PLL3Source,
   6218                                  pll3->PLL3M,
   6219                                  pll3->PLL3N,
   6220                                  pll3->PLL3P,
   6221                                  pll3->PLL3Q,
   6222                                  pll3->PLL3R);
   \                     ??RCCEx_PLL3_Config_1: (+1)
   \       0x28   0x....             LDR.N    R1,??DataTable24_9
   \       0x2A   0x680A             LDR      R2,[R1, #+0]
   \       0x2C   0x....             LDR.N    R0,??DataTable24_5
   \       0x2E   0x4002             ANDS     R2,R0,R2
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x4302             ORRS     R2,R0,R2
   \       0x34   0x6860             LDR      R0,[R4, #+4]
   \       0x36   0xEA52 0x2200      ORRS     R2,R2,R0, LSL #+8
   \       0x3A   0x600A             STR      R2,[R1, #+0]
   \       0x3C   0x68A0             LDR      R0,[R4, #+8]
   \       0x3E   0x1E40             SUBS     R0,R0,#+1
   \       0x40   0x05C0             LSLS     R0,R0,#+23
   \       0x42   0x0DC0             LSRS     R0,R0,#+23
   \       0x44   0x68E2             LDR      R2,[R4, #+12]
   \       0x46   0x1E52             SUBS     R2,R2,#+1
   \       0x48   0x0252             LSLS     R2,R2,#+9
   \       0x4A   0xF412 0x427E      ANDS     R2,R2,#0xFE00
   \       0x4E   0x4310             ORRS     R0,R2,R0
   \       0x50   0x6922             LDR      R2,[R4, #+16]
   \       0x52   0x1E52             SUBS     R2,R2,#+1
   \       0x54   0x0412             LSLS     R2,R2,#+16
   \       0x56   0xF412 0x02FE      ANDS     R2,R2,#0x7F0000
   \       0x5A   0x4310             ORRS     R0,R2,R0
   \       0x5C   0x6962             LDR      R2,[R4, #+20]
   \       0x5E   0x1E52             SUBS     R2,R2,#+1
   \       0x60   0x0612             LSLS     R2,R2,#+24
   \       0x62   0xF012 0x42FE      ANDS     R2,R2,#0x7F000000
   \       0x66   0x4310             ORRS     R0,R2,R0
   \       0x68   0x....             LDR.N    R2,??DataTable24_10
   \       0x6A   0x6010             STR      R0,[R2, #+0]
   6223          
   6224            /* Select PLL3 input reference frequency range: VCI */
   6225            __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
   \       0x6C   0x680A             LDR      R2,[R1, #+0]
   \       0x6E   0xF032 0x020C      BICS     R2,R2,#0xC
   \       0x72   0x69A0             LDR      R0,[R4, #+24]
   \       0x74   0x4302             ORRS     R2,R0,R2
   \       0x76   0x600A             STR      R2,[R1, #+0]
   6226          
   6227            /* Select PLL3 output frequency range : VCO */
   6228            __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL);
   \       0x78   0x680A             LDR      R2,[R1, #+0]
   \       0x7A   0xF032 0x0220      BICS     R2,R2,#0x20
   \       0x7E   0x69E0             LDR      R0,[R4, #+28]
   \       0x80   0x4302             ORRS     R2,R0,R2
   \       0x82   0x600A             STR      R2,[R1, #+0]
   6229          
   6230            /* Configure the PLL3 Clock output(s) */
   6231            __HAL_RCC_PLL3_CLKOUT_ENABLE(pll3->PLL3ClockOut);
   \       0x84   0x680A             LDR      R2,[R1, #+0]
   \       0x86   0x6A60             LDR      R0,[R4, #+36]
   \       0x88   0x4302             ORRS     R2,R0,R2
   \       0x8A   0x600A             STR      R2,[R1, #+0]
   6232          
   6233            /* Disable PLL3FRACN . */
   6234            __HAL_RCC_PLL3_FRACN_DISABLE();
   \       0x8C   0x6808             LDR      R0,[R1, #+0]
   \       0x8E   0xF030 0x0010      BICS     R0,R0,#0x10
   \       0x92   0x6008             STR      R0,[R1, #+0]
   6235          
   6236            /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
   6237            __HAL_RCC_PLL3_FRACN_CONFIG(pll3->PLL3FRACN);
   \       0x94   0x....             LDR.N    R0,??DataTable24_11
   \       0x96   0x6802             LDR      R2,[R0, #+0]
   \       0x98   0xF36F 0x02CF      BFC      R2,#+3,#+13
   \       0x9C   0x6A23             LDR      R3,[R4, #+32]
   \       0x9E   0xEA52 0x02C3      ORRS     R2,R2,R3, LSL #+3
   \       0xA2   0x6002             STR      R2,[R0, #+0]
   6238          
   6239            /* Enable PLL3FRACN . */
   6240            __HAL_RCC_PLL3_FRACN_ENABLE();
   \       0xA4   0x6808             LDR      R0,[R1, #+0]
   \       0xA6   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xAA   0x6008             STR      R0,[R1, #+0]
   6241          
   6242            /* Enable  PLL3. */
   6243            __HAL_RCC_PLL3_ENABLE();
   \       0xAC   0x6828             LDR      R0,[R5, #+0]
   \       0xAE   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \       0xB2   0x6028             STR      R0,[R5, #+0]
   6244          
   6245            /* Get Start Tick*/
   6246            tickstart = HAL_GetTick();
   \       0xB4   0x.... 0x....      BL       HAL_GetTick
   \       0xB8   0x0004             MOVS     R4,R0
   6247          
   6248            /* Wait till PLL3 is ready */
   6249            while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
   \                     ??RCCEx_PLL3_Config_3: (+1)
   \       0xBA   0x6828             LDR      R0,[R5, #+0]
   \       0xBC   0x0080             LSLS     R0,R0,#+2
   \       0xBE   0xD406             BMI.N    ??RCCEx_PLL3_Config_4
   6250            {
   6251              if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
   \       0xC0   0x.... 0x....      BL       HAL_GetTick
   \       0xC4   0x1B00             SUBS     R0,R0,R4
   \       0xC6   0x2803             CMP      R0,#+3
   \       0xC8   0xD3F7             BCC.N    ??RCCEx_PLL3_Config_3
   6252              {
   6253                return HAL_TIMEOUT;
   \       0xCA   0x2003             MOVS     R0,#+3
   \       0xCC   0xE000             B.N      ??RCCEx_PLL3_Config_2
   6254              }
   6255            }
   6256            return HAL_OK;
   \                     ??RCCEx_PLL3_Config_4: (+1)
   \       0xCE   0x2000             MOVS     R0,#+0
   \                     ??RCCEx_PLL3_Config_2: (+1)
   \       0xD0   0xBD70             POP      {R4-R6,PC}
   6257          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \        0x0   0x4402'0C1C        DC32     0x44020c1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x4402'0C28        DC32     0x44020c28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x4402'0CE8        DC32     0x44020ce8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x4402'0824        DC32     0x44020824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x4402'0CF0        DC32     0x44020cf0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x4600'0000        DC32     0x46000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x4A74'2400        DC32     0x4a742400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x4BBE'BC20        DC32     0x4bbebc20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \        0x0   0x00FF'FFCF        DC32     0xffffcf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x4600'0000        DC32     0x46000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x4A74'2400        DC32     0x4a742400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x4BBE'BC20        DC32     0x4bbebc20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x4600'0000        DC32     0x46000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x4A74'2400        DC32     0x4a742400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x4BBE'BC20        DC32     0x4bbebc20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x4402'0CE4        DC32     0x44020ce4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x3F27'7007        DC32     0x3f277007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \        0x0   0x4402'0C2C        DC32     0x44020c2c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \        0x0   0x4402'0C3C        DC32     0x44020c3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \        0x0   0x4402'0C40        DC32     0x44020c40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \        0x0   0x4402'0C30        DC32     0x44020c30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \        0x0   0x4402'0C44        DC32     0x44020c44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \        0x0   0x4402'0C48        DC32     0x44020c48

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \        0x0   0x4402'0CD8        DC32     0x44020cd8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \        0x0   0x4402'0CDC        DC32     0x44020cdc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \        0x0   0x4402'0CE0        DC32     0x44020ce0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \        0x0   0x4402'0C1C        DC32     0x44020c1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_15:
   \        0x0   0x4402'0C34        DC32     0x44020c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_16:
   \        0x0   0x4402'0C28        DC32     0x44020c28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_17:
   \        0x0   0x4402'0C38        DC32     0x44020c38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_18:
   \        0x0   0x03D0'9000        DC32     0x3d09000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_19:
   \        0x0   0x4402'0C00        DC32     0x44020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x03D0'9000        DC32     0x3d09000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x4402'0CE8        DC32     0x44020ce8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x003D'0900        DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0x00BB'8000        DC32     0xbb8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x4402'0CE4        DC32     0x44020ce4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \        0x0   0x4402'0CF0        DC32     0x44020cf0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \        0x0   0x4402'0C00        DC32     0x44020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \        0x0   0x02DC'6C00        DC32     0x2dc6c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \        0x0   0x4402'0C2C        DC32     0x44020c2c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \        0x0   0xFFFF'C0FC        DC32     0xffffc0fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \        0x0   0x4402'0C3C        DC32     0x44020c3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_7:
   \        0x0   0x4402'0C40        DC32     0x44020c40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_8:
   \        0x0   0xFFF8'FFEC        DC32     0xfff8ffec

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_9:
   \        0x0   0x4402'0C30        DC32     0x44020c30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_10:
   \        0x0   0x4402'0C44        DC32     0x44020c44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_11:
   \        0x0   0x4402'0C48        DC32     0x44020c48

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_12:
   \        0x0   0x4402'0C1C        DC32     0x44020c1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_13:
   \        0x0   0x4402'0824        DC32     0x44020824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_14:
   \        0x0   0x4402'0C74        DC32     0x44020c74

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_15:
   \        0x0   0x4000'6004        DC32     0x40006004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_16:
   \        0x0   0x4000'6000        DC32     0x40006000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_17:
   \        0x0   0x4000'6008        DC32     0x40006008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_18:
   \        0x0   0x4000'600C        DC32     0x4000600c
   6258          #endif /* RCC_CR_PLL3ON */
   6259          
   6260          /**
   6261            * @}
   6262            */
   6263          
   6264          #endif /* HAL_RCC_MODULE_ENABLED */
   6265          /**
   6266            * @}
   6267            */
   6268          
   6269          /**
   6270            * @}
   6271            */
   6272          
   6273          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCCEx_CRSConfig
       0   HAL_RCCEx_CRSGetSynchronizationInfo
       0   HAL_RCCEx_CRSSoftwareSynchronizationGenerate
      16   HAL_RCCEx_CRSWaitSynchronization
        16   -> HAL_GetTick
       0   HAL_RCCEx_CRS_ErrorCallback
       0   HAL_RCCEx_CRS_ExpectedSyncCallback
       8   HAL_RCCEx_CRS_IRQHandler
         8   -> HAL_RCCEx_CRS_ErrorCallback
         8   -> HAL_RCCEx_CRS_ExpectedSyncCallback
         8   -> HAL_RCCEx_CRS_SyncOkCallback
         8   -> HAL_RCCEx_CRS_SyncWarnCallback
       0   HAL_RCCEx_CRS_SyncOkCallback
       0   HAL_RCCEx_CRS_SyncWarnCallback
       8   HAL_RCCEx_DisableLSCO
         8   -> HAL_PWR_DisableBkUpAccess
         8   -> HAL_PWR_EnableBkUpAccess
       0   HAL_RCCEx_DisableLSECSS
      16   HAL_RCCEx_DisablePLL2
        16   -> HAL_GetTick
      16   HAL_RCCEx_DisablePLL3
        16   -> HAL_GetTick
       8   HAL_RCCEx_EnableLSCO
         8   -> HAL_PWR_DisableBkUpAccess
         8   -> HAL_PWR_EnableBkUpAccess
       0   HAL_RCCEx_EnableLSECSS
      24   HAL_RCCEx_EnablePLL2
        24   -> HAL_GetTick
        24   -> RCCEx_PLLSource_Enable
      24   HAL_RCCEx_EnablePLL3
        24   -> HAL_GetTick
        24   -> RCCEx_PLLSource_Enable
      16   HAL_RCCEx_GetPLL1ClockFreq
        16   -> GPIO_Debug
      12   HAL_RCCEx_GetPLL2ClockFreq
      12   HAL_RCCEx_GetPLL3ClockFreq
       4   HAL_RCCEx_GetPeriphCLKConfig
      40   HAL_RCCEx_GetPeriphCLKFreq
        40   -> HAL_RCCEx_GetPLL1ClockFreq
        40   -> HAL_RCCEx_GetPLL2ClockFreq
        40   -> HAL_RCCEx_GetPLL3ClockFreq
        40   -> HAL_RCC_GetHCLKFreq
        40   -> HAL_RCC_GetPCLK1Freq
        40   -> HAL_RCC_GetPCLK2Freq
        40   -> HAL_RCC_GetPCLK3Freq
        40   -> HAL_RCC_GetSysClockFreq
        40 __iar_llswitch
       0   HAL_RCCEx_KerWakeUpStopCLKConfig
       0   HAL_RCCEx_LSECSS_Callback
       8   HAL_RCCEx_LSECSS_IRQHandler
         8   -> HAL_RCCEx_LSECSS_Callback
      24   HAL_RCCEx_PeriphCLKConfig
        24   -> GPIO_Debug
        24   -> HAL_GetTick
        24   -> RCCEx_PLL2_Config
        24   -> RCCEx_PLL3_Config
       0   HAL_RCCEx_WakeUpStopCLKConfig
      16   RCCEx_PLL2_Config
        16   -> HAL_GetTick
      16   RCCEx_PLL3_Config
        16   -> HAL_GetTick
      16   RCCEx_PLLSource_Enable
        16   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable1
       4  ??DataTable2
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_12
       4  ??DataTable24_13
       4  ??DataTable24_14
       4  ??DataTable24_15
       4  ??DataTable24_16
       4  ??DataTable24_17
       4  ??DataTable24_18
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_15
       4  ??DataTable4_16
       4  ??DataTable4_17
       4  ??DataTable4_18
       4  ??DataTable4_19
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
      74  HAL_RCCEx_CRSConfig
      42  HAL_RCCEx_CRSGetSynchronizationInfo
      14  HAL_RCCEx_CRSSoftwareSynchronizationGenerate
     146  HAL_RCCEx_CRSWaitSynchronization
       2  HAL_RCCEx_CRS_ErrorCallback
       2  HAL_RCCEx_CRS_ExpectedSyncCallback
     120  HAL_RCCEx_CRS_IRQHandler
       2  HAL_RCCEx_CRS_SyncOkCallback
       2  HAL_RCCEx_CRS_SyncWarnCallback
      44  HAL_RCCEx_DisableLSCO
      14  HAL_RCCEx_DisableLSECSS
      60  HAL_RCCEx_DisablePLL2
      60  HAL_RCCEx_DisablePLL3
      52  HAL_RCCEx_EnableLSCO
      14  HAL_RCCEx_EnableLSECSS
     244  HAL_RCCEx_EnablePLL2
     244  HAL_RCCEx_EnablePLL3
     502  HAL_RCCEx_GetPLL1ClockFreq
     490  HAL_RCCEx_GetPLL2ClockFreq
     480  HAL_RCCEx_GetPLL3ClockFreq
   1'016  HAL_RCCEx_GetPeriphCLKConfig
   5'738  HAL_RCCEx_GetPeriphCLKFreq
      16  HAL_RCCEx_KerWakeUpStopCLKConfig
       2  HAL_RCCEx_LSECSS_Callback
      18  HAL_RCCEx_LSECSS_IRQHandler
   4'378  HAL_RCCEx_PeriphCLKConfig
      16  HAL_RCCEx_WakeUpStopCLKConfig
     210  RCCEx_PLL2_Config
     210  RCCEx_PLL3_Config
     150  RCCEx_PLLSource_Enable
      32  -- Other

 
 14'614 bytes in section .text
 
 14'572 bytes of CODE memory (+ 42 bytes shared)

Errors: none
Warnings: none
