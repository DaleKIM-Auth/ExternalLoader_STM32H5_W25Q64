###############################################################################
#
# IAR ANSI C/C++ Compiler V9.40.1.364/W64 for ARM         23/Nov/2023  21:46:14
# Copyright 1999-2023 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_rcc.c
#    Command line      =
#        -f
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_rcc.o.rsp
#        (C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_rcc.c
#        -D STM32H562xx -lCN
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir
#        -lA
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir
#        -o
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33.no_dsp.no_se -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\CMSIS\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Library\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Loader\
#        -Ol) --dependencies=n
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_rcc.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir\stm32h5xx_hal_rcc.lst
#    Object file       =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_rcc.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32h5xx_hal_rcc.c
      4            * @author  MCD Application Team
      5            * @brief   RCC HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Reset and Clock Control (RCC) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + Peripheral Control functions
     10            *
     11            ******************************************************************************
     12            * @attention
     13            *
     14            * Copyright (c) 2023 STMicroelectronics.
     15            * All rights reserved.
     16            *
     17            * This software is licensed under terms that can be found in the LICENSE file
     18            * in the root directory of this software component.
     19            * If no LICENSE file comes with this software, it is provided AS-IS.
     20            *
     21            ******************************************************************************
     22            @verbatim
     23            ==============================================================================
     24                                ##### RCC specific features #####
     25            ==============================================================================
     26              [..]
     27                After reset the device is running from High Speed Internal oscillator
     28                (64 MHz) with Flash 3 wait states. Flash prefetch buffer, D-Cache
     29                and I-Cache are disabled, and all peripherals are off except internal
     30                SRAM, Flash and JTAG.
     31          
     32                (+) There is no prescaler on High speed (AHBs) and Low speed (APBs) busses:
     33                    all peripherals mapped on these busses are running at HSI speed.
     34                (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
     35                (+) All GPIOs are in analog mode, except the JTAG pins which
     36                    are assigned to be used for debug purpose.
     37          
     38              [..]
     39                Once the device started from reset, the user application has to:
     40                (+) Configure the clock source to be used to drive the System clock
     41                    (if the application needs higher frequency/performance)
     42                (+) Configure the System clock frequency and Flash settings
     43                (+) Configure the AHB and APB busses prescalers
     44                (+) Enable the clock for the peripheral(s) to be used
     45                (+) Configure the clock source(s) for peripherals which clocks are not
     46                    derived from the System clock (SAIx, RTC, ADC, USB, SDMMC, etc.)
     47          
     48            @endverbatim
     49            */
     50          
     51          /* Includes ------------------------------------------------------------------*/
     52          #include "stm32h5xx_hal.h"
     53          
     54          /** @addtogroup STM32H5xx_HAL_Driver
     55            * @{
     56            */
     57          
     58          /** @defgroup RCC RCC
     59            * @brief RCC HAL module driver
     60            * @{
     61            */
     62          
     63          #ifdef HAL_RCC_MODULE_ENABLED
     64          
     65          /* Private typedef -----------------------------------------------------------*/
     66          /* Private define ------------------------------------------------------------*/
     67          /** @defgroup RCC_Private_Constants RCC Private Constants
     68            * @{
     69            */
     70          
     71          /** @defgroup RCC_Timeout_Value Timeout Values
     72            * @{
     73            */
     74          #define RCC_LSI_TIMEOUT_VALUE           ((uint32_t)2U)    /* 2 ms (minimum Tick + 1) */
     75          #define RCC_HSI48_TIMEOUT_VALUE         ((uint32_t)2U)    /* 2 ms (minimum Tick + 1) */
     76          #define RCC_PLL_TIMEOUT_VALUE           ((uint32_t)2U)    /* 2 ms (minimum Tick + 1) */
     77          #define RCC_CLOCKSWITCH_TIMEOUT_VALUE   ((uint32_t)5000U) /* 5 s    */
     78          #define RCC_PLL_FRAC_WAIT_VALUE         1U        /* PLL Fractional part waiting time before new latch enable : 1 ms */
     79          /**
     80            * @}
     81            */
     82          
     83          /**
     84            * @}
     85            */
     86          
     87          /* Private macro -------------------------------------------------------------*/
     88          /** @defgroup RCC_Private_Macros RCC Private Macros
     89            * @{
     90            */
     91          
     92          #define MCO1_CLK_ENABLE()     __HAL_RCC_GPIOA_CLK_ENABLE()
     93          #define MCO1_GPIO_PORT        GPIOA
     94          #define MCO1_PIN              GPIO_PIN_8
     95          
     96          #define MCO2_CLK_ENABLE()      __HAL_RCC_GPIOC_CLK_ENABLE()
     97          #define MCO2_GPIO_PORT         GPIOC
     98          #define MCO2_PIN               GPIO_PIN_9
     99          
    100          /**
    101            * @}
    102            */
    103          
    104          /* Private variables ---------------------------------------------------------*/
    105          
    106          /* Private function prototypes -----------------------------------------------*/
    107          /* Exported functions --------------------------------------------------------*/
    108          
    109          /** @defgroup RCC_Exported_Functions RCC Exported Functions
    110            * @{
    111            */
    112          
    113          /** @defgroup RCC_Exported_Functions_Group1 Initialization and de-initialization functions
    114            *  @brief    Initialization and Configuration functions
    115            *
    116            @verbatim
    117           ===============================================================================
    118                     ##### Initialization and de-initialization functions #####
    119           ===============================================================================
    120              [..]
    121                This section provides functions allowing to configure the internal and external oscillators
    122                (HSE, HSI, LSE, CSI, LSI, PLL1, HSE CSS and MCOs) and the System busses clocks (SYSCLK, AHB, APB1, APB2
    123                 and APB3).
    124          
    125              [..] Internal/external clock and PLL configuration
    126                   (+) HSI (high-speed internal): 64 MHz factory-trimmed RC used directly or through
    127                       the PLL as System clock source.
    128          
    129                   (#) CSI is a low-power RC oscillator which can be used directly as system clock, peripheral
    130                       clock, or PLL input. But even with frequency calibration, is less accurate than an
    131                       external crystal oscillator or ceramic resonator.
    132          
    133                   (+) LSI (low-speed internal): 32 KHz low consumption RC used as IWDG and/or RTC
    134                       clock source.
    135          
    136                   (+) HSE (high-speed external): 4 to 48 MHz crystal oscillator used directly or
    137                       through the PLL as System clock source. Can be used also optionally as RTC clock source.
    138          
    139                   (+) LSE (low-speed external): 32.768 KHz oscillator used optionally as RTC clock source.
    140          
    141                   (+) PLL1 (clocked by HSI, HSE or CSI) providing up to three independent output clocks:
    142                     (++) The first output is used to generate the high speed system clock (up to 250MHz).
    143                     (++) The second output is used to generate the clock for the USB (48 MHz), the FDCAN1/2,
    144                          the SPI1/2/3, the OCTOSPI, the RNG (<=48 MHz), the SDMMC1/2 and to generate an accurate
    145                          clock to achieve high-quality audio performance on SAI1/2 interface.
    146          
    147                   (+) PLL2 (clocked by HSI, HSE or CSI) providing up to three independent output clocks:
    148                     (++) The first output is used to generate the clock for the LPTIMs, the SPI1/2/3 and to generate
    149                          an accurate clock to achieve high-quality audio performance on SAI1/2 interface.
    150                     (++) The second output is used to generate the clock for USARTs, the UARTs, the LPUART1,
    151                          the FDCAN1/2, the SPI4/5/6 and the USB.
    152                     (++) The third output is used to generate the clock the SDMMC1/2, the ADC/DAC, the I2C1/2,
    153                          the I3C1/2 and the OCTOSPI.
    154          
    155                   (+) PLL3 (clocked by HSI , HSE or CSI) providing up to three independent output clocks:
    156                     (++) The first output is used to generate the clock for SPI1/2/3 and to generate an accurate
    157                          clock to achieve high-quality audio performance on SAI1/2 interface.
    158                     (++) The second  output is used to generate the clock for USARTs, the UARTs, the LPUART1,
    159                          the SPI4/5/6 and the USB.
    160                     (++) The third output is used to generate the clock for the I2Cs, the I3Cs and the LPTIMs.
    161          
    162                   (+) HSE CSS (HSE Clock Security System): once enabled, if a HSE clock failure occurs
    163                      (HSE used directly or through PLL1 as System clock source), the System clock
    164                       is automatically switched to HSI and an interrupt is generated if enabled.
    165                       The interrupt is linked to the Cortex-M33 NMI (Non-Maskable Interrupt)
    166                       exception vector.
    167          
    168                   (#) MCO1 (micro controller clock output1), used to output HSI, LSE, HSE, PLL1(PLL1_Q)
    169                       or HSI48 clock (through a configurable pre-scaler) on PA8 pin.
    170          
    171                   (#) MCO2 (micro controller clock output2), used to output HSE, PLL2(PLL2_P), SYSCLK,
    172                       LSI, CSI, or PLL1(PLL1_P) clock (through a configurable pre-scaler) on PC9 pin.
    173          
    174              [..] System, AHB and APB busses clocks configuration
    175                   (+) Several clock sources can be used to drive the System clock (SYSCLK): CSI, HSI, HSE and the main PLL.
    176                       The AHB clock (HCLK) is derived from System clock through configurable
    177                       prescaler and used to clock the CPU, memory and peripherals mapped
    178                       on AHB bus (DMA, GPIO...). APB1 (PCLK1), APB2 (PCLK2) and APB3 (PCLK3) clocks are derived
    179                       from AHB clock through configurable prescalers and used to clock
    180                       the peripherals mapped on these busses. You can use
    181                       "HAL_RCC_GetSysClockFreq()" function to retrieve the frequencies of these clocks.
    182          
    183                   -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
    184          
    185                     (+@) SAI: the SAI clock can be derived either from specific PLL (PLL1, PLL2 or PLL3),
    186                          the per_ck clock (HSE, HSI or CSI) or from an external clock mapped on the SAI_CKIN pin.
    187                          You have to use HAL_RCCEx_PeriphCLKConfig() function to configure this clock.
    188                     (+@) SPI/I2S: the SPI1/2/3 clock can be derived either from specific PLL (PLL1, PLL2 or PLL3),
    189                          the per_ck clock (HSE, HSI or CSI) or from an external clock mapped on the SPI_CKIN pin.
    190                          You have to use HAL_RCCEx_PeriphCLKConfig() function to configure this clock.
    191                     (+@) RTC: the RTC clock can be derived either from the LSI, LSE or HSE clock
    192                          divided by 2 to 31.
    193                          You have to use __HAL_RCC_RTC_ENABLE() and HAL_RCCEx_PeriphCLKConfig() function
    194                          to configure this clock.
    195                     (+@) USB: USB requires a frequency equal to 48 MHz to work correctly. This clock is derived
    196                          of the main PLL or PLL2 through PLLQ divider. You have to use HAL_RCCEx_PeriphCLKConfig()
    197                          function to configure this clock.
    198                     (+@) UCPD: the UCPD clock is derived from HSI (divided by 4) clock.
    199                     (+@) SDMMC: SDMMC1/2 peripherals require a frequency equal or lower than 48 MHz.
    200                          This clock is derived from the PLL1 or PLL2 through PLL1Q or PLL2R divider. You have
    201                          to use HAL_RCCEx_PeriphCLKConfig() function to configure this clock.
    202                     (+@) IWDG clock which is always the LSI clock. You have to use HAL_RCCEx_PeriphCLKConfig()
    203                          function to configure this clock.
    204                     (+@) RNG: the RNG clock can be derived either from PLL1Q, HSI48, LSE or LSI clock. You have
    205                          to use HAL_RCCEx_PeriphCLKConfig() function to configure this clock.
    206                     (+@) DAC: the DAC clock can be derived either from LSE or LSI clock. You have
    207                          to use HAL_RCCEx_PeriphCLKConfig() function to configure this clock.
    208                     (+@) FDCAN: the FDCAN1/2 clock can be derived either from HSE, PLL1Q or PLL2Q clock. You have
    209                          to use HAL_RCCEx_PeriphCLKConfig() function to configure this clock.
    210                     (+@) CEC: the CEC clock can be derived either from LSE, LSI or CSI (divided by 122) clock.You have
    211                          to use HAL_RCCEx_PeriphCLKConfig() function to configure this clock.
    212                     (+@) ETH: the Ethernet clock is derived from PLL1Q clock.
    213          
    214          
    215          
    216                   (+) The maximum frequency of the SYSCLK, HCLK, PCLK1, PCLK2 and PCLK3 is 250 MHz.
    217                       The clock source frequency should be adapted depending on the device voltage range
    218                       as listed in the Reference Manual "Clock source frequency versus voltage scaling" chapter.
    219          
    220            @endverbatim
    221          
    222          
    223                     Table 1. HCLK clock frequency for STM32H5xx devices
    224                     +-----------------------------------------------------------------------------------------------+
    225                     | Latency         |                          HCLK clock frequency (MHz)                         |
    226                     |                 |-----------------------------------------------------------------------------|
    227                     |                 |  voltage range 0  |  voltage range 1 | voltage range 2  | voltage range 3   |
    228                     |                 |    1.26 - 1.35V   |   1.15 - 1.26V   |   1.05 - 1.15V   |   0,95 - 1,05V    |
    229                     |-----------------|-------------------|------------------|------------------|-------------------|
    230                     |0WS(1 CPU cycles)|   0 < HCLK <= 38  |  0 < HCLK <= 32  |  0 < HCLK <= 26  | 0 < HCLK <= 16    |
    231                     |-----------------|-------------------|------------------|------------------|-------------------|
    232                     |1WS(2 CPU cycles)|  38 < HCLK <= 76  | 32 < HCLK <= 64  | 26 < HCLK <= 50  | 16 < HCLK <= 32   |
    233                     |-----------------|-------------------|------------------|------------------|-------------------|
    234                     |2WS(3 CPU cycles)|  76 < HCLK <= 114 | 64 < HCLK <= 96  | 50 < HCLK <= 80  | 32 < HCLK <= 50   |
    235                     |-----------------|-------------------|------------------|------------------|-------------------|
    236                     |3WS(4 CPU cycles)| 114 < HCLK <= 152 | 96 < HCLK <= 128 | 80 < HCLK <= 106 | 50 < HCLK <= 65   |
    237                     |-----------------|-------------------|------------------|------------------|-------------------|
    238                     |4WS(5 CPU cycles)|  152 < HCLK <= 190| 128 < HCLK <= 160| 106 < HCLK <= 130| 65 < HCLK <= 80   |
    239                     |-----------------|-------------------|------------------|------------------|-------------------|
    240                     |5WS(6 CPU cycles)|  190 < HCLK <= 250| 160 < HCLK <= 180|        NA        |         NA        |
    241                     +-----------------+-------------------+------------------+------------------+-------------------+
    242            * @{
    243            */
    244          
    245          /**
    246            * @brief  Reset the RCC clock configuration to the default reset state.
    247            * @note   The default reset state of the clock configuration is given below:
    248            *            - HSI ON and used as system clock source
    249            *            - HSE, CSI, PLL, PLL2 and PLL3 OFF
    250            *            - AHB, APB1 and APB2 prescaler set to 1.
    251            *            - HSECSS, MCO1 and MCO2 OFF
    252            *            - All interrupts disabled
    253            * @note   This function doesn't modify the configuration of the
    254            *            - Peripheral clocks
    255            *            - LSI, LSE and RTC clocks
    256            * @retval HAL Status.
    257            */
    258          

   \                                 In section .text, align 2, keep-with-next
    259          HAL_StatusTypeDef HAL_RCC_DeInit(void)
    260          {
   \                     HAL_RCC_DeInit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    261            uint32_t tickstart;
    262          
    263            /* Increasing the CPU frequency */
    264            if (FLASH_LATENCY_DEFAULT  > __HAL_FLASH_GET_LATENCY())
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable3
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0xF010 0x000F      ANDS     R0,R0,#0xF
   \        0xC   0x2803             CMP      R0,#+3
   \        0xE   0xD20B             BCS.N    ??HAL_RCC_DeInit_0
    265            {
    266              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    267              __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
   \       0x10   0x2003             MOVS     R0,#+3
   \       0x12   0x6821             LDR      R1,[R4, #+0]
   \       0x14   0xF360 0x0103      BFI      R1,R0,#+0,#+4
   \       0x18   0x6021             STR      R1,[R4, #+0]
    268          
    269              /* Check that the new number of wait states is taken into account to access the Flash
    270              memory by reading the FLASH_ACR register */
    271              if (__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x20   0x2803             CMP      R0,#+3
   \       0x22   0xD001             BEQ.N    ??HAL_RCC_DeInit_0
    272              {
    273                return HAL_ERROR;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE0CC             B.N      ??HAL_RCC_DeInit_1
    274              }
    275          
    276            }
    277          
    278            /* Get start tick*/
    279            tickstart = HAL_GetTick();
   \                     ??HAL_RCC_DeInit_0: (+1)
   \       0x28   0x.... 0x....      BL       HAL_GetTick
   \       0x2C   0x0006             MOVS     R6,R0
    280          
    281            /* Set HSION bit */
    282            SET_BIT(RCC->CR, RCC_CR_HSION);
   \       0x2E   0x.... 0x....      LDR.W    R5,??DataTable3_1
   \       0x32   0x6828             LDR      R0,[R5, #+0]
   \       0x34   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x38   0x6028             STR      R0,[R5, #+0]
    283          
    284            /* Wait till HSI is ready */
    285            while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
   \                     ??HAL_RCC_DeInit_2: (+1)
   \       0x3A   0x6828             LDR      R0,[R5, #+0]
   \       0x3C   0x0780             LSLS     R0,R0,#+30
   \       0x3E   0xD406             BMI.N    ??HAL_RCC_DeInit_3
    286            {
    287              if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
   \       0x40   0x.... 0x....      BL       HAL_GetTick
   \       0x44   0x1B80             SUBS     R0,R0,R6
   \       0x46   0x2803             CMP      R0,#+3
   \       0x48   0xD3F7             BCC.N    ??HAL_RCC_DeInit_2
    288              {
    289                return HAL_TIMEOUT;
   \       0x4A   0x2003             MOVS     R0,#+3
   \       0x4C   0xE0B9             B.N      ??HAL_RCC_DeInit_1
    290              }
    291            }
    292          
    293            /* Set HSIDIV Default value */
    294            CLEAR_BIT(RCC->CR, RCC_CR_HSIDIV);
   \                     ??HAL_RCC_DeInit_3: (+1)
   \       0x4E   0x6828             LDR      R0,[R5, #+0]
   \       0x50   0xF030 0x0018      BICS     R0,R0,#0x18
   \       0x54   0x6028             STR      R0,[R5, #+0]
    295          
    296            /* Set HSITRIM default value */
    297            WRITE_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM_6);
   \       0x56   0xF45F 0x0080      MOVS     R0,#+4194304
   \       0x5A   0x.... 0x....      LDR.W    R1,??DataTable3_2
   \       0x5E   0x6008             STR      R0,[R1, #+0]
    298          
    299          
    300            /* Adapt Systick interrupt period */
    301            if (HAL_InitTick(uwTickPrio) != HAL_OK)
   \       0x60   0x.... 0x....      LDR.W    R0,??DataTable3_3
   \       0x64   0x6800             LDR      R0,[R0, #+0]
   \       0x66   0x.... 0x....      BL       HAL_InitTick
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD001             BEQ.N    ??HAL_RCC_DeInit_4
    302            {
    303              return HAL_ERROR;
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0xE0A7             B.N      ??HAL_RCC_DeInit_1
    304            }
    305          
    306            /* Get start tick*/
    307            tickstart = HAL_GetTick();
   \                     ??HAL_RCC_DeInit_4: (+1)
   \       0x72   0x.... 0x....      BL       HAL_GetTick
   \       0x76   0x0006             MOVS     R6,R0
    308          
    309            /* Reset CFGR register (HSI is selected as system clock source) */
    310            CLEAR_REG(RCC->CFGR1);
   \       0x78   0x.... 0x....      LDR.W    R7,??DataTable3_4
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x6038             STR      R0,[R7, #+0]
    311            CLEAR_REG(RCC->CFGR2);
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x.... 0x....      LDR.W    R1,??DataTable3_5
   \       0x86   0x6008             STR      R0,[R1, #+0]
    312          
    313            /* Wait till clock switch is ready */
    314            while (READ_BIT(RCC->CFGR1, RCC_CFGR1_SWS) != 0U)
   \                     ??HAL_RCC_DeInit_5: (+1)
   \       0x88   0x6838             LDR      R0,[R7, #+0]
   \       0x8A   0xF010 0x0F18      TST      R0,#0x18
   \       0x8E   0xD008             BEQ.N    ??HAL_RCC_DeInit_6
    315            {
    316              if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
   \       0x90   0x.... 0x....      BL       HAL_GetTick
   \       0x94   0x1B80             SUBS     R0,R0,R6
   \       0x96   0xF241 0x3189      MOVW     R1,#+5001
   \       0x9A   0x4288             CMP      R0,R1
   \       0x9C   0xD3F4             BCC.N    ??HAL_RCC_DeInit_5
    317              {
    318                return HAL_TIMEOUT;
   \       0x9E   0x2003             MOVS     R0,#+3
   \       0xA0   0xE08F             B.N      ??HAL_RCC_DeInit_1
    319              }
    320            }
    321          
    322            /* Reset HSECSSON, HSEON, HSIKERON, CSION, CSIKERON and HSI48ON bits */
    323            CLEAR_BIT(RCC->CR, RCC_CR_CSION | RCC_CR_CSIKERON | RCC_CR_HSECSSON | RCC_CR_HSIKERON | RCC_CR_HSI48ON | \
    324                      RCC_CR_HSEON);
   \                     ??HAL_RCC_DeInit_6: (+1)
   \       0xA2   0x6829             LDR      R1,[R5, #+0]
   \       0xA4   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \       0xA8   0x4001             ANDS     R1,R0,R1
   \       0xAA   0x6029             STR      R1,[R5, #+0]
    325          
    326            /* Reset HSEEXT bit*/
    327            CLEAR_BIT(RCC->CR, RCC_CR_HSEEXT);
   \       0xAC   0x6828             LDR      R0,[R5, #+0]
   \       0xAE   0xF430 0x1080      BICS     R0,R0,#0x100000
   \       0xB2   0x6028             STR      R0,[R5, #+0]
    328          
    329            /* Get Start Tick */
    330            tickstart = HAL_GetTick();
   \       0xB4   0x.... 0x....      BL       HAL_GetTick
   \       0xB8   0x0006             MOVS     R6,R0
    331          
    332            /* Clear PLL1ON bit */
    333            CLEAR_BIT(RCC->CR, RCC_CR_PLL1ON);
   \       0xBA   0x6828             LDR      R0,[R5, #+0]
   \       0xBC   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \       0xC0   0x6028             STR      R0,[R5, #+0]
    334          
    335            /* Wait till PLL1 is disabled */
    336            while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
   \                     ??HAL_RCC_DeInit_7: (+1)
   \       0xC2   0x6828             LDR      R0,[R5, #+0]
   \       0xC4   0x0180             LSLS     R0,R0,#+6
   \       0xC6   0xD506             BPL.N    ??HAL_RCC_DeInit_8
    337            {
    338              if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
   \       0xC8   0x.... 0x....      BL       HAL_GetTick
   \       0xCC   0x1B80             SUBS     R0,R0,R6
   \       0xCE   0x2803             CMP      R0,#+3
   \       0xD0   0xD3F7             BCC.N    ??HAL_RCC_DeInit_7
    339              {
    340                return HAL_TIMEOUT;
   \       0xD2   0x2003             MOVS     R0,#+3
   \       0xD4   0xE075             B.N      ??HAL_RCC_DeInit_1
    341              }
    342            }
    343          
    344            /* Get Start Tick */
    345            tickstart = HAL_GetTick();
   \                     ??HAL_RCC_DeInit_8: (+1)
   \       0xD6   0x.... 0x....      BL       HAL_GetTick
   \       0xDA   0x0006             MOVS     R6,R0
    346          
    347            /* Reset PLL2N bit */
    348            CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);
   \       0xDC   0x6828             LDR      R0,[R5, #+0]
   \       0xDE   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \       0xE2   0x6028             STR      R0,[R5, #+0]
    349          
    350            /* Wait till PLL2 is disabled */
    351            while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
   \                     ??HAL_RCC_DeInit_9: (+1)
   \       0xE4   0x6828             LDR      R0,[R5, #+0]
   \       0xE6   0x0100             LSLS     R0,R0,#+4
   \       0xE8   0xD506             BPL.N    ??HAL_RCC_DeInit_10
    352            {
    353              if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
   \       0xEA   0x.... 0x....      BL       HAL_GetTick
   \       0xEE   0x1B80             SUBS     R0,R0,R6
   \       0xF0   0x2803             CMP      R0,#+3
   \       0xF2   0xD3F7             BCC.N    ??HAL_RCC_DeInit_9
    354              {
    355                return HAL_TIMEOUT;
   \       0xF4   0x2003             MOVS     R0,#+3
   \       0xF6   0xE064             B.N      ??HAL_RCC_DeInit_1
    356              }
    357            }
    358          
    359          #if defined(RCC_CR_PLL3ON)
    360          
    361            /* Get Start Tick */
    362            tickstart = HAL_GetTick();
   \                     ??HAL_RCC_DeInit_10: (+1)
   \       0xF8   0x.... 0x....      BL       HAL_GetTick
   \       0xFC   0x0006             MOVS     R6,R0
    363          
    364            /* Reset PLL3 bit */
    365            CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);
   \       0xFE   0x6828             LDR      R0,[R5, #+0]
   \      0x100   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \      0x104   0x6028             STR      R0,[R5, #+0]
    366          
    367            /* Wait till PLL3 is disabled */
    368            while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
   \                     ??HAL_RCC_DeInit_11: (+1)
   \      0x106   0x6828             LDR      R0,[R5, #+0]
   \      0x108   0x0080             LSLS     R0,R0,#+2
   \      0x10A   0xD506             BPL.N    ??HAL_RCC_DeInit_12
    369            {
    370              if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
   \      0x10C   0x.... 0x....      BL       HAL_GetTick
   \      0x110   0x1B80             SUBS     R0,R0,R6
   \      0x112   0x2803             CMP      R0,#+3
   \      0x114   0xD3F7             BCC.N    ??HAL_RCC_DeInit_11
    371              {
    372                return HAL_TIMEOUT;
   \      0x116   0x2003             MOVS     R0,#+3
   \      0x118   0xE053             B.N      ??HAL_RCC_DeInit_1
    373              }
    374            }
    375          #endif /* RCC_CR_PLL3ON */
    376          
    377            /* Reset PLL1CFGR register */
    378            CLEAR_REG(RCC->PLL1CFGR);
   \                     ??HAL_RCC_DeInit_12: (+1)
   \      0x11A   0x2000             MOVS     R0,#+0
   \      0x11C   0x.... 0x....      LDR.W    R1,??DataTable3_7
   \      0x120   0x6008             STR      R0,[R1, #+0]
    379          
    380            /* Reset PLL1DIVR register */
    381            WRITE_REG(RCC->PLL1DIVR, 0x01010280U);
   \      0x122   0x.... 0x....      LDR.W    R0,??DataTable3_8
   \      0x126   0x.... 0x....      LDR.W    R1,??DataTable3_9
   \      0x12A   0x6008             STR      R0,[R1, #+0]
    382          
    383            /* Reset PLL1FRACR register */
    384            CLEAR_REG(RCC->PLL1FRACR);
   \      0x12C   0x2100             MOVS     R1,#+0
   \      0x12E   0x.... 0x....      LDR.W    R2,??DataTable3_10
   \      0x132   0x6011             STR      R1,[R2, #+0]
    385          
    386            /* Reset PLL2CFGR register */
    387            CLEAR_REG(RCC->PLL2CFGR);
   \      0x134   0x2100             MOVS     R1,#+0
   \      0x136   0x.... 0x....      LDR.W    R2,??DataTable3_11
   \      0x13A   0x6011             STR      R1,[R2, #+0]
    388          
    389            /* Reset PLL2DIVR register */
    390            WRITE_REG(RCC->PLL2DIVR, 0x01010280U);
   \      0x13C   0x.... 0x....      LDR.W    R1,??DataTable3_12
   \      0x140   0x6008             STR      R0,[R1, #+0]
    391          
    392            /* Reset PLL2FRACR register */
    393            CLEAR_REG(RCC->PLL2FRACR);
   \      0x142   0x2100             MOVS     R1,#+0
   \      0x144   0x.... 0x....      LDR.W    R2,??DataTable3_13
   \      0x148   0x6011             STR      R1,[R2, #+0]
    394          
    395          #if defined(RCC_CR_PLL3ON)
    396            /* Reset PLL3CFGR register */
    397            CLEAR_REG(RCC->PLL3CFGR);
   \      0x14A   0x2100             MOVS     R1,#+0
   \      0x14C   0x.... 0x....      LDR.W    R2,??DataTable3_14
   \      0x150   0x6011             STR      R1,[R2, #+0]
    398          
    399            /* Reset PLL3DIVR register */
    400            WRITE_REG(RCC->PLL3DIVR, 0x01010280U);
   \      0x152   0x.... 0x....      LDR.W    R1,??DataTable3_15
   \      0x156   0x6008             STR      R0,[R1, #+0]
    401          
    402            /* Reset PLL3FRACR register */
    403            CLEAR_REG(RCC->PLL3FRACR);
   \      0x158   0x2000             MOVS     R0,#+0
   \      0x15A   0x.... 0x....      LDR.W    R1,??DataTable3_16
   \      0x15E   0x6008             STR      R0,[R1, #+0]
    404          #endif /* RCC_CR_PLL3ON */
    405          
    406            /* Reset HSEBYP bit */
    407            CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
   \      0x160   0x6828             LDR      R0,[R5, #+0]
   \      0x162   0xF430 0x2080      BICS     R0,R0,#0x40000
   \      0x166   0x6028             STR      R0,[R5, #+0]
    408          
    409            /* Disable all interrupts */
    410            CLEAR_REG(RCC->CIER);
   \      0x168   0x2000             MOVS     R0,#+0
   \      0x16A   0x.... 0x....      LDR.W    R1,??DataTable3_17
   \      0x16E   0x6008             STR      R0,[R1, #+0]
    411          
    412            /* Clear all interrupts flags */
    413            WRITE_REG(RCC->CICR, 0xFFFFFFFFU);
   \      0x170   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x174   0x.... 0x....      LDR.W    R1,??DataTable4
   \      0x178   0x6008             STR      R0,[R1, #+0]
    414          
    415            /* Reset all RSR flags */
    416            SET_BIT(RCC->RSR, RCC_RSR_RMVF);
   \      0x17A   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \      0x17E   0x6801             LDR      R1,[R0, #+0]
   \      0x180   0xF451 0x0100      ORRS     R1,R1,#0x800000
   \      0x184   0x6001             STR      R1,[R0, #+0]
    417          
    418            /* Update the SystemCoreClock global variable */
    419            SystemCoreClock = HSI_VALUE;
   \      0x186   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \      0x18A   0x.... 0x....      LDR.W    R1,??DataTable8
   \      0x18E   0x6008             STR      R0,[R1, #+0]
    420          
    421            /* Decreasing the number of wait states because of lower CPU frequency */
    422            if (FLASH_LATENCY_DEFAULT  < __HAL_FLASH_GET_LATENCY())
   \      0x190   0x6820             LDR      R0,[R4, #+0]
   \      0x192   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x196   0x2804             CMP      R0,#+4
   \      0x198   0xD30B             BCC.N    ??HAL_RCC_DeInit_13
    423            {
    424              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    425              __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
   \      0x19A   0x2003             MOVS     R0,#+3
   \      0x19C   0x6821             LDR      R1,[R4, #+0]
   \      0x19E   0xF360 0x0103      BFI      R1,R0,#+0,#+4
   \      0x1A2   0x6021             STR      R1,[R4, #+0]
    426          
    427              /* Check that the new number of wait states is taken into account to access the Flash
    428              memory by reading the FLASH_ACR register */
    429              if (__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
   \      0x1A4   0x6820             LDR      R0,[R4, #+0]
   \      0x1A6   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x1AA   0x2803             CMP      R0,#+3
   \      0x1AC   0xD001             BEQ.N    ??HAL_RCC_DeInit_13
    430              {
    431                return HAL_ERROR;
   \      0x1AE   0x2001             MOVS     R0,#+1
   \      0x1B0   0xE007             B.N      ??HAL_RCC_DeInit_1
    432              }
    433            }
    434          
    435            /* Adapt Systick interrupt period */
    436            if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
   \                     ??HAL_RCC_DeInit_13: (+1)
   \      0x1B2   0x200F             MOVS     R0,#+15
   \      0x1B4   0x.... 0x....      BL       HAL_InitTick
   \      0x1B8   0x2800             CMP      R0,#+0
   \      0x1BA   0xD001             BEQ.N    ??HAL_RCC_DeInit_14
    437            {
    438              return HAL_ERROR;
   \      0x1BC   0x2001             MOVS     R0,#+1
   \      0x1BE   0xE000             B.N      ??HAL_RCC_DeInit_1
    439            }
    440            else
    441            {
    442              return HAL_OK;
   \                     ??HAL_RCC_DeInit_14: (+1)
   \      0x1C0   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_DeInit_1: (+1)
   \      0x1C2   0xBDF2             POP      {R1,R4-R7,PC}
    443            }
    444          }
    445          
    446          /**
    447            * @brief  Initialize the RCC Oscillators according to the specified parameters in the
    448            *         RCC_OscInitTypeDef.
    449            * @param  pOscInitStruct pointer to an RCC_OscInitTypeDef structure that
    450            *         contains the configuration information for the RCC Oscillators.
    451            * @note   The PLL is not disabled when used as system clock.
    452            * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not
    453            *         supported by this macro. User should request a transition to LSE Off
    454            *         first and then LSE On or LSE Bypass.
    455            * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not
    456            *         supported by this macro. User should request a transition to HSE Off
    457            *         first and then HSE On or HSE Bypass.
    458            * @retval HAL status
    459            */

   \                                 In section .text, align 2, keep-with-next
    460          HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pOscInitStruct)
    461          {
   \                     HAL_RCC_OscConfig: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
    462            uint32_t tickstart;
    463            uint32_t temp_sysclksrc;
    464            uint32_t temp_pllckselr;
    465            uint32_t temp1_pllckcfg;
    466            uint32_t temp2_pllckcfg;
    467          
    468            /* Check Null pointer */
    469            if (pOscInitStruct == NULL)
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD101             BNE.N    ??HAL_RCC_OscConfig_0
    470            {
    471              return HAL_ERROR;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE31D             B.N      ??HAL_RCC_OscConfig_1
    472            }
    473          
    474            /* Check the parameters */
    475            assert_param(IS_RCC_OSCILLATORTYPE(pOscInitStruct->OscillatorType));
    476            temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
   \                     ??HAL_RCC_OscConfig_0: (+1)
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \       0x12   0x6804             LDR      R4,[R0, #+0]
   \       0x14   0xF014 0x0418      ANDS     R4,R4,#0x18
    477            temp_pllckselr = __HAL_RCC_GET_PLL1_OSCSOURCE();
   \       0x18   0x.... 0x....      LDR.W    R6,??DataTable3_7
   \       0x1C   0x6837             LDR      R7,[R6, #+0]
   \       0x1E   0xF017 0x0703      ANDS     R7,R7,#0x3
    478          
    479            /*----------------------------- CSI Configuration --------------------------*/
    480            if (((pOscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
   \       0x22   0x7828             LDRB     R0,[R5, #+0]
   \       0x24   0x06C0             LSLS     R0,R0,#+27
   \       0x26   0xD513             BPL.N    ??HAL_RCC_OscConfig_2
    481            {
    482              /* Check the parameters */
    483              assert_param(IS_RCC_CSI(pOscInitStruct->CSIState));
    484              assert_param(IS_RCC_CSICALIBRATION_VALUE(pOscInitStruct->CSICalibrationValue));
    485          
    486              /* When the CSI is used as system clock it will not be disabled */
    487              if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_CSI) ||
    488                  ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_pllckselr == RCC_PLL1_SOURCE_CSI)))
   \       0x28   0x2C08             CMP      R4,#+8
   \       0x2A   0xD003             BEQ.N    ??HAL_RCC_OscConfig_3
   \       0x2C   0x2C18             CMP      R4,#+24
   \       0x2E   0xD11F             BNE.N    ??HAL_RCC_OscConfig_4
   \       0x30   0x2F02             CMP      R7,#+2
   \       0x32   0xD11D             BNE.N    ??HAL_RCC_OscConfig_4
    489              {
    490                if (pOscInitStruct->CSIState == RCC_CSI_OFF)
   \                     ??HAL_RCC_OscConfig_3: (+1)
   \       0x34   0x69E8             LDR      R0,[R5, #+28]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD101             BNE.N    ??HAL_RCC_OscConfig_5
    491                {
    492                  return HAL_ERROR;
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xE305             B.N      ??HAL_RCC_OscConfig_1
    493                }
    494          
    495                /* Otherwise, just the calibration and CSI is allowed */
    496                else
    497                {
    498                  /* Adjusts the Internal Low-power oscillator (CSI) calibration value.*/
    499                  __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(pOscInitStruct->CSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_5: (+1)
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \       0x42   0x6801             LDR      R1,[R0, #+0]
   \       0x44   0xF431 0x117C      BICS     R1,R1,#0x3F0000
   \       0x48   0x6A2A             LDR      R2,[R5, #+32]
   \       0x4A   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \       0x4E   0x6001             STR      R1,[R0, #+0]
    500                }
    501              }
    502              else
    503              {
    504                /* Check the CSI State */
    505                if ((pOscInitStruct->CSIState) != RCC_CSI_OFF)
    506                {
    507                  /* Enable the Internal High Speed oscillator (CSI). */
    508                  __HAL_RCC_CSI_ENABLE();
    509          
    510                  /* Get Start Tick*/
    511                  tickstart = HAL_GetTick();
    512          
    513                  /* Wait till CSI is ready */
    514                  while (READ_BIT(RCC->CR, RCC_CR_CSIRDY) == 0U)
    515                  {
    516                    if ((HAL_GetTick() - tickstart) > RCC_CSI_TIMEOUT_VALUE)
    517                    {
    518                      return HAL_TIMEOUT;
    519                    }
    520                  }
    521          
    522                  /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
    523                  __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(pOscInitStruct->CSICalibrationValue);
    524                }
    525                else
    526                {
    527                  /* Disable the Internal High Speed oscillator (CSI). */
    528                  __HAL_RCC_CSI_DISABLE();
    529          
    530                  /* Get Start Tick*/
    531                  tickstart = HAL_GetTick();
    532          
    533                  /* Wait till CSI is disabled */
    534                  while (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
    535                  {
    536                    if ((HAL_GetTick() - tickstart) > RCC_CSI_TIMEOUT_VALUE)
    537                    {
    538                      return HAL_TIMEOUT;
    539                    }
    540                  }
    541                }
    542              }
    543            }
    544            /*------------------------------- HSE Configuration ------------------------*/
    545            if (((pOscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   \                     ??HAL_RCC_OscConfig_2: (+1)
   \       0x50   0x7828             LDRB     R0,[R5, #+0]
   \       0x52   0x07C0             LSLS     R0,R0,#+31
   \       0x54   0xF140 0x80BB      BPL.W    ??HAL_RCC_OscConfig_6
    546            {
    547              /* Check the parameters */
    548              assert_param(IS_RCC_HSE(pOscInitStruct->HSEState));
    549          
    550              /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    551              if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
    552                  ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_pllckselr == RCC_PLL1_SOURCE_HSE)))
   \       0x58   0x2C10             CMP      R4,#+16
   \       0x5A   0xD003             BEQ.N    ??HAL_RCC_OscConfig_7
   \       0x5C   0x2C18             CMP      R4,#+24
   \       0x5E   0xD142             BNE.N    ??HAL_RCC_OscConfig_8
   \       0x60   0x2F03             CMP      R7,#+3
   \       0x62   0xD140             BNE.N    ??HAL_RCC_OscConfig_8
    553              {
    554                if (pOscInitStruct->HSEState == RCC_HSE_OFF)
   \                     ??HAL_RCC_OscConfig_7: (+1)
   \       0x64   0x6868             LDR      R0,[R5, #+4]
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xF040 0x80B1      BNE.W    ??HAL_RCC_OscConfig_6
    555                {
    556                  return HAL_ERROR;
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xE2EC             B.N      ??HAL_RCC_OscConfig_1
    557                }
    558              }
   \                     ??HAL_RCC_OscConfig_4: (+1)
   \       0x70   0x69E8             LDR      R0,[R5, #+28]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD020             BEQ.N    ??HAL_RCC_OscConfig_9
   \       0x76   0x.... 0x....      LDR.W    R8,??DataTable3_1
   \       0x7A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x7E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x82   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \       0x86   0x.... 0x....      BL       HAL_GetTick
   \       0x8A   0x4681             MOV      R9,R0
   \                     ??HAL_RCC_OscConfig_10: (+1)
   \       0x8C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x90   0x0580             LSLS     R0,R0,#+22
   \       0x92   0xD407             BMI.N    ??HAL_RCC_OscConfig_11
   \       0x94   0x.... 0x....      BL       HAL_GetTick
   \       0x98   0xEBB0 0x0009      SUBS     R0,R0,R9
   \       0x9C   0x2803             CMP      R0,#+3
   \       0x9E   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_10
   \       0xA0   0x2003             MOVS     R0,#+3
   \       0xA2   0xE2D2             B.N      ??HAL_RCC_OscConfig_1
   \                     ??HAL_RCC_OscConfig_11: (+1)
   \       0xA4   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \       0xA8   0x6801             LDR      R1,[R0, #+0]
   \       0xAA   0xF431 0x117C      BICS     R1,R1,#0x3F0000
   \       0xAE   0x6A2A             LDR      R2,[R5, #+32]
   \       0xB0   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \       0xB4   0x6001             STR      R1,[R0, #+0]
   \       0xB6   0xE7CB             B.N      ??HAL_RCC_OscConfig_2
   \                     ??HAL_RCC_OscConfig_9: (+1)
   \       0xB8   0x.... 0x....      LDR.W    R8,??DataTable3_1
   \       0xBC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xC0   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0xC4   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \       0xC8   0x.... 0x....      BL       HAL_GetTick
   \       0xCC   0x4681             MOV      R9,R0
   \                     ??HAL_RCC_OscConfig_12: (+1)
   \       0xCE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xD2   0x0580             LSLS     R0,R0,#+22
   \       0xD4   0xD5BC             BPL.N    ??HAL_RCC_OscConfig_2
   \       0xD6   0x.... 0x....      BL       HAL_GetTick
   \       0xDA   0xEBB0 0x0009      SUBS     R0,R0,R9
   \       0xDE   0x2803             CMP      R0,#+3
   \       0xE0   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_12
   \       0xE2   0x2003             MOVS     R0,#+3
   \       0xE4   0xE2B1             B.N      ??HAL_RCC_OscConfig_1
    559              else
    560              {
    561                /* Set the new HSE configuration ---------------------------------------*/
    562                __HAL_RCC_HSE_CONFIG(pOscInitStruct->HSEState);
   \                     ??HAL_RCC_OscConfig_8: (+1)
   \       0xE6   0x6868             LDR      R0,[R5, #+4]
   \       0xE8   0xF5B0 0x3F80      CMP      R0,#+65536
   \       0xEC   0xD106             BNE.N    ??HAL_RCC_OscConfig_13
   \       0xEE   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \       0xF2   0x6801             LDR      R1,[R0, #+0]
   \       0xF4   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \       0xF8   0x6001             STR      R1,[R0, #+0]
   \       0xFA   0xE045             B.N      ??HAL_RCC_OscConfig_14
   \                     ??HAL_RCC_OscConfig_13: (+1)
   \       0xFC   0x6868             LDR      R0,[R5, #+4]
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD10E             BNE.N    ??HAL_RCC_OscConfig_15
   \      0x102   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \      0x106   0x6801             LDR      R1,[R0, #+0]
   \      0x108   0xF431 0x3180      BICS     R1,R1,#0x10000
   \      0x10C   0x6001             STR      R1,[R0, #+0]
   \      0x10E   0x6801             LDR      R1,[R0, #+0]
   \      0x110   0xF431 0x1180      BICS     R1,R1,#0x100000
   \      0x114   0x6001             STR      R1,[R0, #+0]
   \      0x116   0x6801             LDR      R1,[R0, #+0]
   \      0x118   0xF431 0x2180      BICS     R1,R1,#0x40000
   \      0x11C   0x6001             STR      R1,[R0, #+0]
   \      0x11E   0xE033             B.N      ??HAL_RCC_OscConfig_14
   \                     ??HAL_RCC_OscConfig_15: (+1)
   \      0x120   0x6868             LDR      R0,[R5, #+4]
   \      0x122   0xF5B0 0x2FA0      CMP      R0,#+327680
   \      0x126   0xD10E             BNE.N    ??HAL_RCC_OscConfig_16
   \      0x128   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \      0x12C   0x6801             LDR      R1,[R0, #+0]
   \      0x12E   0xF451 0x2180      ORRS     R1,R1,#0x40000
   \      0x132   0x6001             STR      R1,[R0, #+0]
   \      0x134   0x6801             LDR      R1,[R0, #+0]
   \      0x136   0xF431 0x1180      BICS     R1,R1,#0x100000
   \      0x13A   0x6001             STR      R1,[R0, #+0]
   \      0x13C   0x6801             LDR      R1,[R0, #+0]
   \      0x13E   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \      0x142   0x6001             STR      R1,[R0, #+0]
   \      0x144   0xE020             B.N      ??HAL_RCC_OscConfig_14
   \                     ??HAL_RCC_OscConfig_16: (+1)
   \      0x146   0x6868             LDR      R0,[R5, #+4]
   \      0x148   0xF5B0 0x1FA8      CMP      R0,#+1376256
   \      0x14C   0xD10E             BNE.N    ??HAL_RCC_OscConfig_17
   \      0x14E   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \      0x152   0x6801             LDR      R1,[R0, #+0]
   \      0x154   0xF451 0x2180      ORRS     R1,R1,#0x40000
   \      0x158   0x6001             STR      R1,[R0, #+0]
   \      0x15A   0x6801             LDR      R1,[R0, #+0]
   \      0x15C   0xF451 0x1180      ORRS     R1,R1,#0x100000
   \      0x160   0x6001             STR      R1,[R0, #+0]
   \      0x162   0x6801             LDR      R1,[R0, #+0]
   \      0x164   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \      0x168   0x6001             STR      R1,[R0, #+0]
   \      0x16A   0xE00D             B.N      ??HAL_RCC_OscConfig_14
   \                     ??HAL_RCC_OscConfig_17: (+1)
   \      0x16C   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \      0x170   0x6801             LDR      R1,[R0, #+0]
   \      0x172   0xF431 0x3180      BICS     R1,R1,#0x10000
   \      0x176   0x6001             STR      R1,[R0, #+0]
   \      0x178   0x6801             LDR      R1,[R0, #+0]
   \      0x17A   0xF431 0x2180      BICS     R1,R1,#0x40000
   \      0x17E   0x6001             STR      R1,[R0, #+0]
   \      0x180   0x6801             LDR      R1,[R0, #+0]
   \      0x182   0xF431 0x1180      BICS     R1,R1,#0x100000
   \      0x186   0x6001             STR      R1,[R0, #+0]
    563          
    564                /* Check the HSE State */
    565                if (pOscInitStruct->HSEState != RCC_HSE_OFF)
   \                     ??HAL_RCC_OscConfig_14: (+1)
   \      0x188   0x6868             LDR      R0,[R5, #+4]
   \      0x18A   0x2800             CMP      R0,#+0
   \      0x18C   0xD00F             BEQ.N    ??HAL_RCC_OscConfig_18
    566                {
    567                  /* Get Start Tick*/
    568                  tickstart = HAL_GetTick();
   \      0x18E   0x.... 0x....      BL       HAL_GetTick
   \      0x192   0x4680             MOV      R8,R0
    569          
    570                  /* Wait till HSE is ready */
    571                  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
   \                     ??HAL_RCC_OscConfig_19: (+1)
   \      0x194   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \      0x198   0x6800             LDR      R0,[R0, #+0]
   \      0x19A   0x0380             LSLS     R0,R0,#+14
   \      0x19C   0xD417             BMI.N    ??HAL_RCC_OscConfig_6
    572                  {
    573                    if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
   \      0x19E   0x.... 0x....      BL       HAL_GetTick
   \      0x1A2   0xEBB0 0x0008      SUBS     R0,R0,R8
   \      0x1A6   0x2865             CMP      R0,#+101
   \      0x1A8   0xD3F4             BCC.N    ??HAL_RCC_OscConfig_19
    574                    {
    575                      return HAL_TIMEOUT;
   \      0x1AA   0x2003             MOVS     R0,#+3
   \      0x1AC   0xE24D             B.N      ??HAL_RCC_OscConfig_1
    576                    }
    577                  }
    578                }
    579                else
    580                {
    581                  /* Get Start Tick*/
    582                  tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_18: (+1)
   \      0x1AE   0x.... 0x....      BL       HAL_GetTick
   \      0x1B2   0x4680             MOV      R8,R0
    583          
    584                  /* Wait till HSE is disabled */
    585                  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
   \                     ??HAL_RCC_OscConfig_20: (+1)
   \      0x1B4   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \      0x1B8   0x6800             LDR      R0,[R0, #+0]
   \      0x1BA   0x0380             LSLS     R0,R0,#+14
   \      0x1BC   0xD507             BPL.N    ??HAL_RCC_OscConfig_6
    586                  {
    587                    if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
   \      0x1BE   0x.... 0x....      BL       HAL_GetTick
   \      0x1C2   0xEBB0 0x0008      SUBS     R0,R0,R8
   \      0x1C6   0x2865             CMP      R0,#+101
   \      0x1C8   0xD3F4             BCC.N    ??HAL_RCC_OscConfig_20
    588                    {
    589                      return HAL_TIMEOUT;
   \      0x1CA   0x2003             MOVS     R0,#+3
   \      0x1CC   0xE23D             B.N      ??HAL_RCC_OscConfig_1
    590                    }
    591                  }
    592                }
    593              }
    594            }
    595            /*----------------------------- HSI Configuration --------------------------*/
    596            if (((pOscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   \                     ??HAL_RCC_OscConfig_6: (+1)
   \      0x1CE   0x7828             LDRB     R0,[R5, #+0]
   \      0x1D0   0x0780             LSLS     R0,R0,#+30
   \      0x1D2   0xD53D             BPL.N    ??HAL_RCC_OscConfig_21
    597            {
    598              /* Check the parameters */
    599              assert_param(IS_RCC_HSI(pOscInitStruct->HSIState));
    600              assert_param(IS_RCC_HSIDIV(pOscInitStruct->HSIDiv));
    601              assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pOscInitStruct->HSICalibrationValue));
    602          
    603              /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    604              if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
    605                  ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_pllckselr == RCC_PLL1_SOURCE_HSI)))
   \      0x1D4   0x2C00             CMP      R4,#+0
   \      0x1D6   0xD003             BEQ.N    ??HAL_RCC_OscConfig_22
   \      0x1D8   0x2C18             CMP      R4,#+24
   \      0x1DA   0xD155             BNE.N    ??HAL_RCC_OscConfig_23
   \      0x1DC   0x2F01             CMP      R7,#+1
   \      0x1DE   0xD153             BNE.N    ??HAL_RCC_OscConfig_23
    606              {
    607                /* When HSI is used as system clock it will not be disabled */
    608                if (pOscInitStruct->HSIState == RCC_HSI_OFF)
   \                     ??HAL_RCC_OscConfig_22: (+1)
   \      0x1E0   0x68E8             LDR      R0,[R5, #+12]
   \      0x1E2   0x2800             CMP      R0,#+0
   \      0x1E4   0xD101             BNE.N    ??HAL_RCC_OscConfig_24
    609                {
    610                  return HAL_ERROR;
   \      0x1E6   0x2001             MOVS     R0,#+1
   \      0x1E8   0xE22F             B.N      ??HAL_RCC_OscConfig_1
    611                }
    612                /* Otherwise, HSI calibration and division may be allowed */
    613                else
    614                {
    615          
    616                  /* HSI division is allowed if HSI is used as system clock */
    617                  if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI)
   \                     ??HAL_RCC_OscConfig_24: (+1)
   \      0x1EA   0x2C00             CMP      R4,#+0
   \      0x1EC   0xD118             BNE.N    ??HAL_RCC_OscConfig_25
    618                  {
    619                    if (__HAL_RCC_GET_HSI_DIVIDER() != (pOscInitStruct->HSIDiv))
   \      0x1EE   0x.... 0x....      LDR.W    R1,??DataTable3_1
   \      0x1F2   0x6808             LDR      R0,[R1, #+0]
   \      0x1F4   0xF010 0x0018      ANDS     R0,R0,#0x18
   \      0x1F8   0x692A             LDR      R2,[R5, #+16]
   \      0x1FA   0x4290             CMP      R0,R2
   \      0x1FC   0xD010             BEQ.N    ??HAL_RCC_OscConfig_25
    620                    {
    621                      /* Adjust the HSI division factor */
    622                      __HAL_RCC_HSI_DIVIDER_CONFIG(pOscInitStruct->HSIDiv);
   \      0x1FE   0x680A             LDR      R2,[R1, #+0]
   \      0x200   0xF032 0x0218      BICS     R2,R2,#0x18
   \      0x204   0x6928             LDR      R0,[R5, #+16]
   \      0x206   0x4302             ORRS     R2,R0,R2
   \      0x208   0x600A             STR      R2,[R1, #+0]
    623          
    624                      /* Update the SystemCoreClock global variable with new HSI value  */
    625                      (void) HAL_RCC_GetHCLKFreq();
   \      0x20A   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
    626          
    627                      /* Configure the source of time base considering new system clocks settings*/
    628                      if (HAL_InitTick(uwTickPrio) != HAL_OK)
   \      0x20E   0x.... 0x....      LDR.W    R0,??DataTable3_3
   \      0x212   0x6800             LDR      R0,[R0, #+0]
   \      0x214   0x.... 0x....      BL       HAL_InitTick
   \      0x218   0x2800             CMP      R0,#+0
   \      0x21A   0xD001             BEQ.N    ??HAL_RCC_OscConfig_25
    629                      {
    630                        return HAL_ERROR;
   \      0x21C   0x2001             MOVS     R0,#+1
   \      0x21E   0xE214             B.N      ??HAL_RCC_OscConfig_1
    631                      }
    632                    }
    633                  }
    634          
    635                  /* Get Start Tick*/
    636                  tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_25: (+1)
   \      0x220   0x.... 0x....      BL       HAL_GetTick
   \      0x224   0x0007             MOVS     R7,R0
    637          
    638                  /* Wait till HSI is ready */
    639                  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
   \                     ??HAL_RCC_OscConfig_26: (+1)
   \      0x226   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \      0x22A   0x6800             LDR      R0,[R0, #+0]
   \      0x22C   0x0780             LSLS     R0,R0,#+30
   \      0x22E   0xD406             BMI.N    ??HAL_RCC_OscConfig_27
    640                  {
    641                    if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
   \      0x230   0x.... 0x....      BL       HAL_GetTick
   \      0x234   0x1BC0             SUBS     R0,R0,R7
   \      0x236   0x2803             CMP      R0,#+3
   \      0x238   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_26
    642                    {
    643                      return HAL_TIMEOUT;
   \      0x23A   0x2003             MOVS     R0,#+3
   \      0x23C   0xE205             B.N      ??HAL_RCC_OscConfig_1
    644                    }
    645                  }
    646                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    647                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pOscInitStruct->HSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_27: (+1)
   \      0x23E   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \      0x242   0x6801             LDR      R1,[R0, #+0]
   \      0x244   0xF431 0x01FE      BICS     R1,R1,#0x7F0000
   \      0x248   0x696A             LDR      R2,[R5, #+20]
   \      0x24A   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \      0x24E   0x6001             STR      R1,[R0, #+0]
    648                }
    649              }
    650              else
    651              {
    652                /* Check the HSI State */
    653                if (pOscInitStruct->HSIState != RCC_HSI_OFF)
    654                {
    655                  /* Adjust the HSI division factor */
    656                  __HAL_RCC_HSI_DIVIDER_CONFIG(pOscInitStruct->HSIDiv);
    657          
    658                  /* Enable the HSI oscillator */
    659                  __HAL_RCC_HSI_ENABLE();
    660          
    661                  /* Get Start Tick*/
    662                  tickstart = HAL_GetTick();
    663          
    664                  /* Wait till HSI is ready */
    665                  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
    666                  {
    667                    if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
    668                    {
    669                      return HAL_TIMEOUT;
    670                    }
    671                  }
    672          
    673                  /* Adjust the Internal High Speed oscillator (HSI) calibration value.*/
    674                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pOscInitStruct->HSICalibrationValue);
    675                }
    676                else
    677                {
    678                  /* Disable the Internal High Speed oscillator (HSI). */
    679                  __HAL_RCC_HSI_DISABLE();
    680          
    681                  /* Get Start Tick*/
    682                  tickstart = HAL_GetTick();
    683          
    684                  /* Wait till HSI is disabled */
    685                  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
    686                  {
    687                    if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
    688                    {
    689                      return HAL_TIMEOUT;
    690                    }
    691                  }
    692                }
    693              }
    694            }
    695            /*------------------------------ LSI Configuration -------------------------*/
    696            if (((pOscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
   \                     ??HAL_RCC_OscConfig_21: (+1)
   \      0x250   0x7828             LDRB     R0,[R5, #+0]
   \      0x252   0x0700             LSLS     R0,R0,#+28
   \      0x254   0xD56B             BPL.N    ??HAL_RCC_OscConfig_28
    697            {
    698          
    699              /* Check the parameters */
    700              assert_param(IS_RCC_LSI(pOscInitStruct->LSIState));
    701          
    702              /* Update LSI configuration in Backup Domain control register    */
    703          
    704              /* Check the LSI State */
    705              if (pOscInitStruct->LSIState != RCC_LSI_OFF)
   \      0x256   0x69A8             LDR      R0,[R5, #+24]
   \      0x258   0x2800             CMP      R0,#+0
   \      0x25A   0xD052             BEQ.N    ??HAL_RCC_OscConfig_29
    706              {
    707                /* Enable the Internal Low Speed oscillator (LSI). */
    708                __HAL_RCC_LSI_ENABLE();
   \      0x25C   0x.... 0x....      LDR.W    R8,??DataTable15_1
   \      0x260   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x264   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \      0x268   0xF8C8 0x0000      STR      R0,[R8, #+0]
    709          
    710                /* Get Start Tick*/
    711                tickstart = HAL_GetTick();
   \      0x26C   0x.... 0x....      BL       HAL_GetTick
   \      0x270   0x0007             MOVS     R7,R0
    712          
    713                /* Wait till LSI is ready */
    714                while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) == 0U)
   \                     ??HAL_RCC_OscConfig_30: (+1)
   \      0x272   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x276   0x0100             LSLS     R0,R0,#+4
   \      0x278   0xD459             BMI.N    ??HAL_RCC_OscConfig_28
    715                {
    716                  if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
   \      0x27A   0x.... 0x....      BL       HAL_GetTick
   \      0x27E   0x1BC0             SUBS     R0,R0,R7
   \      0x280   0x2803             CMP      R0,#+3
   \      0x282   0xD3F6             BCC.N    ??HAL_RCC_OscConfig_30
    717                  {
    718                    return HAL_TIMEOUT;
   \      0x284   0x2003             MOVS     R0,#+3
   \      0x286   0xE1E0             B.N      ??HAL_RCC_OscConfig_1
    719                  }
    720                }
    721              }
   \                     ??HAL_RCC_OscConfig_23: (+1)
   \      0x288   0x68E8             LDR      R0,[R5, #+12]
   \      0x28A   0x2800             CMP      R0,#+0
   \      0x28C   0xD023             BEQ.N    ??HAL_RCC_OscConfig_31
   \      0x28E   0x.... 0x....      LDR.W    R7,??DataTable3_1
   \      0x292   0x6839             LDR      R1,[R7, #+0]
   \      0x294   0xF031 0x0118      BICS     R1,R1,#0x18
   \      0x298   0x6928             LDR      R0,[R5, #+16]
   \      0x29A   0x4301             ORRS     R1,R0,R1
   \      0x29C   0x6039             STR      R1,[R7, #+0]
   \      0x29E   0x6838             LDR      R0,[R7, #+0]
   \      0x2A0   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x2A4   0x6038             STR      R0,[R7, #+0]
   \      0x2A6   0x.... 0x....      BL       HAL_GetTick
   \      0x2AA   0x4680             MOV      R8,R0
   \                     ??HAL_RCC_OscConfig_32: (+1)
   \      0x2AC   0x6838             LDR      R0,[R7, #+0]
   \      0x2AE   0x0780             LSLS     R0,R0,#+30
   \      0x2B0   0xD407             BMI.N    ??HAL_RCC_OscConfig_33
   \      0x2B2   0x.... 0x....      BL       HAL_GetTick
   \      0x2B6   0xEBB0 0x0008      SUBS     R0,R0,R8
   \      0x2BA   0x2803             CMP      R0,#+3
   \      0x2BC   0xD3F6             BCC.N    ??HAL_RCC_OscConfig_32
   \      0x2BE   0x2003             MOVS     R0,#+3
   \      0x2C0   0xE1C3             B.N      ??HAL_RCC_OscConfig_1
   \                     ??HAL_RCC_OscConfig_33: (+1)
   \      0x2C2   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \      0x2C6   0x6801             LDR      R1,[R0, #+0]
   \      0x2C8   0xF431 0x01FE      BICS     R1,R1,#0x7F0000
   \      0x2CC   0x696A             LDR      R2,[R5, #+20]
   \      0x2CE   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \      0x2D2   0x6001             STR      R1,[R0, #+0]
   \      0x2D4   0xE7BC             B.N      ??HAL_RCC_OscConfig_21
   \                     ??HAL_RCC_OscConfig_31: (+1)
   \      0x2D6   0x.... 0x....      LDR.W    R8,??DataTable3_1
   \      0x2DA   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x2DE   0x0840             LSRS     R0,R0,#+1
   \      0x2E0   0x0040             LSLS     R0,R0,#+1
   \      0x2E2   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \      0x2E6   0x.... 0x....      BL       HAL_GetTick
   \      0x2EA   0x0007             MOVS     R7,R0
   \                     ??HAL_RCC_OscConfig_34: (+1)
   \      0x2EC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x2F0   0x0780             LSLS     R0,R0,#+30
   \      0x2F2   0xD5AD             BPL.N    ??HAL_RCC_OscConfig_21
   \      0x2F4   0x.... 0x....      BL       HAL_GetTick
   \      0x2F8   0x1BC0             SUBS     R0,R0,R7
   \      0x2FA   0x2803             CMP      R0,#+3
   \      0x2FC   0xD3F6             BCC.N    ??HAL_RCC_OscConfig_34
   \      0x2FE   0x2003             MOVS     R0,#+3
   \      0x300   0xE1A3             B.N      ??HAL_RCC_OscConfig_1
    722              else
    723              {
    724                /* Disable the Internal Low Speed oscillator (LSI). */
    725                __HAL_RCC_LSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_29: (+1)
   \      0x302   0x.... 0x....      LDR.W    R8,??DataTable15_1
   \      0x306   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x30A   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \      0x30E   0xF8C8 0x0000      STR      R0,[R8, #+0]
    726          
    727                /* Get Start Tick*/
    728                tickstart = HAL_GetTick();
   \      0x312   0x.... 0x....      BL       HAL_GetTick
   \      0x316   0x0007             MOVS     R7,R0
    729          
    730                /* Wait till LSI is disabled */
    731                while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
   \                     ??HAL_RCC_OscConfig_35: (+1)
   \      0x318   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x31C   0x0100             LSLS     R0,R0,#+4
   \      0x31E   0xD506             BPL.N    ??HAL_RCC_OscConfig_28
    732                {
    733                  if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
   \      0x320   0x.... 0x....      BL       HAL_GetTick
   \      0x324   0x1BC0             SUBS     R0,R0,R7
   \      0x326   0x2803             CMP      R0,#+3
   \      0x328   0xD3F6             BCC.N    ??HAL_RCC_OscConfig_35
    734                  {
    735                    return HAL_TIMEOUT;
   \      0x32A   0x2003             MOVS     R0,#+3
   \      0x32C   0xE18D             B.N      ??HAL_RCC_OscConfig_1
    736                  }
    737                }
    738              }
    739          
    740            }
    741            /*------------------------------ LSE Configuration -------------------------*/
    742            if (((pOscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
   \                     ??HAL_RCC_OscConfig_28: (+1)
   \      0x32E   0x7828             LDRB     R0,[R5, #+0]
   \      0x330   0x0740             LSLS     R0,R0,#+29
   \      0x332   0xF140 0x808A      BPL.W    ??HAL_RCC_OscConfig_36
    743            {
    744          
    745              /* Check the parameters */
    746              assert_param(IS_RCC_LSE(pOscInitStruct->LSEState));
    747          
    748              /* Update LSE configuration in Backup Domain control register    */
    749              /* Requires to enable write access to Backup Domain */
    750              if (HAL_IS_BIT_CLR(PWR->DBPCR, PWR_DBPCR_DBP))
   \      0x336   0x.... 0x....      LDR.W    R7,??DataTable15_2
   \      0x33A   0x6838             LDR      R0,[R7, #+0]
   \      0x33C   0x07C0             LSLS     R0,R0,#+31
   \      0x33E   0xD411             BMI.N    ??HAL_RCC_OscConfig_37
    751              {
    752                /* Enable write access to Backup domain */
    753                SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
   \      0x340   0x6838             LDR      R0,[R7, #+0]
   \      0x342   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x346   0x6038             STR      R0,[R7, #+0]
    754          
    755                /* Wait for Backup domain Write protection disable */
    756                tickstart = HAL_GetTick();
   \      0x348   0x.... 0x....      BL       HAL_GetTick
   \      0x34C   0x4680             MOV      R8,R0
    757          
    758                while (HAL_IS_BIT_CLR(PWR->DBPCR, PWR_DBPCR_DBP))
   \                     ??HAL_RCC_OscConfig_38: (+1)
   \      0x34E   0x6838             LDR      R0,[R7, #+0]
   \      0x350   0x07C0             LSLS     R0,R0,#+31
   \      0x352   0xD407             BMI.N    ??HAL_RCC_OscConfig_37
    759                {
    760                  if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
   \      0x354   0x.... 0x....      BL       HAL_GetTick
   \      0x358   0xEBB0 0x0008      SUBS     R0,R0,R8
   \      0x35C   0x2803             CMP      R0,#+3
   \      0x35E   0xD3F6             BCC.N    ??HAL_RCC_OscConfig_38
    761                  {
    762                    return HAL_TIMEOUT;
   \      0x360   0x2003             MOVS     R0,#+3
   \      0x362   0xE172             B.N      ??HAL_RCC_OscConfig_1
    763                  }
    764                }
    765              }
    766          
    767              /* Set the new LSE configuration -----------------------------------------*/
    768              __HAL_RCC_LSE_CONFIG(pOscInitStruct->LSEState);
   \                     ??HAL_RCC_OscConfig_37: (+1)
   \      0x364   0x68A8             LDR      R0,[R5, #+8]
   \      0x366   0x2801             CMP      R0,#+1
   \      0x368   0xD106             BNE.N    ??HAL_RCC_OscConfig_39
   \      0x36A   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \      0x36E   0x6801             LDR      R1,[R0, #+0]
   \      0x370   0xF051 0x0101      ORRS     R1,R1,#0x1
   \      0x374   0x6001             STR      R1,[R0, #+0]
   \      0x376   0xE043             B.N      ??HAL_RCC_OscConfig_40
   \                     ??HAL_RCC_OscConfig_39: (+1)
   \      0x378   0x68A8             LDR      R0,[R5, #+8]
   \      0x37A   0x2800             CMP      R0,#+0
   \      0x37C   0xD10E             BNE.N    ??HAL_RCC_OscConfig_41
   \      0x37E   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \      0x382   0x6801             LDR      R1,[R0, #+0]
   \      0x384   0x0849             LSRS     R1,R1,#+1
   \      0x386   0x0049             LSLS     R1,R1,#+1
   \      0x388   0x6001             STR      R1,[R0, #+0]
   \      0x38A   0x6801             LDR      R1,[R0, #+0]
   \      0x38C   0xF031 0x0180      BICS     R1,R1,#0x80
   \      0x390   0x6001             STR      R1,[R0, #+0]
   \      0x392   0x6801             LDR      R1,[R0, #+0]
   \      0x394   0xF031 0x0104      BICS     R1,R1,#0x4
   \      0x398   0x6001             STR      R1,[R0, #+0]
   \      0x39A   0xE031             B.N      ??HAL_RCC_OscConfig_40
   \                     ??HAL_RCC_OscConfig_41: (+1)
   \      0x39C   0x68A8             LDR      R0,[R5, #+8]
   \      0x39E   0x2805             CMP      R0,#+5
   \      0x3A0   0xD10E             BNE.N    ??HAL_RCC_OscConfig_42
   \      0x3A2   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \      0x3A6   0x6801             LDR      R1,[R0, #+0]
   \      0x3A8   0xF051 0x0104      ORRS     R1,R1,#0x4
   \      0x3AC   0x6001             STR      R1,[R0, #+0]
   \      0x3AE   0x6801             LDR      R1,[R0, #+0]
   \      0x3B0   0xF031 0x0180      BICS     R1,R1,#0x80
   \      0x3B4   0x6001             STR      R1,[R0, #+0]
   \      0x3B6   0x6801             LDR      R1,[R0, #+0]
   \      0x3B8   0xF051 0x0101      ORRS     R1,R1,#0x1
   \      0x3BC   0x6001             STR      R1,[R0, #+0]
   \      0x3BE   0xE01F             B.N      ??HAL_RCC_OscConfig_40
   \                     ??HAL_RCC_OscConfig_42: (+1)
   \      0x3C0   0x68A8             LDR      R0,[R5, #+8]
   \      0x3C2   0x2885             CMP      R0,#+133
   \      0x3C4   0xD10E             BNE.N    ??HAL_RCC_OscConfig_43
   \      0x3C6   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \      0x3CA   0x6801             LDR      R1,[R0, #+0]
   \      0x3CC   0xF051 0x0104      ORRS     R1,R1,#0x4
   \      0x3D0   0x6001             STR      R1,[R0, #+0]
   \      0x3D2   0x6801             LDR      R1,[R0, #+0]
   \      0x3D4   0xF051 0x0180      ORRS     R1,R1,#0x80
   \      0x3D8   0x6001             STR      R1,[R0, #+0]
   \      0x3DA   0x6801             LDR      R1,[R0, #+0]
   \      0x3DC   0xF051 0x0101      ORRS     R1,R1,#0x1
   \      0x3E0   0x6001             STR      R1,[R0, #+0]
   \      0x3E2   0xE00D             B.N      ??HAL_RCC_OscConfig_40
   \                     ??HAL_RCC_OscConfig_43: (+1)
   \      0x3E4   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \      0x3E8   0x6801             LDR      R1,[R0, #+0]
   \      0x3EA   0x0849             LSRS     R1,R1,#+1
   \      0x3EC   0x0049             LSLS     R1,R1,#+1
   \      0x3EE   0x6001             STR      R1,[R0, #+0]
   \      0x3F0   0x6801             LDR      R1,[R0, #+0]
   \      0x3F2   0xF031 0x0104      BICS     R1,R1,#0x4
   \      0x3F6   0x6001             STR      R1,[R0, #+0]
   \      0x3F8   0x6801             LDR      R1,[R0, #+0]
   \      0x3FA   0xF031 0x0180      BICS     R1,R1,#0x80
   \      0x3FE   0x6001             STR      R1,[R0, #+0]
    769          
    770              /* Check the LSE State */
    771              if (pOscInitStruct->LSEState != RCC_LSE_OFF)
   \                     ??HAL_RCC_OscConfig_40: (+1)
   \      0x400   0x68A8             LDR      R0,[R5, #+8]
   \      0x402   0x2800             CMP      R0,#+0
   \      0x404   0xD010             BEQ.N    ??HAL_RCC_OscConfig_44
    772              {
    773                /* Get Start Tick*/
    774                tickstart = HAL_GetTick();
   \      0x406   0x.... 0x....      BL       HAL_GetTick
   \      0x40A   0x0007             MOVS     R7,R0
    775          
    776                /* Wait till LSE is ready */
    777                while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
   \                     ??HAL_RCC_OscConfig_45: (+1)
   \      0x40C   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \      0x410   0x6800             LDR      R0,[R0, #+0]
   \      0x412   0x0780             LSLS     R0,R0,#+30
   \      0x414   0xD419             BMI.N    ??HAL_RCC_OscConfig_36
    778                {
    779                  if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
   \      0x416   0x.... 0x....      BL       HAL_GetTick
   \      0x41A   0x1BC0             SUBS     R0,R0,R7
   \      0x41C   0xF241 0x3189      MOVW     R1,#+5001
   \      0x420   0x4288             CMP      R0,R1
   \      0x422   0xD3F3             BCC.N    ??HAL_RCC_OscConfig_45
    780                  {
    781                    return HAL_TIMEOUT;
   \      0x424   0x2003             MOVS     R0,#+3
   \      0x426   0xE110             B.N      ??HAL_RCC_OscConfig_1
    782                  }
    783                }
    784              }
    785              else
    786              {
    787                /* Get Start Tick*/
    788                tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_44: (+1)
   \      0x428   0x.... 0x....      BL       HAL_GetTick
   \      0x42C   0x0007             MOVS     R7,R0
    789          
    790                /* Wait till LSE is disabled */
    791                while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
   \                     ??HAL_RCC_OscConfig_46: (+1)
   \      0x42E   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \      0x432   0x6800             LDR      R0,[R0, #+0]
   \      0x434   0x0780             LSLS     R0,R0,#+30
   \      0x436   0xD508             BPL.N    ??HAL_RCC_OscConfig_36
    792                {
    793                  if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
   \      0x438   0x.... 0x....      BL       HAL_GetTick
   \      0x43C   0x1BC0             SUBS     R0,R0,R7
   \      0x43E   0xF241 0x3189      MOVW     R1,#+5001
   \      0x442   0x4288             CMP      R0,R1
   \      0x444   0xD3F3             BCC.N    ??HAL_RCC_OscConfig_46
    794                  {
    795                    return HAL_TIMEOUT;
   \      0x446   0x2003             MOVS     R0,#+3
   \      0x448   0xE0FF             B.N      ??HAL_RCC_OscConfig_1
    796                  }
    797                }
    798              }
    799          
    800            }
    801            /*------------------------------ HSI48 Configuration -----------------------*/
    802            if (((pOscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
   \                     ??HAL_RCC_OscConfig_36: (+1)
   \      0x44A   0x7828             LDRB     R0,[R5, #+0]
   \      0x44C   0x0680             LSLS     R0,R0,#+26
   \      0x44E   0xD52E             BPL.N    ??HAL_RCC_OscConfig_47
    803            {
    804              /* Check the parameters */
    805              assert_param(IS_RCC_HSI48(pOscInitStruct->HSI48State));
    806          
    807              /* Check the HSI48 State */
    808              if (pOscInitStruct->HSI48State != RCC_HSI48_OFF)
   \      0x450   0x6A68             LDR      R0,[R5, #+36]
   \      0x452   0x2800             CMP      R0,#+0
   \      0x454   0xD015             BEQ.N    ??HAL_RCC_OscConfig_48
    809              {
    810                /* Enable the Internal High Speed oscillator (HSI48). */
    811                __HAL_RCC_HSI48_ENABLE();
   \      0x456   0x.... 0x....      LDR.W    R8,??DataTable3_1
   \      0x45A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x45E   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \      0x462   0xF8C8 0x0000      STR      R0,[R8, #+0]
    812          
    813                /* Get Start Tick*/
    814                tickstart = HAL_GetTick();
   \      0x466   0x.... 0x....      BL       HAL_GetTick
   \      0x46A   0x0007             MOVS     R7,R0
    815          
    816                /* Wait till HSI48 is ready */
    817                while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) == 0U)
   \                     ??HAL_RCC_OscConfig_49: (+1)
   \      0x46C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x470   0x0480             LSLS     R0,R0,#+18
   \      0x472   0xD41C             BMI.N    ??HAL_RCC_OscConfig_47
    818                {
    819                  if ((HAL_GetTick() - tickstart) > RCC_HSI48_TIMEOUT_VALUE)
   \      0x474   0x.... 0x....      BL       HAL_GetTick
   \      0x478   0x1BC0             SUBS     R0,R0,R7
   \      0x47A   0x2803             CMP      R0,#+3
   \      0x47C   0xD3F6             BCC.N    ??HAL_RCC_OscConfig_49
    820                  {
    821                    return HAL_TIMEOUT;
   \      0x47E   0x2003             MOVS     R0,#+3
   \      0x480   0xE0E3             B.N      ??HAL_RCC_OscConfig_1
    822                  }
    823                }
    824              }
    825              else
    826              {
    827                /* Disable the Internal High Speed oscillator (HSI48). */
    828                __HAL_RCC_HSI48_DISABLE();
   \                     ??HAL_RCC_OscConfig_48: (+1)
   \      0x482   0x.... 0x....      LDR.W    R8,??DataTable3_1
   \      0x486   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x48A   0xF430 0x5080      BICS     R0,R0,#0x1000
   \      0x48E   0xF8C8 0x0000      STR      R0,[R8, #+0]
    829          
    830                /* Get Start Tick*/
    831                tickstart = HAL_GetTick();
   \      0x492   0x.... 0x....      BL       HAL_GetTick
   \      0x496   0x0007             MOVS     R7,R0
    832          
    833                /* Wait till HSI48 is disabled */
    834                while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) != 0U)
   \                     ??HAL_RCC_OscConfig_50: (+1)
   \      0x498   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x49C   0x0480             LSLS     R0,R0,#+18
   \      0x49E   0xD506             BPL.N    ??HAL_RCC_OscConfig_47
    835                {
    836                  if ((HAL_GetTick() - tickstart) > RCC_HSI48_TIMEOUT_VALUE)
   \      0x4A0   0x.... 0x....      BL       HAL_GetTick
   \      0x4A4   0x1BC0             SUBS     R0,R0,R7
   \      0x4A6   0x2803             CMP      R0,#+3
   \      0x4A8   0xD3F6             BCC.N    ??HAL_RCC_OscConfig_50
    837                  {
    838                    return HAL_TIMEOUT;
   \      0x4AA   0x2003             MOVS     R0,#+3
   \      0x4AC   0xE0CD             B.N      ??HAL_RCC_OscConfig_1
    839                  }
    840                }
    841              }
    842            }
    843          
    844            /*-------------------------------- PLL1 Configuration -----------------------*/
    845            /* Check the parameters */
    846            assert_param(IS_RCC_PLL(pOscInitStruct->PLL.PLLState));
    847          
    848            if ((pOscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
   \                     ??HAL_RCC_OscConfig_47: (+1)
   \      0x4AE   0x6AA8             LDR      R0,[R5, #+40]
   \      0x4B0   0x2800             CMP      R0,#+0
   \      0x4B2   0xF000 0x80C9      BEQ.W    ??HAL_RCC_OscConfig_51
    849            {
    850              /* Check if the PLL1 is used as system clock or not */
    851              if (temp_sysclksrc != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \      0x4B6   0x2C18             CMP      R4,#+24
   \      0x4B8   0xF000 0x8080      BEQ.W    ??HAL_RCC_OscConfig_52
    852              {
    853                if ((pOscInitStruct->PLL.PLLState) == RCC_PLL_ON)
   \      0x4BC   0x6AA8             LDR      R0,[R5, #+40]
   \      0x4BE   0x2802             CMP      R0,#+2
   \      0x4C0   0xD163             BNE.N    ??HAL_RCC_OscConfig_53
    854                {
    855                  /* Check the parameters */
    856                  assert_param(IS_RCC_PLL1_SOURCE(pOscInitStruct->PLL.PLLSource));
    857                  assert_param(IS_RCC_PLL1_DIVM_VALUE(pOscInitStruct->PLL.PLLM));
    858                  assert_param(IS_RCC_PLL1_MULN_VALUE(pOscInitStruct->PLL.PLLN));
    859                  assert_param(IS_RCC_PLL1_DIVP_VALUE(pOscInitStruct->PLL.PLLP));
    860                  assert_param(IS_RCC_PLL1_DIVQ_VALUE(pOscInitStruct->PLL.PLLQ));
    861                  assert_param(IS_RCC_PLL1_DIVR_VALUE(pOscInitStruct->PLL.PLLR));
    862          
    863                  /* Disable the PLL1. */
    864                  __HAL_RCC_PLL1_DISABLE();
   \      0x4C2   0x.... 0x....      LDR.W    R4,??DataTable3_1
   \      0x4C6   0x6820             LDR      R0,[R4, #+0]
   \      0x4C8   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \      0x4CC   0x6020             STR      R0,[R4, #+0]
    865          
    866                  /* Get Start Tick*/
    867                  tickstart = HAL_GetTick();
   \      0x4CE   0x.... 0x....      BL       HAL_GetTick
   \      0x4D2   0x0007             MOVS     R7,R0
    868          
    869                  /* Wait till PLL1 is disabled */
    870                  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
   \                     ??HAL_RCC_OscConfig_54: (+1)
   \      0x4D4   0x6820             LDR      R0,[R4, #+0]
   \      0x4D6   0x0180             LSLS     R0,R0,#+6
   \      0x4D8   0xD506             BPL.N    ??HAL_RCC_OscConfig_55
    871                  {
    872                    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
   \      0x4DA   0x.... 0x....      BL       HAL_GetTick
   \      0x4DE   0x1BC0             SUBS     R0,R0,R7
   \      0x4E0   0x2803             CMP      R0,#+3
   \      0x4E2   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_54
    873                    {
    874                      return HAL_TIMEOUT;
   \      0x4E4   0x2003             MOVS     R0,#+3
   \      0x4E6   0xE0B0             B.N      ??HAL_RCC_OscConfig_1
    875                    }
    876                  }
    877          
    878                  /* Configure the PLL1 clock source, multiplication and division factors. */
    879                  __HAL_RCC_PLL1_CONFIG(pOscInitStruct->PLL.PLLSource,
    880                                        pOscInitStruct->PLL.PLLM,
    881                                        pOscInitStruct->PLL.PLLN,
    882                                        pOscInitStruct->PLL.PLLP,
    883                                        pOscInitStruct->PLL.PLLQ,
    884                                        pOscInitStruct->PLL.PLLR);
   \                     ??HAL_RCC_OscConfig_55: (+1)
   \      0x4E8   0x6831             LDR      R1,[R6, #+0]
   \      0x4EA   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \      0x4EE   0x4001             ANDS     R1,R0,R1
   \      0x4F0   0x6AE8             LDR      R0,[R5, #+44]
   \      0x4F2   0x4301             ORRS     R1,R0,R1
   \      0x4F4   0x6B28             LDR      R0,[R5, #+48]
   \      0x4F6   0xEA51 0x2100      ORRS     R1,R1,R0, LSL #+8
   \      0x4FA   0x6031             STR      R1,[R6, #+0]
   \      0x4FC   0x6B68             LDR      R0,[R5, #+52]
   \      0x4FE   0x1E40             SUBS     R0,R0,#+1
   \      0x500   0x05C0             LSLS     R0,R0,#+23
   \      0x502   0x0DC0             LSRS     R0,R0,#+23
   \      0x504   0x6BA9             LDR      R1,[R5, #+56]
   \      0x506   0x1E49             SUBS     R1,R1,#+1
   \      0x508   0x0249             LSLS     R1,R1,#+9
   \      0x50A   0xF411 0x417E      ANDS     R1,R1,#0xFE00
   \      0x50E   0x4308             ORRS     R0,R1,R0
   \      0x510   0x6BE9             LDR      R1,[R5, #+60]
   \      0x512   0x1E49             SUBS     R1,R1,#+1
   \      0x514   0x0409             LSLS     R1,R1,#+16
   \      0x516   0xF411 0x01FE      ANDS     R1,R1,#0x7F0000
   \      0x51A   0x4308             ORRS     R0,R1,R0
   \      0x51C   0x6C29             LDR      R1,[R5, #+64]
   \      0x51E   0x1E49             SUBS     R1,R1,#+1
   \      0x520   0x0609             LSLS     R1,R1,#+24
   \      0x522   0xF011 0x41FE      ANDS     R1,R1,#0x7F000000
   \      0x526   0x4308             ORRS     R0,R1,R0
   \      0x528   0x.... 0x....      LDR.W    R1,??DataTable3_9
   \      0x52C   0x6008             STR      R0,[R1, #+0]
    885          
    886                  assert_param(IS_RCC_PLL1_FRACN_VALUE(pOscInitStruct->PLL.PLLFRACN));
    887          
    888                  /* Disable PLL1FRACN . */
    889                  __HAL_RCC_PLL1_FRACN_DISABLE();
   \      0x52E   0x6830             LDR      R0,[R6, #+0]
   \      0x530   0xF030 0x0010      BICS     R0,R0,#0x10
   \      0x534   0x6030             STR      R0,[R6, #+0]
    890          
    891                  /* Configure PLL  PLL1FRACN */
    892                  __HAL_RCC_PLL1_FRACN_CONFIG(pOscInitStruct->PLL.PLLFRACN);
   \      0x536   0x6CE8             LDR      R0,[R5, #+76]
   \      0x538   0x00C0             LSLS     R0,R0,#+3
   \      0x53A   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \      0x53E   0x6008             STR      R0,[R1, #+0]
    893          
    894                  /* Enable PLL1FRACN . */
    895                  __HAL_RCC_PLL1_FRACN_ENABLE();
   \      0x540   0x6830             LDR      R0,[R6, #+0]
   \      0x542   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x546   0x6030             STR      R0,[R6, #+0]
    896          
    897                  assert_param(IS_RCC_PLL1_VCIRGE_VALUE(pOscInitStruct->PLL.PLLRGE));
    898          
    899                  /* Select PLL1 input reference frequency range: VCI */
    900                  __HAL_RCC_PLL1_VCIRANGE(pOscInitStruct->PLL.PLLRGE) ;
   \      0x548   0x6831             LDR      R1,[R6, #+0]
   \      0x54A   0xF031 0x010C      BICS     R1,R1,#0xC
   \      0x54E   0x6C68             LDR      R0,[R5, #+68]
   \      0x550   0x4301             ORRS     R1,R0,R1
   \      0x552   0x6031             STR      R1,[R6, #+0]
    901          
    902                  assert_param(IS_RCC_PLL1_VCORGE_VALUE(pOscInitStruct->PLL.PLLVCOSEL));
    903          
    904                  /* Select PLL1 output frequency range : VCO */
    905                  __HAL_RCC_PLL1_VCORANGE(pOscInitStruct->PLL.PLLVCOSEL) ;
   \      0x554   0x6831             LDR      R1,[R6, #+0]
   \      0x556   0xF031 0x0120      BICS     R1,R1,#0x20
   \      0x55A   0x6CA8             LDR      R0,[R5, #+72]
   \      0x55C   0x4301             ORRS     R1,R0,R1
   \      0x55E   0x6031             STR      R1,[R6, #+0]
    906          
    907                  /* Enable PLL1 System Clock output. */
    908                  __HAL_RCC_PLL1_CLKOUT_ENABLE(RCC_PLL1_DIVP);
   \      0x560   0x6830             LDR      R0,[R6, #+0]
   \      0x562   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \      0x566   0x6030             STR      R0,[R6, #+0]
    909          
    910                  /* Enable the PLL1. */
    911                  __HAL_RCC_PLL1_ENABLE();
   \      0x568   0x6820             LDR      R0,[R4, #+0]
   \      0x56A   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \      0x56E   0x6020             STR      R0,[R4, #+0]
    912          
    913                  /* Get Start Tick*/
    914                  tickstart = HAL_GetTick();
   \      0x570   0x.... 0x....      BL       HAL_GetTick
   \      0x574   0x0005             MOVS     R5,R0
    915          
    916                  /* Wait till PLL1 is ready */
    917                  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
   \                     ??HAL_RCC_OscConfig_56: (+1)
   \      0x576   0x6820             LDR      R0,[R4, #+0]
   \      0x578   0x0180             LSLS     R0,R0,#+6
   \      0x57A   0xD465             BMI.N    ??HAL_RCC_OscConfig_51
    918                  {
    919                    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
   \      0x57C   0x.... 0x....      BL       HAL_GetTick
   \      0x580   0x1B40             SUBS     R0,R0,R5
   \      0x582   0x2803             CMP      R0,#+3
   \      0x584   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_56
    920                    {
    921                      return HAL_TIMEOUT;
   \      0x586   0x2003             MOVS     R0,#+3
   \      0x588   0xE05F             B.N      ??HAL_RCC_OscConfig_1
    922                    }
    923                  }
    924                }
    925                else
    926                {
    927                  /* Disable the PLL1. */
    928                  __HAL_RCC_PLL1_DISABLE();
   \                     ??HAL_RCC_OscConfig_53: (+1)
   \      0x58A   0x.... 0x....      LDR.W    R5,??DataTable3_1
   \      0x58E   0x6828             LDR      R0,[R5, #+0]
   \      0x590   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \      0x594   0x6028             STR      R0,[R5, #+0]
    929          
    930                  /* Get Start Tick*/
    931                  tickstart = HAL_GetTick();
   \      0x596   0x.... 0x....      BL       HAL_GetTick
   \      0x59A   0x0004             MOVS     R4,R0
    932          
    933                  /* Wait till PLL1 is disabled */
    934                  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
   \                     ??HAL_RCC_OscConfig_57: (+1)
   \      0x59C   0x6828             LDR      R0,[R5, #+0]
   \      0x59E   0x0180             LSLS     R0,R0,#+6
   \      0x5A0   0xD506             BPL.N    ??HAL_RCC_OscConfig_58
    935                  {
    936                    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
   \      0x5A2   0x.... 0x....      BL       HAL_GetTick
   \      0x5A6   0x1B00             SUBS     R0,R0,R4
   \      0x5A8   0x2803             CMP      R0,#+3
   \      0x5AA   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_57
    937                    {
    938                      return HAL_TIMEOUT;
   \      0x5AC   0x2003             MOVS     R0,#+3
   \      0x5AE   0xE04C             B.N      ??HAL_RCC_OscConfig_1
    939                    }
    940                  }
    941          
    942                  /* Unselect PLL1 clock source and disable all PLL1 outputs to save power */
    943                  RCC->PLL1CFGR &= ~(RCC_PLL1CFGR_PLL1SRC | RCC_PLL1CFGR_PLL1PEN | RCC_PLL1CFGR_PLL1QEN | RCC_PLL1CFGR_PLL1REN);
   \                     ??HAL_RCC_OscConfig_58: (+1)
   \      0x5B0   0x6831             LDR      R1,[R6, #+0]
   \      0x5B2   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \      0x5B6   0x4001             ANDS     R1,R0,R1
   \      0x5B8   0x6031             STR      R1,[R6, #+0]
   \      0x5BA   0xE045             B.N      ??HAL_RCC_OscConfig_51
    944          
    945                }
    946              }
    947              else
    948              {
    949                /* Do not return HAL_ERROR if request repeats the current configuration */
    950                temp1_pllckcfg = RCC->PLL1CFGR;
   \                     ??HAL_RCC_OscConfig_52: (+1)
   \      0x5BC   0x6831             LDR      R1,[R6, #+0]
    951                temp2_pllckcfg = RCC->PLL1DIVR;
   \      0x5BE   0x.... 0x....      LDR.W    R0,??DataTable3_9
   \      0x5C2   0x6800             LDR      R0,[R0, #+0]
    952                if (((pOscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
    953                    (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1SRC) != pOscInitStruct->PLL.PLLSource) ||
    954                    ((READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1M) >> \
    955                      RCC_PLL1CFGR_PLL1M_Pos) != (pOscInitStruct->PLL.PLLM)) ||
    956                    (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1N) != (pOscInitStruct->PLL.PLLN - 1U)) ||
    957                    ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1P) >> \
    958                      RCC_PLL1DIVR_PLL1P_Pos) != (pOscInitStruct->PLL.PLLP - 1U)) ||
    959                    ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1Q) >> \
    960                      RCC_PLL1DIVR_PLL1Q_Pos) != (pOscInitStruct->PLL.PLLQ - 1U)) ||
    961                    ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1R) >> \
    962                      RCC_PLL1DIVR_PLL1R_Pos) != (pOscInitStruct->PLL.PLLR - 1U)))
   \      0x5C4   0x6AAA             LDR      R2,[R5, #+40]
   \      0x5C6   0x2A01             CMP      R2,#+1
   \      0x5C8   0xD021             BEQ.N    ??HAL_RCC_OscConfig_59
   \      0x5CA   0xF011 0x0203      ANDS     R2,R1,#0x3
   \      0x5CE   0x6AEB             LDR      R3,[R5, #+44]
   \      0x5D0   0x429A             CMP      R2,R3
   \      0x5D2   0xD11C             BNE.N    ??HAL_RCC_OscConfig_59
   \      0x5D4   0xF3C1 0x2105      UBFX     R1,R1,#+8,#+6
   \      0x5D8   0x6B2A             LDR      R2,[R5, #+48]
   \      0x5DA   0x4291             CMP      R1,R2
   \      0x5DC   0xD117             BNE.N    ??HAL_RCC_OscConfig_59
   \      0x5DE   0x05C1             LSLS     R1,R0,#+23
   \      0x5E0   0x0DC9             LSRS     R1,R1,#+23
   \      0x5E2   0x6B6A             LDR      R2,[R5, #+52]
   \      0x5E4   0x1E52             SUBS     R2,R2,#+1
   \      0x5E6   0x4291             CMP      R1,R2
   \      0x5E8   0xD111             BNE.N    ??HAL_RCC_OscConfig_59
   \      0x5EA   0xF3C0 0x2146      UBFX     R1,R0,#+9,#+7
   \      0x5EE   0x6BAA             LDR      R2,[R5, #+56]
   \      0x5F0   0x1E52             SUBS     R2,R2,#+1
   \      0x5F2   0x4291             CMP      R1,R2
   \      0x5F4   0xD10B             BNE.N    ??HAL_RCC_OscConfig_59
   \      0x5F6   0xF3C0 0x4106      UBFX     R1,R0,#+16,#+7
   \      0x5FA   0x6BEA             LDR      R2,[R5, #+60]
   \      0x5FC   0x1E52             SUBS     R2,R2,#+1
   \      0x5FE   0x4291             CMP      R1,R2
   \      0x600   0xD105             BNE.N    ??HAL_RCC_OscConfig_59
   \      0x602   0xF3C0 0x6006      UBFX     R0,R0,#+24,#+7
   \      0x606   0x6C29             LDR      R1,[R5, #+64]
   \      0x608   0x1E49             SUBS     R1,R1,#+1
   \      0x60A   0x4288             CMP      R0,R1
   \      0x60C   0xD001             BEQ.N    ??HAL_RCC_OscConfig_60
    963                {
    964                  return HAL_ERROR;
   \                     ??HAL_RCC_OscConfig_59: (+1)
   \      0x60E   0x2001             MOVS     R0,#+1
   \      0x610   0xE01B             B.N      ??HAL_RCC_OscConfig_1
    965                }
    966          
    967                /* FRACN1 on-the-fly value update */
    968                if ((READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_PLL1FRACN) >> \
    969                     RCC_PLL1FRACR_PLL1FRACN_Pos) != (pOscInitStruct->PLL.PLLFRACN))
   \                     ??HAL_RCC_OscConfig_60: (+1)
   \      0x612   0x.... 0x....      LDR.W    R4,??DataTable15_4
   \      0x616   0x6820             LDR      R0,[R4, #+0]
   \      0x618   0xF3C0 0x00CC      UBFX     R0,R0,#+3,#+13
   \      0x61C   0x6CE9             LDR      R1,[R5, #+76]
   \      0x61E   0x4288             CMP      R0,R1
   \      0x620   0xD012             BEQ.N    ??HAL_RCC_OscConfig_51
    970                {
    971                  assert_param(IS_RCC_PLL1_FRACN_VALUE(pOscInitStruct->PLL.PLLFRACN));
    972          
    973                  /* Disable PLL1FRACN . */
    974                  __HAL_RCC_PLL1_FRACN_DISABLE();
   \      0x622   0x6830             LDR      R0,[R6, #+0]
   \      0x624   0xF030 0x0010      BICS     R0,R0,#0x10
   \      0x628   0x6030             STR      R0,[R6, #+0]
    975          
    976                  /* Get Start Tick*/
    977                  tickstart = HAL_GetTick();
   \      0x62A   0x.... 0x....      BL       HAL_GetTick
   \      0x62E   0x0007             MOVS     R7,R0
    978          
    979                  /* Wait at least 2 CK_REF (PLL input source divided by M) period to make sure next latched value
    980                     will be taken into account. */
    981                  while ((HAL_GetTick() - tickstart) < RCC_PLL_FRAC_WAIT_VALUE)
   \                     ??HAL_RCC_OscConfig_61: (+1)
   \      0x630   0x.... 0x....      BL       HAL_GetTick
   \      0x634   0x1BC0             SUBS     R0,R0,R7
   \      0x636   0x2800             CMP      R0,#+0
   \      0x638   0xD0FA             BEQ.N    ??HAL_RCC_OscConfig_61
    982                  {
    983                  }
    984          
    985                  /* Configure PLL PLL1FRACN */
    986                  __HAL_RCC_PLL1_FRACN_CONFIG(pOscInitStruct->PLL.PLLFRACN);
   \      0x63A   0x6CE8             LDR      R0,[R5, #+76]
   \      0x63C   0x00C0             LSLS     R0,R0,#+3
   \      0x63E   0x6020             STR      R0,[R4, #+0]
    987          
    988                  /* Enable PLL1FRACN to latch the new value. */
    989                  __HAL_RCC_PLL1_FRACN_ENABLE();
   \      0x640   0x6830             LDR      R0,[R6, #+0]
   \      0x642   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x646   0x6030             STR      R0,[R6, #+0]
    990                }
    991          
    992              }
    993            }
    994            return HAL_OK;
   \                     ??HAL_RCC_OscConfig_51: (+1)
   \      0x648   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_OscConfig_1: (+1)
   \      0x64A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    995          }
    996          
    997          /**
    998            * @brief  Initialize the CPU, AHB and APB busses clocks according to the specified
    999            *         parameters in the pClkInitStruct.
   1000            * @param  pClkInitStruct  pointer to an RCC_OscInitTypeDef structure that
   1001            *         contains the configuration information for the RCC peripheral.
   1002            * @param  FLatency  FLASH Latency
   1003            *          This parameter can be one of the following values:
   1004            *            @arg FLASH_LATENCY_0   FLASH 0 Latency cycle
   1005            *            @arg FLASH_LATENCY_1   FLASH 1 Latency cycle
   1006            *            @arg FLASH_LATENCY_2   FLASH 2 Latency cycles
   1007            *            @arg FLASH_LATENCY_3   FLASH 3 Latency cycles
   1008            *            @arg FLASH_LATENCY_4   FLASH 4 Latency cycles
   1009            *            @arg FLASH_LATENCY_5   FLASH 5 Latency cycles
   1010            *
   1011            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
   1012            *         and updated by HAL_RCC_GetHCLKFreq() function called within this function
   1013            *
   1014            * @note   The HSI is used by default as system clock source after
   1015            *         startup from Reset, wake-up from STANDBY mode. After restart from Reset,
   1016            *         the HSI frequency is set to its default value 64 MHz.
   1017            *
   1018            * @note   The HSI or CSI can be selected as system clock source after wake-up
   1019            *         from STOP modes or in case of failure of the HSE when used directly or indirectly
   1020            *         as system clock (if the Clock Security System CSS is enabled).
   1021            *
   1022            * @note   A switch from one clock source to another occurs only if the target
   1023            *         clock source is ready (clock stable after startup delay or PLL locked).
   1024            *         If a clock source which is not yet ready is selected, the switch will
   1025            *         occur when the clock source is ready.
   1026            *
   1027            * @note   You can use HAL_RCC_GetClockConfig() function to know which clock is
   1028            *         currently used as system clock source.
   1029            *
   1030            * @retval HAL Status.
   1031            */

   \                                 In section .text, align 2, keep-with-next
   1032          HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef  *pClkInitStruct, uint32_t FLatency)
   1033          {
   \                     HAL_RCC_ClockConfig: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000E             MOVS     R6,R1
   1034            HAL_StatusTypeDef halstatus;
   1035            uint32_t tickstart;
   1036          
   1037            /* Check Null pointer */
   1038            if (pClkInitStruct == NULL)
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD101             BNE.N    ??HAL_RCC_ClockConfig_0
   1039            {
   1040              return HAL_ERROR;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE12E             B.N      ??HAL_RCC_ClockConfig_1
   1041            }
   1042          
   1043            /* Check the parameters */
   1044            assert_param(IS_RCC_CLOCKTYPE(pClkInitStruct->ClockType));
   1045            assert_param(IS_FLASH_LATENCY(FLatency));
   1046          
   1047            /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
   1048              must be correctly programmed according to the frequency of the CPU clock
   1049              (HCLK) and the supply voltage of the device. */
   1050          
   1051            /* Increasing the number of wait states because of higher CPU frequency */
   1052            if (FLatency > __HAL_FLASH_GET_LATENCY())
   \                     ??HAL_RCC_ClockConfig_0: (+1)
   \       0x10   0x....             LDR.N    R5,??DataTable3
   \       0x12   0x6828             LDR      R0,[R5, #+0]
   \       0x14   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x18   0x42B0             CMP      R0,R6
   \       0x1A   0xD20B             BCS.N    ??HAL_RCC_ClockConfig_2
   1053            {
   1054              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
   1055              __HAL_FLASH_SET_LATENCY(FLatency);
   \       0x1C   0x6828             LDR      R0,[R5, #+0]
   \       0x1E   0x0900             LSRS     R0,R0,#+4
   \       0x20   0x0100             LSLS     R0,R0,#+4
   \       0x22   0x4330             ORRS     R0,R6,R0
   \       0x24   0x6028             STR      R0,[R5, #+0]
   1056          
   1057              /* Check that the new number of wait states is taken into account to access the Flash
   1058              memory by reading the FLASH_ACR register */
   1059              if (__HAL_FLASH_GET_LATENCY() != FLatency)
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x2C   0x42B0             CMP      R0,R6
   \       0x2E   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_2
   1060              {
   1061                return HAL_ERROR;
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0xE11C             B.N      ??HAL_RCC_ClockConfig_1
   1062              }
   1063            }
   1064          
   1065            /* Increasing the BUS frequency divider */
   1066            /*-------------------------- PCLK3 Configuration ---------------------------*/
   1067            if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK3) == RCC_CLOCKTYPE_PCLK3)
   \                     ??HAL_RCC_ClockConfig_2: (+1)
   \       0x34   0x7820             LDRB     R0,[R4, #+0]
   \       0x36   0x06C0             LSLS     R0,R0,#+27
   \       0x38   0xD50E             BPL.N    ??HAL_RCC_ClockConfig_3
   1068            {
   1069              if ((pClkInitStruct->APB3CLKDivider) > ((RCC->CFGR2 & RCC_CFGR2_PPRE3) >> 8))
   \       0x3A   0x....             LDR.N    R0,??DataTable3_5
   \       0x3C   0x6801             LDR      R1,[R0, #+0]
   \       0x3E   0x0A09             LSRS     R1,R1,#+8
   \       0x40   0xF011 0x0170      ANDS     R1,R1,#0x70
   \       0x44   0x6962             LDR      R2,[R4, #+20]
   \       0x46   0x4291             CMP      R1,R2
   \       0x48   0xD206             BCS.N    ??HAL_RCC_ClockConfig_3
   1070              {
   1071                assert_param(IS_RCC_PCLK(pClkInitStruct->APB3CLKDivider));
   1072                MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE3, ((pClkInitStruct->APB3CLKDivider) << 8));
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0xF431 0x41E0      BICS     R1,R1,#0x7000
   \       0x50   0x6962             LDR      R2,[R4, #+20]
   \       0x52   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \       0x56   0x6001             STR      R1,[R0, #+0]
   1073              }
   1074            }
   1075            /*-------------------------- PCLK2 Configuration ---------------------------*/
   1076            if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
   \                     ??HAL_RCC_ClockConfig_3: (+1)
   \       0x58   0x7820             LDRB     R0,[R4, #+0]
   \       0x5A   0x0700             LSLS     R0,R0,#+28
   \       0x5C   0xD50E             BPL.N    ??HAL_RCC_ClockConfig_4
   1077            {
   1078              if ((pClkInitStruct->APB2CLKDivider) > ((RCC->CFGR2 & RCC_CFGR2_PPRE2) >> 4))
   \       0x5E   0x....             LDR.N    R0,??DataTable3_5
   \       0x60   0x6801             LDR      R1,[R0, #+0]
   \       0x62   0x0909             LSRS     R1,R1,#+4
   \       0x64   0xF011 0x0170      ANDS     R1,R1,#0x70
   \       0x68   0x6922             LDR      R2,[R4, #+16]
   \       0x6A   0x4291             CMP      R1,R2
   \       0x6C   0xD206             BCS.N    ??HAL_RCC_ClockConfig_4
   1079              {
   1080                assert_param(IS_RCC_PCLK(pClkInitStruct->APB2CLKDivider));
   1081                MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, ((pClkInitStruct->APB2CLKDivider) << 4));
   \       0x6E   0x6801             LDR      R1,[R0, #+0]
   \       0x70   0xF431 0x61E0      BICS     R1,R1,#0x700
   \       0x74   0x6922             LDR      R2,[R4, #+16]
   \       0x76   0xEA51 0x1102      ORRS     R1,R1,R2, LSL #+4
   \       0x7A   0x6001             STR      R1,[R0, #+0]
   1082              }
   1083            }
   1084          
   1085            /*-------------------------- PCLK1 Configuration ---------------------------*/
   1086            if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
   \                     ??HAL_RCC_ClockConfig_4: (+1)
   \       0x7C   0x7820             LDRB     R0,[R4, #+0]
   \       0x7E   0x0740             LSLS     R0,R0,#+29
   \       0x80   0xD50C             BPL.N    ??HAL_RCC_ClockConfig_5
   1087            {
   1088              if ((pClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
   \       0x82   0x....             LDR.N    R1,??DataTable3_5
   \       0x84   0x6808             LDR      R0,[R1, #+0]
   \       0x86   0xF010 0x0070      ANDS     R0,R0,#0x70
   \       0x8A   0x68E2             LDR      R2,[R4, #+12]
   \       0x8C   0x4290             CMP      R0,R2
   \       0x8E   0xD205             BCS.N    ??HAL_RCC_ClockConfig_5
   1089              {
   1090                assert_param(IS_RCC_PCLK(pClkInitStruct->APB1CLKDivider));
   1091                MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, pClkInitStruct->APB1CLKDivider);
   \       0x90   0x680A             LDR      R2,[R1, #+0]
   \       0x92   0xF032 0x0270      BICS     R2,R2,#0x70
   \       0x96   0x68E0             LDR      R0,[R4, #+12]
   \       0x98   0x4302             ORRS     R2,R0,R2
   \       0x9A   0x600A             STR      R2,[R1, #+0]
   1092              }
   1093            }
   1094          
   1095            /*-------------------------- HCLK Configuration --------------------------*/
   1096            if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
   \                     ??HAL_RCC_ClockConfig_5: (+1)
   \       0x9C   0x7820             LDRB     R0,[R4, #+0]
   \       0x9E   0x0780             LSLS     R0,R0,#+30
   \       0xA0   0xD50C             BPL.N    ??HAL_RCC_ClockConfig_6
   1097            {
   1098              if ((pClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
   \       0xA2   0x....             LDR.N    R1,??DataTable3_5
   \       0xA4   0x6808             LDR      R0,[R1, #+0]
   \       0xA6   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0xAA   0x68A2             LDR      R2,[R4, #+8]
   \       0xAC   0x4290             CMP      R0,R2
   \       0xAE   0xD205             BCS.N    ??HAL_RCC_ClockConfig_6
   1099              {
   1100                assert_param(IS_RCC_HCLK(pClkInitStruct->AHBCLKDivider));
   1101                MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pClkInitStruct->AHBCLKDivider);
   \       0xB0   0x680A             LDR      R2,[R1, #+0]
   \       0xB2   0x0912             LSRS     R2,R2,#+4
   \       0xB4   0x0112             LSLS     R2,R2,#+4
   \       0xB6   0x68A0             LDR      R0,[R4, #+8]
   \       0xB8   0x4302             ORRS     R2,R0,R2
   \       0xBA   0x600A             STR      R2,[R1, #+0]
   1102              }
   1103            }
   1104          
   1105            /*------------------------- SYSCLK Configuration ---------------------------*/
   1106            if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
   \                     ??HAL_RCC_ClockConfig_6: (+1)
   \       0xBC   0x7820             LDRB     R0,[R4, #+0]
   \       0xBE   0x07C0             LSLS     R0,R0,#+31
   \       0xC0   0xD56F             BPL.N    ??HAL_RCC_ClockConfig_7
   1107            {
   1108              assert_param(IS_RCC_SYSCLKSOURCE(pClkInitStruct->SYSCLKSource));
   1109          
   1110              /* PLL is selected as System Clock Source */
   1111              if (pClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \       0xC2   0x6860             LDR      R0,[R4, #+4]
   \       0xC4   0x2803             CMP      R0,#+3
   \       0xC6   0xD105             BNE.N    ??HAL_RCC_ClockConfig_8
   1112              {
   1113                /* Check the PLL ready flag */
   1114                if (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
   \       0xC8   0x....             LDR.N    R0,??DataTable3_1
   \       0xCA   0x6800             LDR      R0,[R0, #+0]
   \       0xCC   0x0180             LSLS     R0,R0,#+6
   \       0xCE   0xD419             BMI.N    ??HAL_RCC_ClockConfig_9
   1115                {
   1116                  return HAL_ERROR;
   \       0xD0   0x2001             MOVS     R0,#+1
   \       0xD2   0xE0CC             B.N      ??HAL_RCC_ClockConfig_1
   1117                }
   1118              }
   1119              else
   1120              {
   1121                /* HSE is selected as System Clock Source */
   1122                if (pClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \                     ??HAL_RCC_ClockConfig_8: (+1)
   \       0xD4   0x6860             LDR      R0,[R4, #+4]
   \       0xD6   0x2802             CMP      R0,#+2
   \       0xD8   0xD105             BNE.N    ??HAL_RCC_ClockConfig_10
   1123                {
   1124                  /* Check the HSE ready flag */
   1125                  if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
   \       0xDA   0x....             LDR.N    R0,??DataTable3_1
   \       0xDC   0x6800             LDR      R0,[R0, #+0]
   \       0xDE   0x0380             LSLS     R0,R0,#+14
   \       0xE0   0xD410             BMI.N    ??HAL_RCC_ClockConfig_9
   1126                  {
   1127                    return HAL_ERROR;
   \       0xE2   0x2001             MOVS     R0,#+1
   \       0xE4   0xE0C3             B.N      ??HAL_RCC_ClockConfig_1
   1128                  }
   1129                }
   1130                /* CSI is selected as System Clock Source */
   1131                else if (pClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
   \                     ??HAL_RCC_ClockConfig_10: (+1)
   \       0xE6   0x6860             LDR      R0,[R4, #+4]
   \       0xE8   0x2801             CMP      R0,#+1
   \       0xEA   0xD105             BNE.N    ??HAL_RCC_ClockConfig_11
   1132                {
   1133                  /* Check the CSI ready flag */
   1134                  if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) == 0U)
   \       0xEC   0x....             LDR.N    R0,??DataTable3_1
   \       0xEE   0x6800             LDR      R0,[R0, #+0]
   \       0xF0   0x0580             LSLS     R0,R0,#+22
   \       0xF2   0xD407             BMI.N    ??HAL_RCC_ClockConfig_9
   1135                  {
   1136                    return HAL_ERROR;
   \       0xF4   0x2001             MOVS     R0,#+1
   \       0xF6   0xE0BA             B.N      ??HAL_RCC_ClockConfig_1
   1137                  }
   1138                }
   1139                /* HSI is selected as System Clock Source */
   1140                else
   1141                {
   1142                  /* Check the HSI ready flag */
   1143                  if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
   \                     ??HAL_RCC_ClockConfig_11: (+1)
   \       0xF8   0x....             LDR.N    R0,??DataTable3_1
   \       0xFA   0x6800             LDR      R0,[R0, #+0]
   \       0xFC   0x0780             LSLS     R0,R0,#+30
   \       0xFE   0xD401             BMI.N    ??HAL_RCC_ClockConfig_9
   1144                  {
   1145                    return HAL_ERROR;
   \      0x100   0x2001             MOVS     R0,#+1
   \      0x102   0xE0B4             B.N      ??HAL_RCC_ClockConfig_1
   1146                  }
   1147                }
   1148              }
   1149          
   1150              MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SW, pClkInitStruct->SYSCLKSource);
   \                     ??HAL_RCC_ClockConfig_9: (+1)
   \      0x104   0x.... 0x....      LDR.W    R7,??DataTable8_1
   \      0x108   0x6839             LDR      R1,[R7, #+0]
   \      0x10A   0x0889             LSRS     R1,R1,#+2
   \      0x10C   0x0089             LSLS     R1,R1,#+2
   \      0x10E   0x6860             LDR      R0,[R4, #+4]
   \      0x110   0x4301             ORRS     R1,R0,R1
   \      0x112   0x6039             STR      R1,[R7, #+0]
   1151          
   1152              /* Get Start Tick*/
   1153              tickstart = HAL_GetTick();
   \      0x114   0x.... 0x....      BL       HAL_GetTick
   \      0x118   0x4680             MOV      R8,R0
   1154          
   1155              if (pClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \      0x11A   0x6860             LDR      R0,[R4, #+4]
   \      0x11C   0x2803             CMP      R0,#+3
   \      0x11E   0xD10E             BNE.N    ??HAL_RCC_ClockConfig_12
   1156              {
   1157                while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_13: (+1)
   \      0x120   0x6838             LDR      R0,[R7, #+0]
   \      0x122   0xF010 0x0018      ANDS     R0,R0,#0x18
   \      0x126   0x2818             CMP      R0,#+24
   \      0x128   0xD03B             BEQ.N    ??HAL_RCC_ClockConfig_7
   1158                {
   1159                  if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
   \      0x12A   0x.... 0x....      BL       HAL_GetTick
   \      0x12E   0xEBB0 0x0008      SUBS     R0,R0,R8
   \      0x132   0xF241 0x3189      MOVW     R1,#+5001
   \      0x136   0x4288             CMP      R0,R1
   \      0x138   0xD3F2             BCC.N    ??HAL_RCC_ClockConfig_13
   1160                  {
   1161                    return HAL_TIMEOUT;
   \      0x13A   0x2003             MOVS     R0,#+3
   \      0x13C   0xE097             B.N      ??HAL_RCC_ClockConfig_1
   1162                  }
   1163                }
   1164              }
   1165              else
   1166              {
   1167                if (pClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \                     ??HAL_RCC_ClockConfig_12: (+1)
   \      0x13E   0x6860             LDR      R0,[R4, #+4]
   \      0x140   0x2802             CMP      R0,#+2
   \      0x142   0xD10E             BNE.N    ??HAL_RCC_ClockConfig_14
   1168                {
   1169                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
   \                     ??HAL_RCC_ClockConfig_15: (+1)
   \      0x144   0x6838             LDR      R0,[R7, #+0]
   \      0x146   0xF010 0x0018      ANDS     R0,R0,#0x18
   \      0x14A   0x2810             CMP      R0,#+16
   \      0x14C   0xD029             BEQ.N    ??HAL_RCC_ClockConfig_7
   1170                  {
   1171                    if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
   \      0x14E   0x.... 0x....      BL       HAL_GetTick
   \      0x152   0xEBB0 0x0008      SUBS     R0,R0,R8
   \      0x156   0xF241 0x3189      MOVW     R1,#+5001
   \      0x15A   0x4288             CMP      R0,R1
   \      0x15C   0xD3F2             BCC.N    ??HAL_RCC_ClockConfig_15
   1172                    {
   1173                      return HAL_TIMEOUT;
   \      0x15E   0x2003             MOVS     R0,#+3
   \      0x160   0xE085             B.N      ??HAL_RCC_ClockConfig_1
   1174                    }
   1175                  }
   1176                }
   1177                else if (pClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
   \                     ??HAL_RCC_ClockConfig_14: (+1)
   \      0x162   0x6860             LDR      R0,[R4, #+4]
   \      0x164   0x2801             CMP      R0,#+1
   \      0x166   0xD10E             BNE.N    ??HAL_RCC_ClockConfig_16
   1178                {
   1179                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_CSI)
   \                     ??HAL_RCC_ClockConfig_17: (+1)
   \      0x168   0x6838             LDR      R0,[R7, #+0]
   \      0x16A   0xF010 0x0018      ANDS     R0,R0,#0x18
   \      0x16E   0x2808             CMP      R0,#+8
   \      0x170   0xD017             BEQ.N    ??HAL_RCC_ClockConfig_7
   1180                  {
   1181                    if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
   \      0x172   0x.... 0x....      BL       HAL_GetTick
   \      0x176   0xEBB0 0x0008      SUBS     R0,R0,R8
   \      0x17A   0xF241 0x3189      MOVW     R1,#+5001
   \      0x17E   0x4288             CMP      R0,R1
   \      0x180   0xD3F2             BCC.N    ??HAL_RCC_ClockConfig_17
   1182                    {
   1183                      return HAL_TIMEOUT;
   \      0x182   0x2003             MOVS     R0,#+3
   \      0x184   0xE073             B.N      ??HAL_RCC_ClockConfig_1
   1184                    }
   1185                  }
   1186                }
   1187                else
   1188                {
   1189                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
   \                     ??HAL_RCC_ClockConfig_16: (+1)
   \      0x186   0x6838             LDR      R0,[R7, #+0]
   \      0x188   0xF010 0x0F18      TST      R0,#0x18
   \      0x18C   0xD009             BEQ.N    ??HAL_RCC_ClockConfig_7
   1190                  {
   1191                    if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
   \      0x18E   0x.... 0x....      BL       HAL_GetTick
   \      0x192   0xEBB0 0x0008      SUBS     R0,R0,R8
   \      0x196   0xF241 0x3189      MOVW     R1,#+5001
   \      0x19A   0x4288             CMP      R0,R1
   \      0x19C   0xD3F3             BCC.N    ??HAL_RCC_ClockConfig_16
   1192                    {
   1193                      return HAL_TIMEOUT;
   \      0x19E   0x2003             MOVS     R0,#+3
   \      0x1A0   0xE065             B.N      ??HAL_RCC_ClockConfig_1
   1194                    }
   1195                  }
   1196                }
   1197              }
   1198            }
   1199          
   1200            /* Decreasing the BUS frequency divider */
   1201            /*-------------------------- HCLK Configuration --------------------------*/
   1202            if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
   \                     ??HAL_RCC_ClockConfig_7: (+1)
   \      0x1A2   0x7820             LDRB     R0,[R4, #+0]
   \      0x1A4   0x0780             LSLS     R0,R0,#+30
   \      0x1A6   0xD50C             BPL.N    ??HAL_RCC_ClockConfig_18
   1203            {
   1204              if ((pClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
   \      0x1A8   0x....             LDR.N    R1,??DataTable3_5
   \      0x1AA   0x68A0             LDR      R0,[R4, #+8]
   \      0x1AC   0x680A             LDR      R2,[R1, #+0]
   \      0x1AE   0xF012 0x020F      ANDS     R2,R2,#0xF
   \      0x1B2   0x4290             CMP      R0,R2
   \      0x1B4   0xD205             BCS.N    ??HAL_RCC_ClockConfig_18
   1205              {
   1206                assert_param(IS_RCC_HCLK(pClkInitStruct->AHBCLKDivider));
   1207                MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pClkInitStruct->AHBCLKDivider);
   \      0x1B6   0x680A             LDR      R2,[R1, #+0]
   \      0x1B8   0x0912             LSRS     R2,R2,#+4
   \      0x1BA   0x0112             LSLS     R2,R2,#+4
   \      0x1BC   0x68A0             LDR      R0,[R4, #+8]
   \      0x1BE   0x4302             ORRS     R2,R0,R2
   \      0x1C0   0x600A             STR      R2,[R1, #+0]
   1208              }
   1209            }
   1210          
   1211            /* Decreasing the number of wait states because of lower CPU frequency */
   1212            if (FLatency < __HAL_FLASH_GET_LATENCY())
   \                     ??HAL_RCC_ClockConfig_18: (+1)
   \      0x1C2   0x6828             LDR      R0,[R5, #+0]
   \      0x1C4   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x1C8   0x4286             CMP      R6,R0
   \      0x1CA   0xD20B             BCS.N    ??HAL_RCC_ClockConfig_19
   1213            {
   1214              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
   1215              __HAL_FLASH_SET_LATENCY(FLatency);
   \      0x1CC   0x6828             LDR      R0,[R5, #+0]
   \      0x1CE   0x0900             LSRS     R0,R0,#+4
   \      0x1D0   0x0100             LSLS     R0,R0,#+4
   \      0x1D2   0x4330             ORRS     R0,R6,R0
   \      0x1D4   0x6028             STR      R0,[R5, #+0]
   1216          
   1217              /* Check that the new number of wait states is taken into account to access the Flash
   1218              memory by reading the FLASH_ACR register */
   1219              if (__HAL_FLASH_GET_LATENCY() != FLatency)
   \      0x1D6   0x6828             LDR      R0,[R5, #+0]
   \      0x1D8   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x1DC   0x42B0             CMP      R0,R6
   \      0x1DE   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_19
   1220              {
   1221                return HAL_ERROR;
   \      0x1E0   0x2001             MOVS     R0,#+1
   \      0x1E2   0xE044             B.N      ??HAL_RCC_ClockConfig_1
   1222              }
   1223            }
   1224          
   1225            /*-------------------------- PCLK1 Configuration ---------------------------*/
   1226            if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
   \                     ??HAL_RCC_ClockConfig_19: (+1)
   \      0x1E4   0x7820             LDRB     R0,[R4, #+0]
   \      0x1E6   0x0740             LSLS     R0,R0,#+29
   \      0x1E8   0xD50C             BPL.N    ??HAL_RCC_ClockConfig_20
   1227            {
   1228              if ((pClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
   \      0x1EA   0x....             LDR.N    R1,??DataTable3_5
   \      0x1EC   0x68E0             LDR      R0,[R4, #+12]
   \      0x1EE   0x680A             LDR      R2,[R1, #+0]
   \      0x1F0   0xF012 0x0270      ANDS     R2,R2,#0x70
   \      0x1F4   0x4290             CMP      R0,R2
   \      0x1F6   0xD205             BCS.N    ??HAL_RCC_ClockConfig_20
   1229              {
   1230                assert_param(IS_RCC_PCLK(pClkInitStruct->APB1CLKDivider));
   1231                MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, pClkInitStruct->APB1CLKDivider);
   \      0x1F8   0x680A             LDR      R2,[R1, #+0]
   \      0x1FA   0xF032 0x0270      BICS     R2,R2,#0x70
   \      0x1FE   0x68E0             LDR      R0,[R4, #+12]
   \      0x200   0x4302             ORRS     R2,R0,R2
   \      0x202   0x600A             STR      R2,[R1, #+0]
   1232              }
   1233            }
   1234          
   1235            /*-------------------------- PCLK2 Configuration ---------------------------*/
   1236            if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
   \                     ??HAL_RCC_ClockConfig_20: (+1)
   \      0x204   0x7820             LDRB     R0,[R4, #+0]
   \      0x206   0x0700             LSLS     R0,R0,#+28
   \      0x208   0xD50E             BPL.N    ??HAL_RCC_ClockConfig_21
   1237            {
   1238              if ((pClkInitStruct->APB2CLKDivider) < ((RCC->CFGR2 & RCC_CFGR2_PPRE2) >> 4))
   \      0x20A   0x....             LDR.N    R0,??DataTable3_5
   \      0x20C   0x6921             LDR      R1,[R4, #+16]
   \      0x20E   0x6802             LDR      R2,[R0, #+0]
   \      0x210   0x0912             LSRS     R2,R2,#+4
   \      0x212   0xF012 0x0270      ANDS     R2,R2,#0x70
   \      0x216   0x4291             CMP      R1,R2
   \      0x218   0xD206             BCS.N    ??HAL_RCC_ClockConfig_21
   1239              {
   1240                assert_param(IS_RCC_PCLK(pClkInitStruct->APB2CLKDivider));
   1241                MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, ((pClkInitStruct->APB2CLKDivider) << 4));
   \      0x21A   0x6801             LDR      R1,[R0, #+0]
   \      0x21C   0xF431 0x61E0      BICS     R1,R1,#0x700
   \      0x220   0x6922             LDR      R2,[R4, #+16]
   \      0x222   0xEA51 0x1102      ORRS     R1,R1,R2, LSL #+4
   \      0x226   0x6001             STR      R1,[R0, #+0]
   1242              }
   1243            }
   1244          
   1245            /*-------------------------- PCLK3 Configuration ---------------------------*/
   1246            if (((pClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK3) == RCC_CLOCKTYPE_PCLK3)
   \                     ??HAL_RCC_ClockConfig_21: (+1)
   \      0x228   0x7820             LDRB     R0,[R4, #+0]
   \      0x22A   0x06C0             LSLS     R0,R0,#+27
   \      0x22C   0xD50E             BPL.N    ??HAL_RCC_ClockConfig_22
   1247            {
   1248              if ((pClkInitStruct->APB3CLKDivider) < ((RCC->CFGR2 & RCC_CFGR2_PPRE3) >> 8))
   \      0x22E   0x....             LDR.N    R0,??DataTable3_5
   \      0x230   0x6961             LDR      R1,[R4, #+20]
   \      0x232   0x6802             LDR      R2,[R0, #+0]
   \      0x234   0x0A12             LSRS     R2,R2,#+8
   \      0x236   0xF012 0x0270      ANDS     R2,R2,#0x70
   \      0x23A   0x4291             CMP      R1,R2
   \      0x23C   0xD206             BCS.N    ??HAL_RCC_ClockConfig_22
   1249              {
   1250                assert_param(IS_RCC_PCLK(pClkInitStruct->APB3CLKDivider));
   1251                MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE3, ((pClkInitStruct->APB3CLKDivider) << 8));
   \      0x23E   0x6801             LDR      R1,[R0, #+0]
   \      0x240   0xF431 0x41E0      BICS     R1,R1,#0x7000
   \      0x244   0x6962             LDR      R2,[R4, #+20]
   \      0x246   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \      0x24A   0x6001             STR      R1,[R0, #+0]
   1252              }
   1253            }
   1254          
   1255            /* Update the SystemCoreClock global variable */
   1256            SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
   \                     ??HAL_RCC_ClockConfig_22: (+1)
   \      0x24C   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \      0x250   0x.... 0x....      LDR.W    R1,??DataTable15_6
   \      0x254   0x....             LDR.N    R2,??DataTable3_5
   \      0x256   0x6812             LDR      R2,[R2, #+0]
   \      0x258   0xF012 0x020F      ANDS     R2,R2,#0xF
   \      0x25C   0x5C89             LDRB     R1,[R1, R2]
   \      0x25E   0x40C8             LSRS     R0,R0,R1
   \      0x260   0x....             LDR.N    R1,??DataTable8
   \      0x262   0x6008             STR      R0,[R1, #+0]
   1257          
   1258            /* Configure the source of time base considering new system clocks settings*/
   1259            halstatus = HAL_InitTick(uwTickPrio);
   \      0x264   0x....             LDR.N    R0,??DataTable3_3
   \      0x266   0x6800             LDR      R0,[R0, #+0]
   \      0x268   0x.... 0x....      BL       HAL_InitTick
   1260          
   1261            return halstatus;
   \      0x26C   0xB2C0             UXTB     R0,R0
   \                     ??HAL_RCC_ClockConfig_1: (+1)
   \      0x26E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1262          }
   1263          
   1264          /**
   1265            * @}
   1266            */
   1267          
   1268          /** @defgroup RCC_Exported_Functions_Group2 Peripheral Control functions
   1269            *  @brief   RCC clocks control functions
   1270            *
   1271          @verbatim
   1272           ===============================================================================
   1273                                ##### Peripheral Control functions #####
   1274           ===============================================================================
   1275              [..]
   1276              This subsection provides a set of functions allowing to:
   1277          
   1278              (+) Output clock to MCO pin.
   1279              (+) Retrieve current clock frequencies.
   1280              (+) Enable the Clock Security System.
   1281          
   1282          @endverbatim
   1283            * @{
   1284            */
   1285          
   1286          /**
   1287            * @brief  Select the clock source to output on MCO1 pin(PA8) or on MCO2 pin(PC9).
   1288            * @note   PA8/PC9 should be configured in alternate function mode.
   1289            * @param  RCC_MCOx  specifies the output direction for the clock source.
   1290            *          For STM32H5xx family this parameter can have only one value:
   1291            *            @arg @ref RCC_MCO1  Clock source to output on MCO1 pin(PA8).
   1292            *            @arg @ref RCC_MCO2  Clock source to output on MCO2 pin(PC9).
   1293            * @param  RCC_MCOSource  specifies the clock source to output.
   1294            *          This parameter can be one of the following values:
   1295            *            @arg RCC_MCO1SOURCE_HSI: HSI clock selected as MCO1 source
   1296            *            @arg RCC_MCO1SOURCE_LSE: LSE clock selected as MCO1 source
   1297            *            @arg RCC_MCO1SOURCE_HSE: HSE clock selected as MCO1 source
   1298            *            @arg RCC_MCO1SOURCE_PLL1QCLK:  PLL1Q clock selected as MCO1 source
   1299            *            @arg RCC_MCO1SOURCE_HSI48: HSI48 (48MHZ) selected as MCO1 source
   1300            *            @arg RCC_MCO2SOURCE_SYSCLK: System clock (SYSCLK) selected as MCO2 source
   1301            *            @arg RCC_MCO2SOURCE_PLL2PCLK: PLL2P clock selected as MCO2 source
   1302            *            @arg RCC_MCO2SOURCE_HSE: HSE clock selected as MCO2 source
   1303            *            @arg RCC_MCO2SOURCE_PLL1PCLK:  PLL1P clock selected as MCO2 source
   1304            *            @arg RCC_MCO2SOURCE_CSI:  CSI clock selected as MCO2 source
   1305            *            @arg RCC_MCO2SOURCE_LSI:  LSI clock selected as MCO2 source
   1306            * @param  RCC_MCODiv  specifies the MCO prescaler.
   1307            *          This parameter can be one of the following values:
   1308            *            @arg RCC_MCODIV_1 up to RCC_MCODIV_15  : divider applied to MCOx clock
   1309            * @retval None
   1310            */

   \                                 In section .text, align 2, keep-with-next
   1311          void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
   1312          {
   \                     HAL_RCC_MCOConfig: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   1313            GPIO_InitTypeDef GPIO_InitStruct;
   1314            /* Check the parameters */
   1315            assert_param(IS_RCC_MCO(RCC_MCOx));
   1316            assert_param(IS_RCC_MCODIV(RCC_MCODiv));
   1317            /* RCC_MCO1 */
   1318            if (RCC_MCOx == RCC_MCO1)
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD123             BNE.N    ??HAL_RCC_MCOConfig_0
   1319            {
   1320              assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
   1321          
   1322              /* MCO1 Clock Enable */
   1323              MCO1_CLK_ENABLE();
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x16   0x6001             STR      R1,[R0, #+0]
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x1E   0x9005             STR      R0,[SP, #+20]
   \       0x20   0x9805             LDR      R0,[SP, #+20]
   1324          
   1325              /* Configure the MCO1 pin in alternate function mode */
   1326              GPIO_InitStruct.Pin = MCO1_PIN;
   \       0x22   0xF44F 0x7080      MOV      R0,#+256
   \       0x26   0x9000             STR      R0,[SP, #+0]
   1327              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \       0x28   0x2002             MOVS     R0,#+2
   \       0x2A   0x9001             STR      R0,[SP, #+4]
   1328              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \       0x2C   0x2003             MOVS     R0,#+3
   \       0x2E   0x9003             STR      R0,[SP, #+12]
   1329              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x9002             STR      R0,[SP, #+8]
   1330              GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x9004             STR      R0,[SP, #+16]
   1331              HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
   \       0x38   0x4669             MOV      R1,SP
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0x3E   0x.... 0x....      BL       HAL_GPIO_Init
   1332          
   1333              /* Mask MCO1 and MCO1PRE[3:0] bits then Select MCO1 clock source and pre-scaler */
   1334              MODIFY_REG(RCC->CFGR1, (RCC_CFGR1_MCO1SEL | RCC_CFGR1_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable15_9
   \       0x46   0x6801             LDR      R1,[R0, #+0]
   \       0x48   0xF031 0x71FE      BICS     R1,R1,#0x1FC0000
   \       0x4C   0x430C             ORRS     R4,R4,R1
   \       0x4E   0x432C             ORRS     R4,R5,R4
   \       0x50   0x6004             STR      R4,[R0, #+0]
   \       0x52   0xE023             B.N      ??HAL_RCC_MCOConfig_1
   1335            }
   1336            else
   1337            {
   1338              assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));
   1339          
   1340              /* MCO2 Clock Enable */
   1341              MCO2_CLK_ENABLE();
   \                     ??HAL_RCC_MCOConfig_0: (+1)
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \       0x58   0x6801             LDR      R1,[R0, #+0]
   \       0x5A   0xF051 0x0104      ORRS     R1,R1,#0x4
   \       0x5E   0x6001             STR      R1,[R0, #+0]
   \       0x60   0x6800             LDR      R0,[R0, #+0]
   \       0x62   0xF010 0x0004      ANDS     R0,R0,#0x4
   \       0x66   0x9005             STR      R0,[SP, #+20]
   \       0x68   0x9805             LDR      R0,[SP, #+20]
   1342          
   1343              /* Configure the MCO2 pin in alternate function mode */
   1344              GPIO_InitStruct.Pin = MCO2_PIN;
   \       0x6A   0xF44F 0x7000      MOV      R0,#+512
   \       0x6E   0x9000             STR      R0,[SP, #+0]
   1345              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \       0x70   0x2002             MOVS     R0,#+2
   \       0x72   0x9001             STR      R0,[SP, #+4]
   1346              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \       0x74   0x2003             MOVS     R0,#+3
   \       0x76   0x9003             STR      R0,[SP, #+12]
   1347              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0x9002             STR      R0,[SP, #+8]
   1348              GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x9004             STR      R0,[SP, #+16]
   1349              HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
   \       0x80   0x4669             MOV      R1,SP
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable15_10
   \       0x86   0x.... 0x....      BL       HAL_GPIO_Init
   1350          
   1351              /* Mask MCO2 and MCO2PRE[3:0] bits then Select MCO2 clock source and pre-scaler */
   1352              MODIFY_REG(RCC->CFGR1, (RCC_CFGR1_MCO2SEL | RCC_CFGR1_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
   \       0x8A   0x.... 0x....      LDR.W    R0,??DataTable15_9
   \       0x8E   0x6801             LDR      R1,[R0, #+0]
   \       0x90   0xF021 0x417E      BIC      R1,R1,#0xFE000000
   \       0x94   0x430C             ORRS     R4,R4,R1
   \       0x96   0xEA54 0x14C5      ORRS     R4,R4,R5, LSL #+7
   \       0x9A   0x6004             STR      R4,[R0, #+0]
   1353            }
   1354          }
   \                     ??HAL_RCC_MCOConfig_1: (+1)
   \       0x9C   0xB007             ADD      SP,SP,#+28
   \       0x9E   0xBD30             POP      {R4,R5,PC}
   1355          
   1356          /**
   1357            * @brief  Return the SYSCLK frequency.
   1358            *
   1359            * @note   The system frequency computed by this function may not be the real
   1360            *         frequency in the chip. It is calculated based on the predefined
   1361            *         constants of the selected clock source:
   1362            * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
   1363            * @note     If SYSCLK source is CSI, function returns values based on CSI_VALUE(**)
   1364            * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(***)
   1365            * @note     If SYSCLK source is PLL, function returns values based on HSI_VALUE(*), CSI_VALUE(**)
   1366            *           or HSE_VALUE(***) multiplied/divided by the PLL factors.
   1367            * @note     (*) HSI_VALUE is a constant defined in stm32h5xx_hal_conf.h file (default value
   1368            *               64 MHz) but the real value may vary depending on the variations
   1369            *               in voltage and temperature.
   1370            * @note     (**) CSI_VALUE is a constant defined in stm32h5xx_hal_conf.h file (default value
   1371            *               4 MHz) but the real value may vary depending on the variations
   1372            *               in voltage and temperature.
   1373            * @note     (***) HSE_VALUE is a constant defined in stm32h5xx_hal_conf.h file (default value
   1374            *                24 MHz), user has to ensure that HSE_VALUE is same as the real
   1375            *                frequency of the crystal used. Otherwise, this function may
   1376            *                have wrong result.
   1377            *
   1378            * @note   The result of this function could be not correct when using fractional
   1379            *         value for HSE crystal.
   1380            *
   1381            * @note   This function can be used by the user application to compute the
   1382            *         baudrate for the communication peripherals or configure other parameters.
   1383            *
   1384            * @note   Each time SYSCLK changes, this function must be called to update the
   1385            *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
   1386            *
   1387            *
   1388            * @retval SYSCLK frequency
   1389            */

   \                                 In section .text, align 4, keep-with-next
   1390          uint32_t HAL_RCC_GetSysClockFreq(void)
   1391          {
   1392            uint32_t pllsource;
   1393            uint32_t pllp;
   1394            uint32_t pllm;
   1395            uint32_t pllfracen;
   1396            uint32_t sysclockfreq;
   1397            uint32_t hsivalue;
   1398            float_t fracn1;
   1399            float_t pllvco;
   1400          
   1401            if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_CSI)
   \                     HAL_RCC_GetSysClockFreq: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable8_1
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF011 0x0118      ANDS     R1,R1,#0x18
   \        0x8   0x2908             CMP      R1,#+8
   \        0xA   0xD102             BNE.N    ??HAL_RCC_GetSysClockFreq_0
   1402            {
   1403              /* CSI used as system clock  source */
   1404              sysclockfreq = CSI_VALUE;
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable15_11
   \       0x10   0xE0CB             B.N      ??HAL_RCC_GetSysClockFreq_1
   1405            }
   1406            else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
   \                     ??HAL_RCC_GetSysClockFreq_0: (+1)
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0xF011 0x0F18      TST      R1,#0x18
   \       0x18   0xD10C             BNE.N    ??HAL_RCC_GetSysClockFreq_2
   1407            {
   1408              /* HSI used as system clock source */
   1409              if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVF) != 0U)
   \       0x1A   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \       0x1E   0x6808             LDR      R0,[R1, #+0]
   \       0x20   0x0680             LSLS     R0,R0,#+26
   \       0x22   0xD505             BPL.N    ??HAL_RCC_GetSysClockFreq_3
   1410              {
   1411                sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \       0x24   0x....             LDR.N    R0,??DataTable4_2
   \       0x26   0x6809             LDR      R1,[R1, #+0]
   \       0x28   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \       0x2C   0x40C8             LSRS     R0,R0,R1
   \       0x2E   0xE0BC             B.N      ??HAL_RCC_GetSysClockFreq_1
   1412              }
   1413              else
   1414              {
   1415                sysclockfreq = (uint32_t) HSI_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_3: (+1)
   \       0x30   0x....             LDR.N    R0,??DataTable4_2
   \       0x32   0xE0BA             B.N      ??HAL_RCC_GetSysClockFreq_1
   1416              }
   1417            }
   1418            else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
   \                     ??HAL_RCC_GetSysClockFreq_2: (+1)
   \       0x34   0x6801             LDR      R1,[R0, #+0]
   \       0x36   0xF011 0x0118      ANDS     R1,R1,#0x18
   \       0x3A   0x2910             CMP      R1,#+16
   \       0x3C   0xD102             BNE.N    ??HAL_RCC_GetSysClockFreq_4
   1419            {
   1420              /* HSE used as system clock source */
   1421              sysclockfreq = HSE_VALUE;
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable15_13
   \       0x42   0xE0B2             B.N      ??HAL_RCC_GetSysClockFreq_1
   1422            }
   1423          
   1424            else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \                     ??HAL_RCC_GetSysClockFreq_4: (+1)
   \       0x44   0x6800             LDR      R0,[R0, #+0]
   \       0x46   0xF010 0x0018      ANDS     R0,R0,#0x18
   \       0x4A   0x2818             CMP      R0,#+24
   \       0x4C   0xF040 0x80AC      BNE.W    ??HAL_RCC_GetSysClockFreq_5
   1425            {
   1426              /* PLL used as system clock  source */
   1427          
   1428              /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
   1429              SYSCLK = PLL_VCO / PLLR
   1430              */
   1431              pllsource = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
   \       0x50   0x.... 0x....      LDR.W    R1,??DataTable15_14
   \       0x54   0x680A             LDR      R2,[R1, #+0]
   \       0x56   0xF012 0x0203      ANDS     R2,R2,#0x3
   1432              pllm = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos);
   \       0x5A   0x6808             LDR      R0,[R1, #+0]
   \       0x5C   0xF3C0 0x2005      UBFX     R0,R0,#+8,#+6
   1433              pllfracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
   \       0x60   0x6809             LDR      R1,[R1, #+0]
   \       0x62   0xF3C1 0x1300      UBFX     R3,R1,#+4,#+1
   1434              fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & \
   1435                                                         RCC_PLL1FRACR_PLL1FRACN) >> RCC_PLL1FRACR_PLL1FRACN_Pos));
   \       0x66   0x....             LDR.N    R1,??DataTable15_4
   \       0x68   0x6809             LDR      R1,[R1, #+0]
   \       0x6A   0xF3C1 0x01CC      UBFX     R1,R1,#+3,#+13
   \       0x6E   0x434B             MULS     R3,R1,R3
   \       0x70   0xEE00 0x3A10      VMOV     S0,R3
   \       0x74   0xEEF8 0x0A40      VCVT.F32.U32 S1,S0
   1436          
   1437              if (pllm != 0U)
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xF000 0x8093      BEQ.W    ??HAL_RCC_GetSysClockFreq_6
   1438              {
   1439                switch (pllsource)
   \       0x7E   0x2A01             CMP      R2,#+1
   \       0x80   0xD002             BEQ.N    ??HAL_RCC_GetSysClockFreq_7
   \       0x82   0x2A03             CMP      R2,#+3
   \       0x84   0xD045             BEQ.N    ??HAL_RCC_GetSysClockFreq_8
   \       0x86   0xE061             B.N      ??HAL_RCC_GetSysClockFreq_9
   1440                {
   1441                  case RCC_PLL1_SOURCE_HSI:  /* HSI used as PLL1 clock source */
   1442          
   1443                    if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVF) != 0U)
   \                     ??HAL_RCC_GetSysClockFreq_7: (+1)
   \       0x88   0x....             LDR.N    R1,??DataTable15_12
   \       0x8A   0x680A             LDR      R2,[R1, #+0]
   \       0x8C   0x0692             LSLS     R2,R2,#+26
   \       0x8E   0xD523             BPL.N    ??HAL_RCC_GetSysClockFreq_10
   1444                    {
   1445                      hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
   \       0x90   0x....             LDR.N    R2,??DataTable4_2
   \       0x92   0x6809             LDR      R1,[R1, #+0]
   \       0x94   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \       0x98   0x40CA             LSRS     R2,R2,R1
   \       0x9A   0xEE00 0x2A10      VMOV     S0,R2
   1446                      pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
   1447                                                                      (fracn1 / (float_t)0x2000) + (float_t)1);
   \       0x9E   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \       0xA2   0xEE01 0x0A10      VMOV     S2,R0
   \       0xA6   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \       0xAA   0xEE80 0x0A01      VDIV.F32 S0,S0,S2
   \       0xAE   0x....             LDR.N    R0,??DataTable15_15
   \       0xB0   0x6800             LDR      R0,[R0, #+0]
   \       0xB2   0x05C0             LSLS     R0,R0,#+23
   \       0xB4   0x0DC0             LSRS     R0,R0,#+23
   \       0xB6   0xEE01 0x0A10      VMOV     S2,R0
   \       0xBA   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \       0xBE   0xEDDF 0x....      VLDR.W   S3,??DataTable13
   \       0xC2   0xEEC0 0x0AA1      VDIV.F32 S1,S1,S3
   \       0xC6   0xEE71 0x0A20      VADD.F32 S1,S2,S1
   \       0xCA   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \       0xCE   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \       0xD2   0xEE60 0x0A20      VMUL.F32 S1,S0,S1
   \       0xD6   0xE01B             B.N      ??HAL_RCC_GetSysClockFreq_11
   1448                    }
   1449                    else
   1450                    {
   1451                      pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
   1452                                                                       (fracn1 / (float_t)0x2000) + (float_t)1);
   \                     ??HAL_RCC_GetSysClockFreq_10: (+1)
   \       0xD8   0xEE00 0x0A10      VMOV     S0,R0
   \       0xDC   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \       0xE0   0xED9F 0x....      VLDR.W   S2,??DataTable14
   \       0xE4   0xEE81 0x0A00      VDIV.F32 S0,S2,S0
   \       0xE8   0x....             LDR.N    R0,??DataTable15_15
   \       0xEA   0x6800             LDR      R0,[R0, #+0]
   \       0xEC   0x05C0             LSLS     R0,R0,#+23
   \       0xEE   0x0DC0             LSRS     R0,R0,#+23
   \       0xF0   0xEE01 0x0A10      VMOV     S2,R0
   \       0xF4   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \       0xF8   0xEDDF 0x....      VLDR.W   S3,??DataTable13
   \       0xFC   0xEEC0 0x0AA1      VDIV.F32 S1,S1,S3
   \      0x100   0xEE71 0x0A20      VADD.F32 S1,S2,S1
   \      0x104   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x108   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \      0x10C   0xEE60 0x0A20      VMUL.F32 S1,S0,S1
   1453                    }
   1454          
   1455                    break;
   \                     ??HAL_RCC_GetSysClockFreq_11: (+1)
   \      0x110   0xE038             B.N      ??HAL_RCC_GetSysClockFreq_12
   1456          
   1457                  case RCC_PLL1_SOURCE_HSE:  /* HSE used as PLL1 clock source */
   1458                    pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
   1459                                                                     (fracn1 / (float_t)0x2000) + (float_t)1);
   \                     ??HAL_RCC_GetSysClockFreq_8: (+1)
   \      0x112   0xEE00 0x0A10      VMOV     S0,R0
   \      0x116   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \      0x11A   0xED9F 0x....      VLDR.W   S2,??DataTable14_1
   \      0x11E   0xEE81 0x0A00      VDIV.F32 S0,S2,S0
   \      0x122   0x....             LDR.N    R0,??DataTable15_15
   \      0x124   0x6800             LDR      R0,[R0, #+0]
   \      0x126   0x05C0             LSLS     R0,R0,#+23
   \      0x128   0x0DC0             LSRS     R0,R0,#+23
   \      0x12A   0xEE01 0x0A10      VMOV     S2,R0
   \      0x12E   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \      0x132   0xEDDF 0x....      VLDR.W   S3,??DataTable13
   \      0x136   0xEEC0 0x0AA1      VDIV.F32 S1,S1,S3
   \      0x13A   0xEE71 0x0A20      VADD.F32 S1,S2,S1
   \      0x13E   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x142   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \      0x146   0xEE60 0x0A20      VMUL.F32 S1,S0,S1
   1460          
   1461                    break;
   \      0x14A   0xE01B             B.N      ??HAL_RCC_GetSysClockFreq_12
   1462          
   1463                  case RCC_PLL1_SOURCE_CSI:  /* CSI used as PLL1 clock source */
   1464                  default:
   1465                    pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
   1466                                                                     (fracn1 / (float_t)0x2000) + (float_t)1);
   \                     ??HAL_RCC_GetSysClockFreq_9: (+1)
   \      0x14C   0xEE00 0x0A10      VMOV     S0,R0
   \      0x150   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \      0x154   0xED9F 0x....      VLDR.W   S2,??DataTable15
   \      0x158   0xEE81 0x0A00      VDIV.F32 S0,S2,S0
   \      0x15C   0x....             LDR.N    R0,??DataTable15_15
   \      0x15E   0x6800             LDR      R0,[R0, #+0]
   \      0x160   0x05C0             LSLS     R0,R0,#+23
   \      0x162   0x0DC0             LSRS     R0,R0,#+23
   \      0x164   0xEE01 0x0A10      VMOV     S2,R0
   \      0x168   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \      0x16C   0xEDDF 0x....      VLDR.W   S3,??DataTable13
   \      0x170   0xEEC0 0x0AA1      VDIV.F32 S1,S1,S3
   \      0x174   0xEE71 0x0A20      VADD.F32 S1,S2,S1
   \      0x178   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x17C   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \      0x180   0xEE60 0x0A20      VMUL.F32 S1,S0,S1
   1467                    break;
   1468                }
   1469          
   1470                pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1P) >> RCC_PLL1DIVR_PLL1P_Pos) + 1U) ;
   \                     ??HAL_RCC_GetSysClockFreq_12: (+1)
   \      0x184   0x....             LDR.N    R0,??DataTable15_15
   \      0x186   0x6800             LDR      R0,[R0, #+0]
   \      0x188   0xF3C0 0x2046      UBFX     R0,R0,#+9,#+7
   \      0x18C   0x1C40             ADDS     R0,R0,#+1
   \      0x18E   0xEE00 0x0A10      VMOV     S0,R0
   1471                sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
   \      0x192   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \      0x196   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \      0x19A   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \      0x19E   0xEE10 0x0A10      VMOV     R0,S0
   \      0x1A2   0xE002             B.N      ??HAL_RCC_GetSysClockFreq_1
   1472              }
   1473              else
   1474              {
   1475                sysclockfreq = 0;
   \                     ??HAL_RCC_GetSysClockFreq_6: (+1)
   \      0x1A4   0x2000             MOVS     R0,#+0
   \      0x1A6   0xE000             B.N      ??HAL_RCC_GetSysClockFreq_1
   1476              }
   1477            }
   1478          
   1479            else
   1480            {
   1481              /* HSI is the default system clock source */
   1482              sysclockfreq = (uint32_t) HSI_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_5: (+1)
   \      0x1A8   0x....             LDR.N    R0,??DataTable4_2
   1483            }
   1484          
   1485            return sysclockfreq;
   \                     ??HAL_RCC_GetSysClockFreq_1: (+1)
   \      0x1AA   0x4770             BX       LR
   1486          }
   1487          
   1488          /**
   1489            * @brief  Return the HCLK frequency.
   1490            * @note   Each time HCLK changes, this function must be called to update the
   1491            *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
   1492            *
   1493            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
   1494            * @retval HCLK frequency in Hz
   1495            */

   \                                 In section .text, align 2, keep-with-next
   1496          uint32_t HAL_RCC_GetHCLKFreq(void)
   1497          {
   \                     HAL_RCC_GetHCLKFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1498          
   1499            SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) \
   1500                                                                          >> RCC_CFGR2_HPRE_Pos] & 0x1FU);
   \        0x2   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \        0x6   0x....             LDR.N    R1,??DataTable8
   \        0x8   0x....             LDR.N    R2,??DataTable15_6
   \        0xA   0x....             LDR.N    R3,??DataTable15_16
   \        0xC   0x681B             LDR      R3,[R3, #+0]
   \        0xE   0xF013 0x030F      ANDS     R3,R3,#0xF
   \       0x12   0x5CD2             LDRB     R2,[R2, R3]
   \       0x14   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \       0x18   0x40D0             LSRS     R0,R0,R2
   \       0x1A   0x6008             STR      R0,[R1, #+0]
   1501          
   1502            return SystemCoreClock;
   \       0x1C   0x6808             LDR      R0,[R1, #+0]
   \       0x1E   0xBD02             POP      {R1,PC}
   1503          }
   1504          
   1505          /**
   1506            * @brief  Return the PCLK1 frequency.
   1507            * @note   Each time PCLK1 changes, this function must be called to update the
   1508            *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
   1509            * @retval PCLK1 frequency in Hz
   1510            */

   \                                 In section .text, align 2, keep-with-next
   1511          uint32_t HAL_RCC_GetPCLK1Freq(void)
   1512          {
   \                     HAL_RCC_GetPCLK1Freq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1513            /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
   1514            return (HAL_RCC_GetHCLKFreq() >> ((APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE1) >> RCC_CFGR2_PPRE1_Pos]) & 0x1FU));
   \        0x2   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \        0x6   0x....             LDR.N    R1,??DataTable15_17
   \        0x8   0x....             LDR.N    R2,??DataTable15_16
   \        0xA   0x6812             LDR      R2,[R2, #+0]
   \        0xC   0xF3C2 0x1202      UBFX     R2,R2,#+4,#+3
   \       0x10   0x5C89             LDRB     R1,[R1, R2]
   \       0x12   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \       0x16   0x40C8             LSRS     R0,R0,R1
   \       0x18   0xBD02             POP      {R1,PC}
   1515          }
   1516          
   1517          /**
   1518            * @brief  Return the PCLK2 frequency.
   1519            * @note   Each time PCLK2 changes, this function must be called to update the
   1520            *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
   1521            * @retval PCLK2 frequency in Hz
   1522            */

   \                                 In section .text, align 2, keep-with-next
   1523          uint32_t HAL_RCC_GetPCLK2Freq(void)
   1524          {
   \                     HAL_RCC_GetPCLK2Freq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1525            /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
   1526            return (HAL_RCC_GetHCLKFreq() >> ((APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE2) >> RCC_CFGR2_PPRE2_Pos]) & 0x1FU));
   \        0x2   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \        0x6   0x....             LDR.N    R1,??DataTable15_17
   \        0x8   0x....             LDR.N    R2,??DataTable15_16
   \        0xA   0x6812             LDR      R2,[R2, #+0]
   \        0xC   0xF3C2 0x2202      UBFX     R2,R2,#+8,#+3
   \       0x10   0x5C89             LDRB     R1,[R1, R2]
   \       0x12   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \       0x16   0x40C8             LSRS     R0,R0,R1
   \       0x18   0xBD02             POP      {R1,PC}
   1527          }
   1528          
   1529          /**
   1530            * @brief  Return the PCLK3 frequency.
   1531            * @note   Each time PCLK3 changes, this function must be called to update the
   1532            *         right PCLK3 value. Otherwise, any configuration based on this function will be incorrect.
   1533            * @retval PCLK3 frequency in Hz
   1534            */

   \                                 In section .text, align 2, keep-with-next
   1535          uint32_t HAL_RCC_GetPCLK3Freq(void)
   1536          {
   \                     HAL_RCC_GetPCLK3Freq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1537            /* Get HCLK source and Compute PCLK3 frequency ---------------------------*/
   1538            return (HAL_RCC_GetHCLKFreq() >> ((APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE3) >> RCC_CFGR2_PPRE3_Pos]) & 0x1FU));
   \        0x2   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \        0x6   0x....             LDR.N    R1,??DataTable15_17
   \        0x8   0x....             LDR.N    R2,??DataTable15_16
   \        0xA   0x6812             LDR      R2,[R2, #+0]
   \        0xC   0xF3C2 0x3202      UBFX     R2,R2,#+12,#+3
   \       0x10   0x5C89             LDRB     R1,[R1, R2]
   \       0x12   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \       0x16   0x40C8             LSRS     R0,R0,R1
   \       0x18   0xBD02             POP      {R1,PC}
   1539          }
   1540          /**
   1541            * @brief  Configure the pOscInitStruct according to the internal
   1542            *         RCC configuration registers.
   1543            * @param  pOscInitStruct  pointer to an RCC_OscInitTypeDef structure that
   1544            *         will be configured.
   1545            * @retval None
   1546            */

   \                                 In section .text, align 2, keep-with-next
   1547          void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *pOscInitStruct)
   1548          {
   1549            uint32_t regval;
   1550            uint32_t reg1val;
   1551            uint32_t reg2val;
   1552          
   1553            /* Check the parameters */
   1554            assert_param(pOscInitStruct != (void *)NULL);
   1555          
   1556            /* Set all possible values for the Oscillator type parameter ---------------*/
   1557            pOscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_CSI | \
   1558                                             RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSI48;
   \                     HAL_RCC_GetOscConfig: (+1)
   \        0x0   0x213F             MOVS     R1,#+63
   \        0x2   0x6001             STR      R1,[R0, #+0]
   1559          
   1560            /* Get Control register */
   1561            regval = RCC->CR;
   \        0x4   0x....             LDR.N    R2,??DataTable15_12
   \        0x6   0x6811             LDR      R1,[R2, #+0]
   1562          
   1563            /* Get the HSE configuration -----------------------------------------------*/
   1564            pOscInitStruct->HSEState = (regval & (RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_HSEEXT));
   \        0x8   0xF411 0x13A8      ANDS     R3,R1,#0x150000
   \        0xC   0x6043             STR      R3,[R0, #+4]
   1565          
   1566            /* Get the CSI configuration -----------------------------------------------*/
   1567            pOscInitStruct->CSIState = regval & RCC_CR_CSION;
   \        0xE   0xF411 0x7380      ANDS     R3,R1,#0x100
   \       0x12   0x61C3             STR      R3,[R0, #+28]
   1568          
   1569            /* Get the HSI configuration -----------------------------------------------*/
   1570            pOscInitStruct->HSIState = regval & RCC_CR_HSION;
   \       0x14   0xF011 0x0301      ANDS     R3,R1,#0x1
   \       0x18   0x60C3             STR      R3,[R0, #+12]
   1571            pOscInitStruct->HSIDiv = regval & RCC_CR_HSIDIV;
   \       0x1A   0xF011 0x0118      ANDS     R1,R1,#0x18
   \       0x1E   0x6101             STR      R1,[R0, #+16]
   1572            pOscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, \
   1573                                                                      RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);
   \       0x20   0x....             LDR.N    R1,??DataTable15_18
   \       0x22   0x6809             LDR      R1,[R1, #+0]
   \       0x24   0xF3C1 0x4106      UBFX     R1,R1,#+16,#+7
   \       0x28   0x6141             STR      R1,[R0, #+20]
   1574          
   1575            /* Get BDCR register */
   1576            regval = RCC->BDCR;
   \       0x2A   0x....             LDR.N    R1,??DataTable15_1
   \       0x2C   0x6809             LDR      R1,[R1, #+0]
   1577          
   1578            /* Get the LSE configuration -----------------------------------------------*/
   1579            pOscInitStruct->LSEState = (regval & (RCC_BDCR_LSEON | RCC_BDCR_LSEBYP | RCC_BDCR_LSEEXT));
   \       0x2E   0xF011 0x0385      ANDS     R3,R1,#0x85
   \       0x32   0x6083             STR      R3,[R0, #+8]
   1580          
   1581            /* Get the LSI configuration -----------------------------------------------*/
   1582            pOscInitStruct->LSIState = regval & RCC_BDCR_LSION;
   \       0x34   0xF011 0x6180      ANDS     R1,R1,#0x4000000
   \       0x38   0x6181             STR      R1,[R0, #+24]
   1583          
   1584            /* Get Control register */
   1585            regval = RCC->CR;
   \       0x3A   0x6811             LDR      R1,[R2, #+0]
   1586          
   1587            /* Get the HSI48 configuration ---------------------------------------------*/
   1588            pOscInitStruct->HSI48State = regval & RCC_CR_HSI48ON;
   \       0x3C   0xF411 0x5280      ANDS     R2,R1,#0x1000
   \       0x40   0x6242             STR      R2,[R0, #+36]
   1589          
   1590            /* Get the PLL configuration -----------------------------------------------*/
   1591            if ((regval & RCC_CR_PLL1ON) == RCC_CR_PLL1ON)
   \       0x42   0x01C9             LSLS     R1,R1,#+7
   \       0x44   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_0
   1592            {
   1593              pOscInitStruct->PLL.PLLState = RCC_PLL_ON;
   \       0x46   0x2102             MOVS     R1,#+2
   \       0x48   0x6281             STR      R1,[R0, #+40]
   \       0x4A   0xE001             B.N      ??HAL_RCC_GetOscConfig_1
   1594            }
   1595            else
   1596            {
   1597              pOscInitStruct->PLL.PLLState = RCC_PLL_OFF;
   \                     ??HAL_RCC_GetOscConfig_0: (+1)
   \       0x4C   0x2101             MOVS     R1,#+1
   \       0x4E   0x6281             STR      R1,[R0, #+40]
   1598            }
   1599          
   1600            /* Get PLL configuration register */
   1601            reg1val = RCC->PLL1CFGR;
   \                     ??HAL_RCC_GetOscConfig_1: (+1)
   \       0x50   0x....             LDR.N    R1,??DataTable15_14
   \       0x52   0x6809             LDR      R1,[R1, #+0]
   1602            reg2val = RCC->PLL1DIVR;
   \       0x54   0x....             LDR.N    R2,??DataTable15_15
   \       0x56   0x6812             LDR      R2,[R2, #+0]
   1603          
   1604            pOscInitStruct->PLL.PLLSource = (uint32_t)(reg1val & RCC_PLL1CFGR_PLL1SRC);
   \       0x58   0xF011 0x0303      ANDS     R3,R1,#0x3
   \       0x5C   0x62C3             STR      R3,[R0, #+44]
   1605            pOscInitStruct->PLL.PLLM = (uint32_t)((reg1val & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos);
   \       0x5E   0xF3C1 0x2305      UBFX     R3,R1,#+8,#+6
   \       0x62   0x6303             STR      R3,[R0, #+48]
   1606            pOscInitStruct->PLL.PLLN = (uint32_t)(((reg2val & RCC_PLL1DIVR_PLL1N) >> RCC_PLL1DIVR_PLL1N_Pos) + 1U);
   \       0x64   0x05D3             LSLS     R3,R2,#+23
   \       0x66   0x0DDB             LSRS     R3,R3,#+23
   \       0x68   0x1C5B             ADDS     R3,R3,#+1
   \       0x6A   0x6343             STR      R3,[R0, #+52]
   1607            pOscInitStruct->PLL.PLLQ = (uint32_t)(((reg2val & RCC_PLL1DIVR_PLL1Q) >> RCC_PLL1DIVR_PLL1Q_Pos) + 1U);
   \       0x6C   0xF3C2 0x4306      UBFX     R3,R2,#+16,#+7
   \       0x70   0x1C5B             ADDS     R3,R3,#+1
   \       0x72   0x63C3             STR      R3,[R0, #+60]
   1608            pOscInitStruct->PLL.PLLR = (uint32_t)(((reg2val & RCC_PLL1DIVR_PLL1R) >> RCC_PLL1DIVR_PLL1R_Pos) + 1U);
   \       0x74   0xF3C2 0x6306      UBFX     R3,R2,#+24,#+7
   \       0x78   0x1C5B             ADDS     R3,R3,#+1
   \       0x7A   0x6403             STR      R3,[R0, #+64]
   1609            pOscInitStruct->PLL.PLLP = (uint32_t)(((reg2val & RCC_PLL1DIVR_PLL1P) >> RCC_PLL1DIVR_PLL1P_Pos) + 1U);
   \       0x7C   0xF3C2 0x2246      UBFX     R2,R2,#+9,#+7
   \       0x80   0x1C52             ADDS     R2,R2,#+1
   \       0x82   0x6382             STR      R2,[R0, #+56]
   1610            pOscInitStruct->PLL.PLLRGE = (uint32_t)((reg1val & RCC_PLL1CFGR_PLL1RGE));
   \       0x84   0xF011 0x020C      ANDS     R2,R1,#0xC
   \       0x88   0x6442             STR      R2,[R0, #+68]
   1611            pOscInitStruct->PLL.PLLVCOSEL = (uint32_t)((reg1val & RCC_PLL1CFGR_PLL1VCOSEL) >> RCC_PLL1CFGR_PLL1VCOSEL_Pos);
   \       0x8A   0xF3C1 0x1140      UBFX     R1,R1,#+5,#+1
   \       0x8E   0x6481             STR      R1,[R0, #+72]
   1612            pOscInitStruct->PLL.PLLFRACN = (uint32_t)(((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) \
   1613                                                       >> RCC_PLL1FRACR_PLL1FRACN_Pos));
   \       0x90   0x....             LDR.N    R1,??DataTable15_4
   \       0x92   0x6809             LDR      R1,[R1, #+0]
   \       0x94   0xF3C1 0x01CC      UBFX     R1,R1,#+3,#+13
   \       0x98   0x64C1             STR      R1,[R0, #+76]
   1614          }
   \       0x9A   0x4770             BX       LR
   1615          
   1616          /**
   1617            * @brief  Configure the pClkInitStruct according to the internal
   1618            *         RCC configuration registers.
   1619            * @param  pClkInitStruct  pointer to an RCC_ClkInitTypeDef structure that
   1620            *         will be configured.
   1621            * @param  pFLatency  Pointer on the Flash Latency.
   1622            * @retval None
   1623            */

   \                                 In section .text, align 2, keep-with-next
   1624          void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *pClkInitStruct, uint32_t *pFLatency)
   1625          {
   1626            uint32_t regval;
   1627          
   1628            /* Check the parameters */
   1629            assert_param(pClkInitStruct != (void *)NULL);
   1630            assert_param(pFLatency != (void *)NULL);
   1631          
   1632            /* Set all possible values for the Clock type parameter --------------------*/
   1633            pClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 | \
   1634                                        RCC_CLOCKTYPE_PCLK3;
   \                     HAL_RCC_GetClockConfig: (+1)
   \        0x0   0x221F             MOVS     R2,#+31
   \        0x2   0x6002             STR      R2,[R0, #+0]
   1635          
   1636            /* Get the SYSCLK configuration --------------------------------------------*/
   1637            pClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR1 & RCC_CFGR1_SW);
   \        0x4   0x....             LDR.N    R2,??DataTable15_9
   \        0x6   0x6812             LDR      R2,[R2, #+0]
   \        0x8   0xF012 0x0203      ANDS     R2,R2,#0x3
   \        0xC   0x6042             STR      R2,[R0, #+4]
   1638          
   1639            /* Get the HCLK configuration ----------------------------------------------*/
   1640            regval = RCC->CFGR2;
   \        0xE   0x....             LDR.N    R2,??DataTable15_16
   \       0x10   0x6812             LDR      R2,[R2, #+0]
   1641            pClkInitStruct->AHBCLKDivider = (uint32_t)(regval & RCC_CFGR2_HPRE);
   \       0x12   0xF012 0x030F      ANDS     R3,R2,#0xF
   \       0x16   0x6083             STR      R3,[R0, #+8]
   1642          
   1643            /* Get the APB1 configuration ----------------------------------------------*/
   1644            pClkInitStruct->APB1CLKDivider = (uint32_t)(regval & RCC_CFGR2_PPRE1);
   \       0x18   0xF012 0x0370      ANDS     R3,R2,#0x70
   \       0x1C   0x60C3             STR      R3,[R0, #+12]
   1645          
   1646            /* Get the APB2 configuration ----------------------------------------------*/
   1647            pClkInitStruct->APB2CLKDivider = (uint32_t)((regval & RCC_CFGR2_PPRE2) >> 4);
   \       0x1E   0x0013             MOVS     R3,R2
   \       0x20   0x091B             LSRS     R3,R3,#+4
   \       0x22   0xF013 0x0370      ANDS     R3,R3,#0x70
   \       0x26   0x6103             STR      R3,[R0, #+16]
   1648          
   1649            /* Get the APB3 configuration ----------------------------------------------*/
   1650            pClkInitStruct->APB3CLKDivider = (uint32_t)((regval & RCC_CFGR2_PPRE3) >> 8);
   \       0x28   0x0A12             LSRS     R2,R2,#+8
   \       0x2A   0xF012 0x0270      ANDS     R2,R2,#0x70
   \       0x2E   0x6142             STR      R2,[R0, #+20]
   1651          
   1652            /* Get the Flash Wait State (Latency) configuration ------------------------*/
   1653            *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
   \       0x30   0x....             LDR.N    R0,??DataTable15_19
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x38   0x6008             STR      R0,[R1, #+0]
   1654          }
   \       0x3A   0x4770             BX       LR
   1655          
   1656          /**
   1657            * @brief  Get and clear reset flags
   1658            * @note   Once reset flags are retrieved, this API is clearing them in order
   1659            *         to isolate next reset reason.
   1660            * @retval can be a combination of @ref RCC_Reset_Flag
   1661            */

   \                                 In section .text, align 2, keep-with-next
   1662          uint32_t HAL_RCC_GetResetSource(void)
   1663          {
   1664            uint32_t reset;
   1665          
   1666            /* Get all reset flags */
   1667            reset = RCC->RSR & RCC_RESET_FLAG_ALL;
   \                     HAL_RCC_GetResetSource: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable15_20
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   \        0x4   0xF010 0x407C      ANDS     R0,R0,#0xFC000000
   1668          
   1669            /* Clear Reset flags */
   1670            RCC->RSR |= RCC_RSR_RMVF;
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0xF452 0x0200      ORRS     R2,R2,#0x800000
   \        0xE   0x600A             STR      R2,[R1, #+0]
   1671          
   1672            return reset;
   \       0x10   0x4770             BX       LR
   1673          }
   1674          
   1675          /**
   1676            * @brief  Enable the HSE Clock Security System.
   1677            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
   1678            *         is automatically disabled and an interrupt is generated to inform the
   1679            *         software about the failure (Clock Security System Interrupt, CSSI),
   1680            *         allowing the MCU to perform rescue operations. The CSSI is linked to
   1681            *         the Cortex-M NMI (Non-Maskable Interrupt) exception vector.
   1682            * @note   The Clock Security System can only be cleared by reset.
   1683            * @retval None
   1684            */

   \                                 In section .text, align 2, keep-with-next
   1685          void HAL_RCC_EnableCSS(void)
   1686          {
   1687            SET_BIT(RCC->CR, RCC_CR_HSECSSON);
   \                     HAL_RCC_EnableCSS: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable15_12
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF451 0x2100      ORRS     R1,R1,#0x80000
   \        0x8   0x6001             STR      R1,[R0, #+0]
   1688          }
   \        0xA   0x4770             BX       LR
   1689          
   1690          /**
   1691            * @brief Handle the RCC Clock Security System interrupt request.
   1692            * @note This API should be called under the NMI_Handler().
   1693            * @retval None
   1694            */

   \                                 In section .text, align 2, keep-with-next
   1695          void HAL_RCC_NMI_IRQHandler(void)
   1696          {
   \                     HAL_RCC_NMI_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1697            /* Check RCC CSSF interrupt flag  */
   1698            if (__HAL_RCC_GET_IT(RCC_IT_HSECSS))
   \        0x2   0x....             LDR.N    R0,??DataTable15_21
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x0540             LSLS     R0,R0,#+21
   \        0x8   0xD505             BPL.N    ??HAL_RCC_NMI_IRQHandler_0
   1699            {
   1700              /* RCC Clock Security System interrupt user callback */
   1701              HAL_RCC_CSSCallback();
   \        0xA   0x.... 0x....      BL       HAL_RCC_CSSCallback
   1702          
   1703              /* Clear RCC CSS pending bit */
   1704              __HAL_RCC_CLEAR_IT(RCC_IT_HSECSS);
   \        0xE   0xF44F 0x6080      MOV      R0,#+1024
   \       0x12   0x....             LDR.N    R1,??DataTable15_22
   \       0x14   0x6008             STR      R0,[R1, #+0]
   1705            }
   1706          }
   \                     ??HAL_RCC_NMI_IRQHandler_0: (+1)
   \       0x16   0xBD01             POP      {R0,PC}
   1707          
   1708          /**
   1709            * @brief  RCC HSE Clock Security System interrupt callback.
   1710            * @retval none
   1711            */

   \                                 In section .text, align 2
   1712          __weak void HAL_RCC_CSSCallback(void)
   1713          {
   1714            /* NOTE : This function should not be modified, when the callback is needed,
   1715                      the HAL_RCC_CSSCallback should be implemented in the user file
   1716             */
   1717          }
   \                     HAL_RCC_CSSCallback: (+1)
   \        0x0   0x4770             BX       LR
   1718          
   1719          /**
   1720            * @}
   1721            */
   1722          
   1723          /** @defgroup RCC_Exported_Functions_Group3 Attributes management functions
   1724            *  @brief Attributes management functions.
   1725            *
   1726          @verbatim
   1727           ===============================================================================
   1728                                 ##### RCC attributes functions #####
   1729           ===============================================================================
   1730              [..]
   1731              This subsection provides a set of functions allowing to:
   1732          
   1733              (+) Configure the RCC item(s) attributes.
   1734              (+) Get the attribute of an RCC item.
   1735          
   1736          @endverbatim
   1737            * @{
   1738            */
   1739          /**
   1740            * @brief  Configure the RCC item(s) attribute(s).
   1741            * @note   Available attributes are to secure items and set RCC as privileged (*).
   1742            *         Default state is non-secure and unprivileged access allowed.
   1743            * @note   Secure and non-secure attributes can only be set from the secure
   1744            *         state when the system implements the security (TZEN=1).
   1745            * @param  Item Item(s) to set attributes on.
   1746            *         This parameter can be a one or a combination of @ref RCC_items (**).
   1747            * @param  Attributes specifies the RCC secure/privilege attributes.
   1748            *         This parameter can be a value of  @ref RCC_attributes
   1749            * @retval None
   1750            *
   1751            * (*)   : For stm32h503xx devices, attributes specifies the privilege attribute only (no items).
   1752            * (**)  : For stm32h503xx devices, this parameter is unused, it can take 0 or any other numerical value.
   1753            */

   \                                 In section .text, align 2, keep-with-next
   1754          void HAL_RCC_ConfigAttributes(uint32_t Item, uint32_t Attributes)
   1755          {
   1756          
   1757            /* Check the parameters */
   1758            assert_param(IS_RCC_ATTRIBUTES(Attributes));
   1759          
   1760          #if defined(RCC_SECCFGR_HSISEC)
   1761            assert_param(IS_RCC_ITEM_ATTRIBUTES(Item));
   1762          
   1763            switch (Attributes)
   \                     HAL_RCC_ConfigAttributes: (+1)
   \        0x0   0x2901             CMP      R1,#+1
   \        0x2   0xD002             BEQ.N    ??HAL_RCC_ConfigAttributes_0
   \        0x4   0x2902             CMP      R1,#+2
   \        0x6   0xD006             BEQ.N    ??HAL_RCC_ConfigAttributes_1
   \        0x8   0xE00B             B.N      ??HAL_RCC_ConfigAttributes_2
   1764            {
   1765          #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
   1766              /* Secure Privilege attribute */
   1767              case RCC_SEC_PRIV:
   1768                SET_BIT(RCC->SECCFGR, Item);
   1769                SET_BIT(RCC->PRIVCFGR, RCC_PRIVCFGR_SPRIV);
   1770                break;
   1771              /* Secure Non-Privilege attribute */
   1772              case RCC_SEC_NPRIV:
   1773                SET_BIT(RCC->SECCFGR, Item);
   1774                CLEAR_BIT(RCC->PRIVCFGR, RCC_PRIVCFGR_SPRIV);
   1775                break;
   1776              /* Non-secure Privilege attribute */
   1777              case RCC_NSEC_PRIV:
   1778                CLEAR_BIT(RCC->SECCFGR, Item);
   1779                SET_BIT(RCC->PRIVCFGR, RCC_PRIVCFGR_NSPRIV);
   1780                break;
   1781              /* Non-secure Non-Privilege attribute */
   1782              case RCC_NSEC_NPRIV:
   1783                CLEAR_BIT(RCC->SECCFGR, Item);
   1784                CLEAR_BIT(RCC->PRIVCFGR, RCC_PRIVCFGR_NSPRIV);
   1785                break;
   1786          #else /* __ARM_FEATURE_CMSE */
   1787              /* Non-secure Privilege attribute */
   1788              case RCC_NSEC_PRIV:
   1789                SET_BIT(RCC->PRIVCFGR, RCC_PRIVCFGR_NSPRIV);
   \                     ??HAL_RCC_ConfigAttributes_0: (+1)
   \        0xA   0x....             LDR.N    R0,??DataTable15_23
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x12   0x6001             STR      R1,[R0, #+0]
   1790                break;
   \       0x14   0xE005             B.N      ??HAL_RCC_ConfigAttributes_3
   1791              /* Non-secure Non-Privilege attribute */
   1792              case RCC_NSEC_NPRIV:
   1793                CLEAR_BIT(RCC->PRIVCFGR, RCC_PRIVCFGR_NSPRIV);
   \                     ??HAL_RCC_ConfigAttributes_1: (+1)
   \       0x16   0x....             LDR.N    R0,??DataTable15_23
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xF031 0x0102      BICS     R1,R1,#0x2
   \       0x1E   0x6001             STR      R1,[R0, #+0]
   1794                break;
   \       0x20   0xE7FF             B.N      ??HAL_RCC_ConfigAttributes_3
   1795          #endif /* __ARM_FEATURE_CMSE */
   1796              default:
   1797                /* Nothing to do */
   1798                break;
   1799            }
   1800          
   1801          #else /* RCC_SECCFGR_HSISEC */
   1802          
   1803            UNUSED(Item);
   1804          
   1805            switch (Attributes)
   1806            {
   1807              /* Privilege attribute */
   1808              case RCC_PRIV:
   1809                SET_BIT(RCC->PRIVCFGR, RCC_PRIVCFGR_PRIV);
   1810                break;
   1811              /* Non-secure Non-Privilege attribute */
   1812              case RCC_NPRIV:
   1813                CLEAR_BIT(RCC->PRIVCFGR, RCC_PRIVCFGR_PRIV);
   1814                break;
   1815              default:
   1816                /* Nothing to do */
   1817                break;
   1818            }
   1819          
   1820          #endif /* RCC_SECCFGR_HSISEC */
   1821          }
   \                     ??HAL_RCC_ConfigAttributes_2: (+1)
   \                     ??HAL_RCC_ConfigAttributes_3: (+1)
   \       0x22   0x4770             BX       LR
   1822          
   1823          /**
   1824            * @brief  Get the attribute of an RCC item.
   1825            * @note   Secure and non-secure attributes are only available from secure state
   1826            *         when the system implements the security (TZEN=1)
   1827            * @param  Item Single item to get secure/non-secure and privilege/non-privilege attribute from.
   1828            *         This parameter can be a one value of @ref RCC_items except RCC_ALL. (*)
   1829            * @param  pAttributes pointer to return the attributes.
   1830            * @retval HAL Status.
   1831            *
   1832            * (*)  : This parameter is unused for stm32h503xx devices, it can take 0 or any other numerical value.
   1833            */

   \                                 In section .text, align 2, keep-with-next
   1834          HAL_StatusTypeDef HAL_RCC_GetConfigAttributes(uint32_t Item, uint32_t *pAttributes)
   1835          {
   1836            uint32_t attributes;
   1837          
   1838            /* Check null pointer */
   1839            if (pAttributes == NULL)
   \                     HAL_RCC_GetConfigAttributes: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0xD101             BNE.N    ??HAL_RCC_GetConfigAttributes_0
   1840            {
   1841              return HAL_ERROR;
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0xE008             B.N      ??HAL_RCC_GetConfigAttributes_1
   1842            }
   1843          
   1844          #if defined(RCC_SECCFGR_HSISEC)
   1845            /* Check the parameters */
   1846            assert_param(IS_RCC_SINGLE_ITEM_ATTRIBUTES(Item));
   1847          
   1848          #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
   1849          
   1850            /* Check item security */
   1851            if ((RCC->SECCFGR & Item) == Item)
   1852            {
   1853              /* Get Secure privileges attribute */
   1854              attributes = ((RCC->PRIVCFGR & RCC_PRIVCFGR_SPRIV) == 0U) ? RCC_SEC_NPRIV : RCC_SEC_PRIV;
   1855            }
   1856            else
   1857            {
   1858              /* Get Non-Secure privileges attribute */
   1859              attributes = ((RCC->PRIVCFGR & RCC_PRIVCFGR_NSPRIV) == 0U) ? RCC_NSEC_NPRIV : RCC_NSEC_PRIV;
   1860            }
   1861          #else  /* __ARM_FEATURE_CMSE */
   1862            attributes = ((RCC->PRIVCFGR & RCC_PRIVCFGR_NSPRIV) == 0U) ? RCC_NSEC_NPRIV : RCC_NSEC_PRIV;
   \                     ??HAL_RCC_GetConfigAttributes_0: (+1)
   \        0x8   0x....             LDR.N    R0,??DataTable15_23
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x0780             LSLS     R0,R0,#+30
   \        0xE   0xD401             BMI.N    ??HAL_RCC_GetConfigAttributes_2
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE000             B.N      ??HAL_RCC_GetConfigAttributes_3
   \                     ??HAL_RCC_GetConfigAttributes_2: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   1863          #endif /* __ARM_FEATURE_CMSE */
   1864          
   1865          #else /* RCC_SECCFGR_HSISEC */
   1866            UNUSED(Item);
   1867            /* Get privileges attribute */
   1868            attributes = ((RCC->PRIVCFGR & RCC_PRIVCFGR_PRIV) == 0U) ? RCC_NPRIV : RCC_PRIV;
   1869          #endif /* RCC_SECCFGR_HSISEC */
   1870          
   1871            /* return value */
   1872            *pAttributes = attributes;
   \                     ??HAL_RCC_GetConfigAttributes_3: (+1)
   \       0x16   0x6008             STR      R0,[R1, #+0]
   1873          
   1874            return HAL_OK;
   \       0x18   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_GetConfigAttributes_1: (+1)
   \       0x1A   0x4770             BX       LR
   1875          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x4002'2000        DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x4402'0C00        DC32     0x44020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x4402'0C10        DC32     0x44020c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x....'....        DC32     uwTickPrio

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x4402'0C1C        DC32     0x44020c1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0x4402'0C20        DC32     0x44020c20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \        0x0   0xFFF6'EAFB        DC32     0xfff6eafb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \        0x0   0x4402'0C28        DC32     0x44020c28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \        0x0   0x0101'0280        DC32     0x1010280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \        0x0   0x4402'0C34        DC32     0x44020c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \        0x0   0x4402'0C38        DC32     0x44020c38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \        0x0   0x4402'0C2C        DC32     0x44020c2c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \        0x0   0x4402'0C3C        DC32     0x44020c3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \        0x0   0x4402'0C40        DC32     0x44020c40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_14:
   \        0x0   0x4402'0C30        DC32     0x44020c30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_15:
   \        0x0   0x4402'0C44        DC32     0x44020c44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_16:
   \        0x0   0x4402'0C48        DC32     0x44020c48

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_17:
   \        0x0   0x4402'0C50        DC32     0x44020c50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x4402'0C58        DC32     0x44020c58

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x4402'0CF4        DC32     0x44020cf4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x03D0'9000        DC32     0x3d09000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x4402'0C1C        DC32     0x44020c1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x4402'0C18        DC32     0x44020c18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x4600'0000        DC32     0x46000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x4C74'2400        DC32     0x4c742400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x4BBE'BC20        DC32     0x4bbebc20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x4A74'2400        DC32     0x4a742400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x4402'0CF0        DC32     0x44020cf0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0x4402'0824        DC32     0x44020824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0xFFFF'C0FC        DC32     0xffffc0fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \        0x0   0x4402'0C38        DC32     0x44020c38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \        0x0   0xFFF8'FFFC        DC32     0xfff8fffc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \        0x0   0x....'....        DC32     AHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \        0x0   0x4402'0C8C        DC32     0x44020c8c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \        0x0   0x4202'0000        DC32     0x42020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \        0x0   0x4402'0C1C        DC32     0x44020c1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \        0x0   0x4202'0800        DC32     0x42020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \        0x0   0x003D'0900        DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \        0x0   0x4402'0C00        DC32     0x44020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \        0x0   0x017D'7840        DC32     0x17d7840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \        0x0   0x4402'0C28        DC32     0x44020c28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \        0x0   0x4402'0C34        DC32     0x44020c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \        0x0   0x4402'0C20        DC32     0x44020c20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \        0x0   0x....'....        DC32     APBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \        0x0   0x4402'0C10        DC32     0x44020c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_19:
   \        0x0   0x4002'2000        DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_20:
   \        0x0   0x4402'0CF4        DC32     0x44020cf4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_21:
   \        0x0   0x4402'0C54        DC32     0x44020c54

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_22:
   \        0x0   0x4402'0C58        DC32     0x44020c58

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_23:
   \        0x0   0x4402'0D14        DC32     0x44020d14
   1876          
   1877          /**
   1878            * @}
   1879            */
   1880          
   1881          /**
   1882            * @}
   1883            */
   1884          
   1885          /* Private function prototypes -----------------------------------------------*/
   1886          #endif /* HAL_RCC_MODULE_ENABLED */
   1887          /**
   1888            * @}
   1889            */
   1890          
   1891          /**
   1892            * @}
   1893            */
   1894          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCC_CSSCallback
      24   HAL_RCC_ClockConfig
        24   -> HAL_GetTick
        24   -> HAL_InitTick
        24   -> HAL_RCC_GetSysClockFreq
       0   HAL_RCC_ConfigAttributes
      24   HAL_RCC_DeInit
        24   -> HAL_GetTick
        24   -> HAL_InitTick
       0   HAL_RCC_EnableCSS
       0   HAL_RCC_GetClockConfig
       0   HAL_RCC_GetConfigAttributes
       8   HAL_RCC_GetHCLKFreq
         8   -> HAL_RCC_GetSysClockFreq
       0   HAL_RCC_GetOscConfig
       8   HAL_RCC_GetPCLK1Freq
         8   -> HAL_RCC_GetHCLKFreq
       8   HAL_RCC_GetPCLK2Freq
         8   -> HAL_RCC_GetHCLKFreq
       8   HAL_RCC_GetPCLK3Freq
         8   -> HAL_RCC_GetHCLKFreq
       0   HAL_RCC_GetResetSource
       0   HAL_RCC_GetSysClockFreq
      40   HAL_RCC_MCOConfig
        40   -> HAL_GPIO_Init
       8   HAL_RCC_NMI_IRQHandler
         8   -> HAL_RCC_CSSCallback
      32   HAL_RCC_OscConfig
        32   -> HAL_GetTick
        32   -> HAL_InitTick
        32   -> HAL_RCC_GetHCLKFreq


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_19
       4  ??DataTable15_2
       4  ??DataTable15_20
       4  ??DataTable15_21
       4  ??DataTable15_22
       4  ??DataTable15_23
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_16
       4  ??DataTable3_17
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       2  HAL_RCC_CSSCallback
     626  HAL_RCC_ClockConfig
      36  HAL_RCC_ConfigAttributes
     452  HAL_RCC_DeInit
      12  HAL_RCC_EnableCSS
      60  HAL_RCC_GetClockConfig
      28  HAL_RCC_GetConfigAttributes
      32  HAL_RCC_GetHCLKFreq
     156  HAL_RCC_GetOscConfig
      26  HAL_RCC_GetPCLK1Freq
      26  HAL_RCC_GetPCLK2Freq
      26  HAL_RCC_GetPCLK3Freq
      18  HAL_RCC_GetResetSource
     428  HAL_RCC_GetSysClockFreq
     160  HAL_RCC_MCOConfig
      24  HAL_RCC_NMI_IRQHandler
   1'614  HAL_RCC_OscConfig

 
 3'930 bytes in section .text
 
 3'928 bytes of CODE memory (+ 2 bytes shared)

Errors: none
Warnings: none
