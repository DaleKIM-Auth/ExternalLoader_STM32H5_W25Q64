###############################################################################
#
# IAR ANSI C/C++ Compiler V9.40.1.364/W64 for ARM         23/Nov/2023  21:46:10
# Copyright 1999-2023 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal.c
#    Command line      =
#        -f
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal.o.rsp
#        (C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal.c
#        -D STM32H562xx -lCN
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir
#        -lA
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir
#        -o
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33.no_dsp.no_se -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\CMSIS\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Library\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Loader\
#        -Ol) --dependencies=n
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir\stm32h5xx_hal.lst
#    Object file       =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal.c
      1          /**
      2            **********************************************************************************************************************
      3            * @file    stm32h5xx_hal.c
      4            * @author  MCD Application Team
      5            * @brief   HAL module driver.
      6            *          This is the common part of the HAL initialization
      7            *
      8            @verbatim
      9            ======================================================================================================================
     10                               ##### How to use this driver #####
     11            ======================================================================================================================
     12              [..]
     13              The common HAL driver contains a set of generic and common APIs that can be
     14              used by the PPP peripheral drivers and the user to start using the HAL.
     15              [..]
     16              The HAL contains two APIs' categories:
     17                   (+) Common HAL APIs
     18                   (+) Services HAL APIs
     19          
     20            @endverbatim
     21            **********************************************************************************************************************
     22            * @attention
     23            *
     24            * Copyright (c) 2023 STMicroelectronics.
     25            * All rights reserved.
     26            *
     27            * This software is licensed under terms that can be found in the LICENSE file
     28            * in the root directory of this software component.
     29            * If no LICENSE file comes with this software, it is provided AS-IS.
     30            *
     31            **********************************************************************************************************************
     32            */
     33          
     34          /* Includes ----------------------------------------------------------------------------------------------------------*/
     35          #include "stm32h5xx_hal.h"
     36          
     37          /** @addtogroup STM32H5xx_HAL_Driver
     38            * @{
     39            */
     40          
     41          /** @defgroup HAL HAL
     42            * @brief HAL module driver
     43            * @{
     44            */
     45          
     46          #ifdef HAL_MODULE_ENABLED
     47          
     48          /* Private typedef ---------------------------------------------------------------------------------------------------*/
     49          /* Private define ----------------------------------------------------------------------------------------------------*/
     50          /**
     51            * @brief STM32H5xx HAL Driver version number 1.1.0
     52             */
     53          #define __STM32H5XX_HAL_VERSION_MAIN   (0x01U) /*!< [31:24] main version */
     54          #define __STM32H5XX_HAL_VERSION_SUB1   (0x01U) /*!< [23:16] sub1 version */
     55          #define __STM32H5XX_HAL_VERSION_SUB2   (0x00U) /*!< [15:8]  sub2 version */
     56          #define __STM32H5XX_HAL_VERSION_RC     (0x00U) /*!< [7:0]  release candidate */
     57          #define __STM32H5XX_HAL_VERSION         ((__STM32H5XX_HAL_VERSION_MAIN << 24U)\
     58                                                   |(__STM32H5XX_HAL_VERSION_SUB1 << 16U)\
     59                                                   |(__STM32H5XX_HAL_VERSION_SUB2 << 8U )\
     60                                                   |(__STM32H5XX_HAL_VERSION_RC))
     61          
     62          #if defined(VREFBUF)
     63          #define VREFBUF_TIMEOUT_VALUE           10U   /* 10 ms */
     64          #endif /* VREFBUF */
     65          
     66          /* Value used to increment hide protection level */
     67          #define SBS_HDPL_INCREMENT_VALUE  (uint8_t)0x6A
     68          
     69          /* Value used to lock/unlock debug functionalities */
     70          #define SBS_DEBUG_LOCK_VALUE      (uint8_t)0xC3
     71          #define SBS_DEBUG_UNLOCK_VALUE    (uint8_t)0xB4
     72          
     73          /* Private macro -----------------------------------------------------------------------------------------------------*/
     74          /* Private variables -------------------------------------------------------------------------------------------------*/
     75          /* Exported variables ------------------------------------------------------------------------------------------------*/
     76          
     77          /** @defgroup HAL_Exported_Variables HAL Exported Variables
     78            * @{
     79            */

   \                                 In section .bss, align 4
     80          __IO uint32_t uwTick;
   \                     uwTick:
   \        0x0                      DS8 4

   \                                 In section .data, align 4
     81          uint32_t uwTickPrio   = (1UL << __NVIC_PRIO_BITS); /* Invalid PRIO */
   \                     uwTickPrio:
   \        0x0   0x0000'0010        DC32 16

   \                                 In section .data, align 1
     82          HAL_TickFreqTypeDef uwTickFreq = HAL_TICK_FREQ_DEFAULT;  /* 1KHz */
   \                     uwTickFreq:
   \        0x0   0x01               DC8 1
     83          /**
     84            * @}
     85            */
     86          
     87          /* Private function prototypes ---------------------------------------------------------------------------------------*/
     88          /* Exported functions ------------------------------------------------------------------------------------------------*/
     89          
     90          /** @defgroup HAL_Exported_Functions HAL Exported Functions
     91            * @{
     92            */
     93          
     94          /** @defgroup HAL_Exported_Functions_Group1 Initialization and de-initialization Functions
     95            *  @brief    Initialization and de-initialization functions
     96            *
     97          @verbatim
     98           =======================================================================================================================
     99                        ##### Initialization and de-initialization functions #####
    100           =======================================================================================================================
    101              [..]  This section provides functions allowing to:
    102                (+) Initializes the Flash interface the NVIC allocation and initial clock
    103                    configuration. It initializes the systick also when timeout is needed
    104                    and the backup domain when enabled.
    105                (+) De-Initializes common part of the HAL.
    106                (+) Configure The time base source to have 1ms time base with a dedicated
    107                    Tick interrupt priority.
    108                  (++) SysTick timer is used by default as source of time base, but user
    109                       can eventually implement his proper time base source (a general purpose
    110                       timer for example or other time source), keeping in mind that Time base
    111                       duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and
    112                       handled in milliseconds basis.
    113                  (++) Time base configuration function (HAL_InitTick ()) is called automatically
    114                       at the beginning of the program after reset by HAL_Init() or at any time
    115                       when clock is configured, by HAL_RCC_ClockConfig().
    116                  (++) Source of time base is configured  to generate interrupts at regular
    117                       time intervals. Care must be taken if HAL_Delay() is called from a
    118                       peripheral ISR process, the Tick interrupt line must have higher priority
    119                      (numerically lower) than the peripheral interrupt. Otherwise the caller
    120                      ISR process will be blocked.
    121                 (++) functions affecting time base configurations are declared as __weak
    122                       to make  override possible  in case of other  implementations in user file.
    123          @endverbatim
    124            * @{
    125            */
    126          
    127          /**
    128            * @brief  Configure the Flash prefetch, the time base source, NVIC and any required global low
    129            *         level hardware by calling the HAL_MspInit() callback function to be optionally defined
    130            *         in user file stm32h5xx_hal_msp.c.
    131            *
    132            * @note   HAL_Init() function is called at the beginning of program after reset and before
    133            *         the clock configuration.
    134            *
    135            * @note   In the default implementation the System Timer (Systick) is used as source of time base.
    136            *         The Systick configuration is based on HSI clock, as HSI is the clock
    137            *         used after a system Reset and the NVIC configuration is set to Priority group 4.
    138            *         Once done, time base tick starts incrementing: the tick variable counter is incremented
    139            *         each 1ms in the SysTick_Handler() interrupt handler.
    140            *
    141            * @retval HAL status
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          HAL_StatusTypeDef HAL_Init(void)
    144          {
   \                     HAL_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    145            /* Configure Flash prefetch */
    146          #if (PREFETCH_ENABLE != 0U)
    147            __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
    148          #endif /* PREFETCH_ENABLE */
    149          
    150            /* Set Interrupt Group Priority */
    151            HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
   \        0x2   0x2003             MOVS     R0,#+3
   \        0x4   0x.... 0x....      BL       HAL_NVIC_SetPriorityGrouping
    152          
    153            /* Update the SystemCoreClock global variable */
    154            SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
   \        0x8   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable53
   \       0x10   0x.... 0x....      LDR.W    R2,??DataTable53_1
   \       0x14   0x6812             LDR      R2,[R2, #+0]
   \       0x16   0xF012 0x020F      ANDS     R2,R2,#0xF
   \       0x1A   0x5C89             LDRB     R1,[R1, R2]
   \       0x1C   0x40C8             LSRS     R0,R0,R1
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable53_2
   \       0x22   0x6008             STR      R0,[R1, #+0]
    155          
    156            /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
    157            if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
   \       0x24   0x200F             MOVS     R0,#+15
   \       0x26   0x.... 0x....      BL       HAL_InitTick
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD001             BEQ.N    ??HAL_Init_0
    158            {
    159              return HAL_ERROR;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xE002             B.N      ??HAL_Init_1
    160            }
    161          
    162            /* Init the low level hardware */
    163            HAL_MspInit();
   \                     ??HAL_Init_0: (+1)
   \       0x32   0x.... 0x....      BL       HAL_MspInit
    164          
    165            /* Return function status */
    166            return HAL_OK;
   \       0x36   0x2000             MOVS     R0,#+0
   \                     ??HAL_Init_1: (+1)
   \       0x38   0xBD02             POP      {R1,PC}
    167          }
    168          
    169          /**
    170            * @brief  This function de-Initializes common part of the HAL and stops the systick.
    171            *         This function is optional.
    172            * @retval HAL status
    173            */

   \                                 In section .text, align 2, keep-with-next
    174          HAL_StatusTypeDef HAL_DeInit(void)
    175          {
   \                     HAL_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    176            /* Reset of all peripherals */
    177            __HAL_RCC_APB1_FORCE_RESET();
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable53_3
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable53_4
   \        0xA   0x6001             STR      R1,[R0, #+0]
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable53_5
   \       0x10   0x.... 0x....      LDR.W    R2,??DataTable53_6
   \       0x14   0x600A             STR      R2,[R1, #+0]
    178            __HAL_RCC_APB1_RELEASE_RESET();
   \       0x16   0x2200             MOVS     R2,#+0
   \       0x18   0x6002             STR      R2,[R0, #+0]
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x6008             STR      R0,[R1, #+0]
    179          
    180            __HAL_RCC_APB2_FORCE_RESET();
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable53_7
   \       0x22   0x.... 0x....      LDR.W    R1,??DataTable53_8
   \       0x26   0x6001             STR      R1,[R0, #+0]
    181            __HAL_RCC_APB2_RELEASE_RESET();
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x6001             STR      R1,[R0, #+0]
    182          
    183            __HAL_RCC_APB3_FORCE_RESET();
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable53_9
   \       0x30   0x.... 0x....      LDR.W    R1,??DataTable53_10
   \       0x34   0x6001             STR      R1,[R0, #+0]
    184            __HAL_RCC_APB3_RELEASE_RESET();
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x6001             STR      R1,[R0, #+0]
    185          
    186            __HAL_RCC_AHB1_FORCE_RESET();
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable53_11
   \       0x3E   0x.... 0x....      LDR.W    R1,??DataTable53_12
   \       0x42   0x6001             STR      R1,[R0, #+0]
    187            __HAL_RCC_AHB1_RELEASE_RESET();
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0x6001             STR      R1,[R0, #+0]
    188          
    189            __HAL_RCC_AHB2_FORCE_RESET();
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable53_13
   \       0x4C   0x.... 0x....      LDR.W    R1,??DataTable53_14
   \       0x50   0x6001             STR      R1,[R0, #+0]
    190            __HAL_RCC_AHB2_RELEASE_RESET();
   \       0x52   0x2100             MOVS     R1,#+0
   \       0x54   0x6001             STR      R1,[R0, #+0]
    191          
    192          #if defined(AHB4PERIPH_BASE)
    193            __HAL_RCC_AHB4_FORCE_RESET();
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable53_15
   \       0x5A   0x.... 0x....      LDR.W    R1,??DataTable53_16
   \       0x5E   0x6001             STR      R1,[R0, #+0]
    194            __HAL_RCC_AHB4_RELEASE_RESET();
   \       0x60   0x2100             MOVS     R1,#+0
   \       0x62   0x6001             STR      R1,[R0, #+0]
    195          #endif /* AHB4PERIPH_BASE */
    196          
    197            /* De-Init the low level hardware */
    198            HAL_MspDeInit();
   \       0x64   0x.... 0x....      BL       HAL_MspDeInit
    199          
    200            /* Return function status */
    201            return HAL_OK;
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xBD02             POP      {R1,PC}
    202          }
    203          
    204          /**
    205            * @brief  Initializes the MSP.
    206            * @retval None
    207            */

   \                                 In section .text, align 2
    208          __weak void HAL_MspInit(void)
    209          {
    210            /* NOTE : This function Should not be modified, when the callback is needed,
    211                      the HAL_MspInit could be implemented in the user file
    212             */
    213          }
   \                     HAL_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    214          
    215          /**
    216            * @brief  DeInitializes the MSP.
    217            * @retval None
    218            */

   \                                 In section .text, align 2
    219          __weak void HAL_MspDeInit(void)
    220          {
    221            /* NOTE : This function Should not be modified, when the callback is needed,
    222                      the HAL_MspDeInit could be implemented in the user file
    223             */
    224          }
   \                     HAL_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    225          
    226          /**
    227            * @brief This function configures the source of the time base.
    228            *        The time source is configured to have 1ms time base with a dedicated
    229            *        Tick interrupt priority.
    230            * @note This function is called  automatically at the beginning of program after
    231            *       reset by HAL_Init() or at any time when clock is reconfigured  by HAL_RCC_ClockConfig().
    232            * @note In the default implementation, SysTick timer is the source of time base.
    233            *       It is used to generate interrupts at regular time intervals.
    234            *       Care must be taken if HAL_Delay() is called from a peripheral ISR process,
    235            *       The SysTick interrupt must have higher priority (numerically lower)
    236            *       than the peripheral interrupt. Otherwise the caller ISR process will be blocked.
    237            *       The function is declared as __weak  to be overwritten  in case of other
    238            *       implementation  in user file.
    239            * @param TickPriority: Tick interrupt priority.
    240            * @retval HAL status
    241            */

   \                                 In section .text, align 4
    242          __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
    243          {
   \                     HAL_InitTick: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    244            /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
    245            if ((uint32_t)uwTickFreq == 0UL)
   \        0x4   0x4911             LDR.N    R1,??HAL_InitTick_0
   \        0x6   0x7808             LDRB     R0,[R1, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD101             BNE.N    ??HAL_InitTick_1
    246            {
    247              return HAL_ERROR;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE01B             B.N      ??HAL_InitTick_2
    248            }
    249          
    250            /* Configure the SysTick to have interrupt in 1ms time basis*/
    251            if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
   \                     ??HAL_InitTick_1: (+1)
   \       0x10   0xF44F 0x707A      MOV      R0,#+1000
   \       0x14   0x7809             LDRB     R1,[R1, #+0]
   \       0x16   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x1A   0x490D             LDR.N    R1,??HAL_InitTick_0+0x4
   \       0x1C   0x6809             LDR      R1,[R1, #+0]
   \       0x1E   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \       0x22   0x.... 0x....      BL       HAL_SYSTICK_Config
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD001             BEQ.N    ??HAL_InitTick_3
    252            {
    253              return HAL_ERROR;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE00C             B.N      ??HAL_InitTick_2
    254            }
    255          
    256            /* Configure the SysTick IRQ priority */
    257            if (TickPriority < (1UL << __NVIC_PRIO_BITS))
   \                     ??HAL_InitTick_3: (+1)
   \       0x2E   0x2C10             CMP      R4,#+16
   \       0x30   0xD209             BCS.N    ??HAL_InitTick_4
    258            {
    259              HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0x0021             MOVS     R1,R4
   \       0x36   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x3A   0x.... 0x....      BL       HAL_NVIC_SetPriority
    260              uwTickPrio = TickPriority;
   \       0x3E   0x4805             LDR.N    R0,??HAL_InitTick_0+0x8
   \       0x40   0x6004             STR      R4,[R0, #+0]
    261            }
    262            else
    263            {
    264              return HAL_ERROR;
    265            }
    266          
    267            /* Return function status */
    268            return HAL_OK;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xE000             B.N      ??HAL_InitTick_2
   \                     ??HAL_InitTick_4: (+1)
   \       0x46   0x2001             MOVS     R0,#+1
   \                     ??HAL_InitTick_2: (+1)
   \       0x48   0xBD10             POP      {R4,PC}
   \       0x4A   0xBF00             Nop
   \                     ??HAL_InitTick_0:
   \       0x4C   0x....'....        DC32     uwTickFreq
   \       0x50   0x....'....        DC32     SystemCoreClock
   \       0x54   0x....'....        DC32     uwTickPrio
    269          }
    270          
    271          /**
    272            * @}
    273            */
    274          
    275          /** @defgroup HAL_Group2 HAL Control functions
    276            *  @brief    HAL Control functions
    277            *
    278          @verbatim
    279           =======================================================================================================================
    280                                                 ##### HAL Control functions #####
    281           =======================================================================================================================
    282              [..]  This section provides functions allowing to:
    283                (+) Provide a tick value in millisecond
    284                (+) Provide a blocking delay in millisecond
    285                (+) Suspend the time base source interrupt
    286                (+) Resume the time base source interrupt
    287                (+) Get the HAL API driver version
    288                (+) Get the device identifier
    289                (+) Get the device revision identifier
    290          
    291          @endverbatim
    292            * @{
    293            */
    294          
    295          /**
    296            * @brief This function is called to increment a global variable "uwTick"
    297            *        used as application time base.
    298            * @note In the default implementation, this variable is incremented each 1ms
    299            *       in Systick ISR.
    300            * @note This function is declared as __weak to be overwritten in case of other
    301            *      implementations in user file.
    302            * @retval None
    303            */

   \                                 In section .text, align 4
    304          __weak void HAL_IncTick(void)
    305          {
    306            uwTick += (uint32_t)uwTickFreq;
   \                     HAL_IncTick: (+1)
   \        0x0   0x4903             LDR.N    R1,??HAL_IncTick_0
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x4803             LDR.N    R0,??HAL_IncTick_0+0x4
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x1882             ADDS     R2,R0,R2
   \        0xA   0x600A             STR      R2,[R1, #+0]
    307          }
   \        0xC   0x4770             BX       LR
   \        0xE   0xBF00             Nop
   \                     ??HAL_IncTick_0:
   \       0x10   0x....'....        DC32     uwTick
   \       0x14   0x....'....        DC32     uwTickFreq
    308          
    309          /**
    310            * @brief Provides a tick value in millisecond.
    311            * @note This function is declared as __weak to be overwritten in case of other
    312            *       implementations in user file.
    313            * @retval tick value
    314            */

   \                                 In section .text, align 4
    315          __weak uint32_t HAL_GetTick(void)
    316          {
    317            return uwTick;
   \                     HAL_GetTick: (+1)
   \        0x0   0x4801             LDR.N    R0,??HAL_GetTick_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
   \        0x6   0xBF00             Nop
   \                     ??HAL_GetTick_0:
   \        0x8   0x....'....        DC32     uwTick
    318          }
    319          
    320          /**
    321            * @brief This function returns a tick priority.
    322            * @retval tick priority
    323            */

   \                                 In section .text, align 2, keep-with-next
    324          uint32_t HAL_GetTickPrio(void)
    325          {
    326            return uwTickPrio;
   \                     HAL_GetTickPrio: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable53_17
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x4770             BX       LR
    327          }
    328          
    329          /**
    330            * @brief Set new tick Freq.
    331            * @retval HAL status
    332            */

   \                                 In section .text, align 2, keep-with-next
    333          HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
    334          {
   \                     HAL_SetTickFreq: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0001             MOVS     R1,R0
    335            HAL_StatusTypeDef status  = HAL_OK;
   \        0x4   0x2000             MOVS     R0,#+0
    336            HAL_TickFreqTypeDef prevTickFreq;
    337          
    338            assert_param(IS_TICKFREQ(Freq));
    339          
    340            if (uwTickFreq != Freq)
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable53_18
   \        0xA   0x782A             LDRB     R2,[R5, #+0]
   \        0xC   0x000B             MOVS     R3,R1
   \        0xE   0xB2DB             UXTB     R3,R3
   \       0x10   0x429A             CMP      R2,R3
   \       0x12   0xD00B             BEQ.N    ??HAL_SetTickFreq_0
    341            {
    342          
    343              /* Back up uwTickFreq frequency */
    344              prevTickFreq = uwTickFreq;
   \       0x14   0x782C             LDRB     R4,[R5, #+0]
    345          
    346              /* Update uwTickFreq global variable used by HAL_InitTick() */
    347              uwTickFreq = Freq;
   \       0x16   0x7029             STRB     R1,[R5, #+0]
    348          
    349              /* Apply the new tick Freq  */
    350              status = HAL_InitTick(uwTickPrio);
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable53_17
   \       0x1C   0x6800             LDR      R0,[R0, #+0]
   \       0x1E   0x.... 0x....      BL       HAL_InitTick
    351              if (status != HAL_OK)
   \       0x22   0x0001             MOVS     R1,R0
   \       0x24   0xB2C9             UXTB     R1,R1
   \       0x26   0x2900             CMP      R1,#+0
   \       0x28   0xD000             BEQ.N    ??HAL_SetTickFreq_0
    352              {
    353                /* Restore previous tick frequency */
    354                uwTickFreq = prevTickFreq;
   \       0x2A   0x702C             STRB     R4,[R5, #+0]
    355              }
    356            }
    357          
    358            return status;
   \                     ??HAL_SetTickFreq_0: (+1)
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}
    359          }
    360          
    361          /**
    362            * @brief Return tick frequency.
    363            * @retval Tick frequency.
    364            *         Value of @ref HAL_TickFreqTypeDef.
    365            */

   \                                 In section .text, align 2, keep-with-next
    366          HAL_TickFreqTypeDef HAL_GetTickFreq(void)
    367          {
    368            return uwTickFreq;
   \                     HAL_GetTickFreq: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_18
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
    369          }
    370          
    371          /**
    372            * @brief This function provides minimum delay (in milliseconds) based
    373            *        on variable incremented.
    374            * @note In the default implementation , SysTick timer is the source of time base.
    375            *       It is used to generate interrupts at regular time intervals where uwTick
    376            *       is incremented.
    377            * @note This function is declared as __weak to be overwritten in case of other
    378            *       implementations in user file.
    379            * @param Delay  specifies the delay time length, in milliseconds.
    380            * @retval None
    381            */

   \                                 In section .text, align 4
    382          __weak void HAL_Delay(uint32_t Delay)
    383          {
   \                     HAL_Delay: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    384            uint32_t tickstart = HAL_GetTick();
   \        0x4   0x.... 0x....      BL       HAL_GetTick
   \        0x8   0x0005             MOVS     R5,R0
    385            uint32_t wait = Delay;
    386          
    387            /* Add a freq to guarantee minimum wait */
    388            if (wait < HAL_MAX_DELAY)
   \        0xA   0xF114 0x0F01      CMN      R4,#+1
   \        0xE   0xD002             BEQ.N    ??HAL_Delay_1
    389            {
    390              wait += (uint32_t)(uwTickFreq);
   \       0x10   0x4804             LDR.N    R0,??HAL_Delay_0
   \       0x12   0x7800             LDRB     R0,[R0, #+0]
   \       0x14   0x1904             ADDS     R4,R0,R4
    391            }
    392          
    393            while ((HAL_GetTick() - tickstart) < wait)
   \                     ??HAL_Delay_1: (+1)
   \       0x16   0x.... 0x....      BL       HAL_GetTick
   \       0x1A   0x1B40             SUBS     R0,R0,R5
   \       0x1C   0x42A0             CMP      R0,R4
   \       0x1E   0xD3FA             BCC.N    ??HAL_Delay_1
    394            {
    395            }
    396          }
   \       0x20   0xBD31             POP      {R0,R4,R5,PC}
   \       0x22   0xBF00             Nop
   \                     ??HAL_Delay_0:
   \       0x24   0x....'....        DC32     uwTickFreq
    397          
    398          /**
    399            * @brief Suspend Tick increment.
    400            * @note In the default implementation , SysTick timer is the source of time base. It is
    401            *       used to generate interrupts at regular time intervals. Once HAL_SuspendTick()
    402            *       is called, the SysTick interrupt will be disabled and so Tick increment
    403            *       is suspended.
    404            * @note This function is declared as __weak to be overwritten in case of other
    405            *       implementations in user file.
    406            * @retval None
    407            */

   \                                 In section .text, align 4
    408          __weak void HAL_SuspendTick(void)
    409          {
    410            /* Disable SysTick Interrupt */
    411            SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
   \                     HAL_SuspendTick: (+1)
   \        0x0   0x4802             LDR.N    R0,??HAL_SuspendTick_0
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF031 0x0102      BICS     R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    412          }
   \        0xA   0x4770             BX       LR
   \                     ??HAL_SuspendTick_0:
   \        0xC   0xE000'E010        DC32     0xe000e010
    413          
    414          /**
    415            * @brief Resume Tick increment.
    416            * @note In the default implementation , SysTick timer is the source of time base. It is
    417            *       used to generate interrupts at regular time intervals. Once HAL_ResumeTick()
    418            *       is called, the SysTick interrupt will be enabled and so Tick increment
    419            *       is resumed.
    420            * @note This function is declared as __weak to be overwritten in case of other
    421            *       implementations in user file.
    422            * @retval None
    423            */

   \                                 In section .text, align 4
    424          __weak void HAL_ResumeTick(void)
    425          {
    426            /* Enable SysTick Interrupt */
    427            SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
   \                     HAL_ResumeTick: (+1)
   \        0x0   0x4802             LDR.N    R0,??HAL_ResumeTick_0
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0102      ORRS     R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    428          }
   \        0xA   0x4770             BX       LR
   \                     ??HAL_ResumeTick_0:
   \        0xC   0xE000'E010        DC32     0xe000e010
    429          
    430          /**
    431            * @brief  Returns the HAL revision
    432            * @retval version : 0xXYZR (8bits for each decimal, R for RC)
    433            */

   \                                 In section .text, align 2, keep-with-next
    434          uint32_t HAL_GetHalVersion(void)
    435          {
    436            return __STM32H5XX_HAL_VERSION;
   \                     HAL_GetHalVersion: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_19
   \        0x2   0x4770             BX       LR
    437          }
    438          
    439          /**
    440            * @brief  Returns the device revision identifier.
    441            * @retval Device revision identifier
    442            */

   \                                 In section .text, align 2, keep-with-next
    443          uint32_t HAL_GetREVID(void)
    444          {
    445            return ((DBGMCU->IDCODE & DBGMCU_IDCODE_REV_ID) >> 16);
   \                     HAL_GetREVID: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_20
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0C00             LSRS     R0,R0,#+16
   \        0x6   0x4770             BX       LR
    446          }
    447          
    448          /**
    449            * @brief  Returns the device identifier.
    450            * @retval Device identifier
    451            */

   \                                 In section .text, align 2, keep-with-next
    452          uint32_t HAL_GetDEVID(void)
    453          {
    454            return (DBGMCU->IDCODE & DBGMCU_IDCODE_DEV_ID);
   \                     HAL_GetDEVID: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_20
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0500             LSLS     R0,R0,#+20
   \        0x6   0x0D00             LSRS     R0,R0,#+20
   \        0x8   0x4770             BX       LR
    455          }
    456          
    457          /**
    458            * @brief  Return the first word of the unique device identifier (UID based on 96 bits)
    459            * @retval Device identifier
    460            */

   \                                 In section .text, align 2, keep-with-next
    461          uint32_t HAL_GetUIDw0(void)
    462          {
    463            return (READ_REG(*((uint32_t *)UID_BASE)));
   \                     HAL_GetUIDw0: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_21
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
    464          }
    465          
    466          /**
    467            * @brief  Return the second word of the unique device identifier (UID based on 96 bits)
    468            * @retval Device identifier
    469            */

   \                                 In section .text, align 2, keep-with-next
    470          uint32_t HAL_GetUIDw1(void)
    471          {
    472            return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
   \                     HAL_GetUIDw1: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_22
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
    473          }
    474          
    475          /**
    476            * @brief  Return the third word of the unique device identifier (UID based on 96 bits)
    477            * @retval Device identifier
    478            */

   \                                 In section .text, align 2, keep-with-next
    479          uint32_t HAL_GetUIDw2(void)
    480          {
    481            return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
   \                     HAL_GetUIDw2: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_23
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
    482          }
    483          
    484          /**
    485            * @}
    486            */
    487          
    488          
    489          /** @defgroup HAL_Exported_Functions_Group3 HAL Debug functions
    490            *  @brief    HAL Debug functions
    491            *
    492          @verbatim
    493           =======================================================================================================================
    494                                                 ##### HAL Debug functions #####
    495           =======================================================================================================================
    496              [..]  This section provides functions allowing to:
    497                (+) Enable/Disable Debug module during STOP mode
    498                (+) Enable/Disable Debug module during STANDBY mode
    499          
    500          @endverbatim
    501            * @{
    502            */
    503          
    504          /**
    505            * @brief  Enable the Debug Module during STOP mode.
    506            * @retval None
    507            */

   \                                 In section .text, align 2, keep-with-next
    508          void HAL_DBGMCU_EnableDBGStopMode(void)
    509          {
    510            SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
   \                     HAL_DBGMCU_EnableDBGStopMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_24
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0102      ORRS     R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    511          }
   \        0xA   0x4770             BX       LR
    512          
    513          /**
    514            * @brief  Disable the Debug Module during STOP mode.
    515            * @retval None
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          void HAL_DBGMCU_DisableDBGStopMode(void)
    518          {
    519            CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
   \                     HAL_DBGMCU_DisableDBGStopMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_24
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF031 0x0102      BICS     R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    520          }
   \        0xA   0x4770             BX       LR
    521          
    522          /**
    523            * @brief  Enable the Debug Module during STANDBY mode.
    524            * @retval None
    525            */

   \                                 In section .text, align 2, keep-with-next
    526          void HAL_DBGMCU_EnableDBGStandbyMode(void)
    527          {
    528            SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
   \                     HAL_DBGMCU_EnableDBGStandbyMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_24
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0104      ORRS     R1,R1,#0x4
   \        0x8   0x6001             STR      R1,[R0, #+0]
    529          }
   \        0xA   0x4770             BX       LR
    530          
    531          /**
    532            * @brief  Disable the Debug Module during STANDBY mode.
    533            * @retval None
    534            */

   \                                 In section .text, align 2, keep-with-next
    535          void HAL_DBGMCU_DisableDBGStandbyMode(void)
    536          {
    537            CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
   \                     HAL_DBGMCU_DisableDBGStandbyMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_24
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF031 0x0104      BICS     R1,R1,#0x4
   \        0x8   0x6001             STR      R1,[R0, #+0]
    538          }
   \        0xA   0x4770             BX       LR
    539          
    540          /**
    541            * @}
    542            */
    543          
    544          /** @defgroup HAL_Exported_Functions_Group4 HAL VREFBUF Control functions
    545            *  @brief    HAL VREFBUF Control functions
    546            *
    547          @verbatim
    548           =======================================================================================================================
    549                                                 ##### HAL VREFBUF Control functions #####
    550           =======================================================================================================================
    551              [..]  This section provides functions allowing to:
    552                (+) Configure the Voltage reference buffer
    553                (+) Enable/Disable the Voltage reference buffer
    554          
    555          @endverbatim
    556            * @{
    557            */
    558          
    559          #if defined(VREFBUF)
    560          /**
    561            * @brief Configure the internal voltage reference buffer voltage scale.
    562            * @param  VoltageScaling: specifies the output voltage to achieve
    563            *          This parameter can be one of the following values:
    564            *            @arg VREFBUF_VOLTAGE_SCALE0: VREF_OUT1 around 2.5 V.
    565            *                                                This requires VDDA equal to or higher than 2.8 V.
    566            *            @arg VREFBUF_VOLTAGE_SCALE1: VREF_OUT2 around 2.048 V.
    567            *                                                This requires VDDA equal to or higher than 2.4 V.
    568            *            @arg VREFBUF_VOLTAGE_SCALE2: VREF_OUT3 around 1.8 V.
    569            *                                                This requires VDDA equal to or higher than 2.1 V.
    570            *            @arg VREFBUF_VOLTAGE_SCALE3: VREF_OUT4 around 1.5 V.
    571            *                                                This requires VDDA equal to or higher than 1.8 V.
    572            * @retval None
    573            */

   \                                 In section .text, align 2, keep-with-next
    574          void HAL_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)
    575          {
    576            /* Check the parameters */
    577            assert_param(IS_VREFBUF_VOLTAGE_SCALE(VoltageScaling));
    578          
    579            MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);
   \                     HAL_VREFBUF_VoltageScalingConfig: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_25
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xF032 0x0270      BICS     R2,R2,#0x70
   \        0x8   0x4310             ORRS     R0,R0,R2
   \        0xA   0x6008             STR      R0,[R1, #+0]
    580          }
   \        0xC   0x4770             BX       LR
    581          
    582          /**
    583            * @brief Configure the internal voltage reference buffer high impedance mode.
    584            * @param  Mode: specifies the high impedance mode
    585            *          This parameter can be one of the following values:
    586            *            @arg VREFBUF_HIGH_IMPEDANCE_DISABLE: VREF+ pin is internally connect to VREFINT output.
    587            *            @arg VREFBUF_HIGH_IMPEDANCE_ENABLE: VREF+ pin is high impedance.
    588            * @retval None
    589            */

   \                                 In section .text, align 2, keep-with-next
    590          void HAL_VREFBUF_HighImpedanceConfig(uint32_t Mode)
    591          {
    592            /* Check the parameters */
    593            assert_param(IS_VREFBUF_HIGH_IMPEDANCE(Mode));
    594          
    595            MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
   \                     HAL_VREFBUF_HighImpedanceConfig: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_25
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xF032 0x0202      BICS     R2,R2,#0x2
   \        0x8   0x4310             ORRS     R0,R0,R2
   \        0xA   0x6008             STR      R0,[R1, #+0]
    596          }
   \        0xC   0x4770             BX       LR
    597          
    598          /**
    599            * @brief  Tune the Internal Voltage Reference buffer (VREFBUF).
    600            * @retval None
    601            */

   \                                 In section .text, align 2, keep-with-next
    602          void HAL_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)
    603          {
    604            /* Check the parameters */
    605            assert_param(IS_VREFBUF_TRIMMING(TrimmingValue));
    606          
    607            MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);
   \                     HAL_VREFBUF_TrimmingConfig: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_26
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x0992             LSRS     R2,R2,#+6
   \        0x6   0x0192             LSLS     R2,R2,#+6
   \        0x8   0x4310             ORRS     R0,R0,R2
   \        0xA   0x6008             STR      R0,[R1, #+0]
    608          }
   \        0xC   0x4770             BX       LR
    609          
    610          /**
    611            * @brief  Enable the Internal Voltage Reference buffer (VREFBUF).
    612            * @retval HAL_OK/HAL_TIMEOUT
    613            */

   \                                 In section .text, align 2, keep-with-next
    614          HAL_StatusTypeDef HAL_EnableVREFBUF(void)
    615          {
   \                     HAL_EnableVREFBUF: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    616            uint32_t  tickstart;
    617          
    618            SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
   \        0x2   0x....             LDR.N    R5,??DataTable53_25
   \        0x4   0x6828             LDR      R0,[R5, #+0]
   \        0x6   0xF050 0x0001      ORRS     R0,R0,#0x1
   \        0xA   0x6028             STR      R0,[R5, #+0]
    619          
    620            /* Get Start Tick*/
    621            tickstart = HAL_GetTick();
   \        0xC   0x.... 0x....      BL       HAL_GetTick
   \       0x10   0x0004             MOVS     R4,R0
    622          
    623            /* Wait for VRR bit  */
    624            while (READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0UL)
   \                     ??HAL_EnableVREFBUF_0: (+1)
   \       0x12   0x6828             LDR      R0,[R5, #+0]
   \       0x14   0x0700             LSLS     R0,R0,#+28
   \       0x16   0xD406             BMI.N    ??HAL_EnableVREFBUF_1
    625            {
    626              if ((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
   \       0x18   0x.... 0x....      BL       HAL_GetTick
   \       0x1C   0x1B00             SUBS     R0,R0,R4
   \       0x1E   0x280B             CMP      R0,#+11
   \       0x20   0xD3F7             BCC.N    ??HAL_EnableVREFBUF_0
    627              {
    628                return HAL_TIMEOUT;
   \       0x22   0x2003             MOVS     R0,#+3
   \       0x24   0xE000             B.N      ??HAL_EnableVREFBUF_2
    629              }
    630            }
    631          
    632            return HAL_OK;
   \                     ??HAL_EnableVREFBUF_1: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \                     ??HAL_EnableVREFBUF_2: (+1)
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}
    633          }
    634          
    635          /**
    636            * @brief  Disable the Internal Voltage Reference buffer (VREFBUF).
    637            *
    638            * @retval None
    639            */

   \                                 In section .text, align 2, keep-with-next
    640          void HAL_DisableVREFBUF(void)
    641          {
    642            CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
   \                     HAL_DisableVREFBUF: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_25
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x0849             LSRS     R1,R1,#+1
   \        0x6   0x0049             LSLS     R1,R1,#+1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    643          }
   \        0xA   0x4770             BX       LR
    644          #endif /* VREFBUF */
    645          
    646          /**
    647            * @}
    648            */
    649          
    650          /** @defgroup HAL_Exported_Functions_Group5 HAL SBS configuration functions
    651            *  @brief    HAL SBS configuration functions
    652            *
    653          @verbatim
    654           =======================================================================================================================
    655                                                 ##### HAL SBS configuration functions #####
    656           =======================================================================================================================
    657              [..]  This section provides functions allowing to:
    658                (+) Select the Ethernet PHY Interface
    659                (+) Enable/Disable the VDD I/Os Compensation Cell
    660                (+) Code selection/configuration for the VDD I/O Compensation cell
    661                (+) Get ready flag status of VDD I/Os Compensation cell
    662                (+) Get PMOS/NMOS compensation value of the I/Os supplied by VDD
    663                (+) Enable/Disable the NMI in case of double ECC error in FLASH Interface
    664          
    665          @endverbatim
    666            * @{
    667            */
    668          
    669          #if defined(SBS_PMCR_ETH_SEL_PHY)
    670          /**
    671            * @brief  Ethernet PHY Interface Selection either MII or RMII
    672            * @param  SBS_ETHInterface: Selects the Ethernet PHY interface
    673            *   This parameter can be one of the following values:
    674            *   @arg SBS_ETH_MII : Select the Media Independent Interface
    675            *   @arg SBS_ETH_RMII: Select the Reduced Media Independent Interface
    676            * @retval None
    677            */

   \                                 In section .text, align 2, keep-with-next
    678          void HAL_SBS_ETHInterfaceSelect(uint32_t SBS_ETHInterface)
    679          {
    680            /* Check the parameter */
    681            assert_param(IS_SBS_ETHERNET_CONFIG(SBS_ETHInterface));
    682          
    683            MODIFY_REG(SBS->PMCR, SBS_PMCR_ETH_SEL_PHY, (uint32_t)(SBS_ETHInterface));
   \                     HAL_SBS_ETHInterfaceSelect: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_27
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xF432 0x0260      BICS     R2,R2,#0xE00000
   \        0x8   0x4310             ORRS     R0,R0,R2
   \        0xA   0x6008             STR      R0,[R1, #+0]
    684          }
   \        0xC   0x4770             BX       LR
    685          #endif /* SBS_PMCR_ETH_SEL_PHY */
    686          
    687          /**
    688            * @brief  Enables the VDD I/Os Compensation Cell.
    689            * @note   The I/O compensation cell can be used only when the device supply
    690            *         voltage ranges from 2.4 to 3.6 V.
    691            * @retval None
    692            */

   \                                 In section .text, align 2, keep-with-next
    693          void HAL_SBS_EnableVddIO1CompensationCell(void)
    694          {
    695            SET_BIT(SBS->CCCSR, SBS_CCCSR_EN1) ;
   \                     HAL_SBS_EnableVddIO1CompensationCell: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_28
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0101      ORRS     R1,R1,#0x1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    696          }
   \        0xA   0x4770             BX       LR
    697          
    698          /**
    699            * @brief  Power-down the VDD I/Os Compensation Cell.
    700            * @note   The I/O compensation cell can be used only when the device supply
    701            *         voltage ranges from 2.4 to 3.6 V.
    702            * @retval None
    703            */

   \                                 In section .text, align 2, keep-with-next
    704          void HAL_SBS_DisableVddIO1CompensationCell(void)
    705          {
    706            CLEAR_BIT(SBS->CCCSR, SBS_CCCSR_EN1);
   \                     HAL_SBS_DisableVddIO1CompensationCell: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_28
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x0849             LSRS     R1,R1,#+1
   \        0x6   0x0049             LSLS     R1,R1,#+1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    707          }
   \        0xA   0x4770             BX       LR
    708          
    709          /**
    710            * @brief  Enables the VDDIO2 I/Os Compensation Cell.
    711            * @note   The I/O compensation cell can be used only when the device supply
    712            *         voltage ranges from 2.4 to 3.6 V.
    713            * @retval None
    714            */

   \                                 In section .text, align 2, keep-with-next
    715          void HAL_SBS_EnableVddIO2CompensationCell(void)
    716          {
    717            SET_BIT(SBS->CCCSR, SBS_CCCSR_EN2) ;
   \                     HAL_SBS_EnableVddIO2CompensationCell: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_28
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0104      ORRS     R1,R1,#0x4
   \        0x8   0x6001             STR      R1,[R0, #+0]
    718          }
   \        0xA   0x4770             BX       LR
    719          
    720          /**
    721            * @brief  Power-down the VDDIO2 I/Os Compensation Cell.
    722            * @note   The I/O compensation cell can be used only when the device supply
    723            *         voltage ranges from 2.4 to 3.6 V.
    724            * @retval None
    725            */

   \                                 In section .text, align 2, keep-with-next
    726          void HAL_SBS_DisableVddIO2CompensationCell(void)
    727          {
    728            CLEAR_BIT(SBS->CCCSR, SBS_CCCSR_EN2);
   \                     HAL_SBS_DisableVddIO2CompensationCell: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_28
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF031 0x0104      BICS     R1,R1,#0x4
   \        0x8   0x6001             STR      R1,[R0, #+0]
    729          }
   \        0xA   0x4770             BX       LR
    730          
    731          /**
    732            * @brief  Code selection for the VDD I/O Compensation cell
    733            * @param  SBS_CompCode: Selects the code to be applied for the I/O compensation cell
    734            *         This parameter can be one of the following values:
    735            *           @arg SBS_VDD_CELL_CODE : Select Code from the cell (available in the SBS_CCVALR)
    736            *           @arg SBS_VDD_REGISTER_CODE: Select Code from the SBS compensation cell code register (SBS_CCSWCR)
    737            * @retval None
    738            */

   \                                 In section .text, align 2, keep-with-next
    739          void HAL_SBS_VDDCompensationCodeSelect(uint32_t SBS_CompCode)
    740          {
    741            /* Check the parameter */
    742            assert_param(IS_SBS_VDD_CODE_SELECT(SBS_CompCode));
    743            MODIFY_REG(SBS->CCCSR, SBS_CCCSR_CS1, (uint32_t)(SBS_CompCode));
   \                     HAL_SBS_VDDCompensationCodeSelect: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_28
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xF032 0x0202      BICS     R2,R2,#0x2
   \        0x8   0x4310             ORRS     R0,R0,R2
   \        0xA   0x6008             STR      R0,[R1, #+0]
    744          }
   \        0xC   0x4770             BX       LR
    745          
    746          /**
    747            * @brief  Code selection for the VDDIO I/O Compensation cell
    748            * @param  SBS_CompCode: Selects the code to be applied for the I/O compensation cell
    749            *         This parameter can be one of the following values:
    750            *           @arg SBS_VDDIO_CELL_CODE : Select Code from the cell (available in the SBS_CCVALR)
    751            *           @arg SBS_VDDIO_REGISTER_CODE: Select Code from the SBS compensation cell code register (SBS_CCSWCR)
    752            * @retval None
    753            */

   \                                 In section .text, align 2, keep-with-next
    754          void HAL_SBS_VDDIOCompensationCodeSelect(uint32_t SBS_CompCode)
    755          {
    756            /* Check the parameter */
    757            assert_param(IS_SBS_VDDIO_CODE_SELECT(SBS_CompCode));
    758            MODIFY_REG(SBS->CCCSR, SBS_CCCSR_CS2, (uint32_t)(SBS_CompCode));
   \                     HAL_SBS_VDDIOCompensationCodeSelect: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_28
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xF032 0x0208      BICS     R2,R2,#0x8
   \        0x8   0x4310             ORRS     R0,R0,R2
   \        0xA   0x6008             STR      R0,[R1, #+0]
    759          }
   \        0xC   0x4770             BX       LR
    760          
    761          /**
    762            * @brief  VDDIO1 I/O Compensation cell get ready flag status
    763            * @retval State of bit (1 or 0).
    764            */

   \                                 In section .text, align 2, keep-with-next
    765          uint32_t HAL_SBS_GetVddIO1CompensationCellReadyFlag(void)
    766          {
    767            return ((READ_BIT(SBS->CCCSR, SBS_CCCSR_RDY1) == SBS_CCCSR_RDY1) ? 1UL : 0UL);
   \                     HAL_SBS_GetVddIO1CompensationCellReadyFlag: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_28
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0A00             LSRS     R0,R0,#+8
   \        0x6   0xF010 0x0001      ANDS     R0,R0,#0x1
   \        0xA   0x4770             BX       LR
    768          }
    769          
    770          /**
    771            * @brief  VDDIO2 I/O Compensation cell get ready flag status
    772            * @retval State of bit (1 or 0).
    773            */

   \                                 In section .text, align 2, keep-with-next
    774          uint32_t HAL_SBS_GetVddIO2CompensationCellReadyFlag(void)
    775          {
    776            return ((READ_BIT(SBS->CCCSR, SBS_CCCSR_RDY2) == SBS_CCCSR_RDY2) ? 1UL : 0UL);
   \                     HAL_SBS_GetVddIO2CompensationCellReadyFlag: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_28
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0A40             LSRS     R0,R0,#+9
   \        0x6   0xF010 0x0001      ANDS     R0,R0,#0x1
   \        0xA   0x4770             BX       LR
    777          }
    778          
    779          /**
    780            * @brief  Code configuration for the VDD I/O Compensation cell
    781            * @param  SBS_PMOSCode: PMOS compensation code
    782            *         This code is applied to the VDD I/O compensation cell when the CS1 bit of the
    783            *          SBS_CCSR is set
    784            * @param  SBS_NMOSCode: NMOS compensation code
    785            *         This code is applied to the VDD I/O compensation cell when the CS1 bit of the
    786            *          SBS_CCSR is set
    787            * @retval None
    788            */

   \                                 In section .text, align 2, keep-with-next
    789          void HAL_SBS_VDDCompensationCodeConfig(uint32_t SBS_PMOSCode, uint32_t SBS_NMOSCode)
    790          {
    791            /* Check the parameter */
    792            assert_param(IS_SBS_CODE_CONFIG(SBS_PMOSCode));
    793            assert_param(IS_SBS_CODE_CONFIG(SBS_NMOSCode));
    794            MODIFY_REG(SBS->CCSWCR, SBS_CCSWCR_SW_ANSRC1 | SBS_CCSWCR_SW_APSRC1, (((uint32_t)(SBS_PMOSCode) << 4) | \
    795                                                                                  (uint32_t)(SBS_NMOSCode)));
   \                     HAL_SBS_VDDCompensationCodeConfig: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable53_29
   \        0x2   0x6813             LDR      R3,[R2, #+0]
   \        0x4   0x0A1B             LSRS     R3,R3,#+8
   \        0x6   0x021B             LSLS     R3,R3,#+8
   \        0x8   0x4319             ORRS     R1,R1,R3
   \        0xA   0xEA51 0x1100      ORRS     R1,R1,R0, LSL #+4
   \        0xE   0x6011             STR      R1,[R2, #+0]
    796          }
   \       0x10   0x4770             BX       LR
    797          
    798          /**
    799            * @brief  Code configuration for the VDDIO I/O Compensation cell
    800            * @param  SBS_PMOSCode: PMOS compensation code
    801            *         This code is applied to the VDDIO I/O compensation cell when the CS2 bit of the
    802            *          SBS_CCSR is set
    803            * @param  SBS_NMOSCode: NMOS compensation code
    804            *         This code is applied to the VDDIO I/O compensation cell when the CS2 bit of the
    805            *          SBS_CCSR is set
    806            * @retval None
    807            */

   \                                 In section .text, align 2, keep-with-next
    808          void HAL_SBS_VDDIOCompensationCodeConfig(uint32_t SBS_PMOSCode, uint32_t SBS_NMOSCode)
    809          {
    810            /* Check the parameter */
    811            assert_param(IS_SBS_CODE_CONFIG(SBS_PMOSCode));
    812            assert_param(IS_SBS_CODE_CONFIG(SBS_NMOSCode));
    813            MODIFY_REG(SBS->CCSWCR, SBS_CCSWCR_SW_ANSRC2 | SBS_CCSWCR_SW_APSRC2, (((uint32_t)(SBS_PMOSCode) << 12) | \
    814                                                                                  ((uint32_t)(SBS_NMOSCode) << 8)));
   \                     HAL_SBS_VDDIOCompensationCodeConfig: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable53_29
   \        0x2   0x6813             LDR      R3,[R2, #+0]
   \        0x4   0xF433 0x437F      BICS     R3,R3,#0xFF00
   \        0x8   0xEA53 0x3300      ORRS     R3,R3,R0, LSL #+12
   \        0xC   0xEA53 0x2301      ORRS     R3,R3,R1, LSL #+8
   \       0x10   0x6013             STR      R3,[R2, #+0]
    815          }
   \       0x12   0x4770             BX       LR
    816          
    817          /**
    818            * @brief  Get NMOS compensation value of the I/Os supplied by VDD
    819            * @retval None
    820            */

   \                                 In section .text, align 2, keep-with-next
    821          uint32_t HAL_SBS_GetNMOSVddCompensationValue(void)
    822          {
    823            return (uint32_t)(READ_BIT(SBS->CCVALR, SBS_CCVALR_ANSRC1));
   \                     HAL_SBS_GetNMOSVddCompensationValue: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_30
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF010 0x000F      ANDS     R0,R0,#0xF
   \        0x8   0x4770             BX       LR
    824          }
    825          
    826          /**
    827            * @brief  Get PMOS compensation value of the I/Os supplied by VDD
    828            * @retval None
    829            */

   \                                 In section .text, align 2, keep-with-next
    830          uint32_t HAL_SBS_GetPMOSVddCompensationValue(void)
    831          {
    832            return (uint32_t)(READ_BIT(SBS->CCVALR, SBS_CCVALR_APSRC1) >>  SBS_CCVALR_APSRC1_Pos);
   \                     HAL_SBS_GetPMOSVddCompensationValue: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_30
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF3C0 0x1003      UBFX     R0,R0,#+4,#+4
   \        0x8   0x4770             BX       LR
    833          }
    834          
    835          /**
    836            * @brief  Get NMOS compensation value of the I/Os supplied by VDDIO2
    837            * @retval None
    838            */

   \                                 In section .text, align 2, keep-with-next
    839          uint32_t HAL_SBS_GetNMOSVddIO2CompensationValue(void)
    840          {
    841            return (uint32_t)(READ_BIT(SBS->CCVALR, SBS_CCVALR_ANSRC2) >>  SBS_CCVALR_ANSRC2_Pos);
   \                     HAL_SBS_GetNMOSVddIO2CompensationValue: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_30
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF3C0 0x2003      UBFX     R0,R0,#+8,#+4
   \        0x8   0x4770             BX       LR
    842          }
    843          
    844          
    845          /**
    846            * @brief  Get PMOS compensation value of the I/Os supplied by VDDIO2
    847            * @retval None
    848            */

   \                                 In section .text, align 2, keep-with-next
    849          uint32_t HAL_SBS_GetPMOSVddIO2CompensationValue(void)
    850          {
    851            return (uint32_t)(READ_BIT(SBS->CCVALR, SBS_CCVALR_APSRC2) >>  SBS_CCVALR_APSRC2_Pos);
   \                     HAL_SBS_GetPMOSVddIO2CompensationValue: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_30
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF3C0 0x3003      UBFX     R0,R0,#+12,#+4
   \        0x8   0x4770             BX       LR
    852          }
    853          
    854          /**
    855            * @brief  Disable the NMI in case of double ECC error in FLASH Interface.
    856            *
    857            * @retval None
    858            */

   \                                 In section .text, align 2, keep-with-next
    859          void HAL_SBS_FLASH_DisableECCNMI(void)
    860          {
    861            SET_BIT(SBS->ECCNMIR, SBS_ECCNMIR_ECCNMI_MASK_EN);
   \                     HAL_SBS_FLASH_DisableECCNMI: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_31
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0101      ORRS     R1,R1,#0x1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    862          }
   \        0xA   0x4770             BX       LR
    863          
    864          /**
    865            * @brief  Enable the NMI in case of double ECC error in FLASH Interface.
    866            *
    867            * @retval None
    868            */

   \                                 In section .text, align 2, keep-with-next
    869          void HAL_SBS_FLASH_EnableECCNMI(void)
    870          {
    871            CLEAR_BIT(SBS->ECCNMIR, SBS_ECCNMIR_ECCNMI_MASK_EN);
   \                     HAL_SBS_FLASH_EnableECCNMI: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_31
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x0849             LSRS     R1,R1,#+1
   \        0x6   0x0049             LSLS     R1,R1,#+1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    872          }
   \        0xA   0x4770             BX       LR
    873          
    874          /**
    875            * @brief  Check if the NMI is Enabled in case of double ECC error in FLASH Interface.
    876            *
    877            * @retval State of bit (1 or 0).
    878            */

   \                                 In section .text, align 2, keep-with-next
    879          uint32_t HAL_SBS_FLASH_ECCNMI_IsDisabled(void)
    880          {
    881            return ((READ_BIT(SBS->ECCNMIR, SBS_ECCNMIR_ECCNMI_MASK_EN) == SBS_ECCNMIR_ECCNMI_MASK_EN) ? 1UL : 0UL);
   \                     HAL_SBS_FLASH_ECCNMI_IsDisabled: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_31
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF010 0x0001      ANDS     R0,R0,#0x1
   \        0x8   0x4770             BX       LR
    882          }
    883          
    884          /**
    885            * @}
    886            */
    887          
    888          /** @defgroup HAL_Exported_Functions_Group6 HAL SBS Boot control functions
    889            *  @brief    HAL SBS Boot functions
    890            *
    891          @verbatim
    892           =======================================================================================================================
    893                                                 ##### HAL SBS Boot control functions #####
    894           =======================================================================================================================
    895              [..]  This section provides functions allowing to:
    896                (+) Increment the HDPL value
    897                (+) Get the HDPL value
    898          
    899          @endverbatim
    900            * @{
    901            */
    902          
    903          /**
    904            * @brief  Increment by 1 the HDPL value
    905            * @retval None
    906            */

   \                                 In section .text, align 2, keep-with-next
    907          void HAL_SBS_IncrementHDPLValue(void)
    908          {
    909            MODIFY_REG(SBS->HDPLCR, SBS_HDPLCR_INCR_HDPL, SBS_HDPL_INCREMENT_VALUE);
   \                     HAL_SBS_IncrementHDPLValue: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_32
   \        0x2   0x216A             MOVS     R1,#+106
   \        0x4   0x6802             LDR      R2,[R0, #+0]
   \        0x6   0xF361 0x0207      BFI      R2,R1,#+0,#+8
   \        0xA   0x6002             STR      R2,[R0, #+0]
    910          }
   \        0xC   0x4770             BX       LR
    911          
    912          /**
    913            * @brief  Get the HDPL Value.
    914            *
    915            * @retval  Returns the HDPL value
    916            *          This return value can be one of the following values:
    917            *            @arg SBS_HDPL_VALUE_0: HDPL0
    918            *            @arg SBS_HDPL_VALUE_1: HDPL1
    919            *            @arg SBS_HDPL_VALUE_2: HDPL2
    920            *            @arg SBS_HDPL_VALUE_3: HDPL3
    921            */

   \                                 In section .text, align 2, keep-with-next
    922          uint32_t HAL_SBS_GetHDPLValue(void)
    923          {
    924            return (uint32_t)(READ_BIT(SBS->HDPLSR, SBS_HDPLSR_HDPL));
   \                     HAL_SBS_GetHDPLValue: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_33
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF000 0x00FF      AND      R0,R0,#0xFF
   \        0x8   0x4770             BX       LR
    925          }
    926          
    927          /**
    928            * @}
    929            */
    930          
    931          /** @defgroup HAL_Exported_Functions_Group7 HAL SBS Hardware secure storage control functions
    932            *  @brief    HAL SBS Hardware secure storage functions
    933            *
    934          @verbatim
    935           =======================================================================================================================
    936                                                 ##### HAL SBS Hardware secure storage control functions #####
    937           =======================================================================================================================
    938              [..]  This section provides functions allowing to:
    939                (+) Select EPOCH security sent to SAES IP
    940                (+) Set/Get EPOCH security selection
    941                (+) Set/Get the OBK-HDPL Value
    942          
    943          @endverbatim
    944            * @{
    945            */
    946          
    947          #if defined(SBS_EPOCHSELCR_EPOCH_SEL)
    948          /**
    949            * @brief  Select EPOCH security sent to SAES IP to encrypt/decrypt keys
    950            * @param  Epoch_Selection: Select EPOCH security
    951            *         This parameter can be one of the following values:
    952            *           @arg SBS_EPOCH_SEL_SECURE    : EPOCH secure selected.
    953            *           @arg SBS_EPOCH_SEL_NONSECURE : EPOCH non secure selected.
    954            *           @arg SBS_EPOCH_SEL_PUFCHECK  : EPOCH all zeros for PUF integrity check.
    955            * @retval None
    956            */

   \                                 In section .text, align 2, keep-with-next
    957          void HAL_SBS_EPOCHSelection(uint32_t Epoch_Selection)
    958          {
    959            /* Check the parameter */
    960            assert_param(IS_SBS_EPOCH_SELECTION(Epoch_Selection));
    961          
    962            MODIFY_REG(SBS->EPOCHSELCR, SBS_EPOCHSELCR_EPOCH_SEL, (uint32_t)(Epoch_Selection));
   \                     HAL_SBS_EPOCHSelection: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_34
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x0892             LSRS     R2,R2,#+2
   \        0x6   0x0092             LSLS     R2,R2,#+2
   \        0x8   0x4310             ORRS     R0,R0,R2
   \        0xA   0x6008             STR      R0,[R1, #+0]
    963          }
   \        0xC   0x4770             BX       LR
    964          
    965          /**
    966            * @brief  Get EPOCH security selection
    967            * @retval Returned value can be one of the following values:
    968            *           @arg SBS_EPOCH_SEL_SECURE    : EPOCH secure selected.
    969            *           @arg SBS_EPOCH_SEL_NONSECURE : EPOCH non secure selected.
    970            *           @arg SBS_EPOCH_SEL_PUFCHECK  : EPOCH all zeros for PUF integrity check.
    971            */

   \                                 In section .text, align 2, keep-with-next
    972          uint32_t HAL_SBS_GetEPOCHSelection(void)
    973          {
    974            return (uint32_t)(READ_BIT(SBS->EPOCHSELCR, SBS_EPOCHSELCR_EPOCH_SEL));
   \                     HAL_SBS_GetEPOCHSelection: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_34
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF010 0x0003      ANDS     R0,R0,#0x3
   \        0x8   0x4770             BX       LR
    975          }
    976          #endif /* SBS_EPOCHSELCR_EPOCH_SEL */
    977          
    978          #if defined(SBS_NEXTHDPLCR_NEXTHDPL)
    979          /**
    980            * @brief  Set the OBK-HDPL Value.
    981            * @param  OBKHDPL_Value Value of the increment to add to HDPL value to generate the OBK-HDPL.
    982            *         This parameter can be one of the following values:
    983            *           @arg SBS_OBKHDPL_INCR_0 : HDPL
    984            *           @arg SBS_OBKHDPL_INCR_1 : HDPL + 1
    985            *           @arg SBS_OBKHDPL_INCR_2 : HDPL + 2
    986            *           @arg SBS_OBKHDPL_INCR_3 : HDPL + 3
    987            * @retval None
    988            */

   \                                 In section .text, align 2, keep-with-next
    989          void HAL_SBS_SetOBKHDPL(uint32_t OBKHDPL_Value)
    990          {
    991            /* Check the parameter */
    992            assert_param(IS_SBS_OBKHDPL_SELECTION(OBKHDPL_Value));
    993          
    994            MODIFY_REG(SBS->NEXTHDPLCR, SBS_NEXTHDPLCR_NEXTHDPL, (uint32_t)(OBKHDPL_Value));
   \                     HAL_SBS_SetOBKHDPL: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_35
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x0892             LSRS     R2,R2,#+2
   \        0x6   0x0092             LSLS     R2,R2,#+2
   \        0x8   0x4310             ORRS     R0,R0,R2
   \        0xA   0x6008             STR      R0,[R1, #+0]
    995          }
   \        0xC   0x4770             BX       LR
    996          
    997          /**
    998            * @brief  Get the OBK-HDPL Value.
    999            * @retval  Returns the incremement to add to HDPL value to generate OBK-HDPL
   1000            *          This return value can be one of the following values:
   1001            *            @arg SBS_OBKHDPL_INCR_0: HDPL
   1002            *            @arg SBS_OBKHDPL_INCR_1: HDPL + 1
   1003            *            @arg SBS_OBKHDPL_INCR_2: HDPL + 2
   1004            *            @arg SBS_OBKHDPL_INCR_3: HDPL + 3
   1005            */

   \                                 In section .text, align 2, keep-with-next
   1006          uint32_t HAL_SBS_GetOBKHDPL(void)
   1007          {
   1008            return (uint32_t)(READ_BIT(SBS->NEXTHDPLCR, SBS_NEXTHDPLCR_NEXTHDPL));
   \                     HAL_SBS_GetOBKHDPL: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_35
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF010 0x0003      ANDS     R0,R0,#0x3
   \        0x8   0x4770             BX       LR
   1009          }
   1010          #endif /* SBS_NEXTHDPLCR_NEXTHDPL */
   1011          
   1012          /**
   1013            * @}
   1014            */
   1015          
   1016          /** @defgroup HAL_Exported_Functions_Group8 HAL SBS Debug control functions
   1017            *  @brief    HAL SBS Debug functions
   1018            *
   1019          @verbatim
   1020           =======================================================================================================================
   1021                                                 ##### SBS Debug control functions #####
   1022           =======================================================================================================================
   1023              [..]  This section provides functions allowing to:
   1024                (+) Open the device access port
   1025                (+) Open the debug
   1026                (+) Configure the authenticated debug HDPL
   1027                (+) Get the current value of the hide protection level
   1028                (+) Lock the access to the debug control register
   1029                (+) Configure/Get the authenticated debug security access
   1030          
   1031          @endverbatim
   1032            * @{
   1033            */
   1034          
   1035          /**
   1036            * @brief  Open the device access port.
   1037            * @note   This function can be only used when device state is Closed.
   1038            * @retval None
   1039            */

   \                                 In section .text, align 2, keep-with-next
   1040          void HAL_SBS_OpenAccessPort(void)
   1041          {
   1042            MODIFY_REG(SBS->DBGCR, SBS_DBGCR_AP_UNLOCK, SBS_DEBUG_UNLOCK_VALUE);
   \                     HAL_SBS_OpenAccessPort: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_36
   \        0x2   0x21B4             MOVS     R1,#+180
   \        0x4   0x6802             LDR      R2,[R0, #+0]
   \        0x6   0xF361 0x0207      BFI      R2,R1,#+0,#+8
   \        0xA   0x6002             STR      R2,[R0, #+0]
   1043          }
   \        0xC   0x4770             BX       LR
   1044          
   1045          /**
   1046            * @brief  Open the debug when the hide protection level is authorized.
   1047            * @note   This function can be only used when device state is Closed.
   1048            * @retval None
   1049            */

   \                                 In section .text, align 2, keep-with-next
   1050          void HAL_SBS_OpenDebug(void)
   1051          {
   1052            MODIFY_REG(SBS->DBGCR, SBS_DBGCR_DBG_UNLOCK, (SBS_DEBUG_UNLOCK_VALUE << SBS_DBGCR_DBG_UNLOCK_Pos));
   \                     HAL_SBS_OpenDebug: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_36
   \        0x2   0x21B4             MOVS     R1,#+180
   \        0x4   0x6802             LDR      R2,[R0, #+0]
   \        0x6   0xF361 0x220F      BFI      R2,R1,#+8,#+8
   \        0xA   0x6002             STR      R2,[R0, #+0]
   1053          }
   \        0xC   0x4770             BX       LR
   1054          
   1055          /**
   1056            * @brief  Configure the authenticated debug hide protection level.
   1057            * @note   This function can be only used when device state is Closed.
   1058            * @param  Level Hide protection level where the authenticated debug opens
   1059            *            This value is one of @ref SBS_HDPL_Value (except SBS_HDPL_VALUE_0)
   1060            * @retval HAL_OK if parameter is correct
   1061            *         HAL_ERROR otherwise
   1062            */

   \                                 In section .text, align 2, keep-with-next
   1063          HAL_StatusTypeDef HAL_SBS_ConfigDebugLevel(uint32_t Level)
   1064          {
   1065            /* Check the parameter */
   1066            assert_param(IS_SBS_HDPL(Level));
   1067          
   1068            if (Level != SBS_HDPL_VALUE_0)
   \                     HAL_SBS_ConfigDebugLevel: (+1)
   \        0x0   0x28B4             CMP      R0,#+180
   \        0x2   0xD008             BEQ.N    ??HAL_SBS_ConfigDebugLevel_0
   1069            {
   1070              MODIFY_REG(SBS->DBGCR, SBS_DBGCR_DBG_AUTH_HDPL, (Level << SBS_DBGCR_DBG_AUTH_HDPL_Pos));
   \        0x4   0x....             LDR.N    R1,??DataTable53_36
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0xF432 0x027F      BICS     R2,R2,#0xFF0000
   \        0xC   0xEA52 0x4200      ORRS     R2,R2,R0, LSL #+16
   \       0x10   0x600A             STR      R2,[R1, #+0]
   1071              return HAL_OK;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE000             B.N      ??HAL_SBS_ConfigDebugLevel_1
   1072            }
   1073            else
   1074            {
   1075              return HAL_ERROR;
   \                     ??HAL_SBS_ConfigDebugLevel_0: (+1)
   \       0x16   0x2001             MOVS     R0,#+1
   \                     ??HAL_SBS_ConfigDebugLevel_1: (+1)
   \       0x18   0x4770             BX       LR
   1076            }
   1077          }
   1078          
   1079          /**
   1080            * @brief  Get the current value of the hide protection level.
   1081            * @note   This function can be only used when device state is Closed.
   1082            * @retval Current hide protection level
   1083            *            This value is one of @ref SBS_HDPL_Value
   1084            */

   \                                 In section .text, align 2, keep-with-next
   1085          uint32_t HAL_SBS_GetDebugLevel(void)
   1086          {
   1087            return ((SBS->DBGCR & SBS_DBGCR_DBG_AUTH_HDPL) >> SBS_DBGCR_DBG_AUTH_HDPL_Pos);
   \                     HAL_SBS_GetDebugLevel: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_36
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF3C0 0x4007      UBFX     R0,R0,#+16,#+8
   \        0x8   0x4770             BX       LR
   1088          }
   1089          
   1090          /**
   1091            * @brief  Lock the access to the debug control register.
   1092            * @note   This function can be only used when device state is Closed.
   1093            * @note   locking the current debug configuration is released only by a reset.
   1094            * @retval None
   1095            */

   \                                 In section .text, align 2, keep-with-next
   1096          void HAL_SBS_LockDebugConfig(void)
   1097          {
   1098            MODIFY_REG(SBS->DBGLOCKR, SBS_DBGLOCKR_DBGCFG_LOCK, SBS_DEBUG_LOCK_VALUE);
   \                     HAL_SBS_LockDebugConfig: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_37
   \        0x2   0x21C3             MOVS     R1,#+195
   \        0x4   0x6802             LDR      R2,[R0, #+0]
   \        0x6   0xF361 0x0207      BFI      R2,R1,#+0,#+8
   \        0xA   0x6002             STR      R2,[R0, #+0]
   1099          }
   \        0xC   0x4770             BX       LR
   1100          
   1101          #if defined(SBS_DBGCR_DBG_AUTH_SEC)
   1102          /**
   1103            * @brief  Configure the authenticated debug security access.
   1104            * @param  Control debug opening secure/non-secure or non-secure only
   1105            *         This parameter can be one of the following values:
   1106            *            @arg SBS_DEBUG_SEC_NSEC: debug opening for secure and non-secure.
   1107            *            @arg SBS_DEBUG_NSEC: debug opening for non-secure only.
   1108            * @retval None
   1109            */

   \                                 In section .text, align 2, keep-with-next
   1110          void HAL_SBS_ConfigDebugSecurity(uint32_t Security)
   1111          {
   1112            MODIFY_REG(SBS->DBGCR, SBS_DBGCR_DBG_AUTH_SEC, (Security << SBS_DBGCR_DBG_AUTH_SEC_Pos));
   \                     HAL_SBS_ConfigDebugSecurity: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_36
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xF360 0x621F      BFI      R2,R0,#+24,#+8
   \        0x8   0x600A             STR      R2,[R1, #+0]
   1113          }
   \        0xA   0x4770             BX       LR
   1114          
   1115          /**
   1116            * @brief  Get the current value of the hide protection level.
   1117            * @note   This function can be only used when device state is Closed.
   1118            * @retval Returned value can be one of the following values:
   1119            *            @arg SBS_DEBUG_SEC_NSEC: debug opening for secure and non-secure.
   1120            *            @arg SBS_DEBUG_NSEC: debug opening for non-secure only.
   1121            */

   \                                 In section .text, align 2, keep-with-next
   1122          uint32_t HAL_SBS_GetDebugSecurity(void)
   1123          {
   1124            return ((SBS->DBGCR & SBS_DBGCR_DBG_AUTH_SEC) >> SBS_DBGCR_DBG_AUTH_SEC_Pos);
   \                     HAL_SBS_GetDebugSecurity: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_36
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0E00             LSRS     R0,R0,#+24
   \        0x6   0x4770             BX       LR
   1125          }
   1126          #endif /* SBS_DBGCR_DBG_AUTH_SEC */
   1127          
   1128          /**
   1129            * @}
   1130            */
   1131          
   1132          /** @defgroup HAL_Exported_Functions_Group9 HAL SBS lock management functions
   1133            *  @brief SBS lock management functions.
   1134            *
   1135          @verbatim
   1136           =======================================================================================================================
   1137                                                  ##### SBS lock functions #####
   1138           =======================================================================================================================
   1139          
   1140          @endverbatim
   1141            * @{
   1142            */
   1143          
   1144          /**
   1145            * @brief  Lock the SBS item(s).
   1146            * @note   Setting lock(s) depends on privilege mode in secure/non-secure code
   1147            *         Lock(s) cleared only at system reset
   1148            * @param  Item Item(s) to set lock on.
   1149            *         This parameter can be a combination of @ref SBS_Lock_items
   1150            * @retval None
   1151            */

   \                                 In section .text, align 2, keep-with-next
   1152          void HAL_SBS_Lock(uint32_t Item)
   1153          {
   1154            /* Check the parameters */
   1155            assert_param(IS_SBS_LOCK_ITEMS(Item));
   1156          
   1157            /* Privilege secure/non-secure locks */
   1158            SBS->CNSLCKR = (0xFFFFU & Item);  /* non-secure lock item in 16 lowest bits */
   \                     HAL_SBS_Lock: (+1)
   \        0x0   0xB280             UXTH     R0,R0
   \        0x2   0x....             LDR.N    R1,??DataTable53_38
   \        0x4   0x6008             STR      R0,[R1, #+0]
   1159          
   1160          #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
   1161            /* Privilege secure only locks */
   1162            SBS->CSLCKR = ((0xFFFF0000U & Item) >> 16U);  /* Secure-only lock item in 16 highest bits */
   1163          #endif /* __ARM_FEATURE_CMSE */
   1164          }
   \        0x6   0x4770             BX       LR
   1165          
   1166          /**
   1167            * @brief  Get the lock state of SBS items.
   1168            * @note   Getting lock(s) depends on privilege mode in secure/non-secure code
   1169            * @param  pItem pointer to return locked items
   1170            *         the return value can be a combination of @ref SBS_Lock_items
   1171            * @retval HAL status
   1172            */

   \                                 In section .text, align 2, keep-with-next
   1173          HAL_StatusTypeDef HAL_SBS_GetLock(uint32_t *pItem)
   1174          {
   1175            uint32_t tmp_lock;
   1176          
   1177            /* Check null pointer */
   1178            if (pItem == NULL)
   \                     HAL_SBS_GetLock: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??HAL_SBS_GetLock_0
   1179            {
   1180              return HAL_ERROR;
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0xE003             B.N      ??HAL_SBS_GetLock_1
   1181            }
   1182          
   1183            /* Get the non-secure lock state */
   1184            tmp_lock = SBS->CNSLCKR;
   \                     ??HAL_SBS_GetLock_0: (+1)
   \        0x8   0x....             LDR.N    R1,??DataTable53_38
   \        0xA   0x6809             LDR      R1,[R1, #+0]
   1185          
   1186            /* Get the secure lock state in secure code */
   1187          #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
   1188            tmp_lock |= (SBS->CSLCKR << 16U);
   1189          #endif /* __ARM_FEATURE_CMSE */
   1190          
   1191            /* Return overall lock status */
   1192            *pItem = tmp_lock;
   \        0xC   0x6001             STR      R1,[R0, #+0]
   1193          
   1194            return HAL_OK;
   \        0xE   0x2000             MOVS     R0,#+0
   \                     ??HAL_SBS_GetLock_1: (+1)
   \       0x10   0x4770             BX       LR
   1195          }
   1196          
   1197          /**
   1198            * @}
   1199            */
   1200          
   1201          /** @defgroup HAL_Exported_Functions_Group10 HAL SBS attributes management functions
   1202            *  @brief SBS attributes management functions.
   1203            *
   1204          @verbatim
   1205           =======================================================================================================================
   1206                                                  ##### SBS attributes functions #####
   1207           =======================================================================================================================
   1208          
   1209          @endverbatim
   1210            * @{
   1211            */
   1212          
   1213          #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
   1214          /**
   1215            * @brief  Configure the SBS item attribute(s).
   1216            * @note   Available attributes are to secure SBS items, so this function is
   1217            *         only available in secure.
   1218            *         SBS_FPU item attribute is only configurable through PRIVILEGE transaction.
   1219            * @param  Item Item(s) to set attributes on.
   1220            *         This parameter can be a one or a combination of @ref SBS_Attributes_items
   1221            * @param  Attributes  specifies the secure/non-secure attributes.
   1222            * @retval None
   1223            */
   1224          void HAL_SBS_ConfigAttributes(uint32_t Item, uint32_t Attributes)
   1225          {
   1226            uint32_t tmp;
   1227          
   1228            /* Check the parameters */
   1229            assert_param(IS_SBS_ITEMS_ATTRIBUTES(Item));
   1230            assert_param(IS_SBS_ATTRIBUTES(Attributes));
   1231          
   1232            tmp = SBS->SECCFGR;
   1233          
   1234            /* Set or reset Item */
   1235            if ((Attributes & SBS_SEC) != 0x00U)
   1236            {
   1237              tmp |= Item;
   1238            }
   1239            else
   1240            {
   1241              tmp &= ~Item;
   1242            }
   1243          
   1244            /* Set secure attributes */
   1245            SBS->SECCFGR = tmp;
   1246          }
   1247          
   1248          
   1249          /**
   1250            * @brief  Get the attribute of a SBS items.
   1251            * @note   Available attributes have read restrictions, so this function is
   1252            *         only available in secure
   1253            * @param  Item Single item to get secure/non-secure attribute from.
   1254            * @param  pAttributes pointer to return the attribute.
   1255            * @retval HAL status
   1256            */
   1257          HAL_StatusTypeDef HAL_SBS_GetConfigAttributes(uint32_t Item, uint32_t *pAttributes)
   1258          {
   1259            /* Check null pointer */
   1260            if (pAttributes == NULL)
   1261            {
   1262              return HAL_ERROR;
   1263            }
   1264          
   1265            /* Check the parameters */
   1266            assert_param(IS_SBS_ITEMS_ATTRIBUTES(Item));
   1267          
   1268            /* Get the secure attribute state */
   1269            if ((SBS->SECCFGR & Item) != 0U)
   1270            {
   1271              *pAttributes = SBS_SEC;
   1272            }
   1273            else
   1274            {
   1275              *pAttributes = SBS_NSEC;
   1276            }
   1277          
   1278            return HAL_OK;
   1279          }
   1280          #endif /* __ARM_FEATURE_CMSE */
   1281          

   \                                 In section .text, align 2, keep-with-next
   1282          void GPIO_Debug(uint32_t counter)
   1283          {
   \                     GPIO_Debug: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1284            __IO uint32_t i = 0;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
   1285            __IO uint32_t j = 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9001             STR      R0,[SP, #+4]
   1286              for(i = 0; i < 0x27FF; i++){
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9000             STR      R0,[SP, #+0]
   \       0x10   0xE002             B.N      ??GPIO_Debug_0
   \                     ??GPIO_Debug_1: (+1)
   \       0x12   0x9800             LDR      R0,[SP, #+0]
   \       0x14   0x1C40             ADDS     R0,R0,#+1
   \       0x16   0x9000             STR      R0,[SP, #+0]
   \                     ??GPIO_Debug_0: (+1)
   \       0x18   0x9800             LDR      R0,[SP, #+0]
   \       0x1A   0xF242 0x71FF      MOVW     R1,#+10239
   \       0x1E   0x4288             CMP      R0,R1
   \       0x20   0xD3F7             BCC.N    ??GPIO_Debug_1
   1287              }
   1288              for(j = 0; j < counter; j++){
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x9001             STR      R0,[SP, #+4]
   \       0x26   0xE008             B.N      ??GPIO_Debug_2
   1289                HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, GPIO_PIN_SET);
   1290                for(i = 0; i < 0xD55; i++){
   1291                }
   1292                HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, GPIO_PIN_RESET);
   1293                for(i = 0; i < 0xD55; i++){
   \                     ??GPIO_Debug_3: (+1)
   \       0x28   0x9800             LDR      R0,[SP, #+0]
   \       0x2A   0x1C40             ADDS     R0,R0,#+1
   \       0x2C   0x9000             STR      R0,[SP, #+0]
   \                     ??GPIO_Debug_4: (+1)
   \       0x2E   0x9800             LDR      R0,[SP, #+0]
   \       0x30   0x42A8             CMP      R0,R5
   \       0x32   0xD3F9             BCC.N    ??GPIO_Debug_3
   \       0x34   0x9801             LDR      R0,[SP, #+4]
   \       0x36   0x1C40             ADDS     R0,R0,#+1
   \       0x38   0x9001             STR      R0,[SP, #+4]
   \                     ??GPIO_Debug_2: (+1)
   \       0x3A   0x9801             LDR      R0,[SP, #+4]
   \       0x3C   0x42A0             CMP      R0,R4
   \       0x3E   0xD218             BCS.N    ??GPIO_Debug_5
   \       0x40   0x....             LDR.N    R6,??DataTable53_39
   \       0x42   0x2201             MOVS     R2,#+1
   \       0x44   0x2108             MOVS     R1,#+8
   \       0x46   0x0030             MOVS     R0,R6
   \       0x48   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x9000             STR      R0,[SP, #+0]
   \       0x50   0xE002             B.N      ??GPIO_Debug_6
   \                     ??GPIO_Debug_7: (+1)
   \       0x52   0x9800             LDR      R0,[SP, #+0]
   \       0x54   0x1C40             ADDS     R0,R0,#+1
   \       0x56   0x9000             STR      R0,[SP, #+0]
   \                     ??GPIO_Debug_6: (+1)
   \       0x58   0xF640 0x5555      MOVW     R5,#+3413
   \       0x5C   0x9800             LDR      R0,[SP, #+0]
   \       0x5E   0x42A8             CMP      R0,R5
   \       0x60   0xD3F7             BCC.N    ??GPIO_Debug_7
   \       0x62   0x2200             MOVS     R2,#+0
   \       0x64   0x2108             MOVS     R1,#+8
   \       0x66   0x0030             MOVS     R0,R6
   \       0x68   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x9000             STR      R0,[SP, #+0]
   \       0x70   0xE7DD             B.N      ??GPIO_Debug_4
   1294                }
   1295              }
   1296          }
   \                     ??GPIO_Debug_5: (+1)
   \       0x72   0xBD73             POP      {R0,R1,R4-R6,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53:
   \        0x0   0x....'....        DC32     AHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_1:
   \        0x0   0x4402'0C20        DC32     0x44020c20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_2:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_3:
   \        0x0   0x4402'0C74        DC32     0x44020c74

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_4:
   \        0x0   0xDFFE'C1FF        DC32     0xdffec1ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_5:
   \        0x0   0x4402'0C78        DC32     0x44020c78

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_6:
   \        0x0   0x4080'062B        DC32     0x4080062b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_7:
   \        0x0   0x4402'0C7C        DC32     0x44020c7c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_8:
   \        0x0   0x017F'7800        DC32     0x17f7800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_9:
   \        0x0   0x4402'0C80        DC32     0x44020c80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_10:
   \        0x0   0x0010'08E0        DC32     0x1008e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_11:
   \        0x0   0x4402'0C60        DC32     0x44020c60

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_12:
   \        0x0   0x010A'D003        DC32     0x10ad003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_13:
   \        0x0   0x4402'0C64        DC32     0x44020c64

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_14:
   \        0x0   0x001F'1DFF        DC32     0x1f1dff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_15:
   \        0x0   0x4402'0C6C        DC32     0x44020c6c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_16:
   \        0x0   0x0011'1880        DC32     0x111880

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_17:
   \        0x0   0x....'....        DC32     uwTickPrio

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_18:
   \        0x0   0x....'....        DC32     uwTickFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_19:
   \        0x0   0x0101'0000        DC32     0x1010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_20:
   \        0x0   0x4402'4000        DC32     0x44024000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_21:
   \        0x0   0x08FF'F800        DC32     0x8fff800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_22:
   \        0x0   0x08FF'F804        DC32     0x8fff804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_23:
   \        0x0   0x08FF'F808        DC32     0x8fff808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_24:
   \        0x0   0x4402'4004        DC32     0x44024004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_25:
   \        0x0   0x4400'7400        DC32     0x44007400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_26:
   \        0x0   0x4400'7404        DC32     0x44007404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_27:
   \        0x0   0x4400'0500        DC32     0x44000500

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_28:
   \        0x0   0x4400'0510        DC32     0x44000510

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_29:
   \        0x0   0x4400'0518        DC32     0x44000518

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_30:
   \        0x0   0x4400'0514        DC32     0x44000514

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_31:
   \        0x0   0x4400'054C        DC32     0x4400054c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_32:
   \        0x0   0x4400'0410        DC32     0x44000410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_33:
   \        0x0   0x4400'0414        DC32     0x44000414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_34:
   \        0x0   0x4400'04A0        DC32     0x440004a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_35:
   \        0x0   0x4400'0418        DC32     0x44000418

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_36:
   \        0x0   0x4400'0420        DC32     0x44000420

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_37:
   \        0x0   0x4400'0424        DC32     0x44000424

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_38:
   \        0x0   0x4400'0544        DC32     0x44000544

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_39:
   \        0x0   0x4202'0400        DC32     0x42020400
   1297          /**
   1298            * @}
   1299            */
   1300          
   1301          /**
   1302            * @}
   1303            */
   1304          
   1305          #endif /* HAL_MODULE_ENABLED */
   1306          /**
   1307            * @}
   1308            */
   1309          
   1310          /**
   1311            * @}
   1312            */
   1313          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   GPIO_Debug
        24   -> HAL_GPIO_WritePin
       0   HAL_DBGMCU_DisableDBGStandbyMode
       0   HAL_DBGMCU_DisableDBGStopMode
       0   HAL_DBGMCU_EnableDBGStandbyMode
       0   HAL_DBGMCU_EnableDBGStopMode
       8   HAL_DeInit
         8   -> HAL_MspDeInit
      16   HAL_Delay
        16   -> HAL_GetTick
       0   HAL_DisableVREFBUF
      16   HAL_EnableVREFBUF
        16   -> HAL_GetTick
       0   HAL_GetDEVID
       0   HAL_GetHalVersion
       0   HAL_GetREVID
       0   HAL_GetTick
       0   HAL_GetTickFreq
       0   HAL_GetTickPrio
       0   HAL_GetUIDw0
       0   HAL_GetUIDw1
       0   HAL_GetUIDw2
       0   HAL_IncTick
       8   HAL_Init
         8   -> HAL_InitTick
         8   -> HAL_MspInit
         8   -> HAL_NVIC_SetPriorityGrouping
         8   -> HAL_RCC_GetSysClockFreq
       8   HAL_InitTick
         8   -> HAL_NVIC_SetPriority
         8   -> HAL_SYSTICK_Config
       0   HAL_MspDeInit
       0   HAL_MspInit
       0   HAL_ResumeTick
       0   HAL_SBS_ConfigDebugLevel
       0   HAL_SBS_ConfigDebugSecurity
       0   HAL_SBS_DisableVddIO1CompensationCell
       0   HAL_SBS_DisableVddIO2CompensationCell
       0   HAL_SBS_EPOCHSelection
       0   HAL_SBS_ETHInterfaceSelect
       0   HAL_SBS_EnableVddIO1CompensationCell
       0   HAL_SBS_EnableVddIO2CompensationCell
       0   HAL_SBS_FLASH_DisableECCNMI
       0   HAL_SBS_FLASH_ECCNMI_IsDisabled
       0   HAL_SBS_FLASH_EnableECCNMI
       0   HAL_SBS_GetDebugLevel
       0   HAL_SBS_GetDebugSecurity
       0   HAL_SBS_GetEPOCHSelection
       0   HAL_SBS_GetHDPLValue
       0   HAL_SBS_GetLock
       0   HAL_SBS_GetNMOSVddCompensationValue
       0   HAL_SBS_GetNMOSVddIO2CompensationValue
       0   HAL_SBS_GetOBKHDPL
       0   HAL_SBS_GetPMOSVddCompensationValue
       0   HAL_SBS_GetPMOSVddIO2CompensationValue
       0   HAL_SBS_GetVddIO1CompensationCellReadyFlag
       0   HAL_SBS_GetVddIO2CompensationCellReadyFlag
       0   HAL_SBS_IncrementHDPLValue
       0   HAL_SBS_Lock
       0   HAL_SBS_LockDebugConfig
       0   HAL_SBS_OpenAccessPort
       0   HAL_SBS_OpenDebug
       0   HAL_SBS_SetOBKHDPL
       0   HAL_SBS_VDDCompensationCodeConfig
       0   HAL_SBS_VDDCompensationCodeSelect
       0   HAL_SBS_VDDIOCompensationCodeConfig
       0   HAL_SBS_VDDIOCompensationCodeSelect
      16   HAL_SetTickFreq
        16   -> HAL_InitTick
       0   HAL_SuspendTick
       0   HAL_VREFBUF_HighImpedanceConfig
       0   HAL_VREFBUF_TrimmingConfig
       0   HAL_VREFBUF_VoltageScalingConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable53
       4  ??DataTable53_1
       4  ??DataTable53_10
       4  ??DataTable53_11
       4  ??DataTable53_12
       4  ??DataTable53_13
       4  ??DataTable53_14
       4  ??DataTable53_15
       4  ??DataTable53_16
       4  ??DataTable53_17
       4  ??DataTable53_18
       4  ??DataTable53_19
       4  ??DataTable53_2
       4  ??DataTable53_20
       4  ??DataTable53_21
       4  ??DataTable53_22
       4  ??DataTable53_23
       4  ??DataTable53_24
       4  ??DataTable53_25
       4  ??DataTable53_26
       4  ??DataTable53_27
       4  ??DataTable53_28
       4  ??DataTable53_29
       4  ??DataTable53_3
       4  ??DataTable53_30
       4  ??DataTable53_31
       4  ??DataTable53_32
       4  ??DataTable53_33
       4  ??DataTable53_34
       4  ??DataTable53_35
       4  ??DataTable53_36
       4  ??DataTable53_37
       4  ??DataTable53_38
       4  ??DataTable53_39
       4  ??DataTable53_4
       4  ??DataTable53_5
       4  ??DataTable53_6
       4  ??DataTable53_7
       4  ??DataTable53_8
       4  ??DataTable53_9
     116  GPIO_Debug
      12  HAL_DBGMCU_DisableDBGStandbyMode
      12  HAL_DBGMCU_DisableDBGStopMode
      12  HAL_DBGMCU_EnableDBGStandbyMode
      12  HAL_DBGMCU_EnableDBGStopMode
     108  HAL_DeInit
      40  HAL_Delay
      12  HAL_DisableVREFBUF
      42  HAL_EnableVREFBUF
      10  HAL_GetDEVID
       4  HAL_GetHalVersion
       8  HAL_GetREVID
      12  HAL_GetTick
       6  HAL_GetTickFreq
       8  HAL_GetTickPrio
       6  HAL_GetUIDw0
       6  HAL_GetUIDw1
       6  HAL_GetUIDw2
      24  HAL_IncTick
      58  HAL_Init
      88  HAL_InitTick
       2  HAL_MspDeInit
       2  HAL_MspInit
      16  HAL_ResumeTick
      26  HAL_SBS_ConfigDebugLevel
      12  HAL_SBS_ConfigDebugSecurity
      12  HAL_SBS_DisableVddIO1CompensationCell
      12  HAL_SBS_DisableVddIO2CompensationCell
      14  HAL_SBS_EPOCHSelection
      14  HAL_SBS_ETHInterfaceSelect
      12  HAL_SBS_EnableVddIO1CompensationCell
      12  HAL_SBS_EnableVddIO2CompensationCell
      12  HAL_SBS_FLASH_DisableECCNMI
      10  HAL_SBS_FLASH_ECCNMI_IsDisabled
      12  HAL_SBS_FLASH_EnableECCNMI
      10  HAL_SBS_GetDebugLevel
       8  HAL_SBS_GetDebugSecurity
      10  HAL_SBS_GetEPOCHSelection
      10  HAL_SBS_GetHDPLValue
      18  HAL_SBS_GetLock
      10  HAL_SBS_GetNMOSVddCompensationValue
      10  HAL_SBS_GetNMOSVddIO2CompensationValue
      10  HAL_SBS_GetOBKHDPL
      10  HAL_SBS_GetPMOSVddCompensationValue
      10  HAL_SBS_GetPMOSVddIO2CompensationValue
      12  HAL_SBS_GetVddIO1CompensationCellReadyFlag
      12  HAL_SBS_GetVddIO2CompensationCellReadyFlag
      14  HAL_SBS_IncrementHDPLValue
       8  HAL_SBS_Lock
      14  HAL_SBS_LockDebugConfig
      14  HAL_SBS_OpenAccessPort
      14  HAL_SBS_OpenDebug
      14  HAL_SBS_SetOBKHDPL
      18  HAL_SBS_VDDCompensationCodeConfig
      14  HAL_SBS_VDDCompensationCodeSelect
      20  HAL_SBS_VDDIOCompensationCodeConfig
      14  HAL_SBS_VDDIOCompensationCodeSelect
      48  HAL_SetTickFreq
      16  HAL_SuspendTick
      14  HAL_VREFBUF_HighImpedanceConfig
      14  HAL_VREFBUF_TrimmingConfig
      14  HAL_VREFBUF_VoltageScalingConfig
       4  uwTick
       1  uwTickFreq
       4  uwTickPrio

 
     4 bytes in section .bss
     5 bytes in section .data
 1'310 bytes in section .text
 
 1'110 bytes of CODE memory (+ 200 bytes shared)
     9 bytes of DATA memory

Errors: none
Warnings: none
