###############################################################################
#
# IAR ANSI C/C++ Compiler V9.40.1.364/W64 for ARM         23/Nov/2023  21:46:16
# Copyright 1999-2023 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_usart.c
#    Command line      =
#        -f
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_usart.o.rsp
#        (C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_usart.c
#        -D STM32H562xx -lCN
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir
#        -lA
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir
#        -o
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33.no_dsp.no_se -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\CMSIS\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Library\
#        -I
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\..\Includes\Loader\
#        -Ol) --dependencies=n
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_usart.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\List\Library_12270351780628986503.dir\stm32h5xx_hal_usart.lst
#    Object file       =
#        C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Project\W25Q64JV_STM32H562\Obj\Library_12270351780628986503.dir\stm32h5xx_hal_usart.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Workspace\W25Q64JV_STM32H562_FlashLoader\Source\Library\stm32h5xx_hal_usart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32h5xx_hal_usart.c
      4            * @author  MCD Application Team
      5            * @brief   USART HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Universal Synchronous/Asynchronous Receiver Transmitter
      8            *          Peripheral (USART).
      9            *           + Initialization and de-initialization functions
     10            *           + IO operation functions
     11            *           + Peripheral Control functions
     12            *           + Peripheral State and Error functions
     13            *
     14            ******************************************************************************
     15            * @attention
     16            *
     17            * Copyright (c) 2023 STMicroelectronics.
     18            * All rights reserved.
     19            *
     20            * This software is licensed under terms that can be found in the LICENSE file
     21            * in the root directory of this software component.
     22            * If no LICENSE file comes with this software, it is provided AS-IS.
     23            *
     24            ******************************************************************************
     25            @verbatim
     26           ===============================================================================
     27                                  ##### How to use this driver #####
     28           ===============================================================================
     29              [..]
     30                The USART HAL driver can be used as follows:
     31          
     32                (#) Declare a USART_HandleTypeDef handle structure (eg. USART_HandleTypeDef husart).
     33                (#) Initialize the USART low level resources by implementing the HAL_USART_MspInit() API:
     34                    (++) Enable the USARTx interface clock.
     35                    (++) USART pins configuration:
     36                      (+++) Enable the clock for the USART GPIOs.
     37                      (+++) Configure these USART pins as alternate function pull-up.
     38                    (++) NVIC configuration if you need to use interrupt process (HAL_USART_Transmit_IT(),
     39                          HAL_USART_Receive_IT() and HAL_USART_TransmitReceive_IT() APIs):
     40                      (+++) Configure the USARTx interrupt priority.
     41                      (+++) Enable the NVIC USART IRQ handle.
     42                      (++) USART interrupts handling:
     43                        -@@-   The specific USART interrupts (Transmission complete interrupt,
     44                            RXNE interrupt and Error Interrupts) will be managed using the macros
     45                            __HAL_USART_ENABLE_IT() and __HAL_USART_DISABLE_IT() inside the transmit and receive process.
     46                    (++) DMA Configuration if you need to use DMA process (HAL_USART_Transmit_DMA()
     47                         HAL_USART_Receive_DMA() and HAL_USART_TransmitReceive_DMA() APIs):
     48                      (+++) Declare a DMA handle structure for the Tx/Rx channel.
     49                      (+++) Enable the DMAx interface clock.
     50                      (+++) Configure the declared DMA handle structure with the required Tx/Rx parameters.
     51                      (+++) Configure the DMA Tx/Rx channel.
     52                      (+++) Associate the initialized DMA handle to the USART DMA Tx/Rx handle.
     53                      (+++) Configure the priority and enable the NVIC for the transfer
     54                            complete interrupt on the DMA Tx/Rx channel.
     55          
     56                (#) Program the Baud Rate, Word Length, Stop Bit, Parity, and Mode
     57                    (Receiver/Transmitter) in the husart handle Init structure.
     58          
     59                (#) Initialize the USART registers by calling the HAL_USART_Init() API:
     60                    (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
     61                         by calling the customized HAL_USART_MspInit(&husart) API.
     62          
     63              [..]
     64               (@) To configure and enable/disable the USART to wake up the MCU from stop mode, resort to UART API's
     65                  HAL_UARTEx_StopModeWakeUpSourceConfig(), HAL_UARTEx_EnableStopMode() and
     66                  HAL_UARTEx_DisableStopMode() in casting the USART handle to UART type UART_HandleTypeDef.
     67          
     68              ##### Callback registration #####
     69              ==================================
     70          
     71              [..]
     72              The compilation define USE_HAL_USART_REGISTER_CALLBACKS when set to 1
     73              allows the user to configure dynamically the driver callbacks.
     74          
     75              [..]
     76              Use Function HAL_USART_RegisterCallback() to register a user callback.
     77              Function HAL_USART_RegisterCallback() allows to register following callbacks:
     78              (+) TxHalfCpltCallback        : Tx Half Complete Callback.
     79              (+) TxCpltCallback            : Tx Complete Callback.
     80              (+) RxHalfCpltCallback        : Rx Half Complete Callback.
     81              (+) RxCpltCallback            : Rx Complete Callback.
     82              (+) TxRxCpltCallback          : Tx Rx Complete Callback.
     83              (+) ErrorCallback             : Error Callback.
     84              (+) AbortCpltCallback         : Abort Complete Callback.
     85              (+) RxFifoFullCallback        : Rx Fifo Full Callback.
     86              (+) TxFifoEmptyCallback       : Tx Fifo Empty Callback.
     87              (+) MspInitCallback           : USART MspInit.
     88              (+) MspDeInitCallback         : USART MspDeInit.
     89              This function takes as parameters the HAL peripheral handle, the Callback ID
     90              and a pointer to the user callback function.
     91          
     92              [..]
     93              Use function HAL_USART_UnRegisterCallback() to reset a callback to the default
     94              weak function.
     95              HAL_USART_UnRegisterCallback() takes as parameters the HAL peripheral handle,
     96              and the Callback ID.
     97              This function allows to reset following callbacks:
     98              (+) TxHalfCpltCallback        : Tx Half Complete Callback.
     99              (+) TxCpltCallback            : Tx Complete Callback.
    100              (+) RxHalfCpltCallback        : Rx Half Complete Callback.
    101              (+) RxCpltCallback            : Rx Complete Callback.
    102              (+) TxRxCpltCallback          : Tx Rx Complete Callback.
    103              (+) ErrorCallback             : Error Callback.
    104              (+) AbortCpltCallback         : Abort Complete Callback.
    105              (+) RxFifoFullCallback        : Rx Fifo Full Callback.
    106              (+) TxFifoEmptyCallback       : Tx Fifo Empty Callback.
    107              (+) MspInitCallback           : USART MspInit.
    108              (+) MspDeInitCallback         : USART MspDeInit.
    109          
    110              [..]
    111              By default, after the HAL_USART_Init() and when the state is HAL_USART_STATE_RESET
    112              all callbacks are set to the corresponding weak functions:
    113              examples HAL_USART_TxCpltCallback(), HAL_USART_RxHalfCpltCallback().
    114              Exception done for MspInit and MspDeInit functions that are respectively
    115              reset to the legacy weak functions in the HAL_USART_Init()
    116              and HAL_USART_DeInit() only when these callbacks are null (not registered beforehand).
    117              If not, MspInit or MspDeInit are not null, the HAL_USART_Init() and HAL_USART_DeInit()
    118              keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
    119          
    120              [..]
    121              Callbacks can be registered/unregistered in HAL_USART_STATE_READY state only.
    122              Exception done MspInit/MspDeInit that can be registered/unregistered
    123              in HAL_USART_STATE_READY or HAL_USART_STATE_RESET state, thus registered (user)
    124              MspInit/DeInit callbacks can be used during the Init/DeInit.
    125              In that case first register the MspInit/MspDeInit user callbacks
    126              using HAL_USART_RegisterCallback() before calling HAL_USART_DeInit()
    127              or HAL_USART_Init() function.
    128          
    129              [..]
    130              When The compilation define USE_HAL_USART_REGISTER_CALLBACKS is set to 0 or
    131              not defined, the callback registration feature is not available
    132              and weak callbacks are used.
    133          
    134          
    135            @endverbatim
    136            ******************************************************************************
    137            */
    138          
    139          /* Includes ------------------------------------------------------------------*/
    140          #include "stm32h5xx_hal.h"
    141          
    142          /** @addtogroup STM32H5xx_HAL_Driver
    143            * @{
    144            */
    145          
    146          /** @defgroup USART USART
    147            * @brief HAL USART Synchronous module driver
    148            * @{
    149            */
    150          
    151          #ifdef HAL_USART_MODULE_ENABLED
    152          
    153          /* Private typedef -----------------------------------------------------------*/
    154          /* Private define ------------------------------------------------------------*/
    155          /** @defgroup USART_Private_Constants USART Private Constants
    156            * @{
    157            */
    158          #define USART_DUMMY_DATA          ((uint16_t) 0xFFFF)           /*!< USART transmitted dummy data                     */
    159          #define USART_TEACK_REACK_TIMEOUT             1000U             /*!< USART TX or RX enable acknowledge time-out value */
    160          #define USART_CR1_FIELDS          ((uint32_t)(USART_CR1_M |  USART_CR1_PCE | USART_CR1_PS    | \
    161                                                        USART_CR1_TE | USART_CR1_RE  | USART_CR1_OVER8 | \
    162                                                        USART_CR1_FIFOEN ))                                  /*!< USART CR1 fields of parameters set by USART_SetConfig API */
    163          
    164          #define USART_CR2_FIELDS          ((uint32_t)(USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_CLKEN | \
    165                                                        USART_CR2_LBCL | USART_CR2_STOP | USART_CR2_SLVEN | \
    166                                                        USART_CR2_DIS_NSS))                                  /*!< USART CR2 fields of parameters set by USART_SetConfig API */
    167          
    168          #define USART_CR3_FIELDS          ((uint32_t)(USART_CR3_TXFTCFG | USART_CR3_RXFTCFG ))             /*!< USART or USART CR3 fields of parameters set by USART_SetConfig API */
    169          
    170          #define USART_BRR_MIN    0x10U        /* USART BRR minimum authorized value */
    171          #define USART_BRR_MAX    0xFFFFU      /* USART BRR maximum authorized value */
    172          /**
    173            * @}
    174            */
    175          
    176          /* Private macros ------------------------------------------------------------*/
    177          /* Private variables ---------------------------------------------------------*/
    178          /* Private function prototypes -----------------------------------------------*/
    179          /** @addtogroup USART_Private_Functions
    180            * @{
    181            */
    182          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
    183          void USART_InitCallbacksToDefault(USART_HandleTypeDef *husart);
    184          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
    185          static void USART_EndTransfer(USART_HandleTypeDef *husart);
    186          #if defined(HAL_DMA_MODULE_ENABLED)
    187          static void USART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    188          static void USART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    189          static void USART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    190          static void USART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    191          static void USART_DMAError(DMA_HandleTypeDef *hdma);
    192          static void USART_DMAAbortOnError(DMA_HandleTypeDef *hdma);
    193          static void USART_DMATxAbortCallback(DMA_HandleTypeDef *hdma);
    194          static void USART_DMARxAbortCallback(DMA_HandleTypeDef *hdma);
    195          #endif /* HAL_DMA_MODULE_ENABLED */
    196          static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status,
    197                                                                uint32_t Tickstart, uint32_t Timeout);
    198          static HAL_StatusTypeDef USART_SetConfig(USART_HandleTypeDef *husart);
    199          static HAL_StatusTypeDef USART_CheckIdleState(USART_HandleTypeDef *husart);
    200          static void USART_TxISR_8BIT(USART_HandleTypeDef *husart);
    201          static void USART_TxISR_16BIT(USART_HandleTypeDef *husart);
    202          static void USART_TxISR_8BIT_FIFOEN(USART_HandleTypeDef *husart);
    203          static void USART_TxISR_16BIT_FIFOEN(USART_HandleTypeDef *husart);
    204          static void USART_EndTransmit_IT(USART_HandleTypeDef *husart);
    205          static void USART_RxISR_8BIT(USART_HandleTypeDef *husart);
    206          static void USART_RxISR_16BIT(USART_HandleTypeDef *husart);
    207          static void USART_RxISR_8BIT_FIFOEN(USART_HandleTypeDef *husart);
    208          static void USART_RxISR_16BIT_FIFOEN(USART_HandleTypeDef *husart);
    209          
    210          
    211          /**
    212            * @}
    213            */
    214          
    215          /* Exported functions --------------------------------------------------------*/
    216          
    217          /** @defgroup USART_Exported_Functions USART Exported Functions
    218            * @{
    219            */
    220          
    221          /** @defgroup USART_Exported_Functions_Group1 Initialization and de-initialization functions
    222            * @brief    Initialization and Configuration functions
    223            *
    224          @verbatim
    225           ===============================================================================
    226                      ##### Initialization and Configuration functions #####
    227           ===============================================================================
    228              [..]
    229              This subsection provides a set of functions allowing to initialize the USART
    230              in asynchronous and in synchronous modes.
    231                (+) For the asynchronous mode only these parameters can be configured:
    232                  (++) Baud Rate
    233                  (++) Word Length
    234                  (++) Stop Bit
    235                  (++) Parity: If the parity is enabled, then the MSB bit of the data written
    236                       in the data register is transmitted but is changed by the parity bit.
    237                  (++) USART polarity
    238                  (++) USART phase
    239                  (++) USART LastBit
    240                  (++) Receiver/transmitter modes
    241          
    242              [..]
    243              The HAL_USART_Init() function follows the USART  synchronous configuration
    244              procedure (details for the procedure are available in reference manual).
    245          
    246          @endverbatim
    247          
    248            Depending on the frame length defined by the M1 and M0 bits (7-bit,
    249            8-bit or 9-bit), the possible USART formats are listed in the
    250            following table.
    251          
    252              Table 1. USART frame format.
    253              +-----------------------------------------------------------------------+
    254              |  M1 bit |  M0 bit |  PCE bit  |            USART frame                |
    255              |---------|---------|-----------|---------------------------------------|
    256              |    0    |    0    |    0      |    | SB |    8 bit data   | STB |     |
    257              |---------|---------|-----------|---------------------------------------|
    258              |    0    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    259              |---------|---------|-----------|---------------------------------------|
    260              |    0    |    1    |    0      |    | SB |    9 bit data   | STB |     |
    261              |---------|---------|-----------|---------------------------------------|
    262              |    0    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    263              |---------|---------|-----------|---------------------------------------|
    264              |    1    |    0    |    0      |    | SB |    7 bit data   | STB |     |
    265              |---------|---------|-----------|---------------------------------------|
    266              |    1    |    0    |    1      |    | SB | 6 bit data | PB | STB |     |
    267              +-----------------------------------------------------------------------+
    268          
    269            * @{
    270            */
    271          
    272          /**
    273            * @brief  Initialize the USART mode according to the specified
    274            *         parameters in the USART_InitTypeDef and initialize the associated handle.
    275            * @param  husart USART handle.
    276            * @retval HAL status
    277            */

   \                                 In section .text, align 2, keep-with-next
    278          HAL_StatusTypeDef HAL_USART_Init(USART_HandleTypeDef *husart)
    279          {
   \                     HAL_USART_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    280            /* Check the USART handle allocation */
    281            if (husart == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_USART_Init_0
    282            {
    283              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE02E             B.N      ??HAL_USART_Init_1
    284            }
    285          
    286            /* Check the parameters */
    287            assert_param(IS_USART_INSTANCE(husart->Instance));
    288          
    289            if (husart->State == HAL_USART_STATE_RESET)
   \                     ??HAL_USART_Init_0: (+1)
   \        0xC   0xF894 0x0059      LDRB     R0,[R4, #+89]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD105             BNE.N    ??HAL_USART_Init_2
    290            {
    291              /* Allocate lock resource and initialize it */
    292              husart->Lock = HAL_UNLOCKED;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF884 0x0058      STRB     R0,[R4, #+88]
    293          
    294          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
    295              USART_InitCallbacksToDefault(husart);
    296          
    297              if (husart->MspInitCallback == NULL)
    298              {
    299                husart->MspInitCallback = HAL_USART_MspInit;
    300              }
    301          
    302              /* Init the low level hardware */
    303              husart->MspInitCallback(husart);
    304          #else
    305              /* Init the low level hardware : GPIO, CLOCK */
    306              HAL_USART_MspInit(husart);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       HAL_USART_MspInit
    307          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
    308            }
    309          
    310            husart->State = HAL_USART_STATE_BUSY;
   \                     ??HAL_USART_Init_2: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xF884 0x0059      STRB     R0,[R4, #+89]
    311          
    312            /* Disable the Peripheral */
    313            __HAL_USART_DISABLE(husart);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0x0840             LSRS     R0,R0,#+1
   \       0x2C   0x0040             LSLS     R0,R0,#+1
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0x6008             STR      R0,[R1, #+0]
    314          
    315            /* Set the Usart Communication parameters */
    316            if (USART_SetConfig(husart) == HAL_ERROR)
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       USART_SetConfig
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD101             BNE.N    ??HAL_USART_Init_3
    317            {
    318              return HAL_ERROR;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xE014             B.N      ??HAL_USART_Init_1
    319            }
    320          
    321            /* In Synchronous mode, the following bits must be kept cleared:
    322            - LINEN bit in the USART_CR2 register
    323            - HDSEL, SCEN and IREN bits in the USART_CR3 register.
    324            */
    325            husart->Instance->CR2 &= ~USART_CR2_LINEN;
   \                     ??HAL_USART_Init_3: (+1)
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x6840             LDR      R0,[R0, #+4]
   \       0x44   0xF430 0x4080      BICS     R0,R0,#0x4000
   \       0x48   0x6821             LDR      R1,[R4, #+0]
   \       0x4A   0x6048             STR      R0,[R1, #+4]
    326            husart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x6880             LDR      R0,[R0, #+8]
   \       0x50   0xF030 0x002A      BICS     R0,R0,#0x2A
   \       0x54   0x6821             LDR      R1,[R4, #+0]
   \       0x56   0x6088             STR      R0,[R1, #+8]
    327          
    328            /* Enable the Peripheral */
    329            __HAL_USART_ENABLE(husart);
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x6800             LDR      R0,[R0, #+0]
   \       0x5C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x60   0x6821             LDR      R1,[R4, #+0]
   \       0x62   0x6008             STR      R0,[R1, #+0]
    330          
    331            /* TEACK and/or REACK to check before moving husart->State to Ready */
    332            return (USART_CheckIdleState(husart));
   \       0x64   0x0020             MOVS     R0,R4
   \       0x66   0x.... 0x....      BL       USART_CheckIdleState
   \                     ??HAL_USART_Init_1: (+1)
   \       0x6A   0xBD10             POP      {R4,PC}
    333          }
    334          
    335          /**
    336            * @brief DeInitialize the USART peripheral.
    337            * @param  husart USART handle.
    338            * @retval HAL status
    339            */

   \                                 In section .text, align 2, keep-with-next
    340          HAL_StatusTypeDef HAL_USART_DeInit(USART_HandleTypeDef *husart)
    341          {
   \                     HAL_USART_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    342            /* Check the USART handle allocation */
    343            if (husart == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_USART_DeInit_0
    344            {
    345              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE017             B.N      ??HAL_USART_DeInit_1
    346            }
    347          
    348            /* Check the parameters */
    349            assert_param(IS_USART_INSTANCE(husart->Instance));
    350          
    351            husart->State = HAL_USART_STATE_BUSY;
   \                     ??HAL_USART_DeInit_0: (+1)
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xF884 0x0059      STRB     R0,[R4, #+89]
    352          
    353            husart->Instance->CR1 = 0x0U;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6821             LDR      R1,[R4, #+0]
   \       0x16   0x6008             STR      R0,[R1, #+0]
    354            husart->Instance->CR2 = 0x0U;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0x6048             STR      R0,[R1, #+4]
    355            husart->Instance->CR3 = 0x0U;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6821             LDR      R1,[R4, #+0]
   \       0x22   0x6088             STR      R0,[R1, #+8]
    356          
    357          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
    358            if (husart->MspDeInitCallback == NULL)
    359            {
    360              husart->MspDeInitCallback = HAL_USART_MspDeInit;
    361            }
    362            /* DeInit the low level hardware */
    363            husart->MspDeInitCallback(husart);
    364          #else
    365            /* DeInit the low level hardware */
    366            HAL_USART_MspDeInit(husart);
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       HAL_USART_MspDeInit
    367          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
    368          
    369            husart->ErrorCode = HAL_USART_ERROR_NONE;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x65E0             STR      R0,[R4, #+92]
    370            husart->State = HAL_USART_STATE_RESET;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xF884 0x0059      STRB     R0,[R4, #+89]
    371          
    372            /* Process Unlock */
    373            __HAL_UNLOCK(husart);
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF884 0x0058      STRB     R0,[R4, #+88]
    374          
    375            return HAL_OK;
   \       0x3A   0x2000             MOVS     R0,#+0
   \                     ??HAL_USART_DeInit_1: (+1)
   \       0x3C   0xBD10             POP      {R4,PC}
    376          }
    377          
    378          /**
    379            * @brief Initialize the USART MSP.
    380            * @param husart USART handle.
    381            * @retval None
    382            */

   \                                 In section .text, align 2
    383          __weak void HAL_USART_MspInit(USART_HandleTypeDef *husart)
    384          {
    385            /* Prevent unused argument(s) compilation warning */
    386            UNUSED(husart);
    387          
    388            /* NOTE : This function should not be modified, when the callback is needed,
    389                      the HAL_USART_MspInit can be implemented in the user file
    390             */
    391          }
   \                     HAL_USART_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    392          
    393          /**
    394            * @brief DeInitialize the USART MSP.
    395            * @param husart USART handle.
    396            * @retval None
    397            */

   \                                 In section .text, align 2
    398          __weak void HAL_USART_MspDeInit(USART_HandleTypeDef *husart)
    399          {
    400            /* Prevent unused argument(s) compilation warning */
    401            UNUSED(husart);
    402          
    403            /* NOTE : This function should not be modified, when the callback is needed,
    404                      the HAL_USART_MspDeInit can be implemented in the user file
    405             */
    406          }
   \                     HAL_USART_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    407          
    408          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
    409          /**
    410            * @brief  Register a User USART Callback
    411            *         To be used to override the weak predefined callback
    412            * @note   The HAL_USART_RegisterCallback() may be called before HAL_USART_Init() in HAL_USART_STATE_RESET
    413            *         to register callbacks for HAL_USART_MSPINIT_CB_ID and HAL_USART_MSPDEINIT_CB_ID
    414            * @param  husart usart handle
    415            * @param  CallbackID ID of the callback to be registered
    416            *         This parameter can be one of the following values:
    417            *           @arg @ref HAL_USART_TX_HALFCOMPLETE_CB_ID Tx Half Complete Callback ID
    418            *           @arg @ref HAL_USART_TX_COMPLETE_CB_ID Tx Complete Callback ID
    419            *           @arg @ref HAL_USART_RX_HALFCOMPLETE_CB_ID Rx Half Complete Callback ID
    420            *           @arg @ref HAL_USART_RX_COMPLETE_CB_ID Rx Complete Callback ID
    421            *           @arg @ref HAL_USART_TX_RX_COMPLETE_CB_ID Rx Complete Callback ID
    422            *           @arg @ref HAL_USART_ERROR_CB_ID Error Callback ID
    423            *           @arg @ref HAL_USART_ABORT_COMPLETE_CB_ID Abort Complete Callback ID
    424            *           @arg @ref HAL_USART_RX_FIFO_FULL_CB_ID Rx Fifo Full Callback ID
    425            *           @arg @ref HAL_USART_TX_FIFO_EMPTY_CB_ID Tx Fifo Empty Callback ID
    426            *           @arg @ref HAL_USART_MSPINIT_CB_ID MspInit Callback ID
    427            *           @arg @ref HAL_USART_MSPDEINIT_CB_ID MspDeInit Callback ID
    428            * @param  pCallback pointer to the Callback function
    429            * @retval HAL status
    430          +  */
    431          HAL_StatusTypeDef HAL_USART_RegisterCallback(USART_HandleTypeDef *husart, HAL_USART_CallbackIDTypeDef CallbackID,
    432                                                       pUSART_CallbackTypeDef pCallback)
    433          {
    434            HAL_StatusTypeDef status = HAL_OK;
    435          
    436            if (pCallback == NULL)
    437            {
    438              /* Update the error code */
    439              husart->ErrorCode |= HAL_USART_ERROR_INVALID_CALLBACK;
    440          
    441              return HAL_ERROR;
    442            }
    443          
    444            if (husart->State == HAL_USART_STATE_READY)
    445            {
    446              switch (CallbackID)
    447              {
    448                case HAL_USART_TX_HALFCOMPLETE_CB_ID :
    449                  husart->TxHalfCpltCallback = pCallback;
    450                  break;
    451          
    452                case HAL_USART_TX_COMPLETE_CB_ID :
    453                  husart->TxCpltCallback = pCallback;
    454                  break;
    455          
    456                case HAL_USART_RX_HALFCOMPLETE_CB_ID :
    457                  husart->RxHalfCpltCallback = pCallback;
    458                  break;
    459          
    460                case HAL_USART_RX_COMPLETE_CB_ID :
    461                  husart->RxCpltCallback = pCallback;
    462                  break;
    463          
    464                case HAL_USART_TX_RX_COMPLETE_CB_ID :
    465                  husart->TxRxCpltCallback = pCallback;
    466                  break;
    467          
    468                case HAL_USART_ERROR_CB_ID :
    469                  husart->ErrorCallback = pCallback;
    470                  break;
    471          
    472                case HAL_USART_ABORT_COMPLETE_CB_ID :
    473                  husart->AbortCpltCallback = pCallback;
    474                  break;
    475          
    476                case HAL_USART_RX_FIFO_FULL_CB_ID :
    477                  husart->RxFifoFullCallback = pCallback;
    478                  break;
    479          
    480                case HAL_USART_TX_FIFO_EMPTY_CB_ID :
    481                  husart->TxFifoEmptyCallback = pCallback;
    482                  break;
    483          
    484                case HAL_USART_MSPINIT_CB_ID :
    485                  husart->MspInitCallback = pCallback;
    486                  break;
    487          
    488                case HAL_USART_MSPDEINIT_CB_ID :
    489                  husart->MspDeInitCallback = pCallback;
    490                  break;
    491          
    492                default :
    493                  /* Update the error code */
    494                  husart->ErrorCode |= HAL_USART_ERROR_INVALID_CALLBACK;
    495          
    496                  /* Return error status */
    497                  status =  HAL_ERROR;
    498                  break;
    499              }
    500            }
    501            else if (husart->State == HAL_USART_STATE_RESET)
    502            {
    503              switch (CallbackID)
    504              {
    505                case HAL_USART_MSPINIT_CB_ID :
    506                  husart->MspInitCallback = pCallback;
    507                  break;
    508          
    509                case HAL_USART_MSPDEINIT_CB_ID :
    510                  husart->MspDeInitCallback = pCallback;
    511                  break;
    512          
    513                default :
    514                  /* Update the error code */
    515                  husart->ErrorCode |= HAL_USART_ERROR_INVALID_CALLBACK;
    516          
    517                  /* Return error status */
    518                  status =  HAL_ERROR;
    519                  break;
    520              }
    521            }
    522            else
    523            {
    524              /* Update the error code */
    525              husart->ErrorCode |= HAL_USART_ERROR_INVALID_CALLBACK;
    526          
    527              /* Return error status */
    528              status =  HAL_ERROR;
    529            }
    530          
    531            return status;
    532          }
    533          
    534          /**
    535            * @brief  Unregister an USART Callback
    536            *         USART callaback is redirected to the weak predefined callback
    537            * @note   The HAL_USART_UnRegisterCallback() may be called before HAL_USART_Init() in HAL_USART_STATE_RESET
    538            *         to un-register callbacks for HAL_USART_MSPINIT_CB_ID and HAL_USART_MSPDEINIT_CB_ID
    539            * @param  husart usart handle
    540            * @param  CallbackID ID of the callback to be unregistered
    541            *         This parameter can be one of the following values:
    542            *           @arg @ref HAL_USART_TX_HALFCOMPLETE_CB_ID Tx Half Complete Callback ID
    543            *           @arg @ref HAL_USART_TX_COMPLETE_CB_ID Tx Complete Callback ID
    544            *           @arg @ref HAL_USART_RX_HALFCOMPLETE_CB_ID Rx Half Complete Callback ID
    545            *           @arg @ref HAL_USART_RX_COMPLETE_CB_ID Rx Complete Callback ID
    546            *           @arg @ref HAL_USART_TX_RX_COMPLETE_CB_ID Rx Complete Callback ID
    547            *           @arg @ref HAL_USART_ERROR_CB_ID Error Callback ID
    548            *           @arg @ref HAL_USART_ABORT_COMPLETE_CB_ID Abort Complete Callback ID
    549            *           @arg @ref HAL_USART_RX_FIFO_FULL_CB_ID Rx Fifo Full Callback ID
    550            *           @arg @ref HAL_USART_TX_FIFO_EMPTY_CB_ID Tx Fifo Empty Callback ID
    551            *           @arg @ref HAL_USART_MSPINIT_CB_ID MspInit Callback ID
    552            *           @arg @ref HAL_USART_MSPDEINIT_CB_ID MspDeInit Callback ID
    553            * @retval HAL status
    554            */
    555          HAL_StatusTypeDef HAL_USART_UnRegisterCallback(USART_HandleTypeDef *husart, HAL_USART_CallbackIDTypeDef CallbackID)
    556          {
    557            HAL_StatusTypeDef status = HAL_OK;
    558          
    559            if (HAL_USART_STATE_READY == husart->State)
    560            {
    561              switch (CallbackID)
    562              {
    563                case HAL_USART_TX_HALFCOMPLETE_CB_ID :
    564                  husart->TxHalfCpltCallback = HAL_USART_TxHalfCpltCallback;               /* Legacy weak  TxHalfCpltCallback  */
    565                  break;
    566          
    567                case HAL_USART_TX_COMPLETE_CB_ID :
    568                  husart->TxCpltCallback = HAL_USART_TxCpltCallback;                       /* Legacy weak TxCpltCallback       */
    569                  break;
    570          
    571                case HAL_USART_RX_HALFCOMPLETE_CB_ID :
    572                  husart->RxHalfCpltCallback = HAL_USART_RxHalfCpltCallback;               /* Legacy weak RxHalfCpltCallback   */
    573                  break;
    574          
    575                case HAL_USART_RX_COMPLETE_CB_ID :
    576                  husart->RxCpltCallback = HAL_USART_RxCpltCallback;                       /* Legacy weak RxCpltCallback       */
    577                  break;
    578          
    579                case HAL_USART_TX_RX_COMPLETE_CB_ID :
    580                  husart->TxRxCpltCallback = HAL_USART_TxRxCpltCallback;                   /* Legacy weak TxRxCpltCallback     */
    581                  break;
    582          
    583                case HAL_USART_ERROR_CB_ID :
    584                  husart->ErrorCallback = HAL_USART_ErrorCallback;                         /* Legacy weak ErrorCallback        */
    585                  break;
    586          
    587                case HAL_USART_ABORT_COMPLETE_CB_ID :
    588                  husart->AbortCpltCallback = HAL_USART_AbortCpltCallback;                 /* Legacy weak AbortCpltCallback    */
    589                  break;
    590          
    591                case HAL_USART_RX_FIFO_FULL_CB_ID :
    592                  husart->RxFifoFullCallback = HAL_USARTEx_RxFifoFullCallback;             /* Legacy weak RxFifoFullCallback   */
    593                  break;
    594          
    595                case HAL_USART_TX_FIFO_EMPTY_CB_ID :
    596                  husart->TxFifoEmptyCallback = HAL_USARTEx_TxFifoEmptyCallback;           /* Legacy weak TxFifoEmptyCallback  */
    597                  break;
    598          
    599                case HAL_USART_MSPINIT_CB_ID :
    600                  husart->MspInitCallback = HAL_USART_MspInit;                             /* Legacy weak MspInitCallback      */
    601                  break;
    602          
    603                case HAL_USART_MSPDEINIT_CB_ID :
    604                  husart->MspDeInitCallback = HAL_USART_MspDeInit;                         /* Legacy weak MspDeInitCallback    */
    605                  break;
    606          
    607                default :
    608                  /* Update the error code */
    609                  husart->ErrorCode |= HAL_USART_ERROR_INVALID_CALLBACK;
    610          
    611                  /* Return error status */
    612                  status =  HAL_ERROR;
    613                  break;
    614              }
    615            }
    616            else if (HAL_USART_STATE_RESET == husart->State)
    617            {
    618              switch (CallbackID)
    619              {
    620                case HAL_USART_MSPINIT_CB_ID :
    621                  husart->MspInitCallback = HAL_USART_MspInit;
    622                  break;
    623          
    624                case HAL_USART_MSPDEINIT_CB_ID :
    625                  husart->MspDeInitCallback = HAL_USART_MspDeInit;
    626                  break;
    627          
    628                default :
    629                  /* Update the error code */
    630                  husart->ErrorCode |= HAL_USART_ERROR_INVALID_CALLBACK;
    631          
    632                  /* Return error status */
    633                  status =  HAL_ERROR;
    634                  break;
    635              }
    636            }
    637            else
    638            {
    639              /* Update the error code */
    640              husart->ErrorCode |= HAL_USART_ERROR_INVALID_CALLBACK;
    641          
    642              /* Return error status */
    643              status =  HAL_ERROR;
    644            }
    645          
    646            return status;
    647          }
    648          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
    649          
    650          
    651          /**
    652            * @}
    653            */
    654          
    655          /** @defgroup USART_Exported_Functions_Group2 IO operation functions
    656            * @brief   USART Transmit and Receive functions
    657            *
    658          @verbatim
    659           ===============================================================================
    660                                ##### IO operation functions #####
    661           ===============================================================================
    662              [..] This subsection provides a set of functions allowing to manage the USART synchronous
    663              data transfers.
    664          
    665              [..] The USART supports master mode only: it cannot receive or send data related to an input
    666                   clock (SCLK is always an output).
    667          
    668              [..]
    669          
    670              (#) There are two modes of transfer:
    671                  (++) Blocking mode: The communication is performed in polling mode.
    672                       The HAL status of all data processing is returned by the same function
    673                       after finishing transfer.
    674                  (++) No-Blocking mode: The communication is performed using Interrupts
    675                       or DMA, These API's return the HAL status.
    676                       The end of the data processing will be indicated through the
    677                       dedicated USART IRQ when using Interrupt mode or the DMA IRQ when
    678                       using DMA mode.
    679                       The HAL_USART_TxCpltCallback(), HAL_USART_RxCpltCallback() and HAL_USART_TxRxCpltCallback() user callbacks
    680                       will be executed respectively at the end of the transmit or Receive process
    681                       The HAL_USART_ErrorCallback()user callback will be executed when a communication error is detected
    682          
    683              (#) Blocking mode API's are :
    684                  (++) HAL_USART_Transmit() in simplex mode
    685                  (++) HAL_USART_Receive() in full duplex receive only
    686                  (++) HAL_USART_TransmitReceive() in full duplex mode
    687          
    688              (#) Non-Blocking mode API's with Interrupt are :
    689                  (++) HAL_USART_Transmit_IT() in simplex mode
    690                  (++) HAL_USART_Receive_IT() in full duplex receive only
    691                  (++) HAL_USART_TransmitReceive_IT() in full duplex mode
    692                  (++) HAL_USART_IRQHandler()
    693          
    694              (#) No-Blocking mode API's  with DMA are :
    695                  (++) HAL_USART_Transmit_DMA() in simplex mode
    696                  (++) HAL_USART_Receive_DMA() in full duplex receive only
    697                  (++) HAL_USART_TransmitReceive_DMA() in full duplex mode
    698                  (++) HAL_USART_DMAPause()
    699                  (++) HAL_USART_DMAResume()
    700                  (++) HAL_USART_DMAStop()
    701          
    702              (#) A set of Transfer Complete Callbacks are provided in Non_Blocking mode:
    703                  (++) HAL_USART_TxCpltCallback()
    704                  (++) HAL_USART_RxCpltCallback()
    705                  (++) HAL_USART_TxHalfCpltCallback()
    706                  (++) HAL_USART_RxHalfCpltCallback()
    707                  (++) HAL_USART_ErrorCallback()
    708                  (++) HAL_USART_TxRxCpltCallback()
    709          
    710              (#) Non-Blocking mode transfers could be aborted using Abort API's :
    711                  (++) HAL_USART_Abort()
    712                  (++) HAL_USART_Abort_IT()
    713          
    714              (#) For Abort services based on interrupts (HAL_USART_Abort_IT), a Abort Complete Callbacks is provided:
    715                  (++) HAL_USART_AbortCpltCallback()
    716          
    717              (#) In Non-Blocking mode transfers, possible errors are split into 2 categories.
    718                  Errors are handled as follows :
    719                  (++) Error is considered as Recoverable and non blocking : Transfer could go till end, but error severity is
    720                       to be evaluated by user : this concerns Frame Error,
    721                       Parity Error or Noise Error in Interrupt mode reception .
    722                       Received character is then retrieved and stored in Rx buffer, Error code is set to allow user to identify
    723                       error type, and HAL_USART_ErrorCallback() user callback is executed.
    724                       Transfer is kept ongoing on USART side.
    725                       If user wants to abort it, Abort services should be called by user.
    726                  (++) Error is considered as Blocking : Transfer could not be completed properly and is aborted.
    727                       This concerns Overrun Error In Interrupt mode reception and all errors in DMA mode.
    728                       Error code is set to allow user to identify error type,
    729                       and HAL_USART_ErrorCallback() user callback is executed.
    730          
    731          @endverbatim
    732            * @{
    733            */
    734          
    735          /**
    736            * @brief  Simplex send an amount of data in blocking mode.
    737            * @note   When USART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
    738            *         the sent data is handled as a set of u16. In this case, Size must indicate the number
    739            *         of u16 provided through pTxData.
    740            * @param  husart USART handle.
    741            * @param  pTxData Pointer to data buffer (u8 or u16 data elements).
    742            * @param  Size Amount of data elements (u8 or u16) to be sent.
    743            * @param  Timeout Timeout duration.
    744            * @retval HAL status
    745            */

   \                                 In section .text, align 2, keep-with-next
    746          HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, const uint8_t *pTxData, uint16_t Size,
    747                                               uint32_t Timeout)
    748          {
   \                     HAL_USART_Transmit: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001F             MOVS     R7,R3
    749            const uint8_t  *ptxdata8bits;
    750            const uint16_t *ptxdata16bits;
    751            uint32_t tickstart;
    752          
    753            if (husart->State == HAL_USART_STATE_READY)
   \        0xC   0xF896 0x0059      LDRB     R0,[R6, #+89]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD173             BNE.N    ??HAL_USART_Transmit_0
    754            {
    755              if ((pTxData == NULL) || (Size == 0U))
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD003             BEQ.N    ??HAL_USART_Transmit_1
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0xB280             UXTH     R0,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD101             BNE.N    ??HAL_USART_Transmit_2
    756              {
    757                return  HAL_ERROR;
   \                     ??HAL_USART_Transmit_1: (+1)
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xE06C             B.N      ??HAL_USART_Transmit_3
    758              }
    759          
    760              /* Process Locked */
    761              __HAL_LOCK(husart);
   \                     ??HAL_USART_Transmit_2: (+1)
   \       0x24   0xF896 0x0058      LDRB     R0,[R6, #+88]
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD101             BNE.N    ??HAL_USART_Transmit_4
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0xE066             B.N      ??HAL_USART_Transmit_3
   \                     ??HAL_USART_Transmit_4: (+1)
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0xF886 0x0058      STRB     R0,[R6, #+88]
    762          
    763              /* Disable the USART DMA Tx request if enabled */
    764              if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
   \       0x36   0x6830             LDR      R0,[R6, #+0]
   \       0x38   0x6880             LDR      R0,[R0, #+8]
   \       0x3A   0x0600             LSLS     R0,R0,#+24
   \       0x3C   0xD505             BPL.N    ??HAL_USART_Transmit_5
    765              {
    766                CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
   \       0x3E   0x6830             LDR      R0,[R6, #+0]
   \       0x40   0x6880             LDR      R0,[R0, #+8]
   \       0x42   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0x46   0x6831             LDR      R1,[R6, #+0]
   \       0x48   0x6088             STR      R0,[R1, #+8]
    767              }
    768          
    769              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \                     ??HAL_USART_Transmit_5: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x65F0             STR      R0,[R6, #+92]
    770              husart->State = HAL_USART_STATE_BUSY_TX;
   \       0x4E   0x2012             MOVS     R0,#+18
   \       0x50   0xF886 0x0059      STRB     R0,[R6, #+89]
    771          
    772              /* Init tickstart for timeout management */
    773              tickstart = HAL_GetTick();
   \       0x54   0x.... 0x....      BL       HAL_GetTick
   \       0x58   0x4680             MOV      R8,R0
    774          
    775              husart->TxXferSize = Size;
   \       0x5A   0x85B4             STRH     R4,[R6, #+44]
    776              husart->TxXferCount = Size;
   \       0x5C   0x85F4             STRH     R4,[R6, #+46]
    777          
    778              /* In case of 9bits/No Parity transfer, pTxData needs to be handled as a uint16_t pointer */
    779              if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
   \       0x5E   0x68B0             LDR      R0,[R6, #+8]
   \       0x60   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x64   0xD104             BNE.N    ??HAL_USART_Transmit_6
   \       0x66   0x6930             LDR      R0,[R6, #+16]
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD101             BNE.N    ??HAL_USART_Transmit_6
    780              {
    781                ptxdata8bits  = NULL;
   \       0x6C   0x2400             MOVS     R4,#+0
    782                ptxdata16bits = (const uint16_t *) pTxData;
   \       0x6E   0xE012             B.N      ??HAL_USART_Transmit_7
    783              }
    784              else
    785              {
    786                ptxdata8bits  = pTxData;
   \                     ??HAL_USART_Transmit_6: (+1)
   \       0x70   0x002C             MOVS     R4,R5
    787                ptxdata16bits = NULL;
   \       0x72   0x2500             MOVS     R5,#+0
   \       0x74   0xE00F             B.N      ??HAL_USART_Transmit_7
    788              }
    789          
    790              /* Check the remaining data to be sent */
    791              while (husart->TxXferCount > 0U)
    792              {
    793                if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
    794                {
    795                  return HAL_TIMEOUT;
    796                }
    797                if (ptxdata8bits == NULL)
    798                {
    799                  husart->Instance->TDR = (uint16_t)(*ptxdata16bits & 0x01FFU);
    800                  ptxdata16bits++;
    801                }
    802                else
    803                {
    804                  husart->Instance->TDR = (uint8_t)(*ptxdata8bits & 0xFFU);
   \                     ??HAL_USART_Transmit_8: (+1)
   \       0x76   0x7820             LDRB     R0,[R4, #+0]
   \       0x78   0x6831             LDR      R1,[R6, #+0]
   \       0x7A   0x6288             STR      R0,[R1, #+40]
    805                  ptxdata8bits++;
   \       0x7C   0x1C64             ADDS     R4,R4,#+1
   \       0x7E   0xE007             B.N      ??HAL_USART_Transmit_9
    806                }
   \                     ??HAL_USART_Transmit_10: (+1)
   \       0x80   0x2C00             CMP      R4,#+0
   \       0x82   0xD1F8             BNE.N    ??HAL_USART_Transmit_8
   \       0x84   0x8828             LDRH     R0,[R5, #+0]
   \       0x86   0x05C0             LSLS     R0,R0,#+23
   \       0x88   0x0DC0             LSRS     R0,R0,#+23
   \       0x8A   0x6831             LDR      R1,[R6, #+0]
   \       0x8C   0x6288             STR      R0,[R1, #+40]
   \       0x8E   0x1CAD             ADDS     R5,R5,#+2
    807          
    808                husart->TxXferCount--;
   \                     ??HAL_USART_Transmit_9: (+1)
   \       0x90   0x8DF0             LDRH     R0,[R6, #+46]
   \       0x92   0x1E40             SUBS     R0,R0,#+1
   \       0x94   0x85F0             STRH     R0,[R6, #+46]
   \                     ??HAL_USART_Transmit_7: (+1)
   \       0x96   0x8DF0             LDRH     R0,[R6, #+46]
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD00A             BEQ.N    ??HAL_USART_Transmit_11
   \       0x9C   0x9700             STR      R7,[SP, #+0]
   \       0x9E   0x4643             MOV      R3,R8
   \       0xA0   0x2200             MOVS     R2,#+0
   \       0xA2   0x2180             MOVS     R1,#+128
   \       0xA4   0x0030             MOVS     R0,R6
   \       0xA6   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD0E8             BEQ.N    ??HAL_USART_Transmit_10
   \       0xAE   0x2003             MOVS     R0,#+3
   \       0xB0   0xE025             B.N      ??HAL_USART_Transmit_3
    809              }
    810          
    811              if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
   \                     ??HAL_USART_Transmit_11: (+1)
   \       0xB2   0x9700             STR      R7,[SP, #+0]
   \       0xB4   0x4643             MOV      R3,R8
   \       0xB6   0x2200             MOVS     R2,#+0
   \       0xB8   0x2140             MOVS     R1,#+64
   \       0xBA   0x0030             MOVS     R0,R6
   \       0xBC   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD001             BEQ.N    ??HAL_USART_Transmit_12
    812              {
    813                return HAL_TIMEOUT;
   \       0xC4   0x2003             MOVS     R0,#+3
   \       0xC6   0xE01A             B.N      ??HAL_USART_Transmit_3
    814              }
    815          
    816              /* Clear Transmission Complete Flag */
    817              __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_TCF);
   \                     ??HAL_USART_Transmit_12: (+1)
   \       0xC8   0x2040             MOVS     R0,#+64
   \       0xCA   0x6831             LDR      R1,[R6, #+0]
   \       0xCC   0x6208             STR      R0,[R1, #+32]
    818          
    819              /* Clear overrun flag and discard the received data */
    820              __HAL_USART_CLEAR_OREFLAG(husart);
   \       0xCE   0x2008             MOVS     R0,#+8
   \       0xD0   0x6831             LDR      R1,[R6, #+0]
   \       0xD2   0x6208             STR      R0,[R1, #+32]
    821              __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
   \       0xD4   0x6830             LDR      R0,[R6, #+0]
   \       0xD6   0x6980             LDR      R0,[R0, #+24]
   \       0xD8   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xDC   0x6831             LDR      R1,[R6, #+0]
   \       0xDE   0x6188             STR      R0,[R1, #+24]
    822              __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
   \       0xE0   0x6830             LDR      R0,[R6, #+0]
   \       0xE2   0x6980             LDR      R0,[R0, #+24]
   \       0xE4   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xE8   0x6831             LDR      R1,[R6, #+0]
   \       0xEA   0x6188             STR      R0,[R1, #+24]
    823          
    824              /* At end of Tx process, restore husart->State to Ready */
    825              husart->State = HAL_USART_STATE_READY;
   \       0xEC   0x2001             MOVS     R0,#+1
   \       0xEE   0xF886 0x0059      STRB     R0,[R6, #+89]
    826          
    827              /* Process Unlocked */
    828              __HAL_UNLOCK(husart);
   \       0xF2   0x2000             MOVS     R0,#+0
   \       0xF4   0xF886 0x0058      STRB     R0,[R6, #+88]
    829          
    830              return HAL_OK;
   \       0xF8   0x2000             MOVS     R0,#+0
   \       0xFA   0xE000             B.N      ??HAL_USART_Transmit_3
    831            }
    832            else
    833            {
    834              return HAL_BUSY;
   \                     ??HAL_USART_Transmit_0: (+1)
   \       0xFC   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_Transmit_3: (+1)
   \       0xFE   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
    835            }
    836          }
    837          
    838          /**
    839            * @brief Receive an amount of data in blocking mode.
    840            * @note   To receive synchronous data, dummy data are simultaneously transmitted.
    841            * @note   When USART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
    842            *         the received data is handled as a set of u16. In this case, Size must indicate the number
    843            *         of u16 available through pRxData.
    844            * @param husart USART handle.
    845            * @param pRxData Pointer to data buffer (u8 or u16 data elements).
    846            * @param Size Amount of data elements (u8 or u16) to be received.
    847            * @param Timeout Timeout duration.
    848            * @retval HAL status
    849            */

   \                                 In section .text, align 2, keep-with-next
    850          HAL_StatusTypeDef HAL_USART_Receive(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
    851          {
   \                     HAL_USART_Receive: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x4699             MOV      R9,R3
    852            uint8_t  *prxdata8bits;
    853            uint16_t *prxdata16bits;
    854            uint16_t uhMask;
    855            uint32_t tickstart;
    856          
    857            if (husart->State == HAL_USART_STATE_READY)
   \        0xC   0xF896 0x0059      LDRB     R0,[R6, #+89]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xF040 0x80A4      BNE.W    ??HAL_USART_Receive_0
    858            {
    859              if ((pRxData == NULL) || (Size == 0U))
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD003             BEQ.N    ??HAL_USART_Receive_1
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0xB280             UXTH     R0,R0
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD101             BNE.N    ??HAL_USART_Receive_2
    860              {
    861                return  HAL_ERROR;
   \                     ??HAL_USART_Receive_1: (+1)
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xE09C             B.N      ??HAL_USART_Receive_3
    862              }
    863          
    864              /* Process Locked */
    865              __HAL_LOCK(husart);
   \                     ??HAL_USART_Receive_2: (+1)
   \       0x26   0xF896 0x0058      LDRB     R0,[R6, #+88]
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD101             BNE.N    ??HAL_USART_Receive_4
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xE096             B.N      ??HAL_USART_Receive_3
   \                     ??HAL_USART_Receive_4: (+1)
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xF886 0x0058      STRB     R0,[R6, #+88]
    866          
    867              /* Disable the USART DMA Rx request if enabled */
    868              if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
   \       0x38   0x6830             LDR      R0,[R6, #+0]
   \       0x3A   0x6880             LDR      R0,[R0, #+8]
   \       0x3C   0x0640             LSLS     R0,R0,#+25
   \       0x3E   0xD505             BPL.N    ??HAL_USART_Receive_5
    869              {
    870                CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
   \       0x40   0x6830             LDR      R0,[R6, #+0]
   \       0x42   0x6880             LDR      R0,[R0, #+8]
   \       0x44   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x48   0x6831             LDR      R1,[R6, #+0]
   \       0x4A   0x6088             STR      R0,[R1, #+8]
    871              }
    872          
    873              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \                     ??HAL_USART_Receive_5: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x65F0             STR      R0,[R6, #+92]
    874              husart->State = HAL_USART_STATE_BUSY_RX;
   \       0x50   0x2022             MOVS     R0,#+34
   \       0x52   0xF886 0x0059      STRB     R0,[R6, #+89]
    875          
    876              /* Init tickstart for timeout management */
    877              tickstart = HAL_GetTick();
   \       0x56   0x.... 0x....      BL       HAL_GetTick
   \       0x5A   0x0007             MOVS     R7,R0
    878          
    879              husart->RxXferSize = Size;
   \       0x5C   0x86B4             STRH     R4,[R6, #+52]
    880              husart->RxXferCount = Size;
   \       0x5E   0x86F4             STRH     R4,[R6, #+54]
    881          
    882              /* Computation of USART mask to apply to RDR register */
    883              USART_MASK_COMPUTATION(husart);
   \       0x60   0x68B0             LDR      R0,[R6, #+8]
   \       0x62   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x66   0xD109             BNE.N    ??HAL_USART_Receive_6
   \       0x68   0x6930             LDR      R0,[R6, #+16]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD103             BNE.N    ??HAL_USART_Receive_7
   \       0x6E   0xF240 0x10FF      MOVW     R0,#+511
   \       0x72   0x8730             STRH     R0,[R6, #+56]
   \       0x74   0xE01D             B.N      ??HAL_USART_Receive_8
   \                     ??HAL_USART_Receive_7: (+1)
   \       0x76   0x20FF             MOVS     R0,#+255
   \       0x78   0x8730             STRH     R0,[R6, #+56]
   \       0x7A   0xE01A             B.N      ??HAL_USART_Receive_8
   \                     ??HAL_USART_Receive_6: (+1)
   \       0x7C   0x68B0             LDR      R0,[R6, #+8]
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD108             BNE.N    ??HAL_USART_Receive_9
   \       0x82   0x6930             LDR      R0,[R6, #+16]
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD102             BNE.N    ??HAL_USART_Receive_10
   \       0x88   0x20FF             MOVS     R0,#+255
   \       0x8A   0x8730             STRH     R0,[R6, #+56]
   \       0x8C   0xE011             B.N      ??HAL_USART_Receive_8
   \                     ??HAL_USART_Receive_10: (+1)
   \       0x8E   0x207F             MOVS     R0,#+127
   \       0x90   0x8730             STRH     R0,[R6, #+56]
   \       0x92   0xE00E             B.N      ??HAL_USART_Receive_8
   \                     ??HAL_USART_Receive_9: (+1)
   \       0x94   0x68B0             LDR      R0,[R6, #+8]
   \       0x96   0xF1B0 0x5F80      CMP      R0,#+268435456
   \       0x9A   0xD108             BNE.N    ??HAL_USART_Receive_11
   \       0x9C   0x6930             LDR      R0,[R6, #+16]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD102             BNE.N    ??HAL_USART_Receive_12
   \       0xA2   0x207F             MOVS     R0,#+127
   \       0xA4   0x8730             STRH     R0,[R6, #+56]
   \       0xA6   0xE004             B.N      ??HAL_USART_Receive_8
   \                     ??HAL_USART_Receive_12: (+1)
   \       0xA8   0x203F             MOVS     R0,#+63
   \       0xAA   0x8730             STRH     R0,[R6, #+56]
   \       0xAC   0xE001             B.N      ??HAL_USART_Receive_8
   \                     ??HAL_USART_Receive_11: (+1)
   \       0xAE   0x2000             MOVS     R0,#+0
   \       0xB0   0x8730             STRH     R0,[R6, #+56]
    884              uhMask = husart->Mask;
   \                     ??HAL_USART_Receive_8: (+1)
   \       0xB2   0xF8B6 0x8038      LDRH     R8,[R6, #+56]
    885          
    886              /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
    887              if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
   \       0xB6   0x68B0             LDR      R0,[R6, #+8]
   \       0xB8   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0xBC   0xD104             BNE.N    ??HAL_USART_Receive_13
   \       0xBE   0x6930             LDR      R0,[R6, #+16]
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD101             BNE.N    ??HAL_USART_Receive_13
    888              {
    889                prxdata8bits  = NULL;
   \       0xC4   0x2400             MOVS     R4,#+0
    890                prxdata16bits = (uint16_t *) pRxData;
   \       0xC6   0xE021             B.N      ??HAL_USART_Receive_14
    891              }
    892              else
    893              {
    894                prxdata8bits  = pRxData;
   \                     ??HAL_USART_Receive_13: (+1)
   \       0xC8   0x002C             MOVS     R4,R5
    895                prxdata16bits = NULL;
   \       0xCA   0x2500             MOVS     R5,#+0
   \       0xCC   0xE01E             B.N      ??HAL_USART_Receive_14
    896              }
    897          
    898              /* as long as data have to be received */
    899              while (husart->RxXferCount > 0U)
    900              {
    901                if (husart->SlaveMode == USART_SLAVEMODE_DISABLE)
    902                {
    903                  /* Wait until TXE flag is set to send dummy byte in order to generate the
    904                  * clock for the slave to send data.
    905                  * Whatever the frame length (7, 8 or 9-bit long), the same dummy value
    906                  * can be written for all the cases. */
    907                  if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
    908                  {
    909                    return HAL_TIMEOUT;
    910                  }
    911                  husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x0FF);
    912                }
    913          
    914                /* Wait for RXNE Flag */
    915                if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
    916                {
    917                  return HAL_TIMEOUT;
    918                }
    919          
    920                if (prxdata8bits == NULL)
    921                {
    922                  *prxdata16bits = (uint16_t)(husart->Instance->RDR & uhMask);
    923                  prxdata16bits++;
    924                }
    925                else
    926                {
    927                  *prxdata8bits = (uint8_t)(husart->Instance->RDR & (uint8_t)(uhMask & 0xFFU));
   \                     ??HAL_USART_Receive_15: (+1)
   \       0xCE   0x6830             LDR      R0,[R6, #+0]
   \       0xD0   0x6A40             LDR      R0,[R0, #+36]
   \       0xD2   0xEA18 0x0000      ANDS     R0,R8,R0
   \       0xD6   0x7020             STRB     R0,[R4, #+0]
    928                  prxdata8bits++;
   \       0xD8   0x1C64             ADDS     R4,R4,#+1
   \       0xDA   0xE014             B.N      ??HAL_USART_Receive_16
    929                }
   \                     ??HAL_USART_Receive_17: (+1)
   \       0xDC   0x20FF             MOVS     R0,#+255
   \       0xDE   0x6831             LDR      R1,[R6, #+0]
   \       0xE0   0x6288             STR      R0,[R1, #+40]
   \                     ??HAL_USART_Receive_18: (+1)
   \       0xE2   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0xE6   0x003B             MOVS     R3,R7
   \       0xE8   0x2200             MOVS     R2,#+0
   \       0xEA   0x2120             MOVS     R1,#+32
   \       0xEC   0x0030             MOVS     R0,R6
   \       0xEE   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \       0xF2   0x2800             CMP      R0,#+0
   \       0xF4   0xD11C             BNE.N    ??HAL_USART_Receive_19
   \                     ??HAL_USART_Receive_20: (+1)
   \       0xF6   0x2C00             CMP      R4,#+0
   \       0xF8   0xD1E9             BNE.N    ??HAL_USART_Receive_15
   \       0xFA   0x6830             LDR      R0,[R6, #+0]
   \       0xFC   0x6A40             LDR      R0,[R0, #+36]
   \       0xFE   0xEA18 0x0000      ANDS     R0,R8,R0
   \      0x102   0x8028             STRH     R0,[R5, #+0]
   \      0x104   0x1CAD             ADDS     R5,R5,#+2
    930          
    931                husart->RxXferCount--;
   \                     ??HAL_USART_Receive_16: (+1)
   \      0x106   0x8EF0             LDRH     R0,[R6, #+54]
   \      0x108   0x1E40             SUBS     R0,R0,#+1
   \      0x10A   0x86F0             STRH     R0,[R6, #+54]
   \                     ??HAL_USART_Receive_14: (+1)
   \      0x10C   0x8EF0             LDRH     R0,[R6, #+54]
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD010             BEQ.N    ??HAL_USART_Receive_21
   \      0x112   0x6C30             LDR      R0,[R6, #+64]
   \      0x114   0x2800             CMP      R0,#+0
   \      0x116   0xD1E4             BNE.N    ??HAL_USART_Receive_18
   \      0x118   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \      0x11C   0x003B             MOVS     R3,R7
   \      0x11E   0x2200             MOVS     R2,#+0
   \      0x120   0x2180             MOVS     R1,#+128
   \      0x122   0x0030             MOVS     R0,R6
   \      0x124   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \      0x128   0x2800             CMP      R0,#+0
   \      0x12A   0xD0D7             BEQ.N    ??HAL_USART_Receive_17
   \      0x12C   0x2003             MOVS     R0,#+3
   \      0x12E   0xE017             B.N      ??HAL_USART_Receive_3
   \                     ??HAL_USART_Receive_19: (+1)
   \      0x130   0x2003             MOVS     R0,#+3
   \      0x132   0xE015             B.N      ??HAL_USART_Receive_3
    932          
    933              }
    934          
    935              /* Clear SPI slave underrun flag and discard transmit data */
    936              if (husart->SlaveMode == USART_SLAVEMODE_ENABLE)
   \                     ??HAL_USART_Receive_21: (+1)
   \      0x134   0x6C30             LDR      R0,[R6, #+64]
   \      0x136   0x2801             CMP      R0,#+1
   \      0x138   0xD109             BNE.N    ??HAL_USART_Receive_22
    937              {
    938                __HAL_USART_CLEAR_UDRFLAG(husart);
   \      0x13A   0xF44F 0x5000      MOV      R0,#+8192
   \      0x13E   0x6831             LDR      R1,[R6, #+0]
   \      0x140   0x6208             STR      R0,[R1, #+32]
    939                __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
   \      0x142   0x6830             LDR      R0,[R6, #+0]
   \      0x144   0x6980             LDR      R0,[R0, #+24]
   \      0x146   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x14A   0x6831             LDR      R1,[R6, #+0]
   \      0x14C   0x6188             STR      R0,[R1, #+24]
    940              }
    941          
    942              /* At end of Rx process, restore husart->State to Ready */
    943              husart->State = HAL_USART_STATE_READY;
   \                     ??HAL_USART_Receive_22: (+1)
   \      0x14E   0x2001             MOVS     R0,#+1
   \      0x150   0xF886 0x0059      STRB     R0,[R6, #+89]
    944          
    945              /* Process Unlocked */
    946              __HAL_UNLOCK(husart);
   \      0x154   0x2000             MOVS     R0,#+0
   \      0x156   0xF886 0x0058      STRB     R0,[R6, #+88]
    947          
    948              return HAL_OK;
   \      0x15A   0x2000             MOVS     R0,#+0
   \      0x15C   0xE000             B.N      ??HAL_USART_Receive_3
    949            }
    950            else
    951            {
    952              return HAL_BUSY;
   \                     ??HAL_USART_Receive_0: (+1)
   \      0x15E   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_Receive_3: (+1)
   \      0x160   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    953            }
    954          }
    955          
    956          /**
    957            * @brief Full-Duplex Send and Receive an amount of data in blocking mode.
    958            * @note   When USART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
    959            *         the sent data and the received data are handled as sets of u16. In this case, Size must indicate the number
    960            *         of u16 available through pTxData and through pRxData.
    961            * @param  husart USART handle.
    962            * @param  pTxData pointer to TX data buffer (u8 or u16 data elements).
    963            * @param  pRxData pointer to RX data buffer (u8 or u16 data elements).
    964            * @param  Size amount of data elements (u8 or u16) to be sent (same amount to be received).
    965            * @param  Timeout Timeout duration.
    966            * @retval HAL status
    967            */

   \                                 In section .text, align 2, keep-with-next
    968          HAL_StatusTypeDef HAL_USART_TransmitReceive(USART_HandleTypeDef *husart, const uint8_t *pTxData, uint8_t *pRxData,
    969                                                      uint16_t Size, uint32_t Timeout)
    970          {
   \                     HAL_USART_TransmitReceive: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x001C             MOVS     R4,R3
    971            uint8_t  *prxdata8bits;
    972            uint16_t *prxdata16bits;
    973            const uint8_t  *ptxdata8bits;
    974            const uint16_t *ptxdata16bits;
    975            uint16_t uhMask;
    976            uint16_t rxdatacount;
    977            uint32_t tickstart;
    978          
    979            if (husart->State == HAL_USART_STATE_READY)
   \        0xA   0xF89B 0x0059      LDRB     R0,[R11, #+89]
   \        0xE   0x2801             CMP      R0,#+1
   \       0x10   0xF040 0x8119      BNE.W    ??HAL_USART_TransmitReceive_0
    980            {
    981              if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD006             BEQ.N    ??HAL_USART_TransmitReceive_1
   \       0x18   0x0017             MOVS     R7,R2
   \       0x1A   0x2F00             CMP      R7,#+0
   \       0x1C   0xD003             BEQ.N    ??HAL_USART_TransmitReceive_1
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0xB280             UXTH     R0,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD101             BNE.N    ??HAL_USART_TransmitReceive_2
    982              {
    983                return  HAL_ERROR;
   \                     ??HAL_USART_TransmitReceive_1: (+1)
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xE10E             B.N      ??HAL_USART_TransmitReceive_3
    984              }
    985          
    986              /* Process Locked */
    987              __HAL_LOCK(husart);
   \                     ??HAL_USART_TransmitReceive_2: (+1)
   \       0x2A   0xF89B 0x0058      LDRB     R0,[R11, #+88]
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xD101             BNE.N    ??HAL_USART_TransmitReceive_4
   \       0x32   0x2002             MOVS     R0,#+2
   \       0x34   0xE108             B.N      ??HAL_USART_TransmitReceive_3
   \                     ??HAL_USART_TransmitReceive_4: (+1)
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0xF88B 0x0058      STRB     R0,[R11, #+88]
    988          
    989              /* Disable the USART DMA Tx request if enabled */
    990              if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
   \       0x3C   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x40   0x6880             LDR      R0,[R0, #+8]
   \       0x42   0x0600             LSLS     R0,R0,#+24
   \       0x44   0xD507             BPL.N    ??HAL_USART_TransmitReceive_5
    991              {
    992                CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
   \       0x46   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x4A   0x6880             LDR      R0,[R0, #+8]
   \       0x4C   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0x50   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \       0x54   0x6088             STR      R0,[R1, #+8]
    993              }
    994          
    995              /* Disable the USART DMA Rx request if enabled */
    996              if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
   \                     ??HAL_USART_TransmitReceive_5: (+1)
   \       0x56   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x5A   0x6880             LDR      R0,[R0, #+8]
   \       0x5C   0x0640             LSLS     R0,R0,#+25
   \       0x5E   0xD507             BPL.N    ??HAL_USART_TransmitReceive_6
    997              {
    998                CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
   \       0x60   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x64   0x6880             LDR      R0,[R0, #+8]
   \       0x66   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x6A   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \       0x6E   0x6088             STR      R0,[R1, #+8]
    999              }
   1000          
   1001              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \                     ??HAL_USART_TransmitReceive_6: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0xF8CB 0x005C      STR      R0,[R11, #+92]
   1002              husart->State = HAL_USART_STATE_BUSY_RX;
   \       0x76   0x2022             MOVS     R0,#+34
   \       0x78   0xF88B 0x0059      STRB     R0,[R11, #+89]
   1003          
   1004              /* Init tickstart for timeout management */
   1005              tickstart = HAL_GetTick();
   \       0x7C   0x.... 0x....      BL       HAL_GetTick
   \       0x80   0x4681             MOV      R9,R0
   1006          
   1007              husart->RxXferSize = Size;
   \       0x82   0xF8AB 0x4034      STRH     R4,[R11, #+52]
   1008              husart->TxXferSize = Size;
   \       0x86   0xF8AB 0x402C      STRH     R4,[R11, #+44]
   1009              husart->TxXferCount = Size;
   \       0x8A   0xF8AB 0x402E      STRH     R4,[R11, #+46]
   1010              husart->RxXferCount = Size;
   \       0x8E   0xF8AB 0x4036      STRH     R4,[R11, #+54]
   1011          
   1012              /* Computation of USART mask to apply to RDR register */
   1013              USART_MASK_COMPUTATION(husart);
   \       0x92   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \       0x96   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x9A   0xD10C             BNE.N    ??HAL_USART_TransmitReceive_7
   \       0x9C   0xF8DB 0x0010      LDR      R0,[R11, #+16]
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD104             BNE.N    ??HAL_USART_TransmitReceive_8
   \       0xA4   0xF240 0x10FF      MOVW     R0,#+511
   \       0xA8   0xF8AB 0x0038      STRH     R0,[R11, #+56]
   \       0xAC   0xE027             B.N      ??HAL_USART_TransmitReceive_9
   \                     ??HAL_USART_TransmitReceive_8: (+1)
   \       0xAE   0x20FF             MOVS     R0,#+255
   \       0xB0   0xF8AB 0x0038      STRH     R0,[R11, #+56]
   \       0xB4   0xE023             B.N      ??HAL_USART_TransmitReceive_9
   \                     ??HAL_USART_TransmitReceive_7: (+1)
   \       0xB6   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD10B             BNE.N    ??HAL_USART_TransmitReceive_10
   \       0xBE   0xF8DB 0x0010      LDR      R0,[R11, #+16]
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD103             BNE.N    ??HAL_USART_TransmitReceive_11
   \       0xC6   0x20FF             MOVS     R0,#+255
   \       0xC8   0xF8AB 0x0038      STRH     R0,[R11, #+56]
   \       0xCC   0xE017             B.N      ??HAL_USART_TransmitReceive_9
   \                     ??HAL_USART_TransmitReceive_11: (+1)
   \       0xCE   0x207F             MOVS     R0,#+127
   \       0xD0   0xF8AB 0x0038      STRH     R0,[R11, #+56]
   \       0xD4   0xE013             B.N      ??HAL_USART_TransmitReceive_9
   \                     ??HAL_USART_TransmitReceive_10: (+1)
   \       0xD6   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \       0xDA   0xF1B0 0x5F80      CMP      R0,#+268435456
   \       0xDE   0xD10B             BNE.N    ??HAL_USART_TransmitReceive_12
   \       0xE0   0xF8DB 0x0010      LDR      R0,[R11, #+16]
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD103             BNE.N    ??HAL_USART_TransmitReceive_13
   \       0xE8   0x207F             MOVS     R0,#+127
   \       0xEA   0xF8AB 0x0038      STRH     R0,[R11, #+56]
   \       0xEE   0xE006             B.N      ??HAL_USART_TransmitReceive_9
   \                     ??HAL_USART_TransmitReceive_13: (+1)
   \       0xF0   0x203F             MOVS     R0,#+63
   \       0xF2   0xF8AB 0x0038      STRH     R0,[R11, #+56]
   \       0xF6   0xE002             B.N      ??HAL_USART_TransmitReceive_9
   \                     ??HAL_USART_TransmitReceive_12: (+1)
   \       0xF8   0x2000             MOVS     R0,#+0
   \       0xFA   0xF8AB 0x0038      STRH     R0,[R11, #+56]
   1014              uhMask = husart->Mask;
   \                     ??HAL_USART_TransmitReceive_9: (+1)
   \       0xFE   0xF8BB 0x8038      LDRH     R8,[R11, #+56]
   1015          
   1016              /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
   1017              if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
   \      0x102   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \      0x106   0xF5B0 0x5F80      CMP      R0,#+4096
   \      0x10A   0xD107             BNE.N    ??HAL_USART_TransmitReceive_14
   \      0x10C   0xF8DB 0x0010      LDR      R0,[R11, #+16]
   \      0x110   0x2800             CMP      R0,#+0
   \      0x112   0xD103             BNE.N    ??HAL_USART_TransmitReceive_14
   1018              {
   1019                prxdata8bits  = NULL;
   \      0x114   0x2500             MOVS     R5,#+0
   1020                ptxdata8bits  = NULL;
   \      0x116   0x2400             MOVS     R4,#+0
   1021                ptxdata16bits = (const uint16_t *) pTxData;
   \      0x118   0x46B2             MOV      R10,R6
   1022                prxdata16bits = (uint16_t *) pRxData;
   \      0x11A   0xE004             B.N      ??HAL_USART_TransmitReceive_15
   1023              }
   1024              else
   1025              {
   1026                prxdata8bits  = pRxData;
   \                     ??HAL_USART_TransmitReceive_14: (+1)
   \      0x11C   0x003D             MOVS     R5,R7
   1027                ptxdata8bits  = pTxData;
   \      0x11E   0x0034             MOVS     R4,R6
   1028                ptxdata16bits = NULL;
   \      0x120   0xF05F 0x0A00      MOVS     R10,#+0
   1029                prxdata16bits = NULL;
   \      0x124   0x2700             MOVS     R7,#+0
   \                     ??HAL_USART_TransmitReceive_15: (+1)
   \      0x126   0x9E0A             LDR      R6,[SP, #+40]
   1030              }
   1031          
   1032              if ((husart->TxXferCount == 0x01U) || (husart->SlaveMode == USART_SLAVEMODE_ENABLE))
   \      0x128   0xF8BB 0x002E      LDRH     R0,[R11, #+46]
   \      0x12C   0x2801             CMP      R0,#+1
   \      0x12E   0xD003             BEQ.N    ??HAL_USART_TransmitReceive_16
   \      0x130   0xF8DB 0x0040      LDR      R0,[R11, #+64]
   \      0x134   0x2801             CMP      R0,#+1
   \      0x136   0xD124             BNE.N    ??HAL_USART_TransmitReceive_17
   1033              {
   1034                /* Wait until TXE flag is set to send data */
   1035                if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
   \                     ??HAL_USART_TransmitReceive_16: (+1)
   \      0x138   0x9600             STR      R6,[SP, #+0]
   \      0x13A   0x464B             MOV      R3,R9
   \      0x13C   0x2200             MOVS     R2,#+0
   \      0x13E   0x2180             MOVS     R1,#+128
   \      0x140   0x4658             MOV      R0,R11
   \      0x142   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \      0x146   0x2800             CMP      R0,#+0
   \      0x148   0xD001             BEQ.N    ??HAL_USART_TransmitReceive_18
   1036                {
   1037                  return HAL_TIMEOUT;
   \      0x14A   0x2003             MOVS     R0,#+3
   \      0x14C   0xE07C             B.N      ??HAL_USART_TransmitReceive_3
   1038                }
   1039                if (ptxdata8bits == NULL)
   \                     ??HAL_USART_TransmitReceive_18: (+1)
   \      0x14E   0x2C00             CMP      R4,#+0
   \      0x150   0xD10A             BNE.N    ??HAL_USART_TransmitReceive_19
   1040                {
   1041                  husart->Instance->TDR = (uint16_t)(*ptxdata16bits & uhMask);
   \      0x152   0xF8BA 0x0000      LDRH     R0,[R10, #+0]
   \      0x156   0xEA18 0x0000      ANDS     R0,R8,R0
   \      0x15A   0xB280             UXTH     R0,R0
   \      0x15C   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0x160   0x6288             STR      R0,[R1, #+40]
   1042                  ptxdata16bits++;
   \      0x162   0xF11A 0x0A02      ADDS     R10,R10,#+2
   \      0x166   0xE007             B.N      ??HAL_USART_TransmitReceive_20
   1043                }
   1044                else
   1045                {
   1046                  husart->Instance->TDR = (uint8_t)(*ptxdata8bits & (uint8_t)(uhMask & 0xFFU));
   \                     ??HAL_USART_TransmitReceive_19: (+1)
   \      0x168   0x7820             LDRB     R0,[R4, #+0]
   \      0x16A   0xEA18 0x0000      ANDS     R0,R8,R0
   \      0x16E   0xB2C0             UXTB     R0,R0
   \      0x170   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0x174   0x6288             STR      R0,[R1, #+40]
   1047                  ptxdata8bits++;
   \      0x176   0x1C64             ADDS     R4,R4,#+1
   1048                }
   1049          
   1050                husart->TxXferCount--;
   \                     ??HAL_USART_TransmitReceive_20: (+1)
   \      0x178   0xF8BB 0x002E      LDRH     R0,[R11, #+46]
   \      0x17C   0x1E40             SUBS     R0,R0,#+1
   \      0x17E   0xF8AB 0x002E      STRH     R0,[R11, #+46]
   1051              }
   1052          
   1053              /* Check the remain data to be sent */
   1054              /* rxdatacount is a temporary variable for MISRAC2012-Rule-13.5 */
   1055              rxdatacount = husart->RxXferCount;
   \                     ??HAL_USART_TransmitReceive_17: (+1)
   \      0x182   0xF8BB 0x1036      LDRH     R1,[R11, #+54]
   \      0x186   0xE035             B.N      ??HAL_USART_TransmitReceive_21
   1056              while ((husart->TxXferCount > 0U) || (rxdatacount > 0U))
   1057              {
   1058                if (husart->TxXferCount > 0U)
   1059                {
   1060                  /* Wait until TXE flag is set to send data */
   1061                  if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
   1062                  {
   1063                    return HAL_TIMEOUT;
   1064                  }
   1065                  if (ptxdata8bits == NULL)
   1066                  {
   1067                    husart->Instance->TDR = (uint16_t)(*ptxdata16bits & uhMask);
   1068                    ptxdata16bits++;
   1069                  }
   1070                  else
   1071                  {
   1072                    husart->Instance->TDR = (uint8_t)(*ptxdata8bits & (uint8_t)(uhMask & 0xFFU));
   1073                    ptxdata8bits++;
   1074                  }
   1075          
   1076                  husart->TxXferCount--;
   1077                }
   1078          
   1079                if (husart->RxXferCount > 0U)
   1080                {
   1081                  /* Wait for RXNE Flag */
   1082                  if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
   1083                  {
   1084                    return HAL_TIMEOUT;
   1085                  }
   1086          
   1087                  if (prxdata8bits == NULL)
   1088                  {
   1089                    *prxdata16bits = (uint16_t)(husart->Instance->RDR & uhMask);
   1090                    prxdata16bits++;
   1091                  }
   1092                  else
   1093                  {
   1094                    *prxdata8bits = (uint8_t)(husart->Instance->RDR & (uint8_t)(uhMask & 0xFFU));
   \                     ??HAL_USART_TransmitReceive_22: (+1)
   \      0x188   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x18C   0x6A40             LDR      R0,[R0, #+36]
   \      0x18E   0xEA18 0x0000      ANDS     R0,R8,R0
   \      0x192   0x7028             STRB     R0,[R5, #+0]
   1095                    prxdata8bits++;
   \      0x194   0x1C6D             ADDS     R5,R5,#+1
   \      0x196   0xE026             B.N      ??HAL_USART_TransmitReceive_23
   1096                  }
   \                     ??HAL_USART_TransmitReceive_24: (+1)
   \      0x198   0x2C00             CMP      R4,#+0
   \      0x19A   0xD141             BNE.N    ??HAL_USART_TransmitReceive_25
   \      0x19C   0xF8BA 0x0000      LDRH     R0,[R10, #+0]
   \      0x1A0   0xEA18 0x0000      ANDS     R0,R8,R0
   \      0x1A4   0xB280             UXTH     R0,R0
   \      0x1A6   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0x1AA   0x6288             STR      R0,[R1, #+40]
   \      0x1AC   0xF11A 0x0A02      ADDS     R10,R10,#+2
   \                     ??HAL_USART_TransmitReceive_26: (+1)
   \      0x1B0   0xF8BB 0x002E      LDRH     R0,[R11, #+46]
   \      0x1B4   0x1E40             SUBS     R0,R0,#+1
   \      0x1B6   0xF8AB 0x002E      STRH     R0,[R11, #+46]
   \                     ??HAL_USART_TransmitReceive_27: (+1)
   \      0x1BA   0xF8BB 0x0036      LDRH     R0,[R11, #+54]
   \      0x1BE   0x2800             CMP      R0,#+0
   \      0x1C0   0xD016             BEQ.N    ??HAL_USART_TransmitReceive_28
   \      0x1C2   0x9600             STR      R6,[SP, #+0]
   \      0x1C4   0x464B             MOV      R3,R9
   \      0x1C6   0x2200             MOVS     R2,#+0
   \      0x1C8   0x2120             MOVS     R1,#+32
   \      0x1CA   0x4658             MOV      R0,R11
   \      0x1CC   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \      0x1D0   0x2800             CMP      R0,#+0
   \      0x1D2   0xD12E             BNE.N    ??HAL_USART_TransmitReceive_29
   \                     ??HAL_USART_TransmitReceive_30: (+1)
   \      0x1D4   0x2D00             CMP      R5,#+0
   \      0x1D6   0xD1D7             BNE.N    ??HAL_USART_TransmitReceive_22
   \      0x1D8   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x1DC   0x6A40             LDR      R0,[R0, #+36]
   \      0x1DE   0xEA18 0x0000      ANDS     R0,R8,R0
   \      0x1E2   0x8038             STRH     R0,[R7, #+0]
   \      0x1E4   0x1CBF             ADDS     R7,R7,#+2
   1097          
   1098                  husart->RxXferCount--;
   \                     ??HAL_USART_TransmitReceive_23: (+1)
   \      0x1E6   0xF8BB 0x0036      LDRH     R0,[R11, #+54]
   \      0x1EA   0x1E40             SUBS     R0,R0,#+1
   \      0x1EC   0xF8AB 0x0036      STRH     R0,[R11, #+54]
   1099                }
   1100                rxdatacount = husart->RxXferCount;
   \                     ??HAL_USART_TransmitReceive_28: (+1)
   \      0x1F0   0xF8BB 0x1036      LDRH     R1,[R11, #+54]
   \                     ??HAL_USART_TransmitReceive_21: (+1)
   \      0x1F4   0xF8BB 0x002E      LDRH     R0,[R11, #+46]
   \      0x1F8   0x2800             CMP      R0,#+0
   \      0x1FA   0xD102             BNE.N    ??HAL_USART_TransmitReceive_31
   \      0x1FC   0xB289             UXTH     R1,R1
   \      0x1FE   0x2900             CMP      R1,#+0
   \      0x200   0xD019             BEQ.N    ??HAL_USART_TransmitReceive_32
   \                     ??HAL_USART_TransmitReceive_31: (+1)
   \      0x202   0xF8BB 0x002E      LDRH     R0,[R11, #+46]
   \      0x206   0x2800             CMP      R0,#+0
   \      0x208   0xD0D7             BEQ.N    ??HAL_USART_TransmitReceive_27
   \      0x20A   0x9600             STR      R6,[SP, #+0]
   \      0x20C   0x464B             MOV      R3,R9
   \      0x20E   0x2200             MOVS     R2,#+0
   \      0x210   0x2180             MOVS     R1,#+128
   \      0x212   0x4658             MOV      R0,R11
   \      0x214   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \      0x218   0x2800             CMP      R0,#+0
   \      0x21A   0xD0BD             BEQ.N    ??HAL_USART_TransmitReceive_24
   \      0x21C   0x2003             MOVS     R0,#+3
   \      0x21E   0xE013             B.N      ??HAL_USART_TransmitReceive_3
   \                     ??HAL_USART_TransmitReceive_25: (+1)
   \      0x220   0x7820             LDRB     R0,[R4, #+0]
   \      0x222   0xEA18 0x0000      ANDS     R0,R8,R0
   \      0x226   0xB2C0             UXTB     R0,R0
   \      0x228   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0x22C   0x6288             STR      R0,[R1, #+40]
   \      0x22E   0x1C64             ADDS     R4,R4,#+1
   \      0x230   0xE7BE             B.N      ??HAL_USART_TransmitReceive_26
   \                     ??HAL_USART_TransmitReceive_29: (+1)
   \      0x232   0x2003             MOVS     R0,#+3
   \      0x234   0xE008             B.N      ??HAL_USART_TransmitReceive_3
   1101              }
   1102          
   1103              /* At end of TxRx process, restore husart->State to Ready */
   1104              husart->State = HAL_USART_STATE_READY;
   \                     ??HAL_USART_TransmitReceive_32: (+1)
   \      0x236   0x2001             MOVS     R0,#+1
   \      0x238   0xF88B 0x0059      STRB     R0,[R11, #+89]
   1105          
   1106              /* Process Unlocked */
   1107              __HAL_UNLOCK(husart);
   \      0x23C   0x2000             MOVS     R0,#+0
   \      0x23E   0xF88B 0x0058      STRB     R0,[R11, #+88]
   1108          
   1109              return HAL_OK;
   \      0x242   0x2000             MOVS     R0,#+0
   \      0x244   0xE000             B.N      ??HAL_USART_TransmitReceive_3
   1110            }
   1111            else
   1112            {
   1113              return HAL_BUSY;
   \                     ??HAL_USART_TransmitReceive_0: (+1)
   \      0x246   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_TransmitReceive_3: (+1)
   \      0x248   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   1114            }
   1115          }
   1116          
   1117          /**
   1118            * @brief  Send an amount of data in interrupt mode.
   1119            * @note   When USART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1120            *         the sent data is handled as a set of u16. In this case, Size must indicate the number
   1121            *         of u16 provided through pTxData.
   1122            * @param  husart USART handle.
   1123            * @param  pTxData pointer to data buffer (u8 or u16 data elements).
   1124            * @param  Size amount of data elements (u8 or u16) to be sent.
   1125            * @retval HAL status
   1126            */

   \                                 In section .text, align 2, keep-with-next
   1127          HAL_StatusTypeDef HAL_USART_Transmit_IT(USART_HandleTypeDef *husart, const uint8_t *pTxData, uint16_t Size)
   1128          {
   \                     HAL_USART_Transmit_IT: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1129            if (husart->State == HAL_USART_STATE_READY)
   \        0x2   0xF890 0x3059      LDRB     R3,[R0, #+89]
   \        0x6   0x2B01             CMP      R3,#+1
   \        0x8   0xD159             BNE.N    ??HAL_USART_Transmit_IT_0
   1130            {
   1131              if ((pTxData == NULL) || (Size == 0U))
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD003             BEQ.N    ??HAL_USART_Transmit_IT_1
   \        0xE   0x0013             MOVS     R3,R2
   \       0x10   0xB29B             UXTH     R3,R3
   \       0x12   0x2B00             CMP      R3,#+0
   \       0x14   0xD101             BNE.N    ??HAL_USART_Transmit_IT_2
   1132              {
   1133                return HAL_ERROR;
   \                     ??HAL_USART_Transmit_IT_1: (+1)
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xE052             B.N      ??HAL_USART_Transmit_IT_3
   1134              }
   1135          
   1136              /* Process Locked */
   1137              __HAL_LOCK(husart);
   \                     ??HAL_USART_Transmit_IT_2: (+1)
   \       0x1A   0xF890 0x3058      LDRB     R3,[R0, #+88]
   \       0x1E   0x2B01             CMP      R3,#+1
   \       0x20   0xD101             BNE.N    ??HAL_USART_Transmit_IT_4
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0xE04C             B.N      ??HAL_USART_Transmit_IT_3
   \                     ??HAL_USART_Transmit_IT_4: (+1)
   \       0x26   0x2301             MOVS     R3,#+1
   \       0x28   0xF880 0x3058      STRB     R3,[R0, #+88]
   1138          
   1139              /* Disable the USART DMA Tx request if enabled */
   1140              if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
   \       0x2C   0x6803             LDR      R3,[R0, #+0]
   \       0x2E   0x689B             LDR      R3,[R3, #+8]
   \       0x30   0x061B             LSLS     R3,R3,#+24
   \       0x32   0xD505             BPL.N    ??HAL_USART_Transmit_IT_5
   1141              {
   1142                CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
   \       0x34   0x6803             LDR      R3,[R0, #+0]
   \       0x36   0x689B             LDR      R3,[R3, #+8]
   \       0x38   0xF033 0x0380      BICS     R3,R3,#0x80
   \       0x3C   0x6804             LDR      R4,[R0, #+0]
   \       0x3E   0x60A3             STR      R3,[R4, #+8]
   1143              }
   1144          
   1145              husart->pTxBuffPtr  = pTxData;
   \                     ??HAL_USART_Transmit_IT_5: (+1)
   \       0x40   0x6281             STR      R1,[R0, #+40]
   1146              husart->TxXferSize  = Size;
   \       0x42   0x8582             STRH     R2,[R0, #+44]
   1147              husart->TxXferCount = Size;
   \       0x44   0x85C2             STRH     R2,[R0, #+46]
   1148              husart->TxISR       = NULL;
   \       0x46   0x2100             MOVS     R1,#+0
   \       0x48   0x64C1             STR      R1,[R0, #+76]
   1149          
   1150              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0x65C1             STR      R1,[R0, #+92]
   1151              husart->State     = HAL_USART_STATE_BUSY_TX;
   \       0x4E   0x2112             MOVS     R1,#+18
   \       0x50   0xF880 0x1059      STRB     R1,[R0, #+89]
   1152          
   1153              /* The USART Error Interrupts: (Frame error, noise error, overrun error)
   1154              are not managed by the USART Transmit Process to avoid the overrun interrupt
   1155              when the usart mode is configured for transmit and receive "USART_MODE_TX_RX"
   1156              to benefit for the frame error and noise interrupts the usart mode should be
   1157              configured only for transmit "USART_MODE_TX" */
   1158          
   1159              /* Configure Tx interrupt processing */
   1160              if (husart->FifoMode == USART_FIFOMODE_ENABLE)
   \       0x54   0x6C41             LDR      R1,[R0, #+68]
   \       0x56   0xF1B1 0x5F00      CMP      R1,#+536870912
   \       0x5A   0xD117             BNE.N    ??HAL_USART_Transmit_IT_6
   1161              {
   1162                /* Set the Tx ISR function pointer according to the data word length */
   1163                if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
   \       0x5C   0x6881             LDR      R1,[R0, #+8]
   \       0x5E   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0x62   0xD106             BNE.N    ??HAL_USART_Transmit_IT_7
   \       0x64   0x6901             LDR      R1,[R0, #+16]
   \       0x66   0x2900             CMP      R1,#+0
   \       0x68   0xD103             BNE.N    ??HAL_USART_Transmit_IT_7
   1164                {
   1165                  husart->TxISR = USART_TxISR_16BIT_FIFOEN;
   \       0x6A   0x.... 0x....      LDR.W    R1,??DataTable5
   \       0x6E   0x64C1             STR      R1,[R0, #+76]
   \       0x70   0xE002             B.N      ??HAL_USART_Transmit_IT_8
   1166                }
   1167                else
   1168                {
   1169                  husart->TxISR = USART_TxISR_8BIT_FIFOEN;
   \                     ??HAL_USART_Transmit_IT_7: (+1)
   \       0x72   0x.... 0x....      LDR.W    R1,??DataTable5_1
   \       0x76   0x64C1             STR      R1,[R0, #+76]
   1170                }
   1171          
   1172                /* Process Unlocked */
   1173                __HAL_UNLOCK(husart);
   \                     ??HAL_USART_Transmit_IT_8: (+1)
   \       0x78   0x2100             MOVS     R1,#+0
   \       0x7A   0xF880 0x1058      STRB     R1,[R0, #+88]
   1174          
   1175                /* Enable the TX FIFO threshold interrupt */
   1176                __HAL_USART_ENABLE_IT(husart, USART_IT_TXFT);
   \       0x7E   0x6801             LDR      R1,[R0, #+0]
   \       0x80   0x6889             LDR      R1,[R1, #+8]
   \       0x82   0xF451 0x0100      ORRS     R1,R1,#0x800000
   \       0x86   0x6800             LDR      R0,[R0, #+0]
   \       0x88   0x6081             STR      R1,[R0, #+8]
   \       0x8A   0xE016             B.N      ??HAL_USART_Transmit_IT_9
   1177              }
   1178              else
   1179              {
   1180                /* Set the Tx ISR function pointer according to the data word length */
   1181                if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
   \                     ??HAL_USART_Transmit_IT_6: (+1)
   \       0x8C   0x6881             LDR      R1,[R0, #+8]
   \       0x8E   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0x92   0xD106             BNE.N    ??HAL_USART_Transmit_IT_10
   \       0x94   0x6901             LDR      R1,[R0, #+16]
   \       0x96   0x2900             CMP      R1,#+0
   \       0x98   0xD103             BNE.N    ??HAL_USART_Transmit_IT_10
   1182                {
   1183                  husart->TxISR = USART_TxISR_16BIT;
   \       0x9A   0x.... 0x....      LDR.W    R1,??DataTable5_2
   \       0x9E   0x64C1             STR      R1,[R0, #+76]
   \       0xA0   0xE002             B.N      ??HAL_USART_Transmit_IT_11
   1184                }
   1185                else
   1186                {
   1187                  husart->TxISR = USART_TxISR_8BIT;
   \                     ??HAL_USART_Transmit_IT_10: (+1)
   \       0xA2   0x.... 0x....      LDR.W    R1,??DataTable5_3
   \       0xA6   0x64C1             STR      R1,[R0, #+76]
   1188                }
   1189          
   1190                /* Process Unlocked */
   1191                __HAL_UNLOCK(husart);
   \                     ??HAL_USART_Transmit_IT_11: (+1)
   \       0xA8   0x2100             MOVS     R1,#+0
   \       0xAA   0xF880 0x1058      STRB     R1,[R0, #+88]
   1192          
   1193                /* Enable the USART Transmit Data Register Empty Interrupt */
   1194                __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
   \       0xAE   0x6801             LDR      R1,[R0, #+0]
   \       0xB0   0x6809             LDR      R1,[R1, #+0]
   \       0xB2   0xF051 0x0180      ORRS     R1,R1,#0x80
   \       0xB6   0x6800             LDR      R0,[R0, #+0]
   \       0xB8   0x6001             STR      R1,[R0, #+0]
   1195              }
   1196          
   1197              return HAL_OK;
   \                     ??HAL_USART_Transmit_IT_9: (+1)
   \       0xBA   0x2000             MOVS     R0,#+0
   \       0xBC   0xE000             B.N      ??HAL_USART_Transmit_IT_3
   1198            }
   1199            else
   1200            {
   1201              return HAL_BUSY;
   \                     ??HAL_USART_Transmit_IT_0: (+1)
   \       0xBE   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_Transmit_IT_3: (+1)
   \       0xC0   0xBC10             POP      {R4}
   \       0xC2   0x4770             BX       LR
   1202            }
   1203          }
   1204          
   1205          /**
   1206            * @brief Receive an amount of data in interrupt mode.
   1207            * @note   To receive synchronous data, dummy data are simultaneously transmitted.
   1208            * @note   When USART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1209            *         the received data is handled as a set of u16. In this case, Size must indicate the number
   1210            *         of u16 available through pRxData.
   1211            * @param  husart USART handle.
   1212            * @param  pRxData pointer to data buffer (u8 or u16 data elements).
   1213            * @param  Size amount of data elements (u8 or u16) to be received.
   1214            * @retval HAL status
   1215            */

   \                                 In section .text, align 2, keep-with-next
   1216          HAL_StatusTypeDef HAL_USART_Receive_IT(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
   1217          {
   \                     HAL_USART_Receive_IT: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1218            uint16_t nb_dummy_data;
   1219          
   1220            if (husart->State == HAL_USART_STATE_READY)
   \        0x2   0xF890 0x3059      LDRB     R3,[R0, #+89]
   \        0x6   0x2B01             CMP      R3,#+1
   \        0x8   0xF040 0x80B9      BNE.W    ??HAL_USART_Receive_IT_0
   1221            {
   1222              if ((pRxData == NULL) || (Size == 0U))
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD003             BEQ.N    ??HAL_USART_Receive_IT_1
   \       0x10   0x0013             MOVS     R3,R2
   \       0x12   0xB29B             UXTH     R3,R3
   \       0x14   0x2B00             CMP      R3,#+0
   \       0x16   0xD101             BNE.N    ??HAL_USART_Receive_IT_2
   1223              {
   1224                return HAL_ERROR;
   \                     ??HAL_USART_Receive_IT_1: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE0B1             B.N      ??HAL_USART_Receive_IT_3
   1225              }
   1226          
   1227              /* Process Locked */
   1228              __HAL_LOCK(husart);
   \                     ??HAL_USART_Receive_IT_2: (+1)
   \       0x1C   0xF890 0x3058      LDRB     R3,[R0, #+88]
   \       0x20   0x2B01             CMP      R3,#+1
   \       0x22   0xD101             BNE.N    ??HAL_USART_Receive_IT_4
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0xE0AB             B.N      ??HAL_USART_Receive_IT_3
   \                     ??HAL_USART_Receive_IT_4: (+1)
   \       0x28   0x2301             MOVS     R3,#+1
   \       0x2A   0xF880 0x3058      STRB     R3,[R0, #+88]
   1229          
   1230              /* Disable the USART DMA Rx request if enabled */
   1231              if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
   \       0x2E   0x6803             LDR      R3,[R0, #+0]
   \       0x30   0x689B             LDR      R3,[R3, #+8]
   \       0x32   0x065B             LSLS     R3,R3,#+25
   \       0x34   0xD505             BPL.N    ??HAL_USART_Receive_IT_5
   1232              {
   1233                CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
   \       0x36   0x6803             LDR      R3,[R0, #+0]
   \       0x38   0x689B             LDR      R3,[R3, #+8]
   \       0x3A   0xF033 0x0340      BICS     R3,R3,#0x40
   \       0x3E   0x6804             LDR      R4,[R0, #+0]
   \       0x40   0x60A3             STR      R3,[R4, #+8]
   1234              }
   1235          
   1236              husart->pRxBuffPtr  = pRxData;
   \                     ??HAL_USART_Receive_IT_5: (+1)
   \       0x42   0x6301             STR      R1,[R0, #+48]
   1237              husart->RxXferSize  = Size;
   \       0x44   0x8682             STRH     R2,[R0, #+52]
   1238              husart->RxXferCount = Size;
   \       0x46   0x86C2             STRH     R2,[R0, #+54]
   1239              husart->RxISR       = NULL;
   \       0x48   0x2100             MOVS     R1,#+0
   \       0x4A   0x6481             STR      R1,[R0, #+72]
   1240          
   1241              USART_MASK_COMPUTATION(husart);
   \       0x4C   0x6881             LDR      R1,[R0, #+8]
   \       0x4E   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0x52   0xD109             BNE.N    ??HAL_USART_Receive_IT_6
   \       0x54   0x6901             LDR      R1,[R0, #+16]
   \       0x56   0x2900             CMP      R1,#+0
   \       0x58   0xD103             BNE.N    ??HAL_USART_Receive_IT_7
   \       0x5A   0xF240 0x11FF      MOVW     R1,#+511
   \       0x5E   0x8701             STRH     R1,[R0, #+56]
   \       0x60   0xE01D             B.N      ??HAL_USART_Receive_IT_8
   \                     ??HAL_USART_Receive_IT_7: (+1)
   \       0x62   0x21FF             MOVS     R1,#+255
   \       0x64   0x8701             STRH     R1,[R0, #+56]
   \       0x66   0xE01A             B.N      ??HAL_USART_Receive_IT_8
   \                     ??HAL_USART_Receive_IT_6: (+1)
   \       0x68   0x6881             LDR      R1,[R0, #+8]
   \       0x6A   0x2900             CMP      R1,#+0
   \       0x6C   0xD108             BNE.N    ??HAL_USART_Receive_IT_9
   \       0x6E   0x6901             LDR      R1,[R0, #+16]
   \       0x70   0x2900             CMP      R1,#+0
   \       0x72   0xD102             BNE.N    ??HAL_USART_Receive_IT_10
   \       0x74   0x21FF             MOVS     R1,#+255
   \       0x76   0x8701             STRH     R1,[R0, #+56]
   \       0x78   0xE011             B.N      ??HAL_USART_Receive_IT_8
   \                     ??HAL_USART_Receive_IT_10: (+1)
   \       0x7A   0x217F             MOVS     R1,#+127
   \       0x7C   0x8701             STRH     R1,[R0, #+56]
   \       0x7E   0xE00E             B.N      ??HAL_USART_Receive_IT_8
   \                     ??HAL_USART_Receive_IT_9: (+1)
   \       0x80   0x6881             LDR      R1,[R0, #+8]
   \       0x82   0xF1B1 0x5F80      CMP      R1,#+268435456
   \       0x86   0xD108             BNE.N    ??HAL_USART_Receive_IT_11
   \       0x88   0x6901             LDR      R1,[R0, #+16]
   \       0x8A   0x2900             CMP      R1,#+0
   \       0x8C   0xD102             BNE.N    ??HAL_USART_Receive_IT_12
   \       0x8E   0x217F             MOVS     R1,#+127
   \       0x90   0x8701             STRH     R1,[R0, #+56]
   \       0x92   0xE004             B.N      ??HAL_USART_Receive_IT_8
   \                     ??HAL_USART_Receive_IT_12: (+1)
   \       0x94   0x213F             MOVS     R1,#+63
   \       0x96   0x8701             STRH     R1,[R0, #+56]
   \       0x98   0xE001             B.N      ??HAL_USART_Receive_IT_8
   \                     ??HAL_USART_Receive_IT_11: (+1)
   \       0x9A   0x2100             MOVS     R1,#+0
   \       0x9C   0x8701             STRH     R1,[R0, #+56]
   1242          
   1243              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \                     ??HAL_USART_Receive_IT_8: (+1)
   \       0x9E   0x2100             MOVS     R1,#+0
   \       0xA0   0x65C1             STR      R1,[R0, #+92]
   1244              husart->State = HAL_USART_STATE_BUSY_RX;
   \       0xA2   0x2122             MOVS     R1,#+34
   \       0xA4   0xF880 0x1059      STRB     R1,[R0, #+89]
   1245          
   1246              /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
   1247              SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
   \       0xA8   0x6801             LDR      R1,[R0, #+0]
   \       0xAA   0x6889             LDR      R1,[R1, #+8]
   \       0xAC   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0xB0   0x6803             LDR      R3,[R0, #+0]
   \       0xB2   0x6099             STR      R1,[R3, #+8]
   1248          
   1249              /* Configure Rx interrupt processing */
   1250              if ((husart->FifoMode == USART_FIFOMODE_ENABLE) && (Size >= husart->NbRxDataToProcess))
   \       0xB4   0x6C41             LDR      R1,[R0, #+68]
   \       0xB6   0xF1B1 0x5F00      CMP      R1,#+536870912
   \       0xBA   0xD125             BNE.N    ??HAL_USART_Receive_IT_13
   \       0xBC   0x0011             MOVS     R1,R2
   \       0xBE   0x8F43             LDRH     R3,[R0, #+58]
   \       0xC0   0xB289             UXTH     R1,R1
   \       0xC2   0x4299             CMP      R1,R3
   \       0xC4   0xD320             BCC.N    ??HAL_USART_Receive_IT_13
   1251              {
   1252                /* Set the Rx ISR function pointer according to the data word length */
   1253                if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
   \       0xC6   0x6881             LDR      R1,[R0, #+8]
   \       0xC8   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0xCC   0xD106             BNE.N    ??HAL_USART_Receive_IT_14
   \       0xCE   0x6901             LDR      R1,[R0, #+16]
   \       0xD0   0x2900             CMP      R1,#+0
   \       0xD2   0xD103             BNE.N    ??HAL_USART_Receive_IT_14
   1254                {
   1255                  husart->RxISR = USART_RxISR_16BIT_FIFOEN;
   \       0xD4   0x.... 0x....      LDR.W    R1,??DataTable5_4
   \       0xD8   0x6481             STR      R1,[R0, #+72]
   \       0xDA   0xE002             B.N      ??HAL_USART_Receive_IT_15
   1256                }
   1257                else
   1258                {
   1259                  husart->RxISR = USART_RxISR_8BIT_FIFOEN;
   \                     ??HAL_USART_Receive_IT_14: (+1)
   \       0xDC   0x.... 0x....      LDR.W    R1,??DataTable5_5
   \       0xE0   0x6481             STR      R1,[R0, #+72]
   1260                }
   1261          
   1262                /* Process Unlocked */
   1263                __HAL_UNLOCK(husart);
   \                     ??HAL_USART_Receive_IT_15: (+1)
   \       0xE2   0x2100             MOVS     R1,#+0
   \       0xE4   0xF880 0x1058      STRB     R1,[R0, #+88]
   1264          
   1265                /* Enable the USART Parity Error interrupt and RX FIFO Threshold interrupt */
   1266                if (husart->Init.Parity != USART_PARITY_NONE)
   \       0xE8   0x6901             LDR      R1,[R0, #+16]
   \       0xEA   0x2900             CMP      R1,#+0
   \       0xEC   0xD005             BEQ.N    ??HAL_USART_Receive_IT_16
   1267                {
   1268                  SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
   \       0xEE   0x6801             LDR      R1,[R0, #+0]
   \       0xF0   0x6809             LDR      R1,[R1, #+0]
   \       0xF2   0xF451 0x7180      ORRS     R1,R1,#0x100
   \       0xF6   0x6803             LDR      R3,[R0, #+0]
   \       0xF8   0x6019             STR      R1,[R3, #+0]
   1269                }
   1270                SET_BIT(husart->Instance->CR3, USART_CR3_RXFTIE);
   \                     ??HAL_USART_Receive_IT_16: (+1)
   \       0xFA   0x6801             LDR      R1,[R0, #+0]
   \       0xFC   0x6889             LDR      R1,[R1, #+8]
   \       0xFE   0xF051 0x5180      ORRS     R1,R1,#0x10000000
   \      0x102   0x6803             LDR      R3,[R0, #+0]
   \      0x104   0x6099             STR      R1,[R3, #+8]
   \      0x106   0xE020             B.N      ??HAL_USART_Receive_IT_17
   1271              }
   1272              else
   1273              {
   1274                /* Set the Rx ISR function pointer according to the data word length */
   1275                if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
   \                     ??HAL_USART_Receive_IT_13: (+1)
   \      0x108   0x6881             LDR      R1,[R0, #+8]
   \      0x10A   0xF5B1 0x5F80      CMP      R1,#+4096
   \      0x10E   0xD106             BNE.N    ??HAL_USART_Receive_IT_18
   \      0x110   0x6901             LDR      R1,[R0, #+16]
   \      0x112   0x2900             CMP      R1,#+0
   \      0x114   0xD103             BNE.N    ??HAL_USART_Receive_IT_18
   1276                {
   1277                  husart->RxISR = USART_RxISR_16BIT;
   \      0x116   0x.... 0x....      LDR.W    R1,??DataTable5_6
   \      0x11A   0x6481             STR      R1,[R0, #+72]
   \      0x11C   0xE002             B.N      ??HAL_USART_Receive_IT_19
   1278                }
   1279                else
   1280                {
   1281                  husart->RxISR = USART_RxISR_8BIT;
   \                     ??HAL_USART_Receive_IT_18: (+1)
   \      0x11E   0x.... 0x....      LDR.W    R1,??DataTable6
   \      0x122   0x6481             STR      R1,[R0, #+72]
   1282                }
   1283          
   1284                /* Process Unlocked */
   1285                __HAL_UNLOCK(husart);
   \                     ??HAL_USART_Receive_IT_19: (+1)
   \      0x124   0x2100             MOVS     R1,#+0
   \      0x126   0xF880 0x1058      STRB     R1,[R0, #+88]
   1286          
   1287                /* Enable the USART Parity Error and Data Register not empty Interrupts */
   1288                if (husart->Init.Parity != USART_PARITY_NONE)
   \      0x12A   0x6901             LDR      R1,[R0, #+16]
   \      0x12C   0x2900             CMP      R1,#+0
   \      0x12E   0xD006             BEQ.N    ??HAL_USART_Receive_IT_20
   1289                {
   1290                  SET_BIT(husart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
   \      0x130   0x6801             LDR      R1,[R0, #+0]
   \      0x132   0x6809             LDR      R1,[R1, #+0]
   \      0x134   0xF451 0x7190      ORRS     R1,R1,#0x120
   \      0x138   0x6803             LDR      R3,[R0, #+0]
   \      0x13A   0x6019             STR      R1,[R3, #+0]
   \      0x13C   0xE005             B.N      ??HAL_USART_Receive_IT_17
   1291                }
   1292                else
   1293                {
   1294                  SET_BIT(husart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
   \                     ??HAL_USART_Receive_IT_20: (+1)
   \      0x13E   0x6801             LDR      R1,[R0, #+0]
   \      0x140   0x6809             LDR      R1,[R1, #+0]
   \      0x142   0xF051 0x0120      ORRS     R1,R1,#0x20
   \      0x146   0x6803             LDR      R3,[R0, #+0]
   \      0x148   0x6019             STR      R1,[R3, #+0]
   1295                }
   1296              }
   1297          
   1298              if (husart->SlaveMode == USART_SLAVEMODE_DISABLE)
   \                     ??HAL_USART_Receive_IT_17: (+1)
   \      0x14A   0x6C01             LDR      R1,[R0, #+64]
   \      0x14C   0x2900             CMP      R1,#+0
   \      0x14E   0xD114             BNE.N    ??HAL_USART_Receive_IT_21
   1299              {
   1300                /* Send dummy data in order to generate the clock for the Slave to send the next data.
   1301                   When FIFO mode is disabled only one data must be transferred.
   1302                   When FIFO mode is enabled data must be transmitted until the RX FIFO reaches its threshold.
   1303                */
   1304                if ((husart->FifoMode == USART_FIFOMODE_ENABLE) && (Size >= husart->NbRxDataToProcess))
   \      0x150   0x6C41             LDR      R1,[R0, #+68]
   \      0x152   0xF1B1 0x5F00      CMP      R1,#+536870912
   \      0x156   0xD10D             BNE.N    ??HAL_USART_Receive_IT_22
   \      0x158   0x8F41             LDRH     R1,[R0, #+58]
   \      0x15A   0xB292             UXTH     R2,R2
   \      0x15C   0x428A             CMP      R2,R1
   \      0x15E   0xD309             BCC.N    ??HAL_USART_Receive_IT_22
   1305                {
   1306                  for (nb_dummy_data = husart->NbRxDataToProcess ; nb_dummy_data > 0U ; nb_dummy_data--)
   \      0x160   0x8F41             LDRH     R1,[R0, #+58]
   \                     ??HAL_USART_Receive_IT_23: (+1)
   \      0x162   0x000A             MOVS     R2,R1
   \      0x164   0xB292             UXTH     R2,R2
   \      0x166   0x2A00             CMP      R2,#+0
   \      0x168   0xD007             BEQ.N    ??HAL_USART_Receive_IT_21
   1307                  {
   1308                    husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
   \      0x16A   0x22FF             MOVS     R2,#+255
   \      0x16C   0x6803             LDR      R3,[R0, #+0]
   \      0x16E   0x629A             STR      R2,[R3, #+40]
   1309                  }
   \      0x170   0x1E49             SUBS     R1,R1,#+1
   \      0x172   0xE7F6             B.N      ??HAL_USART_Receive_IT_23
   1310                }
   1311                else
   1312                {
   1313                  husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
   \                     ??HAL_USART_Receive_IT_22: (+1)
   \      0x174   0x21FF             MOVS     R1,#+255
   \      0x176   0x6800             LDR      R0,[R0, #+0]
   \      0x178   0x6281             STR      R1,[R0, #+40]
   1314                }
   1315              }
   1316          
   1317              return HAL_OK;
   \                     ??HAL_USART_Receive_IT_21: (+1)
   \      0x17A   0x2000             MOVS     R0,#+0
   \      0x17C   0xE000             B.N      ??HAL_USART_Receive_IT_3
   1318            }
   1319            else
   1320            {
   1321              return HAL_BUSY;
   \                     ??HAL_USART_Receive_IT_0: (+1)
   \      0x17E   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_Receive_IT_3: (+1)
   \      0x180   0xBC10             POP      {R4}
   \      0x182   0x4770             BX       LR
   1322            }
   1323          }
   1324          
   1325          /**
   1326            * @brief Full-Duplex Send and Receive an amount of data in interrupt mode.
   1327            * @note   When USART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1328            *         the sent data and the received data are handled as sets of u16. In this case, Size must indicate the number
   1329            *         of u16 available through pTxData and through pRxData.
   1330            * @param  husart USART handle.
   1331            * @param  pTxData pointer to TX data buffer (u8 or u16 data elements).
   1332            * @param  pRxData pointer to RX data buffer (u8 or u16 data elements).
   1333            * @param  Size amount of data elements (u8 or u16) to be sent (same amount to be received).
   1334            * @retval HAL status
   1335            */

   \                                 In section .text, align 2, keep-with-next
   1336          HAL_StatusTypeDef HAL_USART_TransmitReceive_IT(USART_HandleTypeDef *husart, const uint8_t *pTxData, uint8_t *pRxData,
   1337                                                         uint16_t Size)
   1338          {
   \                     HAL_USART_TransmitReceive_IT: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   1339          
   1340            if (husart->State == HAL_USART_STATE_READY)
   \        0x2   0xF890 0x4059      LDRB     R4,[R0, #+89]
   \        0x6   0x2C01             CMP      R4,#+1
   \        0x8   0xF040 0x80C5      BNE.W    ??HAL_USART_TransmitReceive_IT_0
   1341            {
   1342              if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD005             BEQ.N    ??HAL_USART_TransmitReceive_IT_1
   \       0x10   0x2A00             CMP      R2,#+0
   \       0x12   0xD003             BEQ.N    ??HAL_USART_TransmitReceive_IT_1
   \       0x14   0x001C             MOVS     R4,R3
   \       0x16   0xB2A4             UXTH     R4,R4
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD101             BNE.N    ??HAL_USART_TransmitReceive_IT_2
   1343              {
   1344                return HAL_ERROR;
   \                     ??HAL_USART_TransmitReceive_IT_1: (+1)
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE0BB             B.N      ??HAL_USART_TransmitReceive_IT_3
   1345              }
   1346          
   1347              /* Process Locked */
   1348              __HAL_LOCK(husart);
   \                     ??HAL_USART_TransmitReceive_IT_2: (+1)
   \       0x20   0xF890 0x4058      LDRB     R4,[R0, #+88]
   \       0x24   0x2C01             CMP      R4,#+1
   \       0x26   0xD101             BNE.N    ??HAL_USART_TransmitReceive_IT_4
   \       0x28   0x2002             MOVS     R0,#+2
   \       0x2A   0xE0B5             B.N      ??HAL_USART_TransmitReceive_IT_3
   \                     ??HAL_USART_TransmitReceive_IT_4: (+1)
   \       0x2C   0x2401             MOVS     R4,#+1
   \       0x2E   0xF880 0x4058      STRB     R4,[R0, #+88]
   1349          
   1350              /* Disable the USART DMA Tx request if enabled */
   1351              if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
   \       0x32   0x6804             LDR      R4,[R0, #+0]
   \       0x34   0x68A4             LDR      R4,[R4, #+8]
   \       0x36   0x0624             LSLS     R4,R4,#+24
   \       0x38   0xD505             BPL.N    ??HAL_USART_TransmitReceive_IT_5
   1352              {
   1353                CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
   \       0x3A   0x6804             LDR      R4,[R0, #+0]
   \       0x3C   0x68A4             LDR      R4,[R4, #+8]
   \       0x3E   0xF034 0x0480      BICS     R4,R4,#0x80
   \       0x42   0x6805             LDR      R5,[R0, #+0]
   \       0x44   0x60AC             STR      R4,[R5, #+8]
   1354              }
   1355          
   1356              /* Disable the USART DMA Rx request if enabled */
   1357              if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
   \                     ??HAL_USART_TransmitReceive_IT_5: (+1)
   \       0x46   0x6804             LDR      R4,[R0, #+0]
   \       0x48   0x68A4             LDR      R4,[R4, #+8]
   \       0x4A   0x0664             LSLS     R4,R4,#+25
   \       0x4C   0xD505             BPL.N    ??HAL_USART_TransmitReceive_IT_6
   1358              {
   1359                CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
   \       0x4E   0x6804             LDR      R4,[R0, #+0]
   \       0x50   0x68A4             LDR      R4,[R4, #+8]
   \       0x52   0xF034 0x0440      BICS     R4,R4,#0x40
   \       0x56   0x6805             LDR      R5,[R0, #+0]
   \       0x58   0x60AC             STR      R4,[R5, #+8]
   1360              }
   1361          
   1362              husart->pRxBuffPtr = pRxData;
   \                     ??HAL_USART_TransmitReceive_IT_6: (+1)
   \       0x5A   0x6302             STR      R2,[R0, #+48]
   1363              husart->RxXferSize = Size;
   \       0x5C   0x8683             STRH     R3,[R0, #+52]
   1364              husart->RxXferCount = Size;
   \       0x5E   0x86C3             STRH     R3,[R0, #+54]
   1365              husart->pTxBuffPtr = pTxData;
   \       0x60   0x6281             STR      R1,[R0, #+40]
   1366              husart->TxXferSize = Size;
   \       0x62   0x8583             STRH     R3,[R0, #+44]
   1367              husart->TxXferCount = Size;
   \       0x64   0x85C3             STRH     R3,[R0, #+46]
   1368          
   1369              /* Computation of USART mask to apply to RDR register */
   1370              USART_MASK_COMPUTATION(husart);
   \       0x66   0x6881             LDR      R1,[R0, #+8]
   \       0x68   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0x6C   0xD109             BNE.N    ??HAL_USART_TransmitReceive_IT_7
   \       0x6E   0x6901             LDR      R1,[R0, #+16]
   \       0x70   0x2900             CMP      R1,#+0
   \       0x72   0xD103             BNE.N    ??HAL_USART_TransmitReceive_IT_8
   \       0x74   0xF240 0x11FF      MOVW     R1,#+511
   \       0x78   0x8701             STRH     R1,[R0, #+56]
   \       0x7A   0xE01D             B.N      ??HAL_USART_TransmitReceive_IT_9
   \                     ??HAL_USART_TransmitReceive_IT_8: (+1)
   \       0x7C   0x21FF             MOVS     R1,#+255
   \       0x7E   0x8701             STRH     R1,[R0, #+56]
   \       0x80   0xE01A             B.N      ??HAL_USART_TransmitReceive_IT_9
   \                     ??HAL_USART_TransmitReceive_IT_7: (+1)
   \       0x82   0x6881             LDR      R1,[R0, #+8]
   \       0x84   0x2900             CMP      R1,#+0
   \       0x86   0xD108             BNE.N    ??HAL_USART_TransmitReceive_IT_10
   \       0x88   0x6901             LDR      R1,[R0, #+16]
   \       0x8A   0x2900             CMP      R1,#+0
   \       0x8C   0xD102             BNE.N    ??HAL_USART_TransmitReceive_IT_11
   \       0x8E   0x21FF             MOVS     R1,#+255
   \       0x90   0x8701             STRH     R1,[R0, #+56]
   \       0x92   0xE011             B.N      ??HAL_USART_TransmitReceive_IT_9
   \                     ??HAL_USART_TransmitReceive_IT_11: (+1)
   \       0x94   0x217F             MOVS     R1,#+127
   \       0x96   0x8701             STRH     R1,[R0, #+56]
   \       0x98   0xE00E             B.N      ??HAL_USART_TransmitReceive_IT_9
   \                     ??HAL_USART_TransmitReceive_IT_10: (+1)
   \       0x9A   0x6881             LDR      R1,[R0, #+8]
   \       0x9C   0xF1B1 0x5F80      CMP      R1,#+268435456
   \       0xA0   0xD108             BNE.N    ??HAL_USART_TransmitReceive_IT_12
   \       0xA2   0x6901             LDR      R1,[R0, #+16]
   \       0xA4   0x2900             CMP      R1,#+0
   \       0xA6   0xD102             BNE.N    ??HAL_USART_TransmitReceive_IT_13
   \       0xA8   0x217F             MOVS     R1,#+127
   \       0xAA   0x8701             STRH     R1,[R0, #+56]
   \       0xAC   0xE004             B.N      ??HAL_USART_TransmitReceive_IT_9
   \                     ??HAL_USART_TransmitReceive_IT_13: (+1)
   \       0xAE   0x213F             MOVS     R1,#+63
   \       0xB0   0x8701             STRH     R1,[R0, #+56]
   \       0xB2   0xE001             B.N      ??HAL_USART_TransmitReceive_IT_9
   \                     ??HAL_USART_TransmitReceive_IT_12: (+1)
   \       0xB4   0x2100             MOVS     R1,#+0
   \       0xB6   0x8701             STRH     R1,[R0, #+56]
   1371          
   1372              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \                     ??HAL_USART_TransmitReceive_IT_9: (+1)
   \       0xB8   0x2100             MOVS     R1,#+0
   \       0xBA   0x65C1             STR      R1,[R0, #+92]
   1373              husart->State = HAL_USART_STATE_BUSY_TX_RX;
   \       0xBC   0x2132             MOVS     R1,#+50
   \       0xBE   0xF880 0x1059      STRB     R1,[R0, #+89]
   1374          
   1375              /* Configure TxRx interrupt processing */
   1376              if ((husart->FifoMode == USART_FIFOMODE_ENABLE) && (Size >= husart->NbRxDataToProcess))
   \       0xC2   0x6C41             LDR      R1,[R0, #+68]
   \       0xC4   0xF1B1 0x5F00      CMP      R1,#+536870912
   \       0xC8   0xD130             BNE.N    ??HAL_USART_TransmitReceive_IT_14
   \       0xCA   0x8F41             LDRH     R1,[R0, #+58]
   \       0xCC   0xB29B             UXTH     R3,R3
   \       0xCE   0x428B             CMP      R3,R1
   \       0xD0   0xD32C             BCC.N    ??HAL_USART_TransmitReceive_IT_14
   1377              {
   1378                /* Set the Rx ISR function pointer according to the data word length */
   1379                if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
   \       0xD2   0x6881             LDR      R1,[R0, #+8]
   \       0xD4   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0xD8   0xD109             BNE.N    ??HAL_USART_TransmitReceive_IT_15
   \       0xDA   0x6901             LDR      R1,[R0, #+16]
   \       0xDC   0x2900             CMP      R1,#+0
   \       0xDE   0xD106             BNE.N    ??HAL_USART_TransmitReceive_IT_15
   1380                {
   1381                  husart->TxISR = USART_TxISR_16BIT_FIFOEN;
   \       0xE0   0x.... 0x....      LDR.W    R1,??DataTable5
   \       0xE4   0x64C1             STR      R1,[R0, #+76]
   1382                  husart->RxISR = USART_RxISR_16BIT_FIFOEN;
   \       0xE6   0x.... 0x....      LDR.W    R1,??DataTable5_4
   \       0xEA   0x6481             STR      R1,[R0, #+72]
   \       0xEC   0xE005             B.N      ??HAL_USART_TransmitReceive_IT_16
   1383                }
   1384                else
   1385                {
   1386                  husart->TxISR = USART_TxISR_8BIT_FIFOEN;
   \                     ??HAL_USART_TransmitReceive_IT_15: (+1)
   \       0xEE   0x.... 0x....      LDR.W    R1,??DataTable5_1
   \       0xF2   0x64C1             STR      R1,[R0, #+76]
   1387                  husart->RxISR = USART_RxISR_8BIT_FIFOEN;
   \       0xF4   0x.... 0x....      LDR.W    R1,??DataTable5_5
   \       0xF8   0x6481             STR      R1,[R0, #+72]
   1388                }
   1389          
   1390                /* Process Locked */
   1391                __HAL_UNLOCK(husart);
   \                     ??HAL_USART_TransmitReceive_IT_16: (+1)
   \       0xFA   0x2100             MOVS     R1,#+0
   \       0xFC   0xF880 0x1058      STRB     R1,[R0, #+88]
   1392          
   1393                /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
   1394                SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
   \      0x100   0x6801             LDR      R1,[R0, #+0]
   \      0x102   0x6889             LDR      R1,[R1, #+8]
   \      0x104   0xF051 0x0101      ORRS     R1,R1,#0x1
   \      0x108   0x6802             LDR      R2,[R0, #+0]
   \      0x10A   0x6091             STR      R1,[R2, #+8]
   1395          
   1396                if (husart->Init.Parity != USART_PARITY_NONE)
   \      0x10C   0x6901             LDR      R1,[R0, #+16]
   \      0x10E   0x2900             CMP      R1,#+0
   \      0x110   0xD005             BEQ.N    ??HAL_USART_TransmitReceive_IT_17
   1397                {
   1398                  /* Enable the USART Parity Error interrupt  */
   1399                  SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
   \      0x112   0x6801             LDR      R1,[R0, #+0]
   \      0x114   0x6809             LDR      R1,[R1, #+0]
   \      0x116   0xF451 0x7180      ORRS     R1,R1,#0x100
   \      0x11A   0x6802             LDR      R2,[R0, #+0]
   \      0x11C   0x6011             STR      R1,[R2, #+0]
   1400                }
   1401          
   1402                /* Enable the TX and  RX FIFO Threshold interrupts */
   1403                SET_BIT(husart->Instance->CR3, (USART_CR3_TXFTIE | USART_CR3_RXFTIE));
   \                     ??HAL_USART_TransmitReceive_IT_17: (+1)
   \      0x11E   0x6801             LDR      R1,[R0, #+0]
   \      0x120   0x6889             LDR      R1,[R1, #+8]
   \      0x122   0xF051 0x5184      ORRS     R1,R1,#0x10800000
   \      0x126   0x6800             LDR      R0,[R0, #+0]
   \      0x128   0x6081             STR      R1,[R0, #+8]
   \      0x12A   0xE032             B.N      ??HAL_USART_TransmitReceive_IT_18
   1404              }
   1405              else
   1406              {
   1407                if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
   \                     ??HAL_USART_TransmitReceive_IT_14: (+1)
   \      0x12C   0x6881             LDR      R1,[R0, #+8]
   \      0x12E   0xF5B1 0x5F80      CMP      R1,#+4096
   \      0x132   0xD109             BNE.N    ??HAL_USART_TransmitReceive_IT_19
   \      0x134   0x6901             LDR      R1,[R0, #+16]
   \      0x136   0x2900             CMP      R1,#+0
   \      0x138   0xD106             BNE.N    ??HAL_USART_TransmitReceive_IT_19
   1408                {
   1409                  husart->TxISR = USART_TxISR_16BIT;
   \      0x13A   0x.... 0x....      LDR.W    R1,??DataTable5_2
   \      0x13E   0x64C1             STR      R1,[R0, #+76]
   1410                  husart->RxISR = USART_RxISR_16BIT;
   \      0x140   0x.... 0x....      LDR.W    R1,??DataTable5_6
   \      0x144   0x6481             STR      R1,[R0, #+72]
   \      0x146   0xE005             B.N      ??HAL_USART_TransmitReceive_IT_20
   1411                }
   1412                else
   1413                {
   1414                  husart->TxISR = USART_TxISR_8BIT;
   \                     ??HAL_USART_TransmitReceive_IT_19: (+1)
   \      0x148   0x.... 0x....      LDR.W    R1,??DataTable5_3
   \      0x14C   0x64C1             STR      R1,[R0, #+76]
   1415                  husart->RxISR = USART_RxISR_8BIT;
   \      0x14E   0x.... 0x....      LDR.W    R1,??DataTable6
   \      0x152   0x6481             STR      R1,[R0, #+72]
   1416                }
   1417          
   1418                /* Process Locked */
   1419                __HAL_UNLOCK(husart);
   \                     ??HAL_USART_TransmitReceive_IT_20: (+1)
   \      0x154   0x2100             MOVS     R1,#+0
   \      0x156   0xF880 0x1058      STRB     R1,[R0, #+88]
   1420          
   1421                /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
   1422                SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
   \      0x15A   0x6801             LDR      R1,[R0, #+0]
   \      0x15C   0x6889             LDR      R1,[R1, #+8]
   \      0x15E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \      0x162   0x6802             LDR      R2,[R0, #+0]
   \      0x164   0x6091             STR      R1,[R2, #+8]
   1423          
   1424                /* Enable the USART Parity Error and USART Data Register not empty Interrupts */
   1425                if (husart->Init.Parity != USART_PARITY_NONE)
   \      0x166   0x6901             LDR      R1,[R0, #+16]
   \      0x168   0x2900             CMP      R1,#+0
   \      0x16A   0xD006             BEQ.N    ??HAL_USART_TransmitReceive_IT_21
   1426                {
   1427                  SET_BIT(husart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
   \      0x16C   0x6801             LDR      R1,[R0, #+0]
   \      0x16E   0x6809             LDR      R1,[R1, #+0]
   \      0x170   0xF451 0x7190      ORRS     R1,R1,#0x120
   \      0x174   0x6802             LDR      R2,[R0, #+0]
   \      0x176   0x6011             STR      R1,[R2, #+0]
   \      0x178   0xE005             B.N      ??HAL_USART_TransmitReceive_IT_22
   1428                }
   1429                else
   1430                {
   1431                  SET_BIT(husart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
   \                     ??HAL_USART_TransmitReceive_IT_21: (+1)
   \      0x17A   0x6801             LDR      R1,[R0, #+0]
   \      0x17C   0x6809             LDR      R1,[R1, #+0]
   \      0x17E   0xF051 0x0120      ORRS     R1,R1,#0x20
   \      0x182   0x6802             LDR      R2,[R0, #+0]
   \      0x184   0x6011             STR      R1,[R2, #+0]
   1432                }
   1433          
   1434                /* Enable the USART Transmit Data Register Empty Interrupt */
   1435                SET_BIT(husart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
   \                     ??HAL_USART_TransmitReceive_IT_22: (+1)
   \      0x186   0x6801             LDR      R1,[R0, #+0]
   \      0x188   0x6809             LDR      R1,[R1, #+0]
   \      0x18A   0xF051 0x0180      ORRS     R1,R1,#0x80
   \      0x18E   0x6800             LDR      R0,[R0, #+0]
   \      0x190   0x6001             STR      R1,[R0, #+0]
   1436              }
   1437          
   1438              return HAL_OK;
   \                     ??HAL_USART_TransmitReceive_IT_18: (+1)
   \      0x192   0x2000             MOVS     R0,#+0
   \      0x194   0xE000             B.N      ??HAL_USART_TransmitReceive_IT_3
   1439            }
   1440            else
   1441            {
   1442              return HAL_BUSY;
   \                     ??HAL_USART_TransmitReceive_IT_0: (+1)
   \      0x196   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_TransmitReceive_IT_3: (+1)
   \      0x198   0xBC30             POP      {R4,R5}
   \      0x19A   0x4770             BX       LR
   1443            }
   1444          }
   1445          
   1446          #if defined(HAL_DMA_MODULE_ENABLED)
   1447          /**
   1448            * @brief Send an amount of data in DMA mode.
   1449            * @note   When USART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1450            *         the sent data is handled as a set of u16. In this case, Size must indicate the number
   1451            *         of u16 provided through pTxData.
   1452            * @param  husart USART handle.
   1453            * @param  pTxData pointer to data buffer (u8 or u16 data elements).
   1454            * @param  Size amount of data elements (u8 or u16) to be sent.
   1455            * @retval HAL status
   1456            */

   \                                 In section .text, align 2, keep-with-next
   1457          HAL_StatusTypeDef HAL_USART_Transmit_DMA(USART_HandleTypeDef *husart, const uint8_t *pTxData, uint16_t Size)
   1458          {
   \                     HAL_USART_Transmit_DMA: (+1)
   \        0x0   0xB513             PUSH     {R0,R1,R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1459            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2000             MOVS     R0,#+0
   1460            const uint32_t *tmp;
   1461            uint16_t nbByte = Size;
   \        0x6   0x0013             MOVS     R3,R2
   1462          
   1463            if (husart->State == HAL_USART_STATE_READY)
   \        0x8   0xF894 0x1059      LDRB     R1,[R4, #+89]
   \        0xC   0x2901             CMP      R1,#+1
   \        0xE   0xD17A             BNE.N    ??HAL_USART_Transmit_DMA_0
   1464            {
   1465              if ((pTxData == NULL) || (Size == 0U))
   \       0x10   0x9901             LDR      R1,[SP, #+4]
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD003             BEQ.N    ??HAL_USART_Transmit_DMA_1
   \       0x16   0x0011             MOVS     R1,R2
   \       0x18   0xB289             UXTH     R1,R1
   \       0x1A   0x2900             CMP      R1,#+0
   \       0x1C   0xD101             BNE.N    ??HAL_USART_Transmit_DMA_2
   1466              {
   1467                return HAL_ERROR;
   \                     ??HAL_USART_Transmit_DMA_1: (+1)
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xE072             B.N      ??HAL_USART_Transmit_DMA_3
   1468              }
   1469          
   1470              /* Process Locked */
   1471              __HAL_LOCK(husart);
   \                     ??HAL_USART_Transmit_DMA_2: (+1)
   \       0x22   0xF894 0x1058      LDRB     R1,[R4, #+88]
   \       0x26   0x2901             CMP      R1,#+1
   \       0x28   0xD101             BNE.N    ??HAL_USART_Transmit_DMA_4
   \       0x2A   0x2002             MOVS     R0,#+2
   \       0x2C   0xE06C             B.N      ??HAL_USART_Transmit_DMA_3
   \                     ??HAL_USART_Transmit_DMA_4: (+1)
   \       0x2E   0x2101             MOVS     R1,#+1
   \       0x30   0xF884 0x1058      STRB     R1,[R4, #+88]
   1472          
   1473              husart->pTxBuffPtr = pTxData;
   \       0x34   0x9901             LDR      R1,[SP, #+4]
   \       0x36   0x62A1             STR      R1,[R4, #+40]
   1474              husart->TxXferSize = Size;
   \       0x38   0x85A2             STRH     R2,[R4, #+44]
   1475              husart->TxXferCount = Size;
   \       0x3A   0x85E2             STRH     R2,[R4, #+46]
   1476          
   1477              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \       0x3C   0x2100             MOVS     R1,#+0
   \       0x3E   0x65E1             STR      R1,[R4, #+92]
   1478              husart->State = HAL_USART_STATE_BUSY_TX;
   \       0x40   0x2112             MOVS     R1,#+18
   \       0x42   0xF884 0x1059      STRB     R1,[R4, #+89]
   1479          
   1480              if (husart->hdmatx != NULL)
   \       0x46   0x6D21             LDR      R1,[R4, #+80]
   \       0x48   0x2900             CMP      R1,#+0
   \       0x4A   0xD041             BEQ.N    ??HAL_USART_Transmit_DMA_5
   1481              {
   1482                /* Set the USART DMA transfer complete callback */
   1483                husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
   \       0x4C   0x.... 0x....      ADR.W    R0,USART_DMATransmitCplt
   \       0x50   0x6D21             LDR      R1,[R4, #+80]
   \       0x52   0x6608             STR      R0,[R1, #+96]
   1484          
   1485                /* Set the USART DMA Half transfer complete callback */
   1486                husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
   \       0x54   0x.... 0x....      ADR.W    R0,USART_DMATxHalfCplt
   \       0x58   0x6D21             LDR      R1,[R4, #+80]
   \       0x5A   0x6648             STR      R0,[R1, #+100]
   1487          
   1488                /* Set the DMA error callback */
   1489                husart->hdmatx->XferErrorCallback = USART_DMAError;
   \       0x5C   0x.... 0x....      ADR.W    R0,USART_DMAError
   \       0x60   0x6D21             LDR      R1,[R4, #+80]
   \       0x62   0x6688             STR      R0,[R1, #+104]
   1490          
   1491                /* In case of 9bits/No Parity transfer, pTxData buffer provided as input parameter
   1492                   should be aligned on a u16 frontier, so nbByte should be equal to Size multiplied by 2 */
   1493                if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
   \       0x64   0x68A0             LDR      R0,[R4, #+8]
   \       0x66   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x6A   0xD104             BNE.N    ??HAL_USART_Transmit_DMA_6
   \       0x6C   0x6920             LDR      R0,[R4, #+16]
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD101             BNE.N    ??HAL_USART_Transmit_DMA_6
   1494                {
   1495                  nbByte = Size * 2U;
   \       0x72   0x0052             LSLS     R2,R2,#+1
   \       0x74   0x0013             MOVS     R3,R2
   1496                }
   1497          
   1498                tmp = (const uint32_t *)&pTxData;
   \                     ??HAL_USART_Transmit_DMA_6: (+1)
   \       0x76   0xA901             ADD      R1,SP,#+4
   1499          
   1500                /* Check linked list mode */
   1501                if ((husart->hdmatx->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
   \       0x78   0x6D20             LDR      R0,[R4, #+80]
   \       0x7A   0xF890 0x0050      LDRB     R0,[R0, #+80]
   \       0x7E   0x0600             LSLS     R0,R0,#+24
   \       0x80   0xD51E             BPL.N    ??HAL_USART_Transmit_DMA_7
   1502                {
   1503                  if ((husart->hdmatx->LinkedListQueue != NULL) && (husart->hdmatx->LinkedListQueue->Head != NULL))
   \       0x82   0x6D20             LDR      R0,[R4, #+80]
   \       0x84   0x6F40             LDR      R0,[R0, #+116]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD018             BEQ.N    ??HAL_USART_Transmit_DMA_8
   \       0x8A   0x6D20             LDR      R0,[R4, #+80]
   \       0x8C   0x6F40             LDR      R0,[R0, #+116]
   \       0x8E   0x6800             LDR      R0,[R0, #+0]
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD013             BEQ.N    ??HAL_USART_Transmit_DMA_8
   1504                  {
   1505                    /* Set DMA data size */
   1506                    husart->hdmatx->LinkedListQueue->Head->LinkRegisters[NODE_CBR1_DEFAULT_OFFSET] = nbByte;
   \       0x94   0xB29B             UXTH     R3,R3
   \       0x96   0x6D20             LDR      R0,[R4, #+80]
   \       0x98   0x6F40             LDR      R0,[R0, #+116]
   \       0x9A   0x6800             LDR      R0,[R0, #+0]
   \       0x9C   0x6083             STR      R3,[R0, #+8]
   1507          
   1508                    /* Set DMA source address */
   1509                    husart->hdmatx->LinkedListQueue->Head->LinkRegisters[NODE_CSAR_DEFAULT_OFFSET] = *(const uint32_t *)tmp;
   \       0x9E   0x6808             LDR      R0,[R1, #+0]
   \       0xA0   0x6D21             LDR      R1,[R4, #+80]
   \       0xA2   0x6F49             LDR      R1,[R1, #+116]
   \       0xA4   0x6809             LDR      R1,[R1, #+0]
   \       0xA6   0x60C8             STR      R0,[R1, #+12]
   1510          
   1511                    /* Set DMA destination address */
   1512                    husart->hdmatx->LinkedListQueue->Head->LinkRegisters[NODE_CDAR_DEFAULT_OFFSET] =
   1513                      (uint32_t)&husart->Instance->TDR;
   \       0xA8   0x6820             LDR      R0,[R4, #+0]
   \       0xAA   0x3028             ADDS     R0,R0,#+40
   \       0xAC   0x6D21             LDR      R1,[R4, #+80]
   \       0xAE   0x6F49             LDR      R1,[R1, #+116]
   \       0xB0   0x6809             LDR      R1,[R1, #+0]
   \       0xB2   0x6108             STR      R0,[R1, #+16]
   1514          
   1515                    /* Enable the USART transmit DMA channel */
   1516                    status = HAL_DMAEx_List_Start_IT(husart->hdmatx);
   \       0xB4   0x6D20             LDR      R0,[R4, #+80]
   \       0xB6   0x.... 0x....      BL       HAL_DMAEx_List_Start_IT
   \       0xBA   0xE009             B.N      ??HAL_USART_Transmit_DMA_5
   1517                  }
   1518                  else
   1519                  {
   1520                    /* Update status */
   1521                    status = HAL_ERROR;
   \                     ??HAL_USART_Transmit_DMA_8: (+1)
   \       0xBC   0x2001             MOVS     R0,#+1
   \       0xBE   0xE007             B.N      ??HAL_USART_Transmit_DMA_5
   1522                  }
   1523                }
   1524                else
   1525                {
   1526                  /* Enable the USART transmit DMA channel */
   1527                  status = HAL_DMA_Start_IT(husart->hdmatx, *(const uint32_t *)tmp, (uint32_t)&husart->Instance->TDR, nbByte);
   \                     ??HAL_USART_Transmit_DMA_7: (+1)
   \       0xC0   0xB29B             UXTH     R3,R3
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0xF110 0x0228      ADDS     R2,R0,#+40
   \       0xC8   0x6809             LDR      R1,[R1, #+0]
   \       0xCA   0x6D20             LDR      R0,[R4, #+80]
   \       0xCC   0x.... 0x....      BL       HAL_DMA_Start_IT
   1528                }
   1529              }
   1530          
   1531              if (status == HAL_OK)
   \                     ??HAL_USART_Transmit_DMA_5: (+1)
   \       0xD0   0xB2C0             UXTB     R0,R0
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD10D             BNE.N    ??HAL_USART_Transmit_DMA_9
   1532              {
   1533                /* Clear the TC flag in the ICR register */
   1534                __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_TCF);
   \       0xD6   0x2040             MOVS     R0,#+64
   \       0xD8   0x6821             LDR      R1,[R4, #+0]
   \       0xDA   0x6208             STR      R0,[R1, #+32]
   1535          
   1536                /* Process Unlocked */
   1537                __HAL_UNLOCK(husart);
   \       0xDC   0x2000             MOVS     R0,#+0
   \       0xDE   0xF884 0x0058      STRB     R0,[R4, #+88]
   1538          
   1539                /* Enable the DMA transfer for transmit request by setting the DMAT bit
   1540                   in the USART CR3 register */
   1541                SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
   \       0xE2   0x6820             LDR      R0,[R4, #+0]
   \       0xE4   0x6880             LDR      R0,[R0, #+8]
   \       0xE6   0xF050 0x0080      ORRS     R0,R0,#0x80
   \       0xEA   0x6821             LDR      R1,[R4, #+0]
   \       0xEC   0x6088             STR      R0,[R1, #+8]
   1542          
   1543                return HAL_OK;
   \       0xEE   0x2000             MOVS     R0,#+0
   \       0xF0   0xE00A             B.N      ??HAL_USART_Transmit_DMA_3
   1544              }
   1545              else
   1546              {
   1547                /* Set error code to DMA */
   1548                husart->ErrorCode = HAL_USART_ERROR_DMA;
   \                     ??HAL_USART_Transmit_DMA_9: (+1)
   \       0xF2   0x2010             MOVS     R0,#+16
   \       0xF4   0x65E0             STR      R0,[R4, #+92]
   1549          
   1550                /* Process Unlocked */
   1551                __HAL_UNLOCK(husart);
   \       0xF6   0x2000             MOVS     R0,#+0
   \       0xF8   0xF884 0x0058      STRB     R0,[R4, #+88]
   1552          
   1553                /* Restore husart->State to ready */
   1554                husart->State = HAL_USART_STATE_READY;
   \       0xFC   0x2001             MOVS     R0,#+1
   \       0xFE   0xF884 0x0059      STRB     R0,[R4, #+89]
   1555          
   1556                return HAL_ERROR;
   \      0x102   0x2001             MOVS     R0,#+1
   \      0x104   0xE000             B.N      ??HAL_USART_Transmit_DMA_3
   1557              }
   1558            }
   1559            else
   1560            {
   1561              return HAL_BUSY;
   \                     ??HAL_USART_Transmit_DMA_0: (+1)
   \      0x106   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_Transmit_DMA_3: (+1)
   \      0x108   0xBD16             POP      {R1,R2,R4,PC}
   1562            }
   1563          }
   1564          
   1565          /**
   1566            * @brief Receive an amount of data in DMA mode.
   1567            * @note   When the USART parity is enabled (PCE = 1), the received data contain
   1568            *         the parity bit (MSB position).
   1569            * @note   The USART DMA transmit channel must be configured in order to generate the clock for the slave.
   1570            * @note   When USART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1571            *         the received data is handled as a set of u16. In this case, Size must indicate the number
   1572            *         of u16 available through pRxData.
   1573            * @param  husart USART handle.
   1574            * @param  pRxData pointer to data buffer (u8 or u16 data elements).
   1575            * @param  Size amount of data elements (u8 or u16) to be received.
   1576            * @retval HAL status
   1577            */

   \                                 In section .text, align 2, keep-with-next
   1578          HAL_StatusTypeDef HAL_USART_Receive_DMA(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
   1579          {
   \                     HAL_USART_Receive_DMA: (+1)
   \        0x0   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1580            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2000             MOVS     R0,#+0
   1581            uint32_t *tmp = (uint32_t *)&pRxData;
   \        0x6   0xAD01             ADD      R5,SP,#+4
   1582            uint16_t nbByte = Size;
   \        0x8   0x0016             MOVS     R6,R2
   1583          
   1584            /* Check that a Rx process is not already ongoing */
   1585            if (husart->State == HAL_USART_STATE_READY)
   \        0xA   0xF894 0x1059      LDRB     R1,[R4, #+89]
   \        0xE   0x2901             CMP      R1,#+1
   \       0x10   0xF040 0x80DB      BNE.W    ??HAL_USART_Receive_DMA_0
   1586            {
   1587              if ((pRxData == NULL) || (Size == 0U))
   \       0x14   0x9901             LDR      R1,[SP, #+4]
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD003             BEQ.N    ??HAL_USART_Receive_DMA_1
   \       0x1A   0x0011             MOVS     R1,R2
   \       0x1C   0xB289             UXTH     R1,R1
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xD101             BNE.N    ??HAL_USART_Receive_DMA_2
   1588              {
   1589                return HAL_ERROR;
   \                     ??HAL_USART_Receive_DMA_1: (+1)
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xE0D2             B.N      ??HAL_USART_Receive_DMA_3
   1590              }
   1591          
   1592              /* Process Locked */
   1593              __HAL_LOCK(husart);
   \                     ??HAL_USART_Receive_DMA_2: (+1)
   \       0x26   0xF894 0x1058      LDRB     R1,[R4, #+88]
   \       0x2A   0x2901             CMP      R1,#+1
   \       0x2C   0xD101             BNE.N    ??HAL_USART_Receive_DMA_4
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xE0CC             B.N      ??HAL_USART_Receive_DMA_3
   \                     ??HAL_USART_Receive_DMA_4: (+1)
   \       0x32   0x2101             MOVS     R1,#+1
   \       0x34   0xF884 0x1058      STRB     R1,[R4, #+88]
   1594          
   1595              husart->pRxBuffPtr = pRxData;
   \       0x38   0x9901             LDR      R1,[SP, #+4]
   \       0x3A   0x6321             STR      R1,[R4, #+48]
   1596              husart->RxXferSize = Size;
   \       0x3C   0x86A2             STRH     R2,[R4, #+52]
   1597              husart->pTxBuffPtr = pRxData;
   \       0x3E   0x9901             LDR      R1,[SP, #+4]
   \       0x40   0x62A1             STR      R1,[R4, #+40]
   1598              husart->TxXferSize = Size;
   \       0x42   0x85A2             STRH     R2,[R4, #+44]
   1599          
   1600              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0x65E1             STR      R1,[R4, #+92]
   1601              husart->State = HAL_USART_STATE_BUSY_RX;
   \       0x48   0x2122             MOVS     R1,#+34
   \       0x4A   0xF884 0x1059      STRB     R1,[R4, #+89]
   1602          
   1603              if (husart->hdmarx != NULL)
   \       0x4E   0x6D61             LDR      R1,[R4, #+84]
   \       0x50   0x2900             CMP      R1,#+0
   \       0x52   0xD042             BEQ.N    ??HAL_USART_Receive_DMA_5
   1604              {
   1605                /* Set the USART DMA Rx transfer complete callback */
   1606                husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
   \       0x54   0x.... 0x....      ADR.W    R0,USART_DMAReceiveCplt
   \       0x58   0x6D61             LDR      R1,[R4, #+84]
   \       0x5A   0x6608             STR      R0,[R1, #+96]
   1607          
   1608                /* Set the USART DMA Half transfer complete callback */
   1609                husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
   \       0x5C   0x.... 0x....      ADR.W    R0,USART_DMARxHalfCplt
   \       0x60   0x6D61             LDR      R1,[R4, #+84]
   \       0x62   0x6648             STR      R0,[R1, #+100]
   1610          
   1611                /* Set the USART DMA Rx transfer error callback */
   1612                husart->hdmarx->XferErrorCallback = USART_DMAError;
   \       0x64   0x.... 0x....      ADR.W    R0,USART_DMAError
   \       0x68   0x6D61             LDR      R1,[R4, #+84]
   \       0x6A   0x6688             STR      R0,[R1, #+104]
   1613          
   1614                /* In case of 9bits/No Parity transfer, pTxData buffer provided as input parameter
   1615                   should be aligned on a u16 frontier, so nbByte should be equal to Size multiplied by 2 */
   1616                if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
   \       0x6C   0x68A0             LDR      R0,[R4, #+8]
   \       0x6E   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x72   0xD104             BNE.N    ??HAL_USART_Receive_DMA_6
   \       0x74   0x6920             LDR      R0,[R4, #+16]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD101             BNE.N    ??HAL_USART_Receive_DMA_6
   1617                {
   1618                  nbByte = Size * 2U;
   \       0x7A   0x0052             LSLS     R2,R2,#+1
   \       0x7C   0x0016             MOVS     R6,R2
   1619                }
   1620          
   1621                /* Check linked list mode */
   1622                if ((husart->hdmarx->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
   \                     ??HAL_USART_Receive_DMA_6: (+1)
   \       0x7E   0x6D60             LDR      R0,[R4, #+84]
   \       0x80   0xF890 0x0050      LDRB     R0,[R0, #+80]
   \       0x84   0x0600             LSLS     R0,R0,#+24
   \       0x86   0xD51F             BPL.N    ??HAL_USART_Receive_DMA_7
   1623                {
   1624                  if ((husart->hdmarx->LinkedListQueue != NULL) && (husart->hdmarx->LinkedListQueue->Head != NULL))
   \       0x88   0x6D60             LDR      R0,[R4, #+84]
   \       0x8A   0x6F40             LDR      R0,[R0, #+116]
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD019             BEQ.N    ??HAL_USART_Receive_DMA_8
   \       0x90   0x6D60             LDR      R0,[R4, #+84]
   \       0x92   0x6F40             LDR      R0,[R0, #+116]
   \       0x94   0x6800             LDR      R0,[R0, #+0]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD014             BEQ.N    ??HAL_USART_Receive_DMA_8
   1625                  {
   1626                    /* Set DMA data size */
   1627                    husart->hdmarx->LinkedListQueue->Head->LinkRegisters[NODE_CBR1_DEFAULT_OFFSET] = nbByte;
   \       0x9A   0x0030             MOVS     R0,R6
   \       0x9C   0xB280             UXTH     R0,R0
   \       0x9E   0x6D61             LDR      R1,[R4, #+84]
   \       0xA0   0x6F49             LDR      R1,[R1, #+116]
   \       0xA2   0x6809             LDR      R1,[R1, #+0]
   \       0xA4   0x6088             STR      R0,[R1, #+8]
   1628          
   1629                    /* Set DMA source address */
   1630                    husart->hdmarx->LinkedListQueue->Head->LinkRegisters[NODE_CSAR_DEFAULT_OFFSET] =
   1631                      (uint32_t)&husart->Instance->RDR;
   \       0xA6   0x6820             LDR      R0,[R4, #+0]
   \       0xA8   0x3024             ADDS     R0,R0,#+36
   \       0xAA   0x6D61             LDR      R1,[R4, #+84]
   \       0xAC   0x6F49             LDR      R1,[R1, #+116]
   \       0xAE   0x6809             LDR      R1,[R1, #+0]
   \       0xB0   0x60C8             STR      R0,[R1, #+12]
   1632          
   1633                    /* Set DMA destination address */
   1634                    husart->hdmarx->LinkedListQueue->Head->LinkRegisters[NODE_CDAR_DEFAULT_OFFSET] = *(uint32_t *)tmp;
   \       0xB2   0x6828             LDR      R0,[R5, #+0]
   \       0xB4   0x6D61             LDR      R1,[R4, #+84]
   \       0xB6   0x6F49             LDR      R1,[R1, #+116]
   \       0xB8   0x6809             LDR      R1,[R1, #+0]
   \       0xBA   0x6108             STR      R0,[R1, #+16]
   1635          
   1636                    /* Enable the USART receive DMA channel */
   1637                    status = HAL_DMAEx_List_Start_IT(husart->hdmarx);
   \       0xBC   0x6D60             LDR      R0,[R4, #+84]
   \       0xBE   0x.... 0x....      BL       HAL_DMAEx_List_Start_IT
   \       0xC2   0xE00A             B.N      ??HAL_USART_Receive_DMA_5
   1638                  }
   1639                  else
   1640                  {
   1641                    /* Update status */
   1642                    status = HAL_ERROR;
   \                     ??HAL_USART_Receive_DMA_8: (+1)
   \       0xC4   0x2001             MOVS     R0,#+1
   \       0xC6   0xE008             B.N      ??HAL_USART_Receive_DMA_5
   1643                  }
   1644                }
   1645                else
   1646                {
   1647                  /* Enable the USART receive DMA channel */
   1648                  status = HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(uint32_t *)tmp, nbByte);
   \                     ??HAL_USART_Receive_DMA_7: (+1)
   \       0xC8   0x0033             MOVS     R3,R6
   \       0xCA   0xB29B             UXTH     R3,R3
   \       0xCC   0x682A             LDR      R2,[R5, #+0]
   \       0xCE   0x6820             LDR      R0,[R4, #+0]
   \       0xD0   0xF110 0x0124      ADDS     R1,R0,#+36
   \       0xD4   0x6D60             LDR      R0,[R4, #+84]
   \       0xD6   0x.... 0x....      BL       HAL_DMA_Start_IT
   1649                }
   1650              }
   1651          
   1652              if ((status == HAL_OK) &&
   1653                  (husart->SlaveMode == USART_SLAVEMODE_DISABLE))
   \                     ??HAL_USART_Receive_DMA_5: (+1)
   \       0xDA   0x0001             MOVS     R1,R0
   \       0xDC   0xB2C9             UXTB     R1,R1
   \       0xDE   0x2900             CMP      R1,#+0
   \       0xE0   0xD13B             BNE.N    ??HAL_USART_Receive_DMA_9
   \       0xE2   0x6C21             LDR      R1,[R4, #+64]
   \       0xE4   0x2900             CMP      R1,#+0
   \       0xE6   0xD138             BNE.N    ??HAL_USART_Receive_DMA_9
   1654              {
   1655                /* Enable the USART transmit DMA channel: the transmit channel is used in order
   1656                   to generate in the non-blocking mode the clock to the slave device,
   1657                   this mode isn't a simplex receive mode but a full-duplex receive mode */
   1658          
   1659                /* Set the USART DMA Tx Complete and Error callback to Null */
   1660                if (husart->hdmatx != NULL)
   \       0xE8   0x6D21             LDR      R1,[R4, #+80]
   \       0xEA   0x2900             CMP      R1,#+0
   \       0xEC   0xD035             BEQ.N    ??HAL_USART_Receive_DMA_9
   1661                {
   1662                  husart->hdmatx->XferErrorCallback = NULL;
   \       0xEE   0x2000             MOVS     R0,#+0
   \       0xF0   0x6D21             LDR      R1,[R4, #+80]
   \       0xF2   0x6688             STR      R0,[R1, #+104]
   1663                  husart->hdmatx->XferHalfCpltCallback = NULL;
   \       0xF4   0x2000             MOVS     R0,#+0
   \       0xF6   0x6D21             LDR      R1,[R4, #+80]
   \       0xF8   0x6648             STR      R0,[R1, #+100]
   1664                  husart->hdmatx->XferCpltCallback = NULL;
   \       0xFA   0x2000             MOVS     R0,#+0
   \       0xFC   0x6D21             LDR      R1,[R4, #+80]
   \       0xFE   0x6608             STR      R0,[R1, #+96]
   1665          
   1666                  /* Check linked list mode */
   1667                  if ((husart->hdmatx->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
   \      0x100   0x6D20             LDR      R0,[R4, #+80]
   \      0x102   0xF890 0x0050      LDRB     R0,[R0, #+80]
   \      0x106   0x0600             LSLS     R0,R0,#+24
   \      0x108   0xD51E             BPL.N    ??HAL_USART_Receive_DMA_10
   1668                  {
   1669                    if ((husart->hdmatx->LinkedListQueue != NULL) && (husart->hdmatx->LinkedListQueue->Head != NULL))
   \      0x10A   0x6D20             LDR      R0,[R4, #+80]
   \      0x10C   0x6F40             LDR      R0,[R0, #+116]
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD018             BEQ.N    ??HAL_USART_Receive_DMA_11
   \      0x112   0x6D20             LDR      R0,[R4, #+80]
   \      0x114   0x6F40             LDR      R0,[R0, #+116]
   \      0x116   0x6800             LDR      R0,[R0, #+0]
   \      0x118   0x2800             CMP      R0,#+0
   \      0x11A   0xD013             BEQ.N    ??HAL_USART_Receive_DMA_11
   1670                    {
   1671                      /* Set DMA data size */
   1672                      husart->hdmatx->LinkedListQueue->Head->LinkRegisters[NODE_CBR1_DEFAULT_OFFSET] = nbByte;
   \      0x11C   0xB2B6             UXTH     R6,R6
   \      0x11E   0x6D20             LDR      R0,[R4, #+80]
   \      0x120   0x6F40             LDR      R0,[R0, #+116]
   \      0x122   0x6800             LDR      R0,[R0, #+0]
   \      0x124   0x6086             STR      R6,[R0, #+8]
   1673          
   1674                      /* Set DMA source address */
   1675                      husart->hdmatx->LinkedListQueue->Head->LinkRegisters[NODE_CSAR_DEFAULT_OFFSET] = *(uint32_t *)tmp;
   \      0x126   0x6828             LDR      R0,[R5, #+0]
   \      0x128   0x6D21             LDR      R1,[R4, #+80]
   \      0x12A   0x6F49             LDR      R1,[R1, #+116]
   \      0x12C   0x6809             LDR      R1,[R1, #+0]
   \      0x12E   0x60C8             STR      R0,[R1, #+12]
   1676          
   1677                      /* Set DMA destination address */
   1678                      husart->hdmatx->LinkedListQueue->Head->LinkRegisters[NODE_CDAR_DEFAULT_OFFSET] =
   1679                        (uint32_t)&husart->Instance->TDR;
   \      0x130   0x6820             LDR      R0,[R4, #+0]
   \      0x132   0x3028             ADDS     R0,R0,#+40
   \      0x134   0x6D21             LDR      R1,[R4, #+80]
   \      0x136   0x6F49             LDR      R1,[R1, #+116]
   \      0x138   0x6809             LDR      R1,[R1, #+0]
   \      0x13A   0x6108             STR      R0,[R1, #+16]
   1680          
   1681                      /* Enable the USART transmit DMA channel */
   1682                      status = HAL_DMAEx_List_Start_IT(husart->hdmatx);
   \      0x13C   0x6D20             LDR      R0,[R4, #+80]
   \      0x13E   0x.... 0x....      BL       HAL_DMAEx_List_Start_IT
   \      0x142   0xE00A             B.N      ??HAL_USART_Receive_DMA_9
   1683                    }
   1684                    else
   1685                    {
   1686                      /* Update status */
   1687                      status = HAL_ERROR;
   \                     ??HAL_USART_Receive_DMA_11: (+1)
   \      0x144   0x2001             MOVS     R0,#+1
   \      0x146   0xE008             B.N      ??HAL_USART_Receive_DMA_9
   1688                    }
   1689                  }
   1690                  else
   1691                  {
   1692                    status = HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t *)tmp, (uint32_t)&husart->Instance->TDR, nbByte);
   \                     ??HAL_USART_Receive_DMA_10: (+1)
   \      0x148   0xB2B6             UXTH     R6,R6
   \      0x14A   0x0033             MOVS     R3,R6
   \      0x14C   0x6820             LDR      R0,[R4, #+0]
   \      0x14E   0xF110 0x0228      ADDS     R2,R0,#+40
   \      0x152   0x6829             LDR      R1,[R5, #+0]
   \      0x154   0x6D20             LDR      R0,[R4, #+80]
   \      0x156   0x.... 0x....      BL       HAL_DMA_Start_IT
   1693                  }
   1694                }
   1695              }
   1696          
   1697              if (status == HAL_OK)
   \                     ??HAL_USART_Receive_DMA_9: (+1)
   \      0x15A   0xB2C0             UXTB     R0,R0
   \      0x15C   0x2800             CMP      R0,#+0
   \      0x15E   0xD11F             BNE.N    ??HAL_USART_Receive_DMA_12
   1698              {
   1699                /* Process Unlocked */
   1700                __HAL_UNLOCK(husart);
   \      0x160   0x2000             MOVS     R0,#+0
   \      0x162   0xF884 0x0058      STRB     R0,[R4, #+88]
   1701          
   1702                if (husart->Init.Parity != USART_PARITY_NONE)
   \      0x166   0x6920             LDR      R0,[R4, #+16]
   \      0x168   0x2800             CMP      R0,#+0
   \      0x16A   0xD005             BEQ.N    ??HAL_USART_Receive_DMA_13
   1703                {
   1704                  /* Enable the USART Parity Error Interrupt */
   1705                  SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
   \      0x16C   0x6820             LDR      R0,[R4, #+0]
   \      0x16E   0x6800             LDR      R0,[R0, #+0]
   \      0x170   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x174   0x6821             LDR      R1,[R4, #+0]
   \      0x176   0x6008             STR      R0,[R1, #+0]
   1706                }
   1707          
   1708                /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
   1709                SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
   \                     ??HAL_USART_Receive_DMA_13: (+1)
   \      0x178   0x6820             LDR      R0,[R4, #+0]
   \      0x17A   0x6880             LDR      R0,[R0, #+8]
   \      0x17C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x180   0x6821             LDR      R1,[R4, #+0]
   \      0x182   0x6088             STR      R0,[R1, #+8]
   1710          
   1711                /* Enable the DMA transfer for the receiver request by setting the DMAR bit
   1712                   in the USART CR3 register */
   1713                SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
   \      0x184   0x6820             LDR      R0,[R4, #+0]
   \      0x186   0x6880             LDR      R0,[R0, #+8]
   \      0x188   0xF050 0x0040      ORRS     R0,R0,#0x40
   \      0x18C   0x6821             LDR      R1,[R4, #+0]
   \      0x18E   0x6088             STR      R0,[R1, #+8]
   1714          
   1715                /* Enable the DMA transfer for transmit request by setting the DMAT bit
   1716                   in the USART CR3 register */
   1717                SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
   \      0x190   0x6820             LDR      R0,[R4, #+0]
   \      0x192   0x6880             LDR      R0,[R0, #+8]
   \      0x194   0xF050 0x0080      ORRS     R0,R0,#0x80
   \      0x198   0x6821             LDR      R1,[R4, #+0]
   \      0x19A   0x6088             STR      R0,[R1, #+8]
   1718          
   1719                return HAL_OK;
   \      0x19C   0x2000             MOVS     R0,#+0
   \      0x19E   0xE015             B.N      ??HAL_USART_Receive_DMA_3
   1720              }
   1721              else
   1722              {
   1723                if ((husart->hdmarx != NULL) && ((husart->hdmarx->Mode & DMA_LINKEDLIST) != DMA_LINKEDLIST))
   \                     ??HAL_USART_Receive_DMA_12: (+1)
   \      0x1A0   0x6D60             LDR      R0,[R4, #+84]
   \      0x1A2   0x2800             CMP      R0,#+0
   \      0x1A4   0xD007             BEQ.N    ??HAL_USART_Receive_DMA_14
   \      0x1A6   0x6D60             LDR      R0,[R4, #+84]
   \      0x1A8   0xF890 0x0050      LDRB     R0,[R0, #+80]
   \      0x1AC   0x0600             LSLS     R0,R0,#+24
   \      0x1AE   0xD402             BMI.N    ??HAL_USART_Receive_DMA_14
   1724                {
   1725                  status = HAL_DMA_Abort(husart->hdmarx);
   \      0x1B0   0x6D60             LDR      R0,[R4, #+84]
   \      0x1B2   0x.... 0x....      BL       HAL_DMA_Abort
   1726                }
   1727          
   1728                /* No need to check on error code */
   1729                UNUSED(status);
   1730          
   1731                /* Set error code to DMA */
   1732                husart->ErrorCode = HAL_USART_ERROR_DMA;
   \                     ??HAL_USART_Receive_DMA_14: (+1)
   \      0x1B6   0x2010             MOVS     R0,#+16
   \      0x1B8   0x65E0             STR      R0,[R4, #+92]
   1733          
   1734                /* Process Unlocked */
   1735                __HAL_UNLOCK(husart);
   \      0x1BA   0x2000             MOVS     R0,#+0
   \      0x1BC   0xF884 0x0058      STRB     R0,[R4, #+88]
   1736          
   1737                /* Restore husart->State to ready */
   1738                husart->State = HAL_USART_STATE_READY;
   \      0x1C0   0x2001             MOVS     R0,#+1
   \      0x1C2   0xF884 0x0059      STRB     R0,[R4, #+89]
   1739          
   1740                return HAL_ERROR;
   \      0x1C6   0x2001             MOVS     R0,#+1
   \      0x1C8   0xE000             B.N      ??HAL_USART_Receive_DMA_3
   1741              }
   1742            }
   1743            else
   1744            {
   1745              return HAL_BUSY;
   \                     ??HAL_USART_Receive_DMA_0: (+1)
   \      0x1CA   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_Receive_DMA_3: (+1)
   \      0x1CC   0xBD76             POP      {R1,R2,R4-R6,PC}
   1746            }
   1747          }
   1748          
   1749          /**
   1750            * @brief Full-Duplex Transmit Receive an amount of data in non-blocking mode.
   1751            * @note   When the USART parity is enabled (PCE = 1) the data received contain the parity bit.
   1752            * @note   When USART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1753            *         the sent data and the received data are handled as sets of u16. In this case, Size must indicate the number
   1754            *         of u16 available through pTxData and through pRxData.
   1755            * @param  husart USART handle.
   1756            * @param  pTxData pointer to TX data buffer (u8 or u16 data elements).
   1757            * @param  pRxData pointer to RX data buffer (u8 or u16 data elements).
   1758            * @param  Size amount of data elements (u8 or u16) to be received/sent.
   1759            * @retval HAL status
   1760            */

   \                                 In section .text, align 2, keep-with-next
   1761          HAL_StatusTypeDef HAL_USART_TransmitReceive_DMA(USART_HandleTypeDef *husart, const uint8_t *pTxData, uint8_t *pRxData,
   1762                                                          uint16_t Size)
   1763          {
   \                     HAL_USART_TransmitReceive_DMA: (+1)
   \        0x0   0xB537             PUSH     {R0-R2,R4,R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1764            HAL_StatusTypeDef status;
   1765            const uint32_t *tmp;
   1766            uint16_t nbByte = Size;
   \        0x4   0x001D             MOVS     R5,R3
   1767          
   1768            if (husart->State == HAL_USART_STATE_READY)
   \        0x6   0xF894 0x0059      LDRB     R0,[R4, #+89]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xF040 0x80E5      BNE.W    ??HAL_USART_TransmitReceive_DMA_0
   1769            {
   1770              if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
   \       0x10   0x9801             LDR      R0,[SP, #+4]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD006             BEQ.N    ??HAL_USART_TransmitReceive_DMA_1
   \       0x16   0x9802             LDR      R0,[SP, #+8]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD003             BEQ.N    ??HAL_USART_TransmitReceive_DMA_1
   \       0x1C   0x0018             MOVS     R0,R3
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD101             BNE.N    ??HAL_USART_TransmitReceive_DMA_2
   1771              {
   1772                return HAL_ERROR;
   \                     ??HAL_USART_TransmitReceive_DMA_1: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE0D9             B.N      ??HAL_USART_TransmitReceive_DMA_3
   1773              }
   1774          
   1775              /* Process Locked */
   1776              __HAL_LOCK(husart);
   \                     ??HAL_USART_TransmitReceive_DMA_2: (+1)
   \       0x28   0xF894 0x0058      LDRB     R0,[R4, #+88]
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD101             BNE.N    ??HAL_USART_TransmitReceive_DMA_4
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xE0D3             B.N      ??HAL_USART_TransmitReceive_DMA_3
   \                     ??HAL_USART_TransmitReceive_DMA_4: (+1)
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xF884 0x0058      STRB     R0,[R4, #+88]
   1777          
   1778              husart->pRxBuffPtr = pRxData;
   \       0x3A   0x9802             LDR      R0,[SP, #+8]
   \       0x3C   0x6320             STR      R0,[R4, #+48]
   1779              husart->RxXferSize = Size;
   \       0x3E   0x86A3             STRH     R3,[R4, #+52]
   1780              husart->pTxBuffPtr = pTxData;
   \       0x40   0x9801             LDR      R0,[SP, #+4]
   \       0x42   0x62A0             STR      R0,[R4, #+40]
   1781              husart->TxXferSize = Size;
   \       0x44   0x85A3             STRH     R3,[R4, #+44]
   1782          
   1783              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x65E0             STR      R0,[R4, #+92]
   1784              husart->State = HAL_USART_STATE_BUSY_TX_RX;
   \       0x4A   0x2032             MOVS     R0,#+50
   \       0x4C   0xF884 0x0059      STRB     R0,[R4, #+89]
   1785          
   1786              if ((husart->hdmarx != NULL) && (husart->hdmatx != NULL))
   \       0x50   0x6D60             LDR      R0,[R4, #+84]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xF000 0x8085      BEQ.W    ??HAL_USART_TransmitReceive_DMA_5
   \       0x58   0x6D20             LDR      R0,[R4, #+80]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xF000 0x8081      BEQ.W    ??HAL_USART_TransmitReceive_DMA_5
   1787              {
   1788                /* Set the USART DMA Rx transfer complete callback */
   1789                husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
   \       0x60   0x.... 0x....      ADR.W    R0,USART_DMAReceiveCplt
   \       0x64   0x6D61             LDR      R1,[R4, #+84]
   \       0x66   0x6608             STR      R0,[R1, #+96]
   1790          
   1791                /* Set the USART DMA Half transfer complete callback */
   1792                husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
   \       0x68   0x.... 0x....      ADR.W    R0,USART_DMARxHalfCplt
   \       0x6C   0x6D61             LDR      R1,[R4, #+84]
   \       0x6E   0x6648             STR      R0,[R1, #+100]
   1793          
   1794                /* Set the USART DMA Tx transfer complete callback */
   1795                husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
   \       0x70   0x.... 0x....      ADR.W    R0,USART_DMATransmitCplt
   \       0x74   0x6D21             LDR      R1,[R4, #+80]
   \       0x76   0x6608             STR      R0,[R1, #+96]
   1796          
   1797                /* Set the USART DMA Half transfer complete callback */
   1798                husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
   \       0x78   0x.... 0x....      ADR.W    R0,USART_DMATxHalfCplt
   \       0x7C   0x6D21             LDR      R1,[R4, #+80]
   \       0x7E   0x6648             STR      R0,[R1, #+100]
   1799          
   1800                /* Set the USART DMA Tx transfer error callback */
   1801                husart->hdmatx->XferErrorCallback = USART_DMAError;
   \       0x80   0x.... 0x....      ADR.W    R0,USART_DMAError
   \       0x84   0x6D21             LDR      R1,[R4, #+80]
   \       0x86   0x6688             STR      R0,[R1, #+104]
   1802          
   1803                /* Set the USART DMA Rx transfer error callback */
   1804                husart->hdmarx->XferErrorCallback = USART_DMAError;
   \       0x88   0x6D61             LDR      R1,[R4, #+84]
   \       0x8A   0x6688             STR      R0,[R1, #+104]
   1805          
   1806                /* In case of 9bits/No Parity transfer, pTxData buffer provided as input parameter
   1807                   should be aligned on a u16 frontier, so nbByte should be equal to Size multiplied by 2 */
   1808                if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
   \       0x8C   0x68A0             LDR      R0,[R4, #+8]
   \       0x8E   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x92   0xD104             BNE.N    ??HAL_USART_TransmitReceive_DMA_6
   \       0x94   0x6920             LDR      R0,[R4, #+16]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD101             BNE.N    ??HAL_USART_TransmitReceive_DMA_6
   1809                {
   1810                  nbByte = Size * 2U;
   \       0x9A   0x005B             LSLS     R3,R3,#+1
   \       0x9C   0x001D             MOVS     R5,R3
   1811                }
   1812          
   1813                /* Check linked list mode */
   1814                tmp = (uint32_t *)&pRxData;
   \                     ??HAL_USART_TransmitReceive_DMA_6: (+1)
   \       0x9E   0xA902             ADD      R1,SP,#+8
   1815                if ((husart->hdmarx->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
   \       0xA0   0x6D60             LDR      R0,[R4, #+84]
   \       0xA2   0xF890 0x0050      LDRB     R0,[R0, #+80]
   \       0xA6   0x0600             LSLS     R0,R0,#+24
   \       0xA8   0xD51F             BPL.N    ??HAL_USART_TransmitReceive_DMA_7
   1816                {
   1817                  if ((husart->hdmarx->LinkedListQueue != NULL) && (husart->hdmarx->LinkedListQueue->Head != NULL))
   \       0xAA   0x6D60             LDR      R0,[R4, #+84]
   \       0xAC   0x6F40             LDR      R0,[R0, #+116]
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD019             BEQ.N    ??HAL_USART_TransmitReceive_DMA_8
   \       0xB2   0x6D60             LDR      R0,[R4, #+84]
   \       0xB4   0x6F40             LDR      R0,[R0, #+116]
   \       0xB6   0x6800             LDR      R0,[R0, #+0]
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD014             BEQ.N    ??HAL_USART_TransmitReceive_DMA_8
   1818                  {
   1819                    /* Set DMA data size */
   1820                    husart->hdmarx->LinkedListQueue->Head->LinkRegisters[NODE_CBR1_DEFAULT_OFFSET] = nbByte;
   \       0xBC   0x0028             MOVS     R0,R5
   \       0xBE   0xB280             UXTH     R0,R0
   \       0xC0   0x6D62             LDR      R2,[R4, #+84]
   \       0xC2   0x6F52             LDR      R2,[R2, #+116]
   \       0xC4   0x6812             LDR      R2,[R2, #+0]
   \       0xC6   0x6090             STR      R0,[R2, #+8]
   1821          
   1822                    /* Set DMA source address */
   1823                    husart->hdmarx->LinkedListQueue->Head->LinkRegisters[NODE_CSAR_DEFAULT_OFFSET] =
   1824                      (uint32_t)&husart->Instance->RDR;
   \       0xC8   0x6820             LDR      R0,[R4, #+0]
   \       0xCA   0x3024             ADDS     R0,R0,#+36
   \       0xCC   0x6D62             LDR      R2,[R4, #+84]
   \       0xCE   0x6F52             LDR      R2,[R2, #+116]
   \       0xD0   0x6812             LDR      R2,[R2, #+0]
   \       0xD2   0x60D0             STR      R0,[R2, #+12]
   1825          
   1826                    /* Set DMA destination address */
   1827                    husart->hdmarx->LinkedListQueue->Head->LinkRegisters[NODE_CDAR_DEFAULT_OFFSET] = *(const uint32_t *)tmp;
   \       0xD4   0x6808             LDR      R0,[R1, #+0]
   \       0xD6   0x6D61             LDR      R1,[R4, #+84]
   \       0xD8   0x6F49             LDR      R1,[R1, #+116]
   \       0xDA   0x6809             LDR      R1,[R1, #+0]
   \       0xDC   0x6108             STR      R0,[R1, #+16]
   1828          
   1829                    /* Enable the USART receive DMA channel */
   1830                    status = HAL_DMAEx_List_Start_IT(husart->hdmarx);
   \       0xDE   0x6D60             LDR      R0,[R4, #+84]
   \       0xE0   0x.... 0x....      BL       HAL_DMAEx_List_Start_IT
   \       0xE4   0xE00A             B.N      ??HAL_USART_TransmitReceive_DMA_9
   1831                  }
   1832                  else
   1833                  {
   1834                    /* Update status */
   1835                    status = HAL_ERROR;
   \                     ??HAL_USART_TransmitReceive_DMA_8: (+1)
   \       0xE6   0x2001             MOVS     R0,#+1
   \       0xE8   0xE008             B.N      ??HAL_USART_TransmitReceive_DMA_9
   1836                  }
   1837                }
   1838                else
   1839                {
   1840                  /* Enable the USART receive DMA channel */
   1841                  status = HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(const uint32_t *)tmp, nbByte);
   \                     ??HAL_USART_TransmitReceive_DMA_7: (+1)
   \       0xEA   0x002B             MOVS     R3,R5
   \       0xEC   0xB29B             UXTH     R3,R3
   \       0xEE   0x680A             LDR      R2,[R1, #+0]
   \       0xF0   0x6820             LDR      R0,[R4, #+0]
   \       0xF2   0xF110 0x0124      ADDS     R1,R0,#+36
   \       0xF6   0x6D60             LDR      R0,[R4, #+84]
   \       0xF8   0x.... 0x....      BL       HAL_DMA_Start_IT
   1842                }
   1843          
   1844                /* Enable the USART transmit DMA channel */
   1845                if (status == HAL_OK)
   \                     ??HAL_USART_TransmitReceive_DMA_9: (+1)
   \       0xFC   0x0001             MOVS     R1,R0
   \       0xFE   0xB2C9             UXTB     R1,R1
   \      0x100   0x2900             CMP      R1,#+0
   \      0x102   0xD12F             BNE.N    ??HAL_USART_TransmitReceive_DMA_10
   1846                {
   1847                  tmp = (const uint32_t *)&pTxData;
   \      0x104   0xA901             ADD      R1,SP,#+4
   1848          
   1849                  /* Check linked list mode */
   1850                  if ((husart->hdmatx->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
   \      0x106   0x6D20             LDR      R0,[R4, #+80]
   \      0x108   0xF890 0x0050      LDRB     R0,[R0, #+80]
   \      0x10C   0x0600             LSLS     R0,R0,#+24
   \      0x10E   0xD51E             BPL.N    ??HAL_USART_TransmitReceive_DMA_11
   1851                  {
   1852                    if ((husart->hdmatx->LinkedListQueue != NULL) && (husart->hdmatx->LinkedListQueue->Head != NULL))
   \      0x110   0x6D20             LDR      R0,[R4, #+80]
   \      0x112   0x6F40             LDR      R0,[R0, #+116]
   \      0x114   0x2800             CMP      R0,#+0
   \      0x116   0xD018             BEQ.N    ??HAL_USART_TransmitReceive_DMA_12
   \      0x118   0x6D20             LDR      R0,[R4, #+80]
   \      0x11A   0x6F40             LDR      R0,[R0, #+116]
   \      0x11C   0x6800             LDR      R0,[R0, #+0]
   \      0x11E   0x2800             CMP      R0,#+0
   \      0x120   0xD013             BEQ.N    ??HAL_USART_TransmitReceive_DMA_12
   1853                    {
   1854                      /* Set DMA data size */
   1855                      husart->hdmatx->LinkedListQueue->Head->LinkRegisters[NODE_CBR1_DEFAULT_OFFSET] = nbByte;
   \      0x122   0xB2AD             UXTH     R5,R5
   \      0x124   0x6D20             LDR      R0,[R4, #+80]
   \      0x126   0x6F40             LDR      R0,[R0, #+116]
   \      0x128   0x6800             LDR      R0,[R0, #+0]
   \      0x12A   0x6085             STR      R5,[R0, #+8]
   1856          
   1857                      /* Set DMA source address */
   1858                      husart->hdmatx->LinkedListQueue->Head->LinkRegisters[NODE_CSAR_DEFAULT_OFFSET] = *(const uint32_t *)tmp;
   \      0x12C   0x6808             LDR      R0,[R1, #+0]
   \      0x12E   0x6D21             LDR      R1,[R4, #+80]
   \      0x130   0x6F49             LDR      R1,[R1, #+116]
   \      0x132   0x6809             LDR      R1,[R1, #+0]
   \      0x134   0x60C8             STR      R0,[R1, #+12]
   1859          
   1860                      /* Set DMA destination address */
   1861                      husart->hdmatx->LinkedListQueue->Head->LinkRegisters[NODE_CDAR_DEFAULT_OFFSET] =
   1862                        (uint32_t)&husart->Instance->TDR;
   \      0x136   0x6820             LDR      R0,[R4, #+0]
   \      0x138   0x3028             ADDS     R0,R0,#+40
   \      0x13A   0x6D21             LDR      R1,[R4, #+80]
   \      0x13C   0x6F49             LDR      R1,[R1, #+116]
   \      0x13E   0x6809             LDR      R1,[R1, #+0]
   \      0x140   0x6108             STR      R0,[R1, #+16]
   1863          
   1864                      /* Enable the USART transmit DMA channel */
   1865                      status = HAL_DMAEx_List_Start_IT(husart->hdmatx);
   \      0x142   0x6D20             LDR      R0,[R4, #+80]
   \      0x144   0x.... 0x....      BL       HAL_DMAEx_List_Start_IT
   \      0x148   0xE00C             B.N      ??HAL_USART_TransmitReceive_DMA_10
   1866                    }
   1867                    else
   1868                    {
   1869                      /* Update status */
   1870                      status = HAL_ERROR;
   \                     ??HAL_USART_TransmitReceive_DMA_12: (+1)
   \      0x14A   0x2001             MOVS     R0,#+1
   \      0x14C   0xE00A             B.N      ??HAL_USART_TransmitReceive_DMA_10
   1871                    }
   1872                  }
   1873                  else
   1874                  {
   1875                    status = HAL_DMA_Start_IT(husart->hdmatx, *(const uint32_t *)tmp, (uint32_t)&husart->Instance->TDR, nbByte);
   \                     ??HAL_USART_TransmitReceive_DMA_11: (+1)
   \      0x14E   0xB2AD             UXTH     R5,R5
   \      0x150   0x002B             MOVS     R3,R5
   \      0x152   0x6820             LDR      R0,[R4, #+0]
   \      0x154   0xF110 0x0228      ADDS     R2,R0,#+40
   \      0x158   0x6809             LDR      R1,[R1, #+0]
   \      0x15A   0x6D20             LDR      R0,[R4, #+80]
   \      0x15C   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x160   0xE000             B.N      ??HAL_USART_TransmitReceive_DMA_10
   1876                  }
   1877                }
   1878              }
   1879              else
   1880              {
   1881                status = HAL_ERROR;
   \                     ??HAL_USART_TransmitReceive_DMA_5: (+1)
   \      0x162   0x2001             MOVS     R0,#+1
   1882              }
   1883          
   1884              if (status == HAL_OK)
   \                     ??HAL_USART_TransmitReceive_DMA_10: (+1)
   \      0x164   0xB2C0             UXTB     R0,R0
   \      0x166   0x2800             CMP      R0,#+0
   \      0x168   0xD122             BNE.N    ??HAL_USART_TransmitReceive_DMA_13
   1885              {
   1886                /* Process Unlocked */
   1887                __HAL_UNLOCK(husart);
   \      0x16A   0x2000             MOVS     R0,#+0
   \      0x16C   0xF884 0x0058      STRB     R0,[R4, #+88]
   1888          
   1889                if (husart->Init.Parity != USART_PARITY_NONE)
   \      0x170   0x6920             LDR      R0,[R4, #+16]
   \      0x172   0x2800             CMP      R0,#+0
   \      0x174   0xD005             BEQ.N    ??HAL_USART_TransmitReceive_DMA_14
   1890                {
   1891                  /* Enable the USART Parity Error Interrupt */
   1892                  SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
   \      0x176   0x6820             LDR      R0,[R4, #+0]
   \      0x178   0x6800             LDR      R0,[R0, #+0]
   \      0x17A   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x17E   0x6821             LDR      R1,[R4, #+0]
   \      0x180   0x6008             STR      R0,[R1, #+0]
   1893                }
   1894          
   1895                /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
   1896                SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
   \                     ??HAL_USART_TransmitReceive_DMA_14: (+1)
   \      0x182   0x6820             LDR      R0,[R4, #+0]
   \      0x184   0x6880             LDR      R0,[R0, #+8]
   \      0x186   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x18A   0x6821             LDR      R1,[R4, #+0]
   \      0x18C   0x6088             STR      R0,[R1, #+8]
   1897          
   1898                /* Clear the TC flag in the ICR register */
   1899                __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_TCF);
   \      0x18E   0x2040             MOVS     R0,#+64
   \      0x190   0x6821             LDR      R1,[R4, #+0]
   \      0x192   0x6208             STR      R0,[R1, #+32]
   1900          
   1901                /* Enable the DMA transfer for the receiver request by setting the DMAR bit
   1902                   in the USART CR3 register */
   1903                SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
   \      0x194   0x6820             LDR      R0,[R4, #+0]
   \      0x196   0x6880             LDR      R0,[R0, #+8]
   \      0x198   0xF050 0x0040      ORRS     R0,R0,#0x40
   \      0x19C   0x6821             LDR      R1,[R4, #+0]
   \      0x19E   0x6088             STR      R0,[R1, #+8]
   1904          
   1905                /* Enable the DMA transfer for transmit request by setting the DMAT bit
   1906                   in the USART CR3 register */
   1907                SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
   \      0x1A0   0x6820             LDR      R0,[R4, #+0]
   \      0x1A2   0x6880             LDR      R0,[R0, #+8]
   \      0x1A4   0xF050 0x0080      ORRS     R0,R0,#0x80
   \      0x1A8   0x6821             LDR      R1,[R4, #+0]
   \      0x1AA   0x6088             STR      R0,[R1, #+8]
   1908          
   1909                return HAL_OK;
   \      0x1AC   0x2000             MOVS     R0,#+0
   \      0x1AE   0xE015             B.N      ??HAL_USART_TransmitReceive_DMA_3
   1910              }
   1911              else
   1912              {
   1913                if ((husart->hdmarx != NULL) && ((husart->hdmarx->Mode & DMA_LINKEDLIST) != DMA_LINKEDLIST))
   \                     ??HAL_USART_TransmitReceive_DMA_13: (+1)
   \      0x1B0   0x6D60             LDR      R0,[R4, #+84]
   \      0x1B2   0x2800             CMP      R0,#+0
   \      0x1B4   0xD007             BEQ.N    ??HAL_USART_TransmitReceive_DMA_15
   \      0x1B6   0x6D60             LDR      R0,[R4, #+84]
   \      0x1B8   0xF890 0x0050      LDRB     R0,[R0, #+80]
   \      0x1BC   0x0600             LSLS     R0,R0,#+24
   \      0x1BE   0xD402             BMI.N    ??HAL_USART_TransmitReceive_DMA_15
   1914                {
   1915                  status = HAL_DMA_Abort(husart->hdmarx);
   \      0x1C0   0x6D60             LDR      R0,[R4, #+84]
   \      0x1C2   0x.... 0x....      BL       HAL_DMA_Abort
   1916                }
   1917          
   1918                /* No need to check on error code */
   1919                UNUSED(status);
   1920          
   1921                /* Set error code to DMA */
   1922                husart->ErrorCode = HAL_USART_ERROR_DMA;
   \                     ??HAL_USART_TransmitReceive_DMA_15: (+1)
   \      0x1C6   0x2010             MOVS     R0,#+16
   \      0x1C8   0x65E0             STR      R0,[R4, #+92]
   1923          
   1924                /* Process Unlocked */
   1925                __HAL_UNLOCK(husart);
   \      0x1CA   0x2000             MOVS     R0,#+0
   \      0x1CC   0xF884 0x0058      STRB     R0,[R4, #+88]
   1926          
   1927                /* Restore husart->State to ready */
   1928                husart->State = HAL_USART_STATE_READY;
   \      0x1D0   0x2001             MOVS     R0,#+1
   \      0x1D2   0xF884 0x0059      STRB     R0,[R4, #+89]
   1929          
   1930                return HAL_ERROR;
   \      0x1D6   0x2001             MOVS     R0,#+1
   \      0x1D8   0xE000             B.N      ??HAL_USART_TransmitReceive_DMA_3
   1931              }
   1932            }
   1933            else
   1934            {
   1935              return HAL_BUSY;
   \                     ??HAL_USART_TransmitReceive_DMA_0: (+1)
   \      0x1DA   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_TransmitReceive_DMA_3: (+1)
   \      0x1DC   0xBD3E             POP      {R1-R5,PC}
   1936            }
   1937          }
   1938          
   1939          /**
   1940            * @brief Pause the DMA Transfer.
   1941            * @param  husart USART handle.
   1942            * @retval HAL status
   1943            */

   \                                 In section .text, align 2, keep-with-next
   1944          HAL_StatusTypeDef HAL_USART_DMAPause(USART_HandleTypeDef *husart)
   1945          {
   \                     HAL_USART_DMAPause: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1946            const HAL_USART_StateTypeDef state = husart->State;
   \        0x4   0xF894 0x5059      LDRB     R5,[R4, #+89]
   1947          
   1948            /* Process Locked */
   1949            __HAL_LOCK(husart);
   \        0x8   0xF894 0x0058      LDRB     R0,[R4, #+88]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE.N    ??HAL_USART_DMAPause_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE05B             B.N      ??HAL_USART_DMAPause_1
   \                     ??HAL_USART_DMAPause_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xF884 0x0058      STRB     R0,[R4, #+88]
   1950          
   1951            if ((HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT)) &&
   1952                (state == HAL_USART_STATE_BUSY_TX))
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x6880             LDR      R0,[R0, #+8]
   \       0x1E   0x0600             LSLS     R0,R0,#+24
   \       0x20   0xD517             BPL.N    ??HAL_USART_DMAPause_2
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x2812             CMP      R0,#+18
   \       0x28   0xD113             BNE.N    ??HAL_USART_DMAPause_2
   1953            {
   1954              /* Suspend the USART DMA Tx channel : use blocking DMA Suspend API (no callback) */
   1955              if (husart->hdmatx != NULL)
   \       0x2A   0x6D20             LDR      R0,[R4, #+80]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD049             BEQ.N    ??HAL_USART_DMAPause_3
   1956              {
   1957                /* Set the USART DMA Suspend callback to Null.
   1958                   No call back execution at end of DMA Suspend procedure */
   1959                husart->hdmatx->XferSuspendCallback = NULL;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x6D21             LDR      R1,[R4, #+80]
   \       0x34   0x6708             STR      R0,[R1, #+112]
   1960          
   1961                if (HAL_DMAEx_Suspend(husart->hdmatx) != HAL_OK)
   \       0x36   0x6D20             LDR      R0,[R4, #+80]
   \       0x38   0x.... 0x....      BL       HAL_DMAEx_Suspend
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD041             BEQ.N    ??HAL_USART_DMAPause_3
   1962                {
   1963                  if (HAL_DMA_GetError(husart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x40   0x6D20             LDR      R0,[R4, #+80]
   \       0x42   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x46   0x2810             CMP      R0,#+16
   \       0x48   0xD13C             BNE.N    ??HAL_USART_DMAPause_3
   1964                  {
   1965                    /* Set error code to DMA */
   1966                    husart->ErrorCode = HAL_USART_ERROR_DMA;
   \       0x4A   0x2010             MOVS     R0,#+16
   \       0x4C   0x65E0             STR      R0,[R4, #+92]
   1967          
   1968                    return HAL_TIMEOUT;
   \       0x4E   0x2003             MOVS     R0,#+3
   \       0x50   0xE03C             B.N      ??HAL_USART_DMAPause_1
   1969                  }
   1970                }
   1971              }
   1972            }
   1973            else if ((state == HAL_USART_STATE_BUSY_RX) ||
   1974                     (state == HAL_USART_STATE_BUSY_TX_RX))
   \                     ??HAL_USART_DMAPause_2: (+1)
   \       0x52   0x0028             MOVS     R0,R5
   \       0x54   0xB2C0             UXTB     R0,R0
   \       0x56   0x2822             CMP      R0,#+34
   \       0x58   0xD003             BEQ.N    ??HAL_USART_DMAPause_4
   \       0x5A   0x0028             MOVS     R0,R5
   \       0x5C   0xB2C0             UXTB     R0,R0
   \       0x5E   0x2832             CMP      R0,#+50
   \       0x60   0xD130             BNE.N    ??HAL_USART_DMAPause_3
   1975            {
   1976              /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
   1977              CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
   \                     ??HAL_USART_DMAPause_4: (+1)
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x6800             LDR      R0,[R0, #+0]
   \       0x66   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0x6A   0x6821             LDR      R1,[R4, #+0]
   \       0x6C   0x6008             STR      R0,[R1, #+0]
   1978              CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x6880             LDR      R0,[R0, #+8]
   \       0x72   0x0840             LSRS     R0,R0,#+1
   \       0x74   0x0040             LSLS     R0,R0,#+1
   \       0x76   0x6821             LDR      R1,[R4, #+0]
   \       0x78   0x6088             STR      R0,[R1, #+8]
   1979          
   1980              /* Set the USART DMA Suspend callback to Null.
   1981              No call back execution at end of DMA Suspend procedure */
   1982              husart->hdmarx->XferSuspendCallback = NULL;
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0x6D61             LDR      R1,[R4, #+84]
   \       0x7E   0x6708             STR      R0,[R1, #+112]
   1983          
   1984              if (HAL_DMAEx_Suspend(husart->hdmarx) != HAL_OK)
   \       0x80   0x6D60             LDR      R0,[R4, #+84]
   \       0x82   0x.... 0x....      BL       HAL_DMAEx_Suspend
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD008             BEQ.N    ??HAL_USART_DMAPause_5
   1985              {
   1986                if (HAL_DMA_GetError(husart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x8A   0x6D60             LDR      R0,[R4, #+84]
   \       0x8C   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x90   0x2810             CMP      R0,#+16
   \       0x92   0xD103             BNE.N    ??HAL_USART_DMAPause_5
   1987                {
   1988                  /* Set error code to DMA */
   1989                  husart->ErrorCode = HAL_USART_ERROR_DMA;
   \       0x94   0x2010             MOVS     R0,#+16
   \       0x96   0x65E0             STR      R0,[R4, #+92]
   1990          
   1991                  return HAL_TIMEOUT;
   \       0x98   0x2003             MOVS     R0,#+3
   \       0x9A   0xE017             B.N      ??HAL_USART_DMAPause_1
   1992                }
   1993              }
   1994          
   1995              if (state == HAL_USART_STATE_BUSY_TX_RX)
   \                     ??HAL_USART_DMAPause_5: (+1)
   \       0x9C   0xB2ED             UXTB     R5,R5
   \       0x9E   0x2D32             CMP      R5,#+50
   \       0xA0   0xD110             BNE.N    ??HAL_USART_DMAPause_3
   1996              {
   1997                /* Set the USART DMA Suspend callback to Null.
   1998                No call back execution at end of DMA Suspend procedure */
   1999                husart->hdmatx->XferSuspendCallback = NULL;
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0x6D21             LDR      R1,[R4, #+80]
   \       0xA6   0x6708             STR      R0,[R1, #+112]
   2000          
   2001                if (HAL_DMAEx_Suspend(husart->hdmatx) != HAL_OK)
   \       0xA8   0x6D20             LDR      R0,[R4, #+80]
   \       0xAA   0x.... 0x....      BL       HAL_DMAEx_Suspend
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD008             BEQ.N    ??HAL_USART_DMAPause_3
   2002                {
   2003                  if (HAL_DMA_GetError(husart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
   \       0xB2   0x6D20             LDR      R0,[R4, #+80]
   \       0xB4   0x.... 0x....      BL       HAL_DMA_GetError
   \       0xB8   0x2810             CMP      R0,#+16
   \       0xBA   0xD103             BNE.N    ??HAL_USART_DMAPause_3
   2004                  {
   2005                    /* Set error code to DMA */
   2006                    husart->ErrorCode = HAL_USART_ERROR_DMA;
   \       0xBC   0x2010             MOVS     R0,#+16
   \       0xBE   0x65E0             STR      R0,[R4, #+92]
   2007          
   2008                    return HAL_TIMEOUT;
   \       0xC0   0x2003             MOVS     R0,#+3
   \       0xC2   0xE003             B.N      ??HAL_USART_DMAPause_1
   2009                  }
   2010                }
   2011              }
   2012            }
   2013            else
   2014            {
   2015              /* Nothing to do */
   2016            }
   2017          
   2018            /* Process Unlocked */
   2019            __HAL_UNLOCK(husart);
   \                     ??HAL_USART_DMAPause_3: (+1)
   \       0xC4   0x2000             MOVS     R0,#+0
   \       0xC6   0xF884 0x0058      STRB     R0,[R4, #+88]
   2020          
   2021            return HAL_OK;
   \       0xCA   0x2000             MOVS     R0,#+0
   \                     ??HAL_USART_DMAPause_1: (+1)
   \       0xCC   0xBD32             POP      {R1,R4,R5,PC}
   2022          }
   2023          
   2024          /**
   2025            * @brief Resume the DMA Transfer.
   2026            * @param  husart USART handle.
   2027            * @retval HAL status
   2028            */

   \                                 In section .text, align 2, keep-with-next
   2029          HAL_StatusTypeDef HAL_USART_DMAResume(USART_HandleTypeDef *husart)
   2030          {
   \                     HAL_USART_DMAResume: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2031            const HAL_USART_StateTypeDef state = husart->State;
   \        0x4   0xF894 0x5059      LDRB     R5,[R4, #+89]
   2032          
   2033            /* Process Locked */
   2034            __HAL_LOCK(husart);
   \        0x8   0xF894 0x0058      LDRB     R0,[R4, #+88]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE.N    ??HAL_USART_DMAResume_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE04B             B.N      ??HAL_USART_DMAResume_1
   \                     ??HAL_USART_DMAResume_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xF884 0x0058      STRB     R0,[R4, #+88]
   2035          
   2036            if (state == HAL_USART_STATE_BUSY_TX)
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x2812             CMP      R0,#+18
   \       0x20   0xD10B             BNE.N    ??HAL_USART_DMAResume_2
   2037            {
   2038              /* Resume the USART DMA Tx channel */
   2039              if (husart->hdmatx != NULL)
   \       0x22   0x6D20             LDR      R0,[R4, #+80]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD03D             BEQ.N    ??HAL_USART_DMAResume_3
   2040              {
   2041                if (HAL_DMAEx_Resume(husart->hdmatx) != HAL_OK)
   \       0x28   0x6D20             LDR      R0,[R4, #+80]
   \       0x2A   0x.... 0x....      BL       HAL_DMAEx_Resume
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD038             BEQ.N    ??HAL_USART_DMAResume_3
   2042                {
   2043                  /* Set error code to DMA */
   2044                  husart->ErrorCode = HAL_USART_ERROR_DMA;
   \       0x32   0x2010             MOVS     R0,#+16
   \       0x34   0x65E0             STR      R0,[R4, #+92]
   2045          
   2046                  return HAL_ERROR;
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0xE038             B.N      ??HAL_USART_DMAResume_1
   2047                }
   2048              }
   2049            }
   2050            else if ((state == HAL_USART_STATE_BUSY_RX) ||
   2051                     (state == HAL_USART_STATE_BUSY_TX_RX))
   \                     ??HAL_USART_DMAResume_2: (+1)
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0xB2C0             UXTB     R0,R0
   \       0x3E   0x2822             CMP      R0,#+34
   \       0x40   0xD003             BEQ.N    ??HAL_USART_DMAResume_4
   \       0x42   0x0028             MOVS     R0,R5
   \       0x44   0xB2C0             UXTB     R0,R0
   \       0x46   0x2832             CMP      R0,#+50
   \       0x48   0xD12C             BNE.N    ??HAL_USART_DMAResume_3
   2052            {
   2053              /* Clear the Overrun flag before resuming the Rx transfer*/
   2054              __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF);
   \                     ??HAL_USART_DMAResume_4: (+1)
   \       0x4A   0x2008             MOVS     R0,#+8
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x6208             STR      R0,[R1, #+32]
   2055          
   2056              /* Re-enable PE and ERR (Frame error, noise error, overrun error) interrupts */
   2057              if (husart->Init.Parity != USART_PARITY_NONE)
   \       0x50   0x6920             LDR      R0,[R4, #+16]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD005             BEQ.N    ??HAL_USART_DMAResume_5
   2058              {
   2059                SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6800             LDR      R0,[R0, #+0]
   \       0x5A   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0x6008             STR      R0,[R1, #+0]
   2060              }
   2061              SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
   \                     ??HAL_USART_DMAResume_5: (+1)
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x6880             LDR      R0,[R0, #+8]
   \       0x66   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x6A   0x6821             LDR      R1,[R4, #+0]
   \       0x6C   0x6088             STR      R0,[R1, #+8]
   2062          
   2063              /* Resume the USART DMA Rx channel */
   2064              if (husart->hdmarx != NULL)
   \       0x6E   0x6D60             LDR      R0,[R4, #+84]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD008             BEQ.N    ??HAL_USART_DMAResume_6
   2065              {
   2066                if (HAL_DMAEx_Resume(husart->hdmarx) != HAL_OK)
   \       0x74   0x6D60             LDR      R0,[R4, #+84]
   \       0x76   0x.... 0x....      BL       HAL_DMAEx_Resume
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD003             BEQ.N    ??HAL_USART_DMAResume_6
   2067                {
   2068                  /* Set error code to DMA */
   2069                  husart->ErrorCode = HAL_USART_ERROR_DMA;
   \       0x7E   0x2010             MOVS     R0,#+16
   \       0x80   0x65E0             STR      R0,[R4, #+92]
   2070          
   2071                  return HAL_ERROR;
   \       0x82   0x2001             MOVS     R0,#+1
   \       0x84   0xE012             B.N      ??HAL_USART_DMAResume_1
   2072                }
   2073              }
   2074          
   2075              if (state == HAL_USART_STATE_BUSY_TX_RX)
   \                     ??HAL_USART_DMAResume_6: (+1)
   \       0x86   0xB2ED             UXTB     R5,R5
   \       0x88   0x2D32             CMP      R5,#+50
   \       0x8A   0xD10B             BNE.N    ??HAL_USART_DMAResume_3
   2076              {
   2077                /* Resume the USART DMA Tx channel */
   2078                if (husart->hdmatx != NULL)
   \       0x8C   0x6D20             LDR      R0,[R4, #+80]
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD008             BEQ.N    ??HAL_USART_DMAResume_3
   2079                {
   2080                  if (HAL_DMAEx_Resume(husart->hdmatx) != HAL_OK)
   \       0x92   0x6D20             LDR      R0,[R4, #+80]
   \       0x94   0x.... 0x....      BL       HAL_DMAEx_Resume
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD003             BEQ.N    ??HAL_USART_DMAResume_3
   2081                  {
   2082                    /* Set error code to DMA */
   2083                    husart->ErrorCode = HAL_USART_ERROR_DMA;
   \       0x9C   0x2010             MOVS     R0,#+16
   \       0x9E   0x65E0             STR      R0,[R4, #+92]
   2084          
   2085                    return HAL_ERROR;
   \       0xA0   0x2001             MOVS     R0,#+1
   \       0xA2   0xE003             B.N      ??HAL_USART_DMAResume_1
   2086                  }
   2087                }
   2088              }
   2089            }
   2090            else
   2091            {
   2092              /* Nothing to do */
   2093            }
   2094          
   2095            /* Process Unlocked */
   2096            __HAL_UNLOCK(husart);
   \                     ??HAL_USART_DMAResume_3: (+1)
   \       0xA4   0x2000             MOVS     R0,#+0
   \       0xA6   0xF884 0x0058      STRB     R0,[R4, #+88]
   2097          
   2098            return HAL_OK;
   \       0xAA   0x2000             MOVS     R0,#+0
   \                     ??HAL_USART_DMAResume_1: (+1)
   \       0xAC   0xBD32             POP      {R1,R4,R5,PC}
   2099          }
   2100          
   2101          /**
   2102            * @brief Stop the DMA Transfer.
   2103            * @param  husart USART handle.
   2104            * @retval HAL status
   2105            */

   \                                 In section .text, align 2, keep-with-next
   2106          HAL_StatusTypeDef HAL_USART_DMAStop(USART_HandleTypeDef *husart)
   2107          {
   \                     HAL_USART_DMAStop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2108            /* The Lock is not implemented on this API to allow the user application
   2109               to call the HAL USART API under callbacks HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback() /
   2110               HAL_USART_TxHalfCpltCallback / HAL_USART_RxHalfCpltCallback:
   2111               indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete
   2112               interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of
   2113               the stream and the corresponding call back is executed. */
   2114          
   2115            /* Disable the USART Tx/Rx DMA requests */
   2116            CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6880             LDR      R0,[R0, #+8]
   \        0x8   0xF030 0x0080      BICS     R0,R0,#0x80
   \        0xC   0x6821             LDR      R1,[R4, #+0]
   \        0xE   0x6088             STR      R0,[R1, #+8]
   2117            CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6880             LDR      R0,[R0, #+8]
   \       0x14   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x6088             STR      R0,[R1, #+8]
   2118          
   2119            /* Abort the USART DMA tx channel */
   2120            if (husart->hdmatx != NULL)
   \       0x1C   0x6D20             LDR      R0,[R4, #+80]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD00D             BEQ.N    ??HAL_USART_DMAStop_0
   2121            {
   2122              if (HAL_DMA_Abort(husart->hdmatx) != HAL_OK)
   \       0x22   0x6D20             LDR      R0,[R4, #+80]
   \       0x24   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD008             BEQ.N    ??HAL_USART_DMAStop_0
   2123              {
   2124                if (HAL_DMA_GetError(husart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x2C   0x6D20             LDR      R0,[R4, #+80]
   \       0x2E   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x32   0x2810             CMP      R0,#+16
   \       0x34   0xD103             BNE.N    ??HAL_USART_DMAStop_0
   2125                {
   2126                  /* Set error code to DMA */
   2127                  husart->ErrorCode = HAL_USART_ERROR_DMA;
   \       0x36   0x2010             MOVS     R0,#+16
   \       0x38   0x65E0             STR      R0,[R4, #+92]
   2128          
   2129                  return HAL_TIMEOUT;
   \       0x3A   0x2003             MOVS     R0,#+3
   \       0x3C   0xE017             B.N      ??HAL_USART_DMAStop_1
   2130                }
   2131              }
   2132            }
   2133            /* Abort the USART DMA rx channel */
   2134            if (husart->hdmarx != NULL)
   \                     ??HAL_USART_DMAStop_0: (+1)
   \       0x3E   0x6D60             LDR      R0,[R4, #+84]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD00D             BEQ.N    ??HAL_USART_DMAStop_2
   2135            {
   2136              if (HAL_DMA_Abort(husart->hdmarx) != HAL_OK)
   \       0x44   0x6D60             LDR      R0,[R4, #+84]
   \       0x46   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD008             BEQ.N    ??HAL_USART_DMAStop_2
   2137              {
   2138                if (HAL_DMA_GetError(husart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x4E   0x6D60             LDR      R0,[R4, #+84]
   \       0x50   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x54   0x2810             CMP      R0,#+16
   \       0x56   0xD103             BNE.N    ??HAL_USART_DMAStop_2
   2139                {
   2140                  /* Set error code to DMA */
   2141                  husart->ErrorCode = HAL_USART_ERROR_DMA;
   \       0x58   0x2010             MOVS     R0,#+16
   \       0x5A   0x65E0             STR      R0,[R4, #+92]
   2142          
   2143                  return HAL_TIMEOUT;
   \       0x5C   0x2003             MOVS     R0,#+3
   \       0x5E   0xE006             B.N      ??HAL_USART_DMAStop_1
   2144                }
   2145              }
   2146            }
   2147          
   2148            USART_EndTransfer(husart);
   \                     ??HAL_USART_DMAStop_2: (+1)
   \       0x60   0x0020             MOVS     R0,R4
   \       0x62   0x.... 0x....      BL       USART_EndTransfer
   2149            husart->State = HAL_USART_STATE_READY;
   \       0x66   0x2001             MOVS     R0,#+1
   \       0x68   0xF884 0x0059      STRB     R0,[R4, #+89]
   2150          
   2151            return HAL_OK;
   \       0x6C   0x2000             MOVS     R0,#+0
   \                     ??HAL_USART_DMAStop_1: (+1)
   \       0x6E   0xBD10             POP      {R4,PC}
   2152          }
   2153          #endif /* HAL_DMA_MODULE_ENABLED */
   2154          
   2155          /**
   2156            * @brief  Abort ongoing transfers (blocking mode).
   2157            * @param  husart USART handle.
   2158            * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode.
   2159            *         This procedure performs following operations :
   2160            *           - Disable USART Interrupts (Tx and Rx)
   2161            *           - Disable the DMA transfer in the peripheral register (if enabled)
   2162            *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
   2163            *           - Set handle State to READY
   2164            * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
   2165            * @retval HAL status
   2166            */

   \                                 In section .text, align 2, keep-with-next
   2167          HAL_StatusTypeDef HAL_USART_Abort(USART_HandleTypeDef *husart)
   2168          {
   \                     HAL_USART_Abort: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2169            /* Disable TXEIE, TCIE, RXNE, RXFT, TXFT, PE and ERR (Frame error, noise error, overrun error) interrupts */
   2170            CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE |
   2171                                              USART_CR1_TCIE));
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0xF430 0x70F0      BICS     R0,R0,#0x1E0
   \        0xC   0x6821             LDR      R1,[R4, #+0]
   \        0xE   0x6008             STR      R0,[R1, #+0]
   2172            CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6881             LDR      R1,[R0, #+8]
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x18   0x4001             ANDS     R1,R0,R1
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x6081             STR      R1,[R0, #+8]
   2173          
   2174          #if defined(HAL_DMA_MODULE_ENABLED)
   2175            /* Abort the USART DMA Tx channel if enabled */
   2176            if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6880             LDR      R0,[R0, #+8]
   \       0x22   0x0600             LSLS     R0,R0,#+24
   \       0x24   0xD513             BPL.N    ??HAL_USART_Abort_0
   2177            {
   2178              /* Abort the USART DMA Tx channel : use blocking DMA Abort API (no callback) */
   2179              if (husart->hdmatx != NULL)
   \       0x26   0x6D20             LDR      R0,[R4, #+80]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD010             BEQ.N    ??HAL_USART_Abort_0
   2180              {
   2181                /* Set the USART DMA Abort callback to Null.
   2182                   No call back execution at end of DMA abort procedure */
   2183                husart->hdmatx->XferAbortCallback = NULL;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x6D21             LDR      R1,[R4, #+80]
   \       0x30   0x66C8             STR      R0,[R1, #+108]
   2184          
   2185                if (HAL_DMA_Abort(husart->hdmatx) != HAL_OK)
   \       0x32   0x6D20             LDR      R0,[R4, #+80]
   \       0x34   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD008             BEQ.N    ??HAL_USART_Abort_0
   2186                {
   2187                  if (HAL_DMA_GetError(husart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x3C   0x6D20             LDR      R0,[R4, #+80]
   \       0x3E   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x42   0x2810             CMP      R0,#+16
   \       0x44   0xD103             BNE.N    ??HAL_USART_Abort_0
   2188                  {
   2189                    /* Set error code to DMA */
   2190                    husart->ErrorCode = HAL_USART_ERROR_DMA;
   \       0x46   0x2010             MOVS     R0,#+16
   \       0x48   0x65E0             STR      R0,[R4, #+92]
   2191          
   2192                    return HAL_TIMEOUT;
   \       0x4A   0x2003             MOVS     R0,#+3
   \       0x4C   0xE034             B.N      ??HAL_USART_Abort_1
   2193                  }
   2194                }
   2195              }
   2196            }
   2197          
   2198            /* Abort the USART DMA Rx channel if enabled */
   2199            if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
   \                     ??HAL_USART_Abort_0: (+1)
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x6880             LDR      R0,[R0, #+8]
   \       0x52   0x0640             LSLS     R0,R0,#+25
   \       0x54   0xD513             BPL.N    ??HAL_USART_Abort_2
   2200            {
   2201              /* Abort the USART DMA Rx channel : use blocking DMA Abort API (no callback) */
   2202              if (husart->hdmarx != NULL)
   \       0x56   0x6D60             LDR      R0,[R4, #+84]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD010             BEQ.N    ??HAL_USART_Abort_2
   2203              {
   2204                /* Set the USART DMA Abort callback to Null.
   2205                   No call back execution at end of DMA abort procedure */
   2206                husart->hdmarx->XferAbortCallback = NULL;
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x6D61             LDR      R1,[R4, #+84]
   \       0x60   0x66C8             STR      R0,[R1, #+108]
   2207          
   2208                if (HAL_DMA_Abort(husart->hdmarx) != HAL_OK)
   \       0x62   0x6D60             LDR      R0,[R4, #+84]
   \       0x64   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD008             BEQ.N    ??HAL_USART_Abort_2
   2209                {
   2210                  if (HAL_DMA_GetError(husart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x6C   0x6D60             LDR      R0,[R4, #+84]
   \       0x6E   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x72   0x2810             CMP      R0,#+16
   \       0x74   0xD103             BNE.N    ??HAL_USART_Abort_2
   2211                  {
   2212                    /* Set error code to DMA */
   2213                    husart->ErrorCode = HAL_USART_ERROR_DMA;
   \       0x76   0x2010             MOVS     R0,#+16
   \       0x78   0x65E0             STR      R0,[R4, #+92]
   2214          
   2215                    return HAL_TIMEOUT;
   \       0x7A   0x2003             MOVS     R0,#+3
   \       0x7C   0xE01C             B.N      ??HAL_USART_Abort_1
   2216                  }
   2217                }
   2218              }
   2219            }
   2220          #endif /* HAL_DMA_MODULE_ENABLED */
   2221          
   2222            /* Reset Tx and Rx transfer counters */
   2223            husart->TxXferCount = 0U;
   \                     ??HAL_USART_Abort_2: (+1)
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x85E0             STRH     R0,[R4, #+46]
   2224            husart->RxXferCount = 0U;
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0x86E0             STRH     R0,[R4, #+54]
   2225          
   2226            /* Clear the Error flags in the ICR register */
   2227            __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
   \       0x86   0x200F             MOVS     R0,#+15
   \       0x88   0x6821             LDR      R1,[R4, #+0]
   \       0x8A   0x6208             STR      R0,[R1, #+32]
   2228          
   2229            /* Flush the whole TX FIFO (if needed) */
   2230            if (husart->FifoMode == USART_FIFOMODE_ENABLE)
   \       0x8C   0x6C60             LDR      R0,[R4, #+68]
   \       0x8E   0xF1B0 0x5F00      CMP      R0,#+536870912
   \       0x92   0xD105             BNE.N    ??HAL_USART_Abort_3
   2231            {
   2232              __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0x6980             LDR      R0,[R0, #+24]
   \       0x98   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x9C   0x6821             LDR      R1,[R4, #+0]
   \       0x9E   0x6188             STR      R0,[R1, #+24]
   2233            }
   2234          
   2235            /* Discard the received data */
   2236            __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
   \                     ??HAL_USART_Abort_3: (+1)
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x6980             LDR      R0,[R0, #+24]
   \       0xA4   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xA8   0x6821             LDR      R1,[R4, #+0]
   \       0xAA   0x6188             STR      R0,[R1, #+24]
   2237          
   2238            /* Restore husart->State to Ready */
   2239            husart->State  = HAL_USART_STATE_READY;
   \       0xAC   0x2001             MOVS     R0,#+1
   \       0xAE   0xF884 0x0059      STRB     R0,[R4, #+89]
   2240          
   2241            /* Reset Handle ErrorCode to No Error */
   2242            husart->ErrorCode = HAL_USART_ERROR_NONE;
   \       0xB2   0x2000             MOVS     R0,#+0
   \       0xB4   0x65E0             STR      R0,[R4, #+92]
   2243          
   2244            return HAL_OK;
   \       0xB6   0x2000             MOVS     R0,#+0
   \                     ??HAL_USART_Abort_1: (+1)
   \       0xB8   0xBD10             POP      {R4,PC}
   2245          }
   2246          
   2247          /**
   2248            * @brief  Abort ongoing transfers (Interrupt mode).
   2249            * @param  husart USART handle.
   2250            * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode.
   2251            *         This procedure performs following operations :
   2252            *           - Disable USART Interrupts (Tx and Rx)
   2253            *           - Disable the DMA transfer in the peripheral register (if enabled)
   2254            *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
   2255            *           - Set handle State to READY
   2256            *           - At abort completion, call user abort complete callback
   2257            * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
   2258            *         considered as completed only when user abort complete callback is executed (not when exiting function).
   2259            * @retval HAL status
   2260            */

   \                                 In section .text, align 2, keep-with-next
   2261          HAL_StatusTypeDef HAL_USART_Abort_IT(USART_HandleTypeDef *husart)
   2262          {
   \                     HAL_USART_Abort_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2263            uint32_t abortcplt = 1U;
   \        0x4   0x2501             MOVS     R5,#+1
   2264          
   2265            /* Disable TXEIE, TCIE, RXNE, RXFT, TXFT, PE and ERR (Frame error, noise error, overrun error) interrupts */
   2266            CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE |
   2267                                              USART_CR1_TCIE));
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0xF430 0x70F0      BICS     R0,R0,#0x1E0
   \        0xE   0x6821             LDR      R1,[R4, #+0]
   \       0x10   0x6008             STR      R0,[R1, #+0]
   2268            CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x6881             LDR      R1,[R0, #+8]
   \       0x16   0x....             LDR.N    R0,??DataTable7
   \       0x18   0x4001             ANDS     R1,R0,R1
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x6081             STR      R1,[R0, #+8]
   2269          
   2270          #if defined(HAL_DMA_MODULE_ENABLED)
   2271            /* If DMA Tx and/or DMA Rx Handles are associated to USART Handle, DMA Abort complete callbacks should be initialised
   2272               before any call to DMA Abort functions */
   2273            /* DMA Tx Handle is valid */
   2274            if (husart->hdmatx != NULL)
   \       0x1E   0x6D20             LDR      R0,[R4, #+80]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD00B             BEQ.N    ??HAL_USART_Abort_IT_0
   2275            {
   2276              /* Set DMA Abort Complete callback if USART DMA Tx request if enabled.
   2277                 Otherwise, set it to NULL */
   2278              if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6880             LDR      R0,[R0, #+8]
   \       0x28   0x0600             LSLS     R0,R0,#+24
   \       0x2A   0xD504             BPL.N    ??HAL_USART_Abort_IT_1
   2279              {
   2280                husart->hdmatx->XferAbortCallback = USART_DMATxAbortCallback;
   \       0x2C   0x.... 0x....      ADR.W    R0,USART_DMATxAbortCallback
   \       0x30   0x6D21             LDR      R1,[R4, #+80]
   \       0x32   0x66C8             STR      R0,[R1, #+108]
   \       0x34   0xE002             B.N      ??HAL_USART_Abort_IT_0
   2281              }
   2282              else
   2283              {
   2284                husart->hdmatx->XferAbortCallback = NULL;
   \                     ??HAL_USART_Abort_IT_1: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6D21             LDR      R1,[R4, #+80]
   \       0x3A   0x66C8             STR      R0,[R1, #+108]
   2285              }
   2286            }
   2287            /* DMA Rx Handle is valid */
   2288            if (husart->hdmarx != NULL)
   \                     ??HAL_USART_Abort_IT_0: (+1)
   \       0x3C   0x6D60             LDR      R0,[R4, #+84]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD00B             BEQ.N    ??HAL_USART_Abort_IT_2
   2289            {
   2290              /* Set DMA Abort Complete callback if USART DMA Rx request if enabled.
   2291                 Otherwise, set it to NULL */
   2292              if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x6880             LDR      R0,[R0, #+8]
   \       0x46   0x0640             LSLS     R0,R0,#+25
   \       0x48   0xD504             BPL.N    ??HAL_USART_Abort_IT_3
   2293              {
   2294                husart->hdmarx->XferAbortCallback = USART_DMARxAbortCallback;
   \       0x4A   0x.... 0x....      ADR.W    R0,USART_DMARxAbortCallback
   \       0x4E   0x6D61             LDR      R1,[R4, #+84]
   \       0x50   0x66C8             STR      R0,[R1, #+108]
   \       0x52   0xE002             B.N      ??HAL_USART_Abort_IT_2
   2295              }
   2296              else
   2297              {
   2298                husart->hdmarx->XferAbortCallback = NULL;
   \                     ??HAL_USART_Abort_IT_3: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x6D61             LDR      R1,[R4, #+84]
   \       0x58   0x66C8             STR      R0,[R1, #+108]
   2299              }
   2300            }
   2301          
   2302            /* Abort the USART DMA Tx channel if enabled */
   2303            if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
   \                     ??HAL_USART_Abort_IT_2: (+1)
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x6880             LDR      R0,[R0, #+8]
   \       0x5E   0x0600             LSLS     R0,R0,#+24
   \       0x60   0xD50C             BPL.N    ??HAL_USART_Abort_IT_4
   2304            {
   2305              /* Abort the USART DMA Tx channel : use non blocking DMA Abort API (callback) */
   2306              if (husart->hdmatx != NULL)
   \       0x62   0x6D20             LDR      R0,[R4, #+80]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD009             BEQ.N    ??HAL_USART_Abort_IT_4
   2307              {
   2308                /* USART Tx DMA Abort callback has already been initialised :
   2309                   will lead to call HAL_USART_AbortCpltCallback() at end of DMA abort procedure */
   2310          
   2311                /* Abort DMA TX */
   2312                if (HAL_DMA_Abort_IT(husart->hdmatx) != HAL_OK)
   \       0x68   0x6D20             LDR      R0,[R4, #+80]
   \       0x6A   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD003             BEQ.N    ??HAL_USART_Abort_IT_5
   2313                {
   2314                  husart->hdmatx->XferAbortCallback = NULL;
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x6D21             LDR      R1,[R4, #+80]
   \       0x76   0x66C8             STR      R0,[R1, #+108]
   \       0x78   0xE000             B.N      ??HAL_USART_Abort_IT_4
   2315                }
   2316                else
   2317                {
   2318                  abortcplt = 0U;
   \                     ??HAL_USART_Abort_IT_5: (+1)
   \       0x7A   0x2500             MOVS     R5,#+0
   2319                }
   2320              }
   2321            }
   2322          
   2323            /* Abort the USART DMA Rx channel if enabled */
   2324            if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
   \                     ??HAL_USART_Abort_IT_4: (+1)
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x6880             LDR      R0,[R0, #+8]
   \       0x80   0x0640             LSLS     R0,R0,#+25
   \       0x82   0xD50D             BPL.N    ??HAL_USART_Abort_IT_6
   2325            {
   2326              /* Abort the USART DMA Rx channel : use non blocking DMA Abort API (callback) */
   2327              if (husart->hdmarx != NULL)
   \       0x84   0x6D60             LDR      R0,[R4, #+84]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD00A             BEQ.N    ??HAL_USART_Abort_IT_6
   2328              {
   2329                /* USART Rx DMA Abort callback has already been initialised :
   2330                   will lead to call HAL_USART_AbortCpltCallback() at end of DMA abort procedure */
   2331          
   2332                /* Abort DMA RX */
   2333                if (HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
   \       0x8A   0x6D60             LDR      R0,[R4, #+84]
   \       0x8C   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD004             BEQ.N    ??HAL_USART_Abort_IT_7
   2334                {
   2335                  husart->hdmarx->XferAbortCallback = NULL;
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0x6D61             LDR      R1,[R4, #+84]
   \       0x98   0x66C8             STR      R0,[R1, #+108]
   2336                  abortcplt = 1U;
   \       0x9A   0x2501             MOVS     R5,#+1
   \       0x9C   0xE000             B.N      ??HAL_USART_Abort_IT_6
   2337                }
   2338                else
   2339                {
   2340                  abortcplt = 0U;
   \                     ??HAL_USART_Abort_IT_7: (+1)
   \       0x9E   0x2500             MOVS     R5,#+0
   2341                }
   2342              }
   2343            }
   2344          #endif /* HAL_DMA_MODULE_ENABLED */
   2345          
   2346            /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
   2347            if (abortcplt == 1U)
   \                     ??HAL_USART_Abort_IT_6: (+1)
   \       0xA0   0x2D01             CMP      R5,#+1
   \       0xA2   0xD11E             BNE.N    ??HAL_USART_Abort_IT_8
   2348            {
   2349              /* Reset Tx and Rx transfer counters */
   2350              husart->TxXferCount = 0U;
   \       0xA4   0x2000             MOVS     R0,#+0
   \       0xA6   0x85E0             STRH     R0,[R4, #+46]
   2351              husart->RxXferCount = 0U;
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0x86E0             STRH     R0,[R4, #+54]
   2352          
   2353              /* Reset errorCode */
   2354              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0x65E0             STR      R0,[R4, #+92]
   2355          
   2356              /* Clear the Error flags in the ICR register */
   2357              __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
   \       0xB0   0x200F             MOVS     R0,#+15
   \       0xB2   0x6821             LDR      R1,[R4, #+0]
   \       0xB4   0x6208             STR      R0,[R1, #+32]
   2358          
   2359              /* Flush the whole TX FIFO (if needed) */
   2360              if (husart->FifoMode == USART_FIFOMODE_ENABLE)
   \       0xB6   0x6C60             LDR      R0,[R4, #+68]
   \       0xB8   0xF1B0 0x5F00      CMP      R0,#+536870912
   \       0xBC   0xD105             BNE.N    ??HAL_USART_Abort_IT_9
   2361              {
   2362                __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
   \       0xBE   0x6820             LDR      R0,[R4, #+0]
   \       0xC0   0x6980             LDR      R0,[R0, #+24]
   \       0xC2   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xC6   0x6821             LDR      R1,[R4, #+0]
   \       0xC8   0x6188             STR      R0,[R1, #+24]
   2363              }
   2364          
   2365              /* Discard the received data */
   2366              __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
   \                     ??HAL_USART_Abort_IT_9: (+1)
   \       0xCA   0x6820             LDR      R0,[R4, #+0]
   \       0xCC   0x6980             LDR      R0,[R0, #+24]
   \       0xCE   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xD2   0x6821             LDR      R1,[R4, #+0]
   \       0xD4   0x6188             STR      R0,[R1, #+24]
   2367          
   2368              /* Restore husart->State to Ready */
   2369              husart->State  = HAL_USART_STATE_READY;
   \       0xD6   0x2001             MOVS     R0,#+1
   \       0xD8   0xF884 0x0059      STRB     R0,[R4, #+89]
   2370          
   2371              /* As no DMA to be aborted, call directly user Abort complete callback */
   2372          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2373              /* Call registered Abort Complete Callback */
   2374              husart->AbortCpltCallback(husart);
   2375          #else
   2376              /* Call legacy weak Abort Complete Callback */
   2377              HAL_USART_AbortCpltCallback(husart);
   \       0xDC   0x0020             MOVS     R0,R4
   \       0xDE   0x.... 0x....      BL       HAL_USART_AbortCpltCallback
   2378          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2379            }
   2380          
   2381            return HAL_OK;
   \                     ??HAL_USART_Abort_IT_8: (+1)
   \       0xE2   0x2000             MOVS     R0,#+0
   \       0xE4   0xBD32             POP      {R1,R4,R5,PC}
   2382          }
   2383          
   2384          /**
   2385            * @brief  Handle USART interrupt request.
   2386            * @param  husart USART handle.
   2387            * @retval None
   2388            */

   \                                 In section .text, align 2, keep-with-next
   2389          void HAL_USART_IRQHandler(USART_HandleTypeDef *husart)
   2390          {
   \                     HAL_USART_IRQHandler: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2391            uint32_t isrflags   = READ_REG(husart->Instance->ISR);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x69C1             LDR      R1,[R0, #+28]
   2392            uint32_t cr1its     = READ_REG(husart->Instance->CR1);
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x6802             LDR      R2,[R0, #+0]
   2393            uint32_t cr3its     = READ_REG(husart->Instance->CR3);
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x6883             LDR      R3,[R0, #+8]
   2394          
   2395            uint32_t errorflags;
   2396            uint32_t errorcode;
   2397          
   2398            /* If no error occurs */
   2399            errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF |
   2400                                                USART_ISR_UDR));
   \       0x10   0xF642 0x000F      MOVW     R0,#+10255
   \       0x14   0x4008             ANDS     R0,R0,R1
   2401            if (errorflags == 0U)
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD10C             BNE.N    ??HAL_USART_IRQHandler_0
   2402            {
   2403              /* USART in mode Receiver ---------------------------------------------------*/
   2404              if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
   2405                  && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
   2406                      || ((cr3its & USART_CR3_RXFTIE) != 0U)))
   \       0x1A   0x068D             LSLS     R5,R1,#+26
   \       0x1C   0xD50A             BPL.N    ??HAL_USART_IRQHandler_0
   \       0x1E   0x0695             LSLS     R5,R2,#+26
   \       0x20   0xD401             BMI.N    ??HAL_USART_IRQHandler_1
   \       0x22   0x00DD             LSLS     R5,R3,#+3
   \       0x24   0xD506             BPL.N    ??HAL_USART_IRQHandler_0
   2407              {
   2408                if (husart->RxISR != NULL)
   \                     ??HAL_USART_IRQHandler_1: (+1)
   \       0x26   0x6CA0             LDR      R0,[R4, #+72]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD002             BEQ.N    ??HAL_USART_IRQHandler_2
   2409                {
   2410                  husart->RxISR(husart);
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x6CA1             LDR      R1,[R4, #+72]
   \       0x30   0x4788             BLX      R1
   2411                }
   2412                return;
   \                     ??HAL_USART_IRQHandler_2: (+1)
   \       0x32   0xE0C9             B.N      ??HAL_USART_IRQHandler_3
   2413              }
   2414            }
   2415          
   2416            /* If some errors occur */
   2417            if ((errorflags != 0U)
   2418                && (((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
   2419                    || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE)) != 0U)))
   \                     ??HAL_USART_IRQHandler_0: (+1)
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xF000 0x80A2      BEQ.W    ??HAL_USART_IRQHandler_4
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x3E   0x4203             TST      R3,R0
   \       0x40   0xD103             BNE.N    ??HAL_USART_IRQHandler_5
   \       0x42   0xF412 0x7F90      TST      R2,#0x120
   \       0x46   0xF000 0x809A      BEQ.W    ??HAL_USART_IRQHandler_4
   2420            {
   2421              /* USART parity error interrupt occurred -------------------------------------*/
   2422              if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
   \                     ??HAL_USART_IRQHandler_5: (+1)
   \       0x4A   0x000D             MOVS     R5,R1
   \       0x4C   0x07ED             LSLS     R5,R5,#+31
   \       0x4E   0xD508             BPL.N    ??HAL_USART_IRQHandler_6
   \       0x50   0x05D5             LSLS     R5,R2,#+23
   \       0x52   0xD506             BPL.N    ??HAL_USART_IRQHandler_6
   2423              {
   2424                __HAL_USART_CLEAR_IT(husart, USART_CLEAR_PEF);
   \       0x54   0x2501             MOVS     R5,#+1
   \       0x56   0x6826             LDR      R6,[R4, #+0]
   \       0x58   0x6235             STR      R5,[R6, #+32]
   2425          
   2426                husart->ErrorCode |= HAL_USART_ERROR_PE;
   \       0x5A   0x6DE5             LDR      R5,[R4, #+92]
   \       0x5C   0xF055 0x0501      ORRS     R5,R5,#0x1
   \       0x60   0x65E5             STR      R5,[R4, #+92]
   2427              }
   2428          
   2429              /* USART frame error interrupt occurred --------------------------------------*/
   2430              if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
   \                     ??HAL_USART_IRQHandler_6: (+1)
   \       0x62   0x078D             LSLS     R5,R1,#+30
   \       0x64   0xD509             BPL.N    ??HAL_USART_IRQHandler_7
   \       0x66   0x001D             MOVS     R5,R3
   \       0x68   0x07ED             LSLS     R5,R5,#+31
   \       0x6A   0xD506             BPL.N    ??HAL_USART_IRQHandler_7
   2431              {
   2432                __HAL_USART_CLEAR_IT(husart, USART_CLEAR_FEF);
   \       0x6C   0x2502             MOVS     R5,#+2
   \       0x6E   0x6826             LDR      R6,[R4, #+0]
   \       0x70   0x6235             STR      R5,[R6, #+32]
   2433          
   2434                husart->ErrorCode |= HAL_USART_ERROR_FE;
   \       0x72   0x6DE5             LDR      R5,[R4, #+92]
   \       0x74   0xF055 0x0504      ORRS     R5,R5,#0x4
   \       0x78   0x65E5             STR      R5,[R4, #+92]
   2435              }
   2436          
   2437              /* USART noise error interrupt occurred --------------------------------------*/
   2438              if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
   \                     ??HAL_USART_IRQHandler_7: (+1)
   \       0x7A   0x074D             LSLS     R5,R1,#+29
   \       0x7C   0xD509             BPL.N    ??HAL_USART_IRQHandler_8
   \       0x7E   0x001D             MOVS     R5,R3
   \       0x80   0x07ED             LSLS     R5,R5,#+31
   \       0x82   0xD506             BPL.N    ??HAL_USART_IRQHandler_8
   2439              {
   2440                __HAL_USART_CLEAR_IT(husart, USART_CLEAR_NEF);
   \       0x84   0x2504             MOVS     R5,#+4
   \       0x86   0x6826             LDR      R6,[R4, #+0]
   \       0x88   0x6235             STR      R5,[R6, #+32]
   2441          
   2442                husart->ErrorCode |= HAL_USART_ERROR_NE;
   \       0x8A   0x6DE5             LDR      R5,[R4, #+92]
   \       0x8C   0xF055 0x0502      ORRS     R5,R5,#0x2
   \       0x90   0x65E5             STR      R5,[R4, #+92]
   2443              }
   2444          
   2445              /* USART Over-Run interrupt occurred -----------------------------------------*/
   2446              if (((isrflags & USART_ISR_ORE) != 0U)
   2447                  && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
   2448                      ((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)))
   \                     ??HAL_USART_IRQHandler_8: (+1)
   \       0x92   0x070D             LSLS     R5,R1,#+28
   \       0x94   0xD50A             BPL.N    ??HAL_USART_IRQHandler_9
   \       0x96   0x0695             LSLS     R5,R2,#+26
   \       0x98   0xD401             BMI.N    ??HAL_USART_IRQHandler_10
   \       0x9A   0x4203             TST      R3,R0
   \       0x9C   0xD006             BEQ.N    ??HAL_USART_IRQHandler_9
   2449              {
   2450                __HAL_USART_CLEAR_IT(husart, USART_CLEAR_OREF);
   \                     ??HAL_USART_IRQHandler_10: (+1)
   \       0x9E   0x2008             MOVS     R0,#+8
   \       0xA0   0x6825             LDR      R5,[R4, #+0]
   \       0xA2   0x6228             STR      R0,[R5, #+32]
   2451          
   2452                husart->ErrorCode |= HAL_USART_ERROR_ORE;
   \       0xA4   0x6DE0             LDR      R0,[R4, #+92]
   \       0xA6   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xAA   0x65E0             STR      R0,[R4, #+92]
   2453              }
   2454          
   2455              /* USART Receiver Timeout interrupt occurred ---------------------------------*/
   2456              if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
   \                     ??HAL_USART_IRQHandler_9: (+1)
   \       0xAC   0x0508             LSLS     R0,R1,#+20
   \       0xAE   0xD509             BPL.N    ??HAL_USART_IRQHandler_11
   \       0xB0   0x0150             LSLS     R0,R2,#+5
   \       0xB2   0xD507             BPL.N    ??HAL_USART_IRQHandler_11
   2457              {
   2458                __HAL_USART_CLEAR_IT(husart, USART_CLEAR_RTOF);
   \       0xB4   0xF44F 0x6000      MOV      R0,#+2048
   \       0xB8   0x6825             LDR      R5,[R4, #+0]
   \       0xBA   0x6228             STR      R0,[R5, #+32]
   2459          
   2460                husart->ErrorCode |= HAL_USART_ERROR_RTO;
   \       0xBC   0x6DE0             LDR      R0,[R4, #+92]
   \       0xBE   0xF050 0x0080      ORRS     R0,R0,#0x80
   \       0xC2   0x65E0             STR      R0,[R4, #+92]
   2461              }
   2462          
   2463              /* USART SPI slave underrun error interrupt occurred -------------------------*/
   2464              if (((isrflags & USART_ISR_UDR) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
   \                     ??HAL_USART_IRQHandler_11: (+1)
   \       0xC4   0x0488             LSLS     R0,R1,#+18
   \       0xC6   0xD513             BPL.N    ??HAL_USART_IRQHandler_12
   \       0xC8   0x0018             MOVS     R0,R3
   \       0xCA   0x07C0             LSLS     R0,R0,#+31
   \       0xCC   0xD510             BPL.N    ??HAL_USART_IRQHandler_12
   2465              {
   2466                /* Ignore SPI slave underrun errors when reception is going on */
   2467                if (husart->State == HAL_USART_STATE_BUSY_RX)
   \       0xCE   0xF894 0x0059      LDRB     R0,[R4, #+89]
   \       0xD2   0x2822             CMP      R0,#+34
   \       0xD4   0xD104             BNE.N    ??HAL_USART_IRQHandler_13
   2468                {
   2469                  __HAL_USART_CLEAR_UDRFLAG(husart);
   \       0xD6   0xF44F 0x5000      MOV      R0,#+8192
   \       0xDA   0x6821             LDR      R1,[R4, #+0]
   \       0xDC   0x6208             STR      R0,[R1, #+32]
   2470                  return;
   \       0xDE   0xE073             B.N      ??HAL_USART_IRQHandler_3
   2471                }
   2472                else
   2473                {
   2474                  __HAL_USART_CLEAR_UDRFLAG(husart);
   \                     ??HAL_USART_IRQHandler_13: (+1)
   \       0xE0   0xF44F 0x5000      MOV      R0,#+8192
   \       0xE4   0x6825             LDR      R5,[R4, #+0]
   \       0xE6   0x6228             STR      R0,[R5, #+32]
   2475                  husart->ErrorCode |= HAL_USART_ERROR_UDR;
   \       0xE8   0x6DE0             LDR      R0,[R4, #+92]
   \       0xEA   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0xEE   0x65E0             STR      R0,[R4, #+92]
   2476                }
   2477              }
   2478          
   2479              /* Call USART Error Call back function if need be --------------------------*/
   2480              if (husart->ErrorCode != HAL_USART_ERROR_NONE)
   \                     ??HAL_USART_IRQHandler_12: (+1)
   \       0xF0   0x6DE0             LDR      R0,[R4, #+92]
   \       0xF2   0x2800             CMP      R0,#+0
   \       0xF4   0xD042             BEQ.N    ??HAL_USART_IRQHandler_14
   2481              {
   2482                /* USART in mode Receiver ---------------------------------------------------*/
   2483                if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
   2484                    && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
   2485                        || ((cr3its & USART_CR3_RXFTIE) != 0U)))
   \       0xF6   0x0688             LSLS     R0,R1,#+26
   \       0xF8   0xD509             BPL.N    ??HAL_USART_IRQHandler_15
   \       0xFA   0x0690             LSLS     R0,R2,#+26
   \       0xFC   0xD401             BMI.N    ??HAL_USART_IRQHandler_16
   \       0xFE   0x00D8             LSLS     R0,R3,#+3
   \      0x100   0xD505             BPL.N    ??HAL_USART_IRQHandler_15
   2486                {
   2487                  if (husart->RxISR != NULL)
   \                     ??HAL_USART_IRQHandler_16: (+1)
   \      0x102   0x6CA0             LDR      R0,[R4, #+72]
   \      0x104   0x2800             CMP      R0,#+0
   \      0x106   0xD002             BEQ.N    ??HAL_USART_IRQHandler_15
   2488                  {
   2489                    husart->RxISR(husart);
   \      0x108   0x0020             MOVS     R0,R4
   \      0x10A   0x6CA1             LDR      R1,[R4, #+72]
   \      0x10C   0x4788             BLX      R1
   2490                  }
   2491                }
   2492          
   2493                /* If Overrun error occurs, or if any error occurs in DMA mode reception,
   2494                   consider error as blocking */
   2495                errorcode = husart->ErrorCode & HAL_USART_ERROR_ORE;
   \                     ??HAL_USART_IRQHandler_15: (+1)
   \      0x10E   0x6DE0             LDR      R0,[R4, #+92]
   \      0x110   0xF010 0x0008      ANDS     R0,R0,#0x8
   2496                if ((HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR)) ||
   2497                    (errorcode != 0U))
   \      0x114   0x6821             LDR      R1,[R4, #+0]
   \      0x116   0x6889             LDR      R1,[R1, #+8]
   \      0x118   0x0649             LSLS     R1,R1,#+25
   \      0x11A   0xD401             BMI.N    ??HAL_USART_IRQHandler_17
   \      0x11C   0x2800             CMP      R0,#+0
   \      0x11E   0xD028             BEQ.N    ??HAL_USART_IRQHandler_18
   2498                {
   2499                  /* Blocking error : transfer is aborted
   2500                     Set the USART state ready to be able to start again the process,
   2501                     Disable Interrupts, and disable DMA requests, if ongoing */
   2502                  USART_EndTransfer(husart);
   \                     ??HAL_USART_IRQHandler_17: (+1)
   \      0x120   0x0020             MOVS     R0,R4
   \      0x122   0x.... 0x....      BL       USART_EndTransfer
   2503          
   2504          #if defined(HAL_DMA_MODULE_ENABLED)
   2505                  /* Abort the USART DMA Rx channel if enabled */
   2506                  if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
   \      0x126   0x6820             LDR      R0,[R4, #+0]
   \      0x128   0x6880             LDR      R0,[R0, #+8]
   \      0x12A   0x0640             LSLS     R0,R0,#+25
   \      0x12C   0xD51D             BPL.N    ??HAL_USART_IRQHandler_19
   2507                  {
   2508                    /* Abort the USART DMA Tx channel */
   2509                    if (husart->hdmatx != NULL)
   \      0x12E   0x6D20             LDR      R0,[R4, #+80]
   \      0x130   0x2800             CMP      R0,#+0
   \      0x132   0xD005             BEQ.N    ??HAL_USART_IRQHandler_20
   2510                    {
   2511                      /* Set the USART Tx DMA Abort callback to NULL : no callback
   2512                         executed at end of DMA abort procedure */
   2513                      husart->hdmatx->XferAbortCallback = NULL;
   \      0x134   0x2000             MOVS     R0,#+0
   \      0x136   0x6D21             LDR      R1,[R4, #+80]
   \      0x138   0x66C8             STR      R0,[R1, #+108]
   2514          
   2515                      /* Abort DMA TX */
   2516                      (void)HAL_DMA_Abort_IT(husart->hdmatx);
   \      0x13A   0x6D20             LDR      R0,[R4, #+80]
   \      0x13C   0x.... 0x....      BL       HAL_DMA_Abort_IT
   2517                    }
   2518          
   2519                    /* Abort the USART DMA Rx channel */
   2520                    if (husart->hdmarx != NULL)
   \                     ??HAL_USART_IRQHandler_20: (+1)
   \      0x140   0x6D60             LDR      R0,[R4, #+84]
   \      0x142   0x2800             CMP      R0,#+0
   \      0x144   0xD00D             BEQ.N    ??HAL_USART_IRQHandler_21
   2521                    {
   2522                      /* Set the USART Rx DMA Abort callback :
   2523                         will lead to call HAL_USART_ErrorCallback() at end of DMA abort procedure */
   2524                      husart->hdmarx->XferAbortCallback = USART_DMAAbortOnError;
   \      0x146   0x.... 0x....      ADR.W    R0,USART_DMAAbortOnError
   \      0x14A   0x6D61             LDR      R1,[R4, #+84]
   \      0x14C   0x66C8             STR      R0,[R1, #+108]
   2525          
   2526                      /* Abort DMA RX */
   2527                      if (HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
   \      0x14E   0x6D60             LDR      R0,[R4, #+84]
   \      0x150   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \      0x154   0x2800             CMP      R0,#+0
   \      0x156   0xD011             BEQ.N    ??HAL_USART_IRQHandler_14
   2528                      {
   2529                        /* Call Directly husart->hdmarx->XferAbortCallback function in case of error */
   2530                        husart->hdmarx->XferAbortCallback(husart->hdmarx);
   \      0x158   0x6D60             LDR      R0,[R4, #+84]
   \      0x15A   0x6D61             LDR      R1,[R4, #+84]
   \      0x15C   0x6EC9             LDR      R1,[R1, #+108]
   \      0x15E   0x4788             BLX      R1
   \      0x160   0xE00C             B.N      ??HAL_USART_IRQHandler_14
   2531                      }
   2532                    }
   2533                    else
   2534                    {
   2535                      /* Call user error callback */
   2536          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2537                      /* Call registered Error Callback */
   2538                      husart->ErrorCallback(husart);
   2539          #else
   2540                      /* Call legacy weak Error Callback */
   2541                      HAL_USART_ErrorCallback(husart);
   \                     ??HAL_USART_IRQHandler_21: (+1)
   \      0x162   0x0020             MOVS     R0,R4
   \      0x164   0x.... 0x....      BL       HAL_USART_ErrorCallback
   \      0x168   0xE008             B.N      ??HAL_USART_IRQHandler_14
   2542          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2543                    }
   2544                  }
   2545                  else
   2546          #endif /* HAL_DMA_MODULE_ENABLED */
   2547                  {
   2548                    /* Call user error callback */
   2549          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2550                    /* Call registered Error Callback */
   2551                    husart->ErrorCallback(husart);
   2552          #else
   2553                    /* Call legacy weak Error Callback */
   2554                    HAL_USART_ErrorCallback(husart);
   \                     ??HAL_USART_IRQHandler_19: (+1)
   \      0x16A   0x0020             MOVS     R0,R4
   \      0x16C   0x.... 0x....      BL       HAL_USART_ErrorCallback
   \      0x170   0xE004             B.N      ??HAL_USART_IRQHandler_14
   2555          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2556                  }
   2557                }
   2558                else
   2559                {
   2560                  /* Non Blocking error : transfer could go on.
   2561                     Error is notified to user through user error callback */
   2562          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2563                  /* Call registered Error Callback */
   2564                  husart->ErrorCallback(husart);
   2565          #else
   2566                  /* Call legacy weak Error Callback */
   2567                  HAL_USART_ErrorCallback(husart);
   \                     ??HAL_USART_IRQHandler_18: (+1)
   \      0x172   0x0020             MOVS     R0,R4
   \      0x174   0x.... 0x....      BL       HAL_USART_ErrorCallback
   2568          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2569                  husart->ErrorCode = HAL_USART_ERROR_NONE;
   \      0x178   0x2000             MOVS     R0,#+0
   \      0x17A   0x65E0             STR      R0,[R4, #+92]
   2570                }
   2571              }
   2572              return;
   \                     ??HAL_USART_IRQHandler_14: (+1)
   \      0x17C   0xE024             B.N      ??HAL_USART_IRQHandler_3
   2573          
   2574            } /* End if some error occurs */
   2575          
   2576          
   2577            /* USART in mode Transmitter ------------------------------------------------*/
   2578            if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
   2579                && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
   2580                    || ((cr3its & USART_CR3_TXFTIE) != 0U)))
   \                     ??HAL_USART_IRQHandler_4: (+1)
   \      0x17E   0x0608             LSLS     R0,R1,#+24
   \      0x180   0xD50A             BPL.N    ??HAL_USART_IRQHandler_22
   \      0x182   0x0610             LSLS     R0,R2,#+24
   \      0x184   0xD401             BMI.N    ??HAL_USART_IRQHandler_23
   \      0x186   0x0218             LSLS     R0,R3,#+8
   \      0x188   0xD506             BPL.N    ??HAL_USART_IRQHandler_22
   2581            {
   2582              if (husart->TxISR != NULL)
   \                     ??HAL_USART_IRQHandler_23: (+1)
   \      0x18A   0x6CE0             LDR      R0,[R4, #+76]
   \      0x18C   0x2800             CMP      R0,#+0
   \      0x18E   0xD002             BEQ.N    ??HAL_USART_IRQHandler_24
   2583              {
   2584                husart->TxISR(husart);
   \      0x190   0x0020             MOVS     R0,R4
   \      0x192   0x6CE1             LDR      R1,[R4, #+76]
   \      0x194   0x4788             BLX      R1
   2585              }
   2586              return;
   \                     ??HAL_USART_IRQHandler_24: (+1)
   \      0x196   0xE017             B.N      ??HAL_USART_IRQHandler_3
   2587            }
   2588          
   2589            /* USART in mode Transmitter (transmission end) -----------------------------*/
   2590            if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
   \                     ??HAL_USART_IRQHandler_22: (+1)
   \      0x198   0x0648             LSLS     R0,R1,#+25
   \      0x19A   0xD505             BPL.N    ??HAL_USART_IRQHandler_25
   \      0x19C   0x0650             LSLS     R0,R2,#+25
   \      0x19E   0xD503             BPL.N    ??HAL_USART_IRQHandler_25
   2591            {
   2592              USART_EndTransmit_IT(husart);
   \      0x1A0   0x0020             MOVS     R0,R4
   \      0x1A2   0x.... 0x....      BL       USART_EndTransmit_IT
   2593              return;
   \      0x1A6   0xE00F             B.N      ??HAL_USART_IRQHandler_3
   2594            }
   2595          
   2596            /* USART TX Fifo Empty occurred ----------------------------------------------*/
   2597            if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
   \                     ??HAL_USART_IRQHandler_25: (+1)
   \      0x1A8   0x0208             LSLS     R0,R1,#+8
   \      0x1AA   0xD505             BPL.N    ??HAL_USART_IRQHandler_26
   \      0x1AC   0x0050             LSLS     R0,R2,#+1
   \      0x1AE   0xD503             BPL.N    ??HAL_USART_IRQHandler_26
   2598            {
   2599          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2600              /* Call registered Tx Fifo Empty Callback */
   2601              husart->TxFifoEmptyCallback(husart);
   2602          #else
   2603              /* Call legacy weak Tx Fifo Empty Callback */
   2604              HAL_USARTEx_TxFifoEmptyCallback(husart);
   \      0x1B0   0x0020             MOVS     R0,R4
   \      0x1B2   0x.... 0x....      BL       HAL_USARTEx_TxFifoEmptyCallback
   2605          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2606              return;
   \      0x1B6   0xE007             B.N      ??HAL_USART_IRQHandler_3
   2607            }
   2608          
   2609            /* USART RX Fifo Full occurred ----------------------------------------------*/
   2610            if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
   \                     ??HAL_USART_IRQHandler_26: (+1)
   \      0x1B8   0x01C8             LSLS     R0,R1,#+7
   \      0x1BA   0xD505             BPL.N    ??HAL_USART_IRQHandler_27
   \      0x1BC   0x2A00             CMP      R2,#+0
   \      0x1BE   0xD503             BPL.N    ??HAL_USART_IRQHandler_27
   2611            {
   2612          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2613              /* Call registered Rx Fifo Full Callback */
   2614              husart->RxFifoFullCallback(husart);
   2615          #else
   2616              /* Call legacy weak Rx Fifo Full Callback */
   2617              HAL_USARTEx_RxFifoFullCallback(husart);
   \      0x1C0   0x0020             MOVS     R0,R4
   \      0x1C2   0x.... 0x....      BL       HAL_USARTEx_RxFifoFullCallback
   2618          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2619              return;
   \      0x1C6   0xE7FF             B.N      ??HAL_USART_IRQHandler_3
   2620            }
   2621          }
   \                     ??HAL_USART_IRQHandler_27: (+1)
   \                     ??HAL_USART_IRQHandler_3: (+1)
   \      0x1C8   0xBD70             POP      {R4-R6,PC}
   2622          
   2623          /**
   2624            * @brief Tx Transfer completed callback.
   2625            * @param husart USART handle.
   2626            * @retval None
   2627            */

   \                                 In section .text, align 2
   2628          __weak void HAL_USART_TxCpltCallback(USART_HandleTypeDef *husart)
   2629          {
   2630            /* Prevent unused argument(s) compilation warning */
   2631            UNUSED(husart);
   2632          
   2633            /* NOTE : This function should not be modified, when the callback is needed,
   2634                      the HAL_USART_TxCpltCallback can be implemented in the user file.
   2635             */
   2636          }
   \                     HAL_USART_TxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2637          
   2638          /**
   2639            * @brief  Tx Half Transfer completed callback.
   2640            * @param husart USART handle.
   2641            * @retval None
   2642            */

   \                                 In section .text, align 2
   2643          __weak void HAL_USART_TxHalfCpltCallback(USART_HandleTypeDef *husart)
   2644          {
   2645            /* Prevent unused argument(s) compilation warning */
   2646            UNUSED(husart);
   2647          
   2648            /* NOTE: This function should not be modified, when the callback is needed,
   2649                     the HAL_USART_TxHalfCpltCallback can be implemented in the user file.
   2650             */
   2651          }
   \                     HAL_USART_TxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2652          
   2653          /**
   2654            * @brief  Rx Transfer completed callback.
   2655            * @param husart USART handle.
   2656            * @retval None
   2657            */

   \                                 In section .text, align 2
   2658          __weak void HAL_USART_RxCpltCallback(USART_HandleTypeDef *husart)
   2659          {
   2660            /* Prevent unused argument(s) compilation warning */
   2661            UNUSED(husart);
   2662          
   2663            /* NOTE: This function should not be modified, when the callback is needed,
   2664                     the HAL_USART_RxCpltCallback can be implemented in the user file.
   2665             */
   2666          }
   \                     HAL_USART_RxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2667          
   2668          /**
   2669            * @brief Rx Half Transfer completed callback.
   2670            * @param husart USART handle.
   2671            * @retval None
   2672            */

   \                                 In section .text, align 2
   2673          __weak void HAL_USART_RxHalfCpltCallback(USART_HandleTypeDef *husart)
   2674          {
   2675            /* Prevent unused argument(s) compilation warning */
   2676            UNUSED(husart);
   2677          
   2678            /* NOTE : This function should not be modified, when the callback is needed,
   2679                      the HAL_USART_RxHalfCpltCallback can be implemented in the user file
   2680             */
   2681          }
   \                     HAL_USART_RxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2682          
   2683          /**
   2684            * @brief Tx/Rx Transfers completed callback for the non-blocking process.
   2685            * @param husart USART handle.
   2686            * @retval None
   2687            */

   \                                 In section .text, align 2
   2688          __weak void HAL_USART_TxRxCpltCallback(USART_HandleTypeDef *husart)
   2689          {
   2690            /* Prevent unused argument(s) compilation warning */
   2691            UNUSED(husart);
   2692          
   2693            /* NOTE : This function should not be modified, when the callback is needed,
   2694                      the HAL_USART_TxRxCpltCallback can be implemented in the user file
   2695             */
   2696          }
   \                     HAL_USART_TxRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2697          
   2698          /**
   2699            * @brief USART error callback.
   2700            * @param husart USART handle.
   2701            * @retval None
   2702            */

   \                                 In section .text, align 2
   2703          __weak void HAL_USART_ErrorCallback(USART_HandleTypeDef *husart)
   2704          {
   2705            /* Prevent unused argument(s) compilation warning */
   2706            UNUSED(husart);
   2707          
   2708            /* NOTE : This function should not be modified, when the callback is needed,
   2709                      the HAL_USART_ErrorCallback can be implemented in the user file.
   2710             */
   2711          }
   \                     HAL_USART_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR
   2712          
   2713          /**
   2714            * @brief  USART Abort Complete callback.
   2715            * @param  husart USART handle.
   2716            * @retval None
   2717            */

   \                                 In section .text, align 2
   2718          __weak void HAL_USART_AbortCpltCallback(USART_HandleTypeDef *husart)
   2719          {
   2720            /* Prevent unused argument(s) compilation warning */
   2721            UNUSED(husart);
   2722          
   2723            /* NOTE : This function should not be modified, when the callback is needed,
   2724                      the HAL_USART_AbortCpltCallback can be implemented in the user file.
   2725             */
   2726          }
   \                     HAL_USART_AbortCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2727          
   2728          /**
   2729            * @}
   2730            */
   2731          
   2732          /** @defgroup USART_Exported_Functions_Group4 Peripheral State and Error functions
   2733            *  @brief   USART Peripheral State and Error functions
   2734            *
   2735          @verbatim
   2736            ==============================================================================
   2737                      ##### Peripheral State and Error functions #####
   2738            ==============================================================================
   2739              [..]
   2740              This subsection provides functions allowing to :
   2741                (+) Return the USART handle state
   2742                (+) Return the USART handle error code
   2743          
   2744          @endverbatim
   2745            * @{
   2746            */
   2747          
   2748          
   2749          /**
   2750            * @brief Return the USART handle state.
   2751            * @param husart pointer to a USART_HandleTypeDef structure that contains
   2752            *              the configuration information for the specified USART.
   2753            * @retval USART handle state
   2754            */

   \                                 In section .text, align 2, keep-with-next
   2755          HAL_USART_StateTypeDef HAL_USART_GetState(const USART_HandleTypeDef *husart)
   2756          {
   2757            return husart->State;
   \                     HAL_USART_GetState: (+1)
   \        0x0   0xF890 0x0059      LDRB     R0,[R0, #+89]
   \        0x4   0x4770             BX       LR
   2758          }
   2759          
   2760          /**
   2761            * @brief Return the USART error code.
   2762            * @param husart pointer to a USART_HandleTypeDef structure that contains
   2763            *              the configuration information for the specified USART.
   2764            * @retval USART handle Error Code
   2765            */

   \                                 In section .text, align 2, keep-with-next
   2766          uint32_t HAL_USART_GetError(const USART_HandleTypeDef *husart)
   2767          {
   2768            return husart->ErrorCode;
   \                     HAL_USART_GetError: (+1)
   \        0x0   0x6DC0             LDR      R0,[R0, #+92]
   \        0x2   0x4770             BX       LR
   2769          }
   2770          
   2771          /**
   2772            * @}
   2773            */
   2774          
   2775          /**
   2776            * @}
   2777            */
   2778          
   2779          /** @defgroup USART_Private_Functions USART Private Functions
   2780            * @{
   2781            */
   2782          
   2783          /**
   2784            * @brief  Initialize the callbacks to their default values.
   2785            * @param  husart USART handle.
   2786            * @retval none
   2787            */
   2788          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2789          void USART_InitCallbacksToDefault(USART_HandleTypeDef *husart)
   2790          {
   2791            /* Init the USART Callback settings */
   2792            husart->TxHalfCpltCallback        = HAL_USART_TxHalfCpltCallback;        /* Legacy weak TxHalfCpltCallback        */
   2793            husart->TxCpltCallback            = HAL_USART_TxCpltCallback;            /* Legacy weak TxCpltCallback            */
   2794            husart->RxHalfCpltCallback        = HAL_USART_RxHalfCpltCallback;        /* Legacy weak RxHalfCpltCallback        */
   2795            husart->RxCpltCallback            = HAL_USART_RxCpltCallback;            /* Legacy weak RxCpltCallback            */
   2796            husart->TxRxCpltCallback          = HAL_USART_TxRxCpltCallback;          /* Legacy weak TxRxCpltCallback          */
   2797            husart->ErrorCallback             = HAL_USART_ErrorCallback;             /* Legacy weak ErrorCallback             */
   2798            husart->AbortCpltCallback         = HAL_USART_AbortCpltCallback;         /* Legacy weak AbortCpltCallback         */
   2799            husart->RxFifoFullCallback        = HAL_USARTEx_RxFifoFullCallback;      /* Legacy weak RxFifoFullCallback        */
   2800            husart->TxFifoEmptyCallback       = HAL_USARTEx_TxFifoEmptyCallback;     /* Legacy weak TxFifoEmptyCallback       */
   2801          }
   2802          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2803          
   2804          /**
   2805            * @brief  End ongoing transfer on USART peripheral (following error detection or Transfer completion).
   2806            * @param  husart USART handle.
   2807            * @retval None
   2808            */

   \                                 In section .text, align 2, keep-with-next
   2809          static void USART_EndTransfer(USART_HandleTypeDef *husart)
   2810          {
   2811            /* Disable TXEIE, TCIE, RXNE, RXFT, TXFT, PE and ERR (Frame error, noise error, overrun error) interrupts */
   2812            CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE |
   2813                                              USART_CR1_TCIE));
   \                     USART_EndTransfer: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x6809             LDR      R1,[R1, #+0]
   \        0x4   0xF431 0x71F0      BICS     R1,R1,#0x1E0
   \        0x8   0x6802             LDR      R2,[R0, #+0]
   \        0xA   0x6011             STR      R1,[R2, #+0]
   2814            CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0x688A             LDR      R2,[R1, #+8]
   \       0x10   0x....             LDR.N    R1,??DataTable7
   \       0x12   0x400A             ANDS     R2,R1,R2
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0x608A             STR      R2,[R1, #+8]
   2815          
   2816            /* At end of process, restore husart->State to Ready */
   2817            husart->State = HAL_USART_STATE_READY;
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0xF880 0x1059      STRB     R1,[R0, #+89]
   2818          }
   \       0x1E   0x4770             BX       LR
   2819          
   2820          #if defined(HAL_DMA_MODULE_ENABLED)
   2821          /**
   2822            * @brief DMA USART transmit process complete callback.
   2823            * @param  hdma DMA handle.
   2824            * @retval None
   2825            */

   \                                 In section .text, align 4, keep-with-next
   2826          static void USART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   2827          {
   \                     USART_DMATransmitCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2828            USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6DC1             LDR      R1,[R0, #+92]
   2829          
   2830            /* Check if DMA in circular mode */
   2831            if (hdma->Mode != DMA_LINKEDLIST_CIRCULAR)
   \        0x4   0x6D00             LDR      R0,[R0, #+80]
   \        0x6   0x2881             CMP      R0,#+129
   \        0x8   0xD00C             BEQ.N    ??USART_DMATransmitCplt_0
   2832            {
   2833              husart->TxXferCount = 0U;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x85C8             STRH     R0,[R1, #+46]
   2834          
   2835              if (husart->State == HAL_USART_STATE_BUSY_TX)
   \        0xE   0xF891 0x0059      LDRB     R0,[R1, #+89]
   \       0x12   0x2812             CMP      R0,#+18
   \       0x14   0xD10D             BNE.N    ??USART_DMATransmitCplt_1
   2836              {
   2837                /* Enable the USART Transmit Complete Interrupt */
   2838                __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
   \       0x16   0x6808             LDR      R0,[R1, #+0]
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x1E   0x6809             LDR      R1,[R1, #+0]
   \       0x20   0x6008             STR      R0,[R1, #+0]
   \       0x22   0xE006             B.N      ??USART_DMATransmitCplt_1
   2839              }
   2840            }
   2841            /* DMA Circular mode */
   2842            else
   2843            {
   2844              if (husart->State == HAL_USART_STATE_BUSY_TX)
   \                     ??USART_DMATransmitCplt_0: (+1)
   \       0x24   0xF891 0x0059      LDRB     R0,[R1, #+89]
   \       0x28   0x2812             CMP      R0,#+18
   \       0x2A   0xD102             BNE.N    ??USART_DMATransmitCplt_1
   2845              {
   2846          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2847                /* Call registered Tx Complete Callback */
   2848                husart->TxCpltCallback(husart);
   2849          #else
   2850                /* Call legacy weak Tx Complete Callback */
   2851                HAL_USART_TxCpltCallback(husart);
   \       0x2C   0x0008             MOVS     R0,R1
   \       0x2E   0x.... 0x....      BL       HAL_USART_TxCpltCallback
   2852          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2853              }
   2854            }
   2855          }
   \                     ??USART_DMATransmitCplt_1: (+1)
   \       0x32   0xBD01             POP      {R0,PC}
   2856          
   2857          /**
   2858            * @brief DMA USART transmit process half complete callback.
   2859            * @param  hdma DMA handle.
   2860            * @retval None
   2861            */

   \                                 In section .text, align 4, keep-with-next
   2862          static void USART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   2863          {
   \                     USART_DMATxHalfCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2864            USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6DC0             LDR      R0,[R0, #+92]
   2865          
   2866          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2867            /* Call registered Tx Half Complete Callback */
   2868            husart->TxHalfCpltCallback(husart);
   2869          #else
   2870            /* Call legacy weak Tx Half Complete Callback */
   2871            HAL_USART_TxHalfCpltCallback(husart);
   \        0x4   0x.... 0x....      BL       HAL_USART_TxHalfCpltCallback
   2872          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2873          }
   \        0x8   0xBD01             POP      {R0,PC}
   2874          
   2875          /**
   2876            * @brief DMA USART receive process complete callback.
   2877            * @param  hdma DMA handle.
   2878            * @retval None
   2879            */

   \                                 In section .text, align 4, keep-with-next
   2880          static void USART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   2881          {
   \                     USART_DMAReceiveCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   2882            USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6DC4             LDR      R4,[R0, #+92]
   2883          
   2884            /* Check if DMA in circular mode*/
   2885            if (hdma->Mode != DMA_LINKEDLIST_CIRCULAR)
   \        0x4   0x6D00             LDR      R0,[R0, #+80]
   \        0x6   0x2881             CMP      R0,#+129
   \        0x8   0xD01C             BEQ.N    ??USART_DMAReceiveCplt_0
   2886            {
   2887              husart->RxXferCount = 0U;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x86E0             STRH     R0,[R4, #+54]
   2888          
   2889              /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
   2890              CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0x16   0x6821             LDR      R1,[R4, #+0]
   \       0x18   0x6008             STR      R0,[R1, #+0]
   2891              CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x6880             LDR      R0,[R0, #+8]
   \       0x1E   0x0840             LSRS     R0,R0,#+1
   \       0x20   0x0040             LSLS     R0,R0,#+1
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x6088             STR      R0,[R1, #+8]
   2892          
   2893              if (husart->State == HAL_USART_STATE_BUSY_RX)
   \       0x26   0xF894 0x0059      LDRB     R0,[R4, #+89]
   \       0x2A   0x2822             CMP      R0,#+34
   \       0x2C   0xD103             BNE.N    ??USART_DMAReceiveCplt_1
   2894              {
   2895          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2896                /* Call registered Rx Complete Callback */
   2897                husart->RxCpltCallback(husart);
   2898          #else
   2899                /* Call legacy weak Rx Complete Callback */
   2900                HAL_USART_RxCpltCallback(husart);
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       HAL_USART_RxCpltCallback
   \       0x34   0xE002             B.N      ??USART_DMAReceiveCplt_2
   2901          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2902              }
   2903              /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
   2904              else
   2905              {
   2906          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2907                /* Call registered Tx Rx Complete Callback */
   2908                husart->TxRxCpltCallback(husart);
   2909          #else
   2910                /* Call legacy weak Tx Rx Complete Callback */
   2911                HAL_USART_TxRxCpltCallback(husart);
   \                     ??USART_DMAReceiveCplt_1: (+1)
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x.... 0x....      BL       HAL_USART_TxRxCpltCallback
   2912          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2913              }
   2914              husart->State = HAL_USART_STATE_READY;
   \                     ??USART_DMAReceiveCplt_2: (+1)
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xF884 0x0059      STRB     R0,[R4, #+89]
   \       0x42   0xE00A             B.N      ??USART_DMAReceiveCplt_3
   2915            }
   2916            /* DMA circular mode */
   2917            else
   2918            {
   2919              if (husart->State == HAL_USART_STATE_BUSY_RX)
   \                     ??USART_DMAReceiveCplt_0: (+1)
   \       0x44   0xF894 0x0059      LDRB     R0,[R4, #+89]
   \       0x48   0x2822             CMP      R0,#+34
   \       0x4A   0xD103             BNE.N    ??USART_DMAReceiveCplt_4
   2920              {
   2921          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2922                /* Call registered Rx Complete Callback */
   2923                husart->RxCpltCallback(husart);
   2924          #else
   2925                /* Call legacy weak Rx Complete Callback */
   2926                HAL_USART_RxCpltCallback(husart);
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x.... 0x....      BL       HAL_USART_RxCpltCallback
   \       0x52   0xE002             B.N      ??USART_DMAReceiveCplt_3
   2927          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2928              }
   2929              /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
   2930              else
   2931              {
   2932          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2933                /* Call registered Tx Rx Complete Callback */
   2934                husart->TxRxCpltCallback(husart);
   2935          #else
   2936                /* Call legacy weak Tx Rx Complete Callback */
   2937                HAL_USART_TxRxCpltCallback(husart);
   \                     ??USART_DMAReceiveCplt_4: (+1)
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0x.... 0x....      BL       HAL_USART_TxRxCpltCallback
   2938          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2939              }
   2940            }
   2941          }
   \                     ??USART_DMAReceiveCplt_3: (+1)
   \       0x5A   0xBD10             POP      {R4,PC}
   2942          
   2943          /**
   2944            * @brief DMA USART receive process half complete callback.
   2945            * @param  hdma DMA handle.
   2946            * @retval None
   2947            */

   \                                 In section .text, align 4, keep-with-next
   2948          static void USART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   2949          {
   \                     USART_DMARxHalfCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2950            USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6DC0             LDR      R0,[R0, #+92]
   2951          
   2952          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2953            /* Call registered Rx Half Complete Callback */
   2954            husart->RxHalfCpltCallback(husart);
   2955          #else
   2956            /* Call legacy weak Rx Half Complete Callback */
   2957            HAL_USART_RxHalfCpltCallback(husart);
   \        0x4   0x.... 0x....      BL       HAL_USART_RxHalfCpltCallback
   2958          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2959          }
   \        0x8   0xBD01             POP      {R0,PC}
   2960          
   2961          /**
   2962            * @brief DMA USART communication error callback.
   2963            * @param  hdma DMA handle.
   2964            * @retval None
   2965            */

   \                                 In section .text, align 4, keep-with-next
   2966          static void USART_DMAError(DMA_HandleTypeDef *hdma)
   2967          {
   \                     USART_DMAError: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   2968            USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6DC4             LDR      R4,[R0, #+92]
   2969          
   2970            husart->RxXferCount = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x86E0             STRH     R0,[R4, #+54]
   2971            husart->TxXferCount = 0U;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x85E0             STRH     R0,[R4, #+46]
   2972            USART_EndTransfer(husart);
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x.... 0x....      BL       USART_EndTransfer
   2973          
   2974            husart->ErrorCode |= HAL_USART_ERROR_DMA;
   \       0x12   0x6DE0             LDR      R0,[R4, #+92]
   \       0x14   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x18   0x65E0             STR      R0,[R4, #+92]
   2975            husart->State = HAL_USART_STATE_READY;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xF884 0x0059      STRB     R0,[R4, #+89]
   2976          
   2977          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2978            /* Call registered Error Callback */
   2979            husart->ErrorCallback(husart);
   2980          #else
   2981            /* Call legacy weak Error Callback */
   2982            HAL_USART_ErrorCallback(husart);
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       HAL_USART_ErrorCallback
   2983          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   2984          }
   \       0x26   0xBD10             POP      {R4,PC}
   2985          
   2986          /**
   2987            * @brief  DMA USART communication abort callback, when initiated by HAL services on Error
   2988            *         (To be called at end of DMA Abort procedure following error occurrence).
   2989            * @param  hdma DMA handle.
   2990            * @retval None
   2991            */

   \                                 In section .text, align 4, keep-with-next
   2992          static void USART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
   2993          {
   \                     USART_DMAAbortOnError: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2994            USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6DC0             LDR      R0,[R0, #+92]
   2995            husart->RxXferCount = 0U;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x86C1             STRH     R1,[R0, #+54]
   2996            husart->TxXferCount = 0U;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x85C1             STRH     R1,[R0, #+46]
   2997          
   2998          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   2999            /* Call registered Error Callback */
   3000            husart->ErrorCallback(husart);
   3001          #else
   3002            /* Call legacy weak Error Callback */
   3003            HAL_USART_ErrorCallback(husart);
   \        0xC   0x.... 0x....      BL       HAL_USART_ErrorCallback
   3004          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   3005          }
   \       0x10   0xBD01             POP      {R0,PC}
   3006          
   3007          /**
   3008            * @brief  DMA USART Tx communication abort callback, when initiated by user
   3009            *         (To be called at end of DMA Tx Abort procedure following user abort request).
   3010            * @note   When this callback is executed, User Abort complete call back is called only if no
   3011            *         Abort still ongoing for Rx DMA Handle.
   3012            * @param  hdma DMA handle.
   3013            * @retval None
   3014            */

   \                                 In section .text, align 4, keep-with-next
   3015          static void USART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
   3016          {
   \                     USART_DMATxAbortCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3017            USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6DC0             LDR      R0,[R0, #+92]
   3018          
   3019            husart->hdmatx->XferAbortCallback = NULL;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6D02             LDR      R2,[R0, #+80]
   \        0x8   0x66D1             STR      R1,[R2, #+108]
   3020          
   3021            /* Check if an Abort process is still ongoing */
   3022            if (husart->hdmarx != NULL)
   \        0xA   0x6D41             LDR      R1,[R0, #+84]
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD003             BEQ.N    ??USART_DMATxAbortCallback_0
   3023            {
   3024              if (husart->hdmarx->XferAbortCallback != NULL)
   \       0x10   0x6D41             LDR      R1,[R0, #+84]
   \       0x12   0x6EC9             LDR      R1,[R1, #+108]
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD10D             BNE.N    ??USART_DMATxAbortCallback_1
   3025              {
   3026                return;
   3027              }
   3028            }
   3029          
   3030            /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
   3031            husart->TxXferCount = 0U;
   \                     ??USART_DMATxAbortCallback_0: (+1)
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x85C1             STRH     R1,[R0, #+46]
   3032            husart->RxXferCount = 0U;
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x86C1             STRH     R1,[R0, #+54]
   3033          
   3034            /* Reset errorCode */
   3035            husart->ErrorCode = HAL_USART_ERROR_NONE;
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x65C1             STR      R1,[R0, #+92]
   3036          
   3037            /* Clear the Error flags in the ICR register */
   3038            __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
   \       0x24   0x210F             MOVS     R1,#+15
   \       0x26   0x6802             LDR      R2,[R0, #+0]
   \       0x28   0x6211             STR      R1,[R2, #+32]
   3039          
   3040            /* Restore husart->State to Ready */
   3041            husart->State = HAL_USART_STATE_READY;
   \       0x2A   0x2101             MOVS     R1,#+1
   \       0x2C   0xF880 0x1059      STRB     R1,[R0, #+89]
   3042          
   3043            /* Call user Abort complete callback */
   3044          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   3045            /* Call registered Abort Complete Callback */
   3046            husart->AbortCpltCallback(husart);
   3047          #else
   3048            /* Call legacy weak Abort Complete Callback */
   3049            HAL_USART_AbortCpltCallback(husart);
   \       0x30   0x.... 0x....      BL       HAL_USART_AbortCpltCallback
   3050          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   3051          
   3052          }
   \                     ??USART_DMATxAbortCallback_1: (+1)
   \       0x34   0xBD01             POP      {R0,PC}
   3053          
   3054          
   3055          /**
   3056            * @brief  DMA USART Rx communication abort callback, when initiated by user
   3057            *         (To be called at end of DMA Rx Abort procedure following user abort request).
   3058            * @note   When this callback is executed, User Abort complete call back is called only if no
   3059            *         Abort still ongoing for Tx DMA Handle.
   3060            * @param  hdma DMA handle.
   3061            * @retval None
   3062            */

   \                                 In section .text, align 4, keep-with-next
   3063          static void USART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
   3064          {
   \                     USART_DMARxAbortCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3065            USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6DC0             LDR      R0,[R0, #+92]
   3066          
   3067            husart->hdmarx->XferAbortCallback = NULL;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6D42             LDR      R2,[R0, #+84]
   \        0x8   0x66D1             STR      R1,[R2, #+108]
   3068          
   3069            /* Check if an Abort process is still ongoing */
   3070            if (husart->hdmatx != NULL)
   \        0xA   0x6D01             LDR      R1,[R0, #+80]
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD003             BEQ.N    ??USART_DMARxAbortCallback_0
   3071            {
   3072              if (husart->hdmatx->XferAbortCallback != NULL)
   \       0x10   0x6D01             LDR      R1,[R0, #+80]
   \       0x12   0x6EC9             LDR      R1,[R1, #+108]
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD10D             BNE.N    ??USART_DMARxAbortCallback_1
   3073              {
   3074                return;
   3075              }
   3076            }
   3077          
   3078            /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
   3079            husart->TxXferCount = 0U;
   \                     ??USART_DMARxAbortCallback_0: (+1)
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x85C1             STRH     R1,[R0, #+46]
   3080            husart->RxXferCount = 0U;
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x86C1             STRH     R1,[R0, #+54]
   3081          
   3082            /* Reset errorCode */
   3083            husart->ErrorCode = HAL_USART_ERROR_NONE;
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x65C1             STR      R1,[R0, #+92]
   3084          
   3085            /* Clear the Error flags in the ICR register */
   3086            __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
   \       0x24   0x210F             MOVS     R1,#+15
   \       0x26   0x6802             LDR      R2,[R0, #+0]
   \       0x28   0x6211             STR      R1,[R2, #+32]
   3087          
   3088            /* Restore husart->State to Ready */
   3089            husart->State  = HAL_USART_STATE_READY;
   \       0x2A   0x2101             MOVS     R1,#+1
   \       0x2C   0xF880 0x1059      STRB     R1,[R0, #+89]
   3090          
   3091            /* Call user Abort complete callback */
   3092          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   3093            /* Call registered Abort Complete Callback */
   3094            husart->AbortCpltCallback(husart);
   3095          #else
   3096            /* Call legacy weak Abort Complete Callback */
   3097            HAL_USART_AbortCpltCallback(husart);
   \       0x30   0x.... 0x....      BL       HAL_USART_AbortCpltCallback
   3098          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   3099          }
   \                     ??USART_DMARxAbortCallback_1: (+1)
   \       0x34   0xBD01             POP      {R0,PC}
   3100          
   3101          #endif /* HAL_DMA_MODULE_ENABLED */
   3102          
   3103          /**
   3104            * @brief  Handle USART Communication Timeout. It waits
   3105            *         until a flag is no longer in the specified status.
   3106            * @param  husart USART handle.
   3107            * @param  Flag Specifies the USART flag to check.
   3108            * @param  Status the actual Flag status (SET or RESET).
   3109            * @param  Tickstart Tick start value
   3110            * @param  Timeout timeout duration.
   3111            * @retval HAL status
   3112            */

   \                                 In section .text, align 2, keep-with-next
   3113          static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status,
   3114                                                                uint32_t Tickstart, uint32_t Timeout)
   3115          {
   \                     USART_WaitOnFlagUntilTimeout: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0x9C06             LDR      R4,[SP, #+24]
   3116            /* Wait until flag is set */
   3117            while ((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
   \                     ??USART_WaitOnFlagUntilTimeout_0: (+1)
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x69C0             LDR      R0,[R0, #+28]
   \       0x12   0x4030             ANDS     R0,R6,R0
   \       0x14   0x42B0             CMP      R0,R6
   \       0x16   0xD101             BNE.N    ??USART_WaitOnFlagUntilTimeout_1
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE000             B.N      ??USART_WaitOnFlagUntilTimeout_2
   \                     ??USART_WaitOnFlagUntilTimeout_1: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??USART_WaitOnFlagUntilTimeout_2: (+1)
   \       0x1E   0x4641             MOV      R1,R8
   \       0x20   0xB2C9             UXTB     R1,R1
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD111             BNE.N    ??USART_WaitOnFlagUntilTimeout_3
   3118            {
   3119              /* Check for the Timeout */
   3120              if (Timeout != HAL_MAX_DELAY)
   \       0x26   0xF114 0x0F01      CMN      R4,#+1
   \       0x2A   0xD0F0             BEQ.N    ??USART_WaitOnFlagUntilTimeout_0
   3121              {
   3122                if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x2C   0x.... 0x....      BL       HAL_GetTick
   \       0x30   0x1BC0             SUBS     R0,R0,R7
   \       0x32   0x4284             CMP      R4,R0
   \       0x34   0xD301             BCC.N    ??USART_WaitOnFlagUntilTimeout_4
   \       0x36   0x2C00             CMP      R4,#+0
   \       0x38   0xD1E9             BNE.N    ??USART_WaitOnFlagUntilTimeout_0
   3123                {
   3124                  husart->State = HAL_USART_STATE_READY;
   \                     ??USART_WaitOnFlagUntilTimeout_4: (+1)
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xF885 0x0059      STRB     R0,[R5, #+89]
   3125          
   3126                  /* Process Unlocked */
   3127                  __HAL_UNLOCK(husart);
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xF885 0x0058      STRB     R0,[R5, #+88]
   3128          
   3129                  return HAL_TIMEOUT;
   \       0x46   0x2003             MOVS     R0,#+3
   \       0x48   0xE000             B.N      ??USART_WaitOnFlagUntilTimeout_5
   3130                }
   3131              }
   3132            }
   3133            return HAL_OK;
   \                     ??USART_WaitOnFlagUntilTimeout_3: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   \                     ??USART_WaitOnFlagUntilTimeout_5: (+1)
   \       0x4C   0xE8BD 0x81F0      POP      {R4-R8,PC}
   3134          }
   3135          
   3136          /**
   3137            * @brief Configure the USART peripheral.
   3138            * @param husart USART handle.
   3139            * @retval HAL status
   3140            */

   \                                 In section .text, align 2, keep-with-next
   3141          static HAL_StatusTypeDef USART_SetConfig(USART_HandleTypeDef *husart)
   3142          {
   \                     USART_SetConfig: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x0004             MOVS     R4,R0
   3143            uint32_t tmpreg;
   3144            USART_ClockSourceTypeDef clocksource;
   3145            HAL_StatusTypeDef ret                = HAL_OK;
   \        0x6   0x2500             MOVS     R5,#+0
   3146            uint16_t brrtemp;
   3147            uint32_t usartdiv                    = 0x00000000;
   \        0x8   0x2100             MOVS     R1,#+0
   3148            PLL2_ClocksTypeDef pll2_clocks;
   3149          #if defined(RCC_CR_PLL3ON)
   3150            PLL3_ClocksTypeDef pll3_clocks;
   3151          #endif /* RCC_CR_PLL3ON */
   3152            uint32_t pclk;
   3153          
   3154            /* Check the parameters */
   3155            assert_param(IS_USART_POLARITY(husart->Init.CLKPolarity));
   3156            assert_param(IS_USART_PHASE(husart->Init.CLKPhase));
   3157            assert_param(IS_USART_LASTBIT(husart->Init.CLKLastBit));
   3158            assert_param(IS_USART_BAUDRATE(husart->Init.BaudRate));
   3159            assert_param(IS_USART_WORD_LENGTH(husart->Init.WordLength));
   3160            assert_param(IS_USART_STOPBITS(husart->Init.StopBits));
   3161            assert_param(IS_USART_PARITY(husart->Init.Parity));
   3162            assert_param(IS_USART_MODE(husart->Init.Mode));
   3163            assert_param(IS_USART_PRESCALER(husart->Init.ClockPrescaler));
   3164          
   3165            /*-------------------------- USART CR1 Configuration -----------------------*/
   3166            /* Clear M, PCE, PS, TE and RE bits and configure
   3167            *  the USART Word Length, Parity and Mode:
   3168            *  set the M bits according to husart->Init.WordLength value
   3169            *  set PCE and PS bits according to husart->Init.Parity value
   3170            *  set TE and RE bits according to husart->Init.Mode value
   3171            *  force OVER8 to 1 to allow to reach the maximum speed (Fclock/8) */
   3172            tmpreg = (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode | USART_CR1_OVER8;
   \        0xA   0x68A3             LDR      R3,[R4, #+8]
   \        0xC   0x6920             LDR      R0,[R4, #+16]
   \        0xE   0x4303             ORRS     R3,R0,R3
   \       0x10   0x6962             LDR      R2,[R4, #+20]
   \       0x12   0x431A             ORRS     R2,R2,R3
   \       0x14   0xF452 0x4200      ORRS     R2,R2,#0x8000
   3173            MODIFY_REG(husart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x6803             LDR      R3,[R0, #+0]
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \       0x20   0x4003             ANDS     R3,R0,R3
   \       0x22   0x431A             ORRS     R2,R2,R3
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6002             STR      R2,[R0, #+0]
   3174          
   3175            /*---------------------------- USART CR2 Configuration ---------------------*/
   3176            /* Clear and configure the USART Clock, CPOL, CPHA, LBCL STOP and SLVEN bits:
   3177             * set CPOL bit according to husart->Init.CLKPolarity value
   3178             * set CPHA bit according to husart->Init.CLKPhase value
   3179             * set LBCL bit according to husart->Init.CLKLastBit value (used in SPI master mode only)
   3180             * set STOP[13:12] bits according to husart->Init.StopBits value */
   3181            tmpreg = (uint32_t)(USART_CLOCK_ENABLE);
   \       0x28   0xF44F 0x6200      MOV      R2,#+2048
   3182            tmpreg |= (uint32_t)husart->Init.CLKLastBit;
   \       0x2C   0x6A20             LDR      R0,[R4, #+32]
   \       0x2E   0x4302             ORRS     R2,R0,R2
   3183            tmpreg |= ((uint32_t)husart->Init.CLKPolarity | (uint32_t)husart->Init.CLKPhase);
   \       0x30   0x69A0             LDR      R0,[R4, #+24]
   \       0x32   0x4302             ORRS     R2,R0,R2
   \       0x34   0x69E0             LDR      R0,[R4, #+28]
   \       0x36   0x4302             ORRS     R2,R0,R2
   3184            tmpreg |= (uint32_t)husart->Init.StopBits;
   \       0x38   0x68E0             LDR      R0,[R4, #+12]
   \       0x3A   0x4302             ORRS     R2,R0,R2
   3185            MODIFY_REG(husart->Instance->CR2, USART_CR2_FIELDS, tmpreg);
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6843             LDR      R3,[R0, #+4]
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \       0x44   0x4003             ANDS     R3,R0,R3
   \       0x46   0x431A             ORRS     R2,R2,R3
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x6042             STR      R2,[R0, #+4]
   3186          
   3187            /*-------------------------- USART PRESC Configuration -----------------------*/
   3188            /* Configure
   3189             * - USART Clock Prescaler : set PRESCALER according to husart->Init.ClockPrescaler value */
   3190            MODIFY_REG(husart->Instance->PRESC, USART_PRESC_PRESCALER, husart->Init.ClockPrescaler);
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x6AC2             LDR      R2,[R0, #+44]
   \       0x50   0x0912             LSRS     R2,R2,#+4
   \       0x52   0x0112             LSLS     R2,R2,#+4
   \       0x54   0x6A60             LDR      R0,[R4, #+36]
   \       0x56   0x4302             ORRS     R2,R0,R2
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x62C2             STR      R2,[R0, #+44]
   3191          
   3192            /*-------------------------- USART BRR Configuration -----------------------*/
   3193            /* BRR is filled-up according to OVER8 bit setting which is forced to 1     */
   3194            USART_GETCLOCKSOURCE(husart, clocksource);
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x.... 0x....      LDR.W    R2,??DataTable8_3
   \       0x62   0x4290             CMP      R0,R2
   \       0x64   0xD11D             BNE.N    ??USART_SetConfig_0
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable9
   \       0x6A   0x6800             LDR      R0,[R0, #+0]
   \       0x6C   0xF010 0x0007      ANDS     R0,R0,#0x7
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD008             BEQ.N    ??USART_SetConfig_1
   \       0x74   0x2802             CMP      R0,#+2
   \       0x76   0xD010             BEQ.N    ??USART_SetConfig_2
   \       0x78   0xD30D             BCC.N    ??USART_SetConfig_3
   \       0x7A   0x2804             CMP      R0,#+4
   \       0x7C   0xD005             BEQ.N    ??USART_SetConfig_4
   \       0x7E   0xD306             BCC.N    ??USART_SetConfig_5
   \       0x80   0x2805             CMP      R0,#+5
   \       0x82   0xD006             BEQ.N    ??USART_SetConfig_6
   \       0x84   0xE00B             B.N      ??USART_SetConfig_7
   \                     ??USART_SetConfig_1: (+1)
   \       0x86   0x2001             MOVS     R0,#+1
   \       0x88   0xE0CF             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_4: (+1)
   \       0x8A   0x2004             MOVS     R0,#+4
   \       0x8C   0xE0CD             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_5: (+1)
   \       0x8E   0x2002             MOVS     R0,#+2
   \       0x90   0xE0CB             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_6: (+1)
   \       0x92   0x2008             MOVS     R0,#+8
   \       0x94   0xE0C9             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_3: (+1)
   \       0x96   0x2010             MOVS     R0,#+16
   \       0x98   0xE0C7             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_2: (+1)
   \       0x9A   0x2020             MOVS     R0,#+32
   \       0x9C   0xE0C5             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_7: (+1)
   \       0x9E   0x2040             MOVS     R0,#+64
   \       0xA0   0xE0C3             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_0: (+1)
   \       0xA2   0x6820             LDR      R0,[R4, #+0]
   \       0xA4   0x.... 0x....      LDR.W    R2,??DataTable9_1
   \       0xA8   0x4290             CMP      R0,R2
   \       0xAA   0xD11F             BNE.N    ??USART_SetConfig_9
   \       0xAC   0x.... 0x....      LDR.W    R0,??DataTable9
   \       0xB0   0x6800             LDR      R0,[R0, #+0]
   \       0xB2   0xF010 0x0038      ANDS     R0,R0,#0x38
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD00A             BEQ.N    ??USART_SetConfig_10
   \       0xBA   0x2808             CMP      R0,#+8
   \       0xBC   0xD010             BEQ.N    ??USART_SetConfig_11
   \       0xBE   0x2810             CMP      R0,#+16
   \       0xC0   0xD010             BEQ.N    ??USART_SetConfig_12
   \       0xC2   0x2818             CMP      R0,#+24
   \       0xC4   0xD008             BEQ.N    ??USART_SetConfig_13
   \       0xC6   0x2820             CMP      R0,#+32
   \       0xC8   0xD004             BEQ.N    ??USART_SetConfig_14
   \       0xCA   0x2828             CMP      R0,#+40
   \       0xCC   0xD006             BEQ.N    ??USART_SetConfig_15
   \       0xCE   0xE00B             B.N      ??USART_SetConfig_16
   \                     ??USART_SetConfig_10: (+1)
   \       0xD0   0x2000             MOVS     R0,#+0
   \       0xD2   0xE0AA             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_14: (+1)
   \       0xD4   0x2004             MOVS     R0,#+4
   \       0xD6   0xE0A8             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_13: (+1)
   \       0xD8   0x2002             MOVS     R0,#+2
   \       0xDA   0xE0A6             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_15: (+1)
   \       0xDC   0x2008             MOVS     R0,#+8
   \       0xDE   0xE0A4             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_11: (+1)
   \       0xE0   0x2010             MOVS     R0,#+16
   \       0xE2   0xE0A2             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_12: (+1)
   \       0xE4   0x2020             MOVS     R0,#+32
   \       0xE6   0xE0A0             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_16: (+1)
   \       0xE8   0x2040             MOVS     R0,#+64
   \       0xEA   0xE09E             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_9: (+1)
   \       0xEC   0x6820             LDR      R0,[R4, #+0]
   \       0xEE   0x.... 0x....      LDR.W    R2,??DataTable9_2
   \       0xF2   0x4290             CMP      R0,R2
   \       0xF4   0xD121             BNE.N    ??USART_SetConfig_17
   \       0xF6   0x.... 0x....      LDR.W    R0,??DataTable9
   \       0xFA   0x6800             LDR      R0,[R0, #+0]
   \       0xFC   0xF410 0x70E0      ANDS     R0,R0,#0x1C0
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xD00C             BEQ.N    ??USART_SetConfig_18
   \      0x104   0x2840             CMP      R0,#+64
   \      0x106   0xD012             BEQ.N    ??USART_SetConfig_19
   \      0x108   0x2880             CMP      R0,#+128
   \      0x10A   0xD012             BEQ.N    ??USART_SetConfig_20
   \      0x10C   0x28C0             CMP      R0,#+192
   \      0x10E   0xD00A             BEQ.N    ??USART_SetConfig_21
   \      0x110   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x114   0xD005             BEQ.N    ??USART_SetConfig_22
   \      0x116   0xF5B0 0x7FA0      CMP      R0,#+320
   \      0x11A   0xD006             BEQ.N    ??USART_SetConfig_23
   \      0x11C   0xE00B             B.N      ??USART_SetConfig_24
   \                     ??USART_SetConfig_18: (+1)
   \      0x11E   0x2000             MOVS     R0,#+0
   \      0x120   0xE083             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_22: (+1)
   \      0x122   0x2004             MOVS     R0,#+4
   \      0x124   0xE081             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_21: (+1)
   \      0x126   0x2002             MOVS     R0,#+2
   \      0x128   0xE07F             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_23: (+1)
   \      0x12A   0x2008             MOVS     R0,#+8
   \      0x12C   0xE07D             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_19: (+1)
   \      0x12E   0x2010             MOVS     R0,#+16
   \      0x130   0xE07B             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_20: (+1)
   \      0x132   0x2020             MOVS     R0,#+32
   \      0x134   0xE079             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_24: (+1)
   \      0x136   0x2040             MOVS     R0,#+64
   \      0x138   0xE077             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_17: (+1)
   \      0x13A   0x6820             LDR      R0,[R4, #+0]
   \      0x13C   0x.... 0x....      LDR.W    R2,??DataTable9_3
   \      0x140   0x4290             CMP      R0,R2
   \      0x142   0xD124             BNE.N    ??USART_SetConfig_25
   \      0x144   0x.... 0x....      LDR.W    R0,??DataTable9
   \      0x148   0x6800             LDR      R0,[R0, #+0]
   \      0x14A   0xF410 0x3060      ANDS     R0,R0,#0x38000
   \      0x14E   0x2800             CMP      R0,#+0
   \      0x150   0xD00F             BEQ.N    ??USART_SetConfig_26
   \      0x152   0xF5B0 0x4F00      CMP      R0,#+32768
   \      0x156   0xD014             BEQ.N    ??USART_SetConfig_27
   \      0x158   0xF5B0 0x3F80      CMP      R0,#+65536
   \      0x15C   0xD013             BEQ.N    ??USART_SetConfig_28
   \      0x15E   0xF5B0 0x3FC0      CMP      R0,#+98304
   \      0x162   0xD00A             BEQ.N    ??USART_SetConfig_29
   \      0x164   0xF5B0 0x3F00      CMP      R0,#+131072
   \      0x168   0xD005             BEQ.N    ??USART_SetConfig_30
   \      0x16A   0xF5B0 0x3F20      CMP      R0,#+163840
   \      0x16E   0xD006             BEQ.N    ??USART_SetConfig_31
   \      0x170   0xE00B             B.N      ??USART_SetConfig_32
   \                     ??USART_SetConfig_26: (+1)
   \      0x172   0x2000             MOVS     R0,#+0
   \      0x174   0xE059             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_30: (+1)
   \      0x176   0x2004             MOVS     R0,#+4
   \      0x178   0xE057             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_29: (+1)
   \      0x17A   0x2002             MOVS     R0,#+2
   \      0x17C   0xE055             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_31: (+1)
   \      0x17E   0x2008             MOVS     R0,#+8
   \      0x180   0xE053             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_27: (+1)
   \      0x182   0x2010             MOVS     R0,#+16
   \      0x184   0xE051             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_28: (+1)
   \      0x186   0x2020             MOVS     R0,#+32
   \      0x188   0xE04F             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_32: (+1)
   \      0x18A   0x2040             MOVS     R0,#+64
   \      0x18C   0xE04D             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_25: (+1)
   \      0x18E   0x6820             LDR      R0,[R4, #+0]
   \      0x190   0x.... 0x....      LDR.W    R2,??DataTable10
   \      0x194   0x4290             CMP      R0,R2
   \      0x196   0xD124             BNE.N    ??USART_SetConfig_33
   \      0x198   0x.... 0x....      LDR.W    R0,??DataTable9
   \      0x19C   0x6800             LDR      R0,[R0, #+0]
   \      0x19E   0xF010 0x5060      ANDS     R0,R0,#0x38000000
   \      0x1A2   0x2800             CMP      R0,#+0
   \      0x1A4   0xD00F             BEQ.N    ??USART_SetConfig_34
   \      0x1A6   0xF1B0 0x6F00      CMP      R0,#+134217728
   \      0x1AA   0xD014             BEQ.N    ??USART_SetConfig_35
   \      0x1AC   0xF1B0 0x5F80      CMP      R0,#+268435456
   \      0x1B0   0xD013             BEQ.N    ??USART_SetConfig_36
   \      0x1B2   0xF1B0 0x5FC0      CMP      R0,#+402653184
   \      0x1B6   0xD00A             BEQ.N    ??USART_SetConfig_37
   \      0x1B8   0xF1B0 0x5F00      CMP      R0,#+536870912
   \      0x1BC   0xD005             BEQ.N    ??USART_SetConfig_38
   \      0x1BE   0xF1B0 0x5F20      CMP      R0,#+671088640
   \      0x1C2   0xD006             BEQ.N    ??USART_SetConfig_39
   \      0x1C4   0xE00B             B.N      ??USART_SetConfig_40
   \                     ??USART_SetConfig_34: (+1)
   \      0x1C6   0x2000             MOVS     R0,#+0
   \      0x1C8   0xE02F             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_38: (+1)
   \      0x1CA   0x2004             MOVS     R0,#+4
   \      0x1CC   0xE02D             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_37: (+1)
   \      0x1CE   0x2002             MOVS     R0,#+2
   \      0x1D0   0xE02B             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_39: (+1)
   \      0x1D2   0x2008             MOVS     R0,#+8
   \      0x1D4   0xE029             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_35: (+1)
   \      0x1D6   0x2010             MOVS     R0,#+16
   \      0x1D8   0xE027             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_36: (+1)
   \      0x1DA   0x2020             MOVS     R0,#+32
   \      0x1DC   0xE025             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_40: (+1)
   \      0x1DE   0x2040             MOVS     R0,#+64
   \      0x1E0   0xE023             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_33: (+1)
   \      0x1E2   0x6820             LDR      R0,[R4, #+0]
   \      0x1E4   0x.... 0x....      LDR.W    R2,??DataTable10_1
   \      0x1E8   0x4290             CMP      R0,R2
   \      0x1EA   0xD11D             BNE.N    ??USART_SetConfig_41
   \      0x1EC   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \      0x1F0   0x6800             LDR      R0,[R0, #+0]
   \      0x1F2   0xF010 0x0007      ANDS     R0,R0,#0x7
   \      0x1F6   0x2800             CMP      R0,#+0
   \      0x1F8   0xD008             BEQ.N    ??USART_SetConfig_42
   \      0x1FA   0x2802             CMP      R0,#+2
   \      0x1FC   0xD010             BEQ.N    ??USART_SetConfig_43
   \      0x1FE   0xD30D             BCC.N    ??USART_SetConfig_44
   \      0x200   0x2804             CMP      R0,#+4
   \      0x202   0xD005             BEQ.N    ??USART_SetConfig_45
   \      0x204   0xD306             BCC.N    ??USART_SetConfig_46
   \      0x206   0x2805             CMP      R0,#+5
   \      0x208   0xD006             BEQ.N    ??USART_SetConfig_47
   \      0x20A   0xE00B             B.N      ??USART_SetConfig_48
   \                     ??USART_SetConfig_42: (+1)
   \      0x20C   0x2000             MOVS     R0,#+0
   \      0x20E   0xE00C             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_45: (+1)
   \      0x210   0x2004             MOVS     R0,#+4
   \      0x212   0xE00A             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_46: (+1)
   \      0x214   0x2002             MOVS     R0,#+2
   \      0x216   0xE008             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_47: (+1)
   \      0x218   0x2008             MOVS     R0,#+8
   \      0x21A   0xE006             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_44: (+1)
   \      0x21C   0x2010             MOVS     R0,#+16
   \      0x21E   0xE004             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_43: (+1)
   \      0x220   0x2020             MOVS     R0,#+32
   \      0x222   0xE002             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_48: (+1)
   \      0x224   0x2040             MOVS     R0,#+64
   \      0x226   0xE000             B.N      ??USART_SetConfig_8
   \                     ??USART_SetConfig_41: (+1)
   \      0x228   0x2040             MOVS     R0,#+64
   3195          
   3196            switch (clocksource)
   \                     ??USART_SetConfig_8: (+1)
   \      0x22A   0xB2C0             UXTB     R0,R0
   \      0x22C   0x2800             CMP      R0,#+0
   \      0x22E   0xD011             BEQ.N    ??USART_SetConfig_49
   \      0x230   0x2801             CMP      R0,#+1
   \      0x232   0xD05A             BEQ.N    ??USART_SetConfig_50
   \      0x234   0x2802             CMP      R0,#+2
   \      0x236   0xF000 0x813B      BEQ.W    ??USART_SetConfig_51
   \      0x23A   0x2804             CMP      R0,#+4
   \      0x23C   0xF000 0x8182      BEQ.W    ??USART_SetConfig_52
   \      0x240   0x2808             CMP      R0,#+8
   \      0x242   0xF000 0x81C9      BEQ.W    ??USART_SetConfig_53
   \      0x246   0x2810             CMP      R0,#+16
   \      0x248   0xF000 0x809A      BEQ.W    ??USART_SetConfig_54
   \      0x24C   0x2820             CMP      R0,#+32
   \      0x24E   0xF000 0x80E3      BEQ.W    ??USART_SetConfig_55
   \      0x252   0xE20B             B.N      ??USART_SetConfig_56
   3197            {
   3198              case USART_CLOCKSOURCE_PCLK1:
   3199                pclk = HAL_RCC_GetPCLK1Freq();
   \                     ??USART_SetConfig_49: (+1)
   \      0x254   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0x258   0x0001             MOVS     R1,R0
   3200                usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pclk, husart->Init.BaudRate, husart->Init.ClockPrescaler));
   \      0x25A   0x6A60             LDR      R0,[R4, #+36]
   \      0x25C   0x2800             CMP      R0,#+0
   \      0x25E   0xD101             BNE.N    ??USART_SetConfig_57
   \      0x260   0x2001             MOVS     R0,#+1
   \      0x262   0xE038             B.N      ??USART_SetConfig_58
   \                     ??USART_SetConfig_57: (+1)
   \      0x264   0x6A60             LDR      R0,[R4, #+36]
   \      0x266   0x2801             CMP      R0,#+1
   \      0x268   0xD101             BNE.N    ??USART_SetConfig_59
   \      0x26A   0x2002             MOVS     R0,#+2
   \      0x26C   0xE033             B.N      ??USART_SetConfig_58
   \                     ??USART_SetConfig_59: (+1)
   \      0x26E   0x6A60             LDR      R0,[R4, #+36]
   \      0x270   0x2802             CMP      R0,#+2
   \      0x272   0xD101             BNE.N    ??USART_SetConfig_60
   \      0x274   0x2004             MOVS     R0,#+4
   \      0x276   0xE02E             B.N      ??USART_SetConfig_58
   \                     ??USART_SetConfig_60: (+1)
   \      0x278   0x6A60             LDR      R0,[R4, #+36]
   \      0x27A   0x2803             CMP      R0,#+3
   \      0x27C   0xD101             BNE.N    ??USART_SetConfig_61
   \      0x27E   0x2006             MOVS     R0,#+6
   \      0x280   0xE029             B.N      ??USART_SetConfig_58
   \                     ??USART_SetConfig_61: (+1)
   \      0x282   0x6A60             LDR      R0,[R4, #+36]
   \      0x284   0x2804             CMP      R0,#+4
   \      0x286   0xD101             BNE.N    ??USART_SetConfig_62
   \      0x288   0x2008             MOVS     R0,#+8
   \      0x28A   0xE024             B.N      ??USART_SetConfig_58
   \                     ??USART_SetConfig_62: (+1)
   \      0x28C   0x6A60             LDR      R0,[R4, #+36]
   \      0x28E   0x2805             CMP      R0,#+5
   \      0x290   0xD101             BNE.N    ??USART_SetConfig_63
   \      0x292   0x200A             MOVS     R0,#+10
   \      0x294   0xE01F             B.N      ??USART_SetConfig_58
   \                     ??USART_SetConfig_63: (+1)
   \      0x296   0x6A60             LDR      R0,[R4, #+36]
   \      0x298   0x2806             CMP      R0,#+6
   \      0x29A   0xD101             BNE.N    ??USART_SetConfig_64
   \      0x29C   0x200C             MOVS     R0,#+12
   \      0x29E   0xE01A             B.N      ??USART_SetConfig_58
   \                     ??USART_SetConfig_64: (+1)
   \      0x2A0   0x6A60             LDR      R0,[R4, #+36]
   \      0x2A2   0x2807             CMP      R0,#+7
   \      0x2A4   0xD101             BNE.N    ??USART_SetConfig_65
   \      0x2A6   0x2010             MOVS     R0,#+16
   \      0x2A8   0xE015             B.N      ??USART_SetConfig_58
   \                     ??USART_SetConfig_65: (+1)
   \      0x2AA   0x6A60             LDR      R0,[R4, #+36]
   \      0x2AC   0x2808             CMP      R0,#+8
   \      0x2AE   0xD101             BNE.N    ??USART_SetConfig_66
   \      0x2B0   0x2020             MOVS     R0,#+32
   \      0x2B2   0xE010             B.N      ??USART_SetConfig_58
   \                     ??USART_SetConfig_66: (+1)
   \      0x2B4   0x6A60             LDR      R0,[R4, #+36]
   \      0x2B6   0x2809             CMP      R0,#+9
   \      0x2B8   0xD101             BNE.N    ??USART_SetConfig_67
   \      0x2BA   0x2040             MOVS     R0,#+64
   \      0x2BC   0xE00B             B.N      ??USART_SetConfig_58
   \                     ??USART_SetConfig_67: (+1)
   \      0x2BE   0x6A60             LDR      R0,[R4, #+36]
   \      0x2C0   0x280A             CMP      R0,#+10
   \      0x2C2   0xD101             BNE.N    ??USART_SetConfig_68
   \      0x2C4   0x2080             MOVS     R0,#+128
   \      0x2C6   0xE006             B.N      ??USART_SetConfig_58
   \                     ??USART_SetConfig_68: (+1)
   \      0x2C8   0x6A60             LDR      R0,[R4, #+36]
   \      0x2CA   0x280B             CMP      R0,#+11
   \      0x2CC   0xD102             BNE.N    ??USART_SetConfig_69
   \      0x2CE   0xF44F 0x7080      MOV      R0,#+256
   \      0x2D2   0xE000             B.N      ??USART_SetConfig_58
   \                     ??USART_SetConfig_69: (+1)
   \      0x2D4   0x2001             MOVS     R0,#+1
   \                     ??USART_SetConfig_58: (+1)
   \      0x2D6   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \      0x2DA   0x6861             LDR      R1,[R4, #+4]
   \      0x2DC   0x0849             LSRS     R1,R1,#+1
   \      0x2DE   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \      0x2E2   0x6860             LDR      R0,[R4, #+4]
   \      0x2E4   0xFBB1 0xF1F0      UDIV     R1,R1,R0
   3201                break;
   \      0x2E8   0xE1C1             B.N      ??USART_SetConfig_70
   3202              case USART_CLOCKSOURCE_PCLK2:
   3203                pclk = HAL_RCC_GetPCLK2Freq();
   \                     ??USART_SetConfig_50: (+1)
   \      0x2EA   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \      0x2EE   0x0001             MOVS     R1,R0
   3204                usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pclk, husart->Init.BaudRate, husart->Init.ClockPrescaler));
   \      0x2F0   0x6A60             LDR      R0,[R4, #+36]
   \      0x2F2   0x2800             CMP      R0,#+0
   \      0x2F4   0xD101             BNE.N    ??USART_SetConfig_71
   \      0x2F6   0x2001             MOVS     R0,#+1
   \      0x2F8   0xE038             B.N      ??USART_SetConfig_72
   \                     ??USART_SetConfig_71: (+1)
   \      0x2FA   0x6A60             LDR      R0,[R4, #+36]
   \      0x2FC   0x2801             CMP      R0,#+1
   \      0x2FE   0xD101             BNE.N    ??USART_SetConfig_73
   \      0x300   0x2002             MOVS     R0,#+2
   \      0x302   0xE033             B.N      ??USART_SetConfig_72
   \                     ??USART_SetConfig_73: (+1)
   \      0x304   0x6A60             LDR      R0,[R4, #+36]
   \      0x306   0x2802             CMP      R0,#+2
   \      0x308   0xD101             BNE.N    ??USART_SetConfig_74
   \      0x30A   0x2004             MOVS     R0,#+4
   \      0x30C   0xE02E             B.N      ??USART_SetConfig_72
   \                     ??USART_SetConfig_74: (+1)
   \      0x30E   0x6A60             LDR      R0,[R4, #+36]
   \      0x310   0x2803             CMP      R0,#+3
   \      0x312   0xD101             BNE.N    ??USART_SetConfig_75
   \      0x314   0x2006             MOVS     R0,#+6
   \      0x316   0xE029             B.N      ??USART_SetConfig_72
   \                     ??USART_SetConfig_75: (+1)
   \      0x318   0x6A60             LDR      R0,[R4, #+36]
   \      0x31A   0x2804             CMP      R0,#+4
   \      0x31C   0xD101             BNE.N    ??USART_SetConfig_76
   \      0x31E   0x2008             MOVS     R0,#+8
   \      0x320   0xE024             B.N      ??USART_SetConfig_72
   \                     ??USART_SetConfig_76: (+1)
   \      0x322   0x6A60             LDR      R0,[R4, #+36]
   \      0x324   0x2805             CMP      R0,#+5
   \      0x326   0xD101             BNE.N    ??USART_SetConfig_77
   \      0x328   0x200A             MOVS     R0,#+10
   \      0x32A   0xE01F             B.N      ??USART_SetConfig_72
   \                     ??USART_SetConfig_77: (+1)
   \      0x32C   0x6A60             LDR      R0,[R4, #+36]
   \      0x32E   0x2806             CMP      R0,#+6
   \      0x330   0xD101             BNE.N    ??USART_SetConfig_78
   \      0x332   0x200C             MOVS     R0,#+12
   \      0x334   0xE01A             B.N      ??USART_SetConfig_72
   \                     ??USART_SetConfig_78: (+1)
   \      0x336   0x6A60             LDR      R0,[R4, #+36]
   \      0x338   0x2807             CMP      R0,#+7
   \      0x33A   0xD101             BNE.N    ??USART_SetConfig_79
   \      0x33C   0x2010             MOVS     R0,#+16
   \      0x33E   0xE015             B.N      ??USART_SetConfig_72
   \                     ??USART_SetConfig_79: (+1)
   \      0x340   0x6A60             LDR      R0,[R4, #+36]
   \      0x342   0x2808             CMP      R0,#+8
   \      0x344   0xD101             BNE.N    ??USART_SetConfig_80
   \      0x346   0x2020             MOVS     R0,#+32
   \      0x348   0xE010             B.N      ??USART_SetConfig_72
   \                     ??USART_SetConfig_80: (+1)
   \      0x34A   0x6A60             LDR      R0,[R4, #+36]
   \      0x34C   0x2809             CMP      R0,#+9
   \      0x34E   0xD101             BNE.N    ??USART_SetConfig_81
   \      0x350   0x2040             MOVS     R0,#+64
   \      0x352   0xE00B             B.N      ??USART_SetConfig_72
   \                     ??USART_SetConfig_81: (+1)
   \      0x354   0x6A60             LDR      R0,[R4, #+36]
   \      0x356   0x280A             CMP      R0,#+10
   \      0x358   0xD101             BNE.N    ??USART_SetConfig_82
   \      0x35A   0x2080             MOVS     R0,#+128
   \      0x35C   0xE006             B.N      ??USART_SetConfig_72
   \                     ??USART_SetConfig_82: (+1)
   \      0x35E   0x6A60             LDR      R0,[R4, #+36]
   \      0x360   0x280B             CMP      R0,#+11
   \      0x362   0xD102             BNE.N    ??USART_SetConfig_83
   \      0x364   0xF44F 0x7080      MOV      R0,#+256
   \      0x368   0xE000             B.N      ??USART_SetConfig_72
   \                     ??USART_SetConfig_83: (+1)
   \      0x36A   0x2001             MOVS     R0,#+1
   \                     ??USART_SetConfig_72: (+1)
   \      0x36C   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \      0x370   0x6861             LDR      R1,[R4, #+4]
   \      0x372   0x0849             LSRS     R1,R1,#+1
   \      0x374   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \      0x378   0x6860             LDR      R0,[R4, #+4]
   \      0x37A   0xFBB1 0xF1F0      UDIV     R1,R1,R0
   3205                break;
   \      0x37E   0xE176             B.N      ??USART_SetConfig_70
   3206              case USART_CLOCKSOURCE_PLL2Q:
   3207                HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??USART_SetConfig_54: (+1)
   \      0x380   0xA803             ADD      R0,SP,#+12
   \      0x382   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3208                usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pll2_clocks.PLL2_Q_Frequency, husart->Init.BaudRate,
   3209                                                          husart->Init.ClockPrescaler));
   \      0x386   0x6A60             LDR      R0,[R4, #+36]
   \      0x388   0x2800             CMP      R0,#+0
   \      0x38A   0xD101             BNE.N    ??USART_SetConfig_84
   \      0x38C   0x2001             MOVS     R0,#+1
   \      0x38E   0xE038             B.N      ??USART_SetConfig_85
   \                     ??USART_SetConfig_84: (+1)
   \      0x390   0x6A60             LDR      R0,[R4, #+36]
   \      0x392   0x2801             CMP      R0,#+1
   \      0x394   0xD101             BNE.N    ??USART_SetConfig_86
   \      0x396   0x2002             MOVS     R0,#+2
   \      0x398   0xE033             B.N      ??USART_SetConfig_85
   \                     ??USART_SetConfig_86: (+1)
   \      0x39A   0x6A60             LDR      R0,[R4, #+36]
   \      0x39C   0x2802             CMP      R0,#+2
   \      0x39E   0xD101             BNE.N    ??USART_SetConfig_87
   \      0x3A0   0x2004             MOVS     R0,#+4
   \      0x3A2   0xE02E             B.N      ??USART_SetConfig_85
   \                     ??USART_SetConfig_87: (+1)
   \      0x3A4   0x6A60             LDR      R0,[R4, #+36]
   \      0x3A6   0x2803             CMP      R0,#+3
   \      0x3A8   0xD101             BNE.N    ??USART_SetConfig_88
   \      0x3AA   0x2006             MOVS     R0,#+6
   \      0x3AC   0xE029             B.N      ??USART_SetConfig_85
   \                     ??USART_SetConfig_88: (+1)
   \      0x3AE   0x6A60             LDR      R0,[R4, #+36]
   \      0x3B0   0x2804             CMP      R0,#+4
   \      0x3B2   0xD101             BNE.N    ??USART_SetConfig_89
   \      0x3B4   0x2008             MOVS     R0,#+8
   \      0x3B6   0xE024             B.N      ??USART_SetConfig_85
   \                     ??USART_SetConfig_89: (+1)
   \      0x3B8   0x6A60             LDR      R0,[R4, #+36]
   \      0x3BA   0x2805             CMP      R0,#+5
   \      0x3BC   0xD101             BNE.N    ??USART_SetConfig_90
   \      0x3BE   0x200A             MOVS     R0,#+10
   \      0x3C0   0xE01F             B.N      ??USART_SetConfig_85
   \                     ??USART_SetConfig_90: (+1)
   \      0x3C2   0x6A60             LDR      R0,[R4, #+36]
   \      0x3C4   0x2806             CMP      R0,#+6
   \      0x3C6   0xD101             BNE.N    ??USART_SetConfig_91
   \      0x3C8   0x200C             MOVS     R0,#+12
   \      0x3CA   0xE01A             B.N      ??USART_SetConfig_85
   \                     ??USART_SetConfig_91: (+1)
   \      0x3CC   0x6A60             LDR      R0,[R4, #+36]
   \      0x3CE   0x2807             CMP      R0,#+7
   \      0x3D0   0xD101             BNE.N    ??USART_SetConfig_92
   \      0x3D2   0x2010             MOVS     R0,#+16
   \      0x3D4   0xE015             B.N      ??USART_SetConfig_85
   \                     ??USART_SetConfig_92: (+1)
   \      0x3D6   0x6A60             LDR      R0,[R4, #+36]
   \      0x3D8   0x2808             CMP      R0,#+8
   \      0x3DA   0xD101             BNE.N    ??USART_SetConfig_93
   \      0x3DC   0x2020             MOVS     R0,#+32
   \      0x3DE   0xE010             B.N      ??USART_SetConfig_85
   \                     ??USART_SetConfig_93: (+1)
   \      0x3E0   0x6A60             LDR      R0,[R4, #+36]
   \      0x3E2   0x2809             CMP      R0,#+9
   \      0x3E4   0xD101             BNE.N    ??USART_SetConfig_94
   \      0x3E6   0x2040             MOVS     R0,#+64
   \      0x3E8   0xE00B             B.N      ??USART_SetConfig_85
   \                     ??USART_SetConfig_94: (+1)
   \      0x3EA   0x6A60             LDR      R0,[R4, #+36]
   \      0x3EC   0x280A             CMP      R0,#+10
   \      0x3EE   0xD101             BNE.N    ??USART_SetConfig_95
   \      0x3F0   0x2080             MOVS     R0,#+128
   \      0x3F2   0xE006             B.N      ??USART_SetConfig_85
   \                     ??USART_SetConfig_95: (+1)
   \      0x3F4   0x6A60             LDR      R0,[R4, #+36]
   \      0x3F6   0x280B             CMP      R0,#+11
   \      0x3F8   0xD102             BNE.N    ??USART_SetConfig_96
   \      0x3FA   0xF44F 0x7080      MOV      R0,#+256
   \      0x3FE   0xE000             B.N      ??USART_SetConfig_85
   \                     ??USART_SetConfig_96: (+1)
   \      0x400   0x2001             MOVS     R0,#+1
   \                     ??USART_SetConfig_85: (+1)
   \      0x402   0x9904             LDR      R1,[SP, #+16]
   \      0x404   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \      0x408   0x6861             LDR      R1,[R4, #+4]
   \      0x40A   0x0849             LSRS     R1,R1,#+1
   \      0x40C   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \      0x410   0x6860             LDR      R0,[R4, #+4]
   \      0x412   0xFBB1 0xF1F0      UDIV     R1,R1,R0
   3210                break;
   \      0x416   0xE12A             B.N      ??USART_SetConfig_70
   3211          #if defined(RCC_CR_PLL3ON)
   3212              case USART_CLOCKSOURCE_PLL3Q:
   3213                HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??USART_SetConfig_55: (+1)
   \      0x418   0x4668             MOV      R0,SP
   \      0x41A   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3214                usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pll3_clocks.PLL3_Q_Frequency, husart->Init.BaudRate,
   3215                                                          husart->Init.ClockPrescaler));
   \      0x41E   0x6A60             LDR      R0,[R4, #+36]
   \      0x420   0x2800             CMP      R0,#+0
   \      0x422   0xD101             BNE.N    ??USART_SetConfig_97
   \      0x424   0x2001             MOVS     R0,#+1
   \      0x426   0xE038             B.N      ??USART_SetConfig_98
   \                     ??USART_SetConfig_97: (+1)
   \      0x428   0x6A60             LDR      R0,[R4, #+36]
   \      0x42A   0x2801             CMP      R0,#+1
   \      0x42C   0xD101             BNE.N    ??USART_SetConfig_99
   \      0x42E   0x2002             MOVS     R0,#+2
   \      0x430   0xE033             B.N      ??USART_SetConfig_98
   \                     ??USART_SetConfig_99: (+1)
   \      0x432   0x6A60             LDR      R0,[R4, #+36]
   \      0x434   0x2802             CMP      R0,#+2
   \      0x436   0xD101             BNE.N    ??USART_SetConfig_100
   \      0x438   0x2004             MOVS     R0,#+4
   \      0x43A   0xE02E             B.N      ??USART_SetConfig_98
   \                     ??USART_SetConfig_100: (+1)
   \      0x43C   0x6A60             LDR      R0,[R4, #+36]
   \      0x43E   0x2803             CMP      R0,#+3
   \      0x440   0xD101             BNE.N    ??USART_SetConfig_101
   \      0x442   0x2006             MOVS     R0,#+6
   \      0x444   0xE029             B.N      ??USART_SetConfig_98
   \                     ??USART_SetConfig_101: (+1)
   \      0x446   0x6A60             LDR      R0,[R4, #+36]
   \      0x448   0x2804             CMP      R0,#+4
   \      0x44A   0xD101             BNE.N    ??USART_SetConfig_102
   \      0x44C   0x2008             MOVS     R0,#+8
   \      0x44E   0xE024             B.N      ??USART_SetConfig_98
   \                     ??USART_SetConfig_102: (+1)
   \      0x450   0x6A60             LDR      R0,[R4, #+36]
   \      0x452   0x2805             CMP      R0,#+5
   \      0x454   0xD101             BNE.N    ??USART_SetConfig_103
   \      0x456   0x200A             MOVS     R0,#+10
   \      0x458   0xE01F             B.N      ??USART_SetConfig_98
   \                     ??USART_SetConfig_103: (+1)
   \      0x45A   0x6A60             LDR      R0,[R4, #+36]
   \      0x45C   0x2806             CMP      R0,#+6
   \      0x45E   0xD101             BNE.N    ??USART_SetConfig_104
   \      0x460   0x200C             MOVS     R0,#+12
   \      0x462   0xE01A             B.N      ??USART_SetConfig_98
   \                     ??USART_SetConfig_104: (+1)
   \      0x464   0x6A60             LDR      R0,[R4, #+36]
   \      0x466   0x2807             CMP      R0,#+7
   \      0x468   0xD101             BNE.N    ??USART_SetConfig_105
   \      0x46A   0x2010             MOVS     R0,#+16
   \      0x46C   0xE015             B.N      ??USART_SetConfig_98
   \                     ??USART_SetConfig_105: (+1)
   \      0x46E   0x6A60             LDR      R0,[R4, #+36]
   \      0x470   0x2808             CMP      R0,#+8
   \      0x472   0xD101             BNE.N    ??USART_SetConfig_106
   \      0x474   0x2020             MOVS     R0,#+32
   \      0x476   0xE010             B.N      ??USART_SetConfig_98
   \                     ??USART_SetConfig_106: (+1)
   \      0x478   0x6A60             LDR      R0,[R4, #+36]
   \      0x47A   0x2809             CMP      R0,#+9
   \      0x47C   0xD101             BNE.N    ??USART_SetConfig_107
   \      0x47E   0x2040             MOVS     R0,#+64
   \      0x480   0xE00B             B.N      ??USART_SetConfig_98
   \                     ??USART_SetConfig_107: (+1)
   \      0x482   0x6A60             LDR      R0,[R4, #+36]
   \      0x484   0x280A             CMP      R0,#+10
   \      0x486   0xD101             BNE.N    ??USART_SetConfig_108
   \      0x488   0x2080             MOVS     R0,#+128
   \      0x48A   0xE006             B.N      ??USART_SetConfig_98
   \                     ??USART_SetConfig_108: (+1)
   \      0x48C   0x6A60             LDR      R0,[R4, #+36]
   \      0x48E   0x280B             CMP      R0,#+11
   \      0x490   0xD102             BNE.N    ??USART_SetConfig_109
   \      0x492   0xF44F 0x7080      MOV      R0,#+256
   \      0x496   0xE000             B.N      ??USART_SetConfig_98
   \                     ??USART_SetConfig_109: (+1)
   \      0x498   0x2001             MOVS     R0,#+1
   \                     ??USART_SetConfig_98: (+1)
   \      0x49A   0x9901             LDR      R1,[SP, #+4]
   \      0x49C   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \      0x4A0   0x6861             LDR      R1,[R4, #+4]
   \      0x4A2   0x0849             LSRS     R1,R1,#+1
   \      0x4A4   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \      0x4A8   0x6860             LDR      R0,[R4, #+4]
   \      0x4AA   0xFBB1 0xF1F0      UDIV     R1,R1,R0
   3216                break;
   \      0x4AE   0xE0DE             B.N      ??USART_SetConfig_70
   3217          #endif /* RCC_CR_PLL3ON */
   3218              case USART_CLOCKSOURCE_HSI:
   3219                usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HSI_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
   \                     ??USART_SetConfig_51: (+1)
   \      0x4B0   0x6A60             LDR      R0,[R4, #+36]
   \      0x4B2   0x2800             CMP      R0,#+0
   \      0x4B4   0xD101             BNE.N    ??USART_SetConfig_110
   \      0x4B6   0x2001             MOVS     R0,#+1
   \      0x4B8   0xE038             B.N      ??USART_SetConfig_111
   \                     ??USART_SetConfig_110: (+1)
   \      0x4BA   0x6A60             LDR      R0,[R4, #+36]
   \      0x4BC   0x2801             CMP      R0,#+1
   \      0x4BE   0xD101             BNE.N    ??USART_SetConfig_112
   \      0x4C0   0x2002             MOVS     R0,#+2
   \      0x4C2   0xE033             B.N      ??USART_SetConfig_111
   \                     ??USART_SetConfig_112: (+1)
   \      0x4C4   0x6A60             LDR      R0,[R4, #+36]
   \      0x4C6   0x2802             CMP      R0,#+2
   \      0x4C8   0xD101             BNE.N    ??USART_SetConfig_113
   \      0x4CA   0x2004             MOVS     R0,#+4
   \      0x4CC   0xE02E             B.N      ??USART_SetConfig_111
   \                     ??USART_SetConfig_113: (+1)
   \      0x4CE   0x6A60             LDR      R0,[R4, #+36]
   \      0x4D0   0x2803             CMP      R0,#+3
   \      0x4D2   0xD101             BNE.N    ??USART_SetConfig_114
   \      0x4D4   0x2006             MOVS     R0,#+6
   \      0x4D6   0xE029             B.N      ??USART_SetConfig_111
   \                     ??USART_SetConfig_114: (+1)
   \      0x4D8   0x6A60             LDR      R0,[R4, #+36]
   \      0x4DA   0x2804             CMP      R0,#+4
   \      0x4DC   0xD101             BNE.N    ??USART_SetConfig_115
   \      0x4DE   0x2008             MOVS     R0,#+8
   \      0x4E0   0xE024             B.N      ??USART_SetConfig_111
   \                     ??USART_SetConfig_115: (+1)
   \      0x4E2   0x6A60             LDR      R0,[R4, #+36]
   \      0x4E4   0x2805             CMP      R0,#+5
   \      0x4E6   0xD101             BNE.N    ??USART_SetConfig_116
   \      0x4E8   0x200A             MOVS     R0,#+10
   \      0x4EA   0xE01F             B.N      ??USART_SetConfig_111
   \                     ??USART_SetConfig_116: (+1)
   \      0x4EC   0x6A60             LDR      R0,[R4, #+36]
   \      0x4EE   0x2806             CMP      R0,#+6
   \      0x4F0   0xD101             BNE.N    ??USART_SetConfig_117
   \      0x4F2   0x200C             MOVS     R0,#+12
   \      0x4F4   0xE01A             B.N      ??USART_SetConfig_111
   \                     ??USART_SetConfig_117: (+1)
   \      0x4F6   0x6A60             LDR      R0,[R4, #+36]
   \      0x4F8   0x2807             CMP      R0,#+7
   \      0x4FA   0xD101             BNE.N    ??USART_SetConfig_118
   \      0x4FC   0x2010             MOVS     R0,#+16
   \      0x4FE   0xE015             B.N      ??USART_SetConfig_111
   \                     ??USART_SetConfig_118: (+1)
   \      0x500   0x6A60             LDR      R0,[R4, #+36]
   \      0x502   0x2808             CMP      R0,#+8
   \      0x504   0xD101             BNE.N    ??USART_SetConfig_119
   \      0x506   0x2020             MOVS     R0,#+32
   \      0x508   0xE010             B.N      ??USART_SetConfig_111
   \                     ??USART_SetConfig_119: (+1)
   \      0x50A   0x6A60             LDR      R0,[R4, #+36]
   \      0x50C   0x2809             CMP      R0,#+9
   \      0x50E   0xD101             BNE.N    ??USART_SetConfig_120
   \      0x510   0x2040             MOVS     R0,#+64
   \      0x512   0xE00B             B.N      ??USART_SetConfig_111
   \                     ??USART_SetConfig_120: (+1)
   \      0x514   0x6A60             LDR      R0,[R4, #+36]
   \      0x516   0x280A             CMP      R0,#+10
   \      0x518   0xD101             BNE.N    ??USART_SetConfig_121
   \      0x51A   0x2080             MOVS     R0,#+128
   \      0x51C   0xE006             B.N      ??USART_SetConfig_111
   \                     ??USART_SetConfig_121: (+1)
   \      0x51E   0x6A60             LDR      R0,[R4, #+36]
   \      0x520   0x280B             CMP      R0,#+11
   \      0x522   0xD102             BNE.N    ??USART_SetConfig_122
   \      0x524   0xF44F 0x7080      MOV      R0,#+256
   \      0x528   0xE000             B.N      ??USART_SetConfig_111
   \                     ??USART_SetConfig_122: (+1)
   \      0x52A   0x2001             MOVS     R0,#+1
   \                     ??USART_SetConfig_111: (+1)
   \      0x52C   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \      0x530   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \      0x534   0x6861             LDR      R1,[R4, #+4]
   \      0x536   0x0849             LSRS     R1,R1,#+1
   \      0x538   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \      0x53C   0x6860             LDR      R0,[R4, #+4]
   \      0x53E   0xFBB1 0xF1F0      UDIV     R1,R1,R0
   3220                break;
   \      0x542   0xE094             B.N      ??USART_SetConfig_70
   3221              case USART_CLOCKSOURCE_CSI:
   3222                usartdiv = (uint32_t)(USART_DIV_SAMPLING8(CSI_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
   \                     ??USART_SetConfig_52: (+1)
   \      0x544   0x6A60             LDR      R0,[R4, #+36]
   \      0x546   0x2800             CMP      R0,#+0
   \      0x548   0xD101             BNE.N    ??USART_SetConfig_123
   \      0x54A   0x2001             MOVS     R0,#+1
   \      0x54C   0xE038             B.N      ??USART_SetConfig_124
   \                     ??USART_SetConfig_123: (+1)
   \      0x54E   0x6A60             LDR      R0,[R4, #+36]
   \      0x550   0x2801             CMP      R0,#+1
   \      0x552   0xD101             BNE.N    ??USART_SetConfig_125
   \      0x554   0x2002             MOVS     R0,#+2
   \      0x556   0xE033             B.N      ??USART_SetConfig_124
   \                     ??USART_SetConfig_125: (+1)
   \      0x558   0x6A60             LDR      R0,[R4, #+36]
   \      0x55A   0x2802             CMP      R0,#+2
   \      0x55C   0xD101             BNE.N    ??USART_SetConfig_126
   \      0x55E   0x2004             MOVS     R0,#+4
   \      0x560   0xE02E             B.N      ??USART_SetConfig_124
   \                     ??USART_SetConfig_126: (+1)
   \      0x562   0x6A60             LDR      R0,[R4, #+36]
   \      0x564   0x2803             CMP      R0,#+3
   \      0x566   0xD101             BNE.N    ??USART_SetConfig_127
   \      0x568   0x2006             MOVS     R0,#+6
   \      0x56A   0xE029             B.N      ??USART_SetConfig_124
   \                     ??USART_SetConfig_127: (+1)
   \      0x56C   0x6A60             LDR      R0,[R4, #+36]
   \      0x56E   0x2804             CMP      R0,#+4
   \      0x570   0xD101             BNE.N    ??USART_SetConfig_128
   \      0x572   0x2008             MOVS     R0,#+8
   \      0x574   0xE024             B.N      ??USART_SetConfig_124
   \                     ??USART_SetConfig_128: (+1)
   \      0x576   0x6A60             LDR      R0,[R4, #+36]
   \      0x578   0x2805             CMP      R0,#+5
   \      0x57A   0xD101             BNE.N    ??USART_SetConfig_129
   \      0x57C   0x200A             MOVS     R0,#+10
   \      0x57E   0xE01F             B.N      ??USART_SetConfig_124
   \                     ??USART_SetConfig_129: (+1)
   \      0x580   0x6A60             LDR      R0,[R4, #+36]
   \      0x582   0x2806             CMP      R0,#+6
   \      0x584   0xD101             BNE.N    ??USART_SetConfig_130
   \      0x586   0x200C             MOVS     R0,#+12
   \      0x588   0xE01A             B.N      ??USART_SetConfig_124
   \                     ??USART_SetConfig_130: (+1)
   \      0x58A   0x6A60             LDR      R0,[R4, #+36]
   \      0x58C   0x2807             CMP      R0,#+7
   \      0x58E   0xD101             BNE.N    ??USART_SetConfig_131
   \      0x590   0x2010             MOVS     R0,#+16
   \      0x592   0xE015             B.N      ??USART_SetConfig_124
   \                     ??USART_SetConfig_131: (+1)
   \      0x594   0x6A60             LDR      R0,[R4, #+36]
   \      0x596   0x2808             CMP      R0,#+8
   \      0x598   0xD101             BNE.N    ??USART_SetConfig_132
   \      0x59A   0x2020             MOVS     R0,#+32
   \      0x59C   0xE010             B.N      ??USART_SetConfig_124
   \                     ??USART_SetConfig_132: (+1)
   \      0x59E   0x6A60             LDR      R0,[R4, #+36]
   \      0x5A0   0x2809             CMP      R0,#+9
   \      0x5A2   0xD101             BNE.N    ??USART_SetConfig_133
   \      0x5A4   0x2040             MOVS     R0,#+64
   \      0x5A6   0xE00B             B.N      ??USART_SetConfig_124
   \                     ??USART_SetConfig_133: (+1)
   \      0x5A8   0x6A60             LDR      R0,[R4, #+36]
   \      0x5AA   0x280A             CMP      R0,#+10
   \      0x5AC   0xD101             BNE.N    ??USART_SetConfig_134
   \      0x5AE   0x2080             MOVS     R0,#+128
   \      0x5B0   0xE006             B.N      ??USART_SetConfig_124
   \                     ??USART_SetConfig_134: (+1)
   \      0x5B2   0x6A60             LDR      R0,[R4, #+36]
   \      0x5B4   0x280B             CMP      R0,#+11
   \      0x5B6   0xD102             BNE.N    ??USART_SetConfig_135
   \      0x5B8   0xF44F 0x7080      MOV      R0,#+256
   \      0x5BC   0xE000             B.N      ??USART_SetConfig_124
   \                     ??USART_SetConfig_135: (+1)
   \      0x5BE   0x2001             MOVS     R0,#+1
   \                     ??USART_SetConfig_124: (+1)
   \      0x5C0   0x.... 0x....      LDR.W    R1,??DataTable10_4
   \      0x5C4   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \      0x5C8   0x6861             LDR      R1,[R4, #+4]
   \      0x5CA   0x0849             LSRS     R1,R1,#+1
   \      0x5CC   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \      0x5D0   0x6860             LDR      R0,[R4, #+4]
   \      0x5D2   0xFBB1 0xF1F0      UDIV     R1,R1,R0
   3223                break;
   \      0x5D6   0xE04A             B.N      ??USART_SetConfig_70
   3224              case USART_CLOCKSOURCE_LSE:
   3225                usartdiv = (uint32_t)(USART_DIV_SAMPLING8(LSE_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
   \                     ??USART_SetConfig_53: (+1)
   \      0x5D8   0x6A60             LDR      R0,[R4, #+36]
   \      0x5DA   0x2800             CMP      R0,#+0
   \      0x5DC   0xD101             BNE.N    ??USART_SetConfig_136
   \      0x5DE   0x2001             MOVS     R0,#+1
   \      0x5E0   0xE038             B.N      ??USART_SetConfig_137
   \                     ??USART_SetConfig_136: (+1)
   \      0x5E2   0x6A60             LDR      R0,[R4, #+36]
   \      0x5E4   0x2801             CMP      R0,#+1
   \      0x5E6   0xD101             BNE.N    ??USART_SetConfig_138
   \      0x5E8   0x2002             MOVS     R0,#+2
   \      0x5EA   0xE033             B.N      ??USART_SetConfig_137
   \                     ??USART_SetConfig_138: (+1)
   \      0x5EC   0x6A60             LDR      R0,[R4, #+36]
   \      0x5EE   0x2802             CMP      R0,#+2
   \      0x5F0   0xD101             BNE.N    ??USART_SetConfig_139
   \      0x5F2   0x2004             MOVS     R0,#+4
   \      0x5F4   0xE02E             B.N      ??USART_SetConfig_137
   \                     ??USART_SetConfig_139: (+1)
   \      0x5F6   0x6A60             LDR      R0,[R4, #+36]
   \      0x5F8   0x2803             CMP      R0,#+3
   \      0x5FA   0xD101             BNE.N    ??USART_SetConfig_140
   \      0x5FC   0x2006             MOVS     R0,#+6
   \      0x5FE   0xE029             B.N      ??USART_SetConfig_137
   \                     ??USART_SetConfig_140: (+1)
   \      0x600   0x6A60             LDR      R0,[R4, #+36]
   \      0x602   0x2804             CMP      R0,#+4
   \      0x604   0xD101             BNE.N    ??USART_SetConfig_141
   \      0x606   0x2008             MOVS     R0,#+8
   \      0x608   0xE024             B.N      ??USART_SetConfig_137
   \                     ??USART_SetConfig_141: (+1)
   \      0x60A   0x6A60             LDR      R0,[R4, #+36]
   \      0x60C   0x2805             CMP      R0,#+5
   \      0x60E   0xD101             BNE.N    ??USART_SetConfig_142
   \      0x610   0x200A             MOVS     R0,#+10
   \      0x612   0xE01F             B.N      ??USART_SetConfig_137
   \                     ??USART_SetConfig_142: (+1)
   \      0x614   0x6A60             LDR      R0,[R4, #+36]
   \      0x616   0x2806             CMP      R0,#+6
   \      0x618   0xD101             BNE.N    ??USART_SetConfig_143
   \      0x61A   0x200C             MOVS     R0,#+12
   \      0x61C   0xE01A             B.N      ??USART_SetConfig_137
   \                     ??USART_SetConfig_143: (+1)
   \      0x61E   0x6A60             LDR      R0,[R4, #+36]
   \      0x620   0x2807             CMP      R0,#+7
   \      0x622   0xD101             BNE.N    ??USART_SetConfig_144
   \      0x624   0x2010             MOVS     R0,#+16
   \      0x626   0xE015             B.N      ??USART_SetConfig_137
   \                     ??USART_SetConfig_144: (+1)
   \      0x628   0x6A60             LDR      R0,[R4, #+36]
   \      0x62A   0x2808             CMP      R0,#+8
   \      0x62C   0xD101             BNE.N    ??USART_SetConfig_145
   \      0x62E   0x2020             MOVS     R0,#+32
   \      0x630   0xE010             B.N      ??USART_SetConfig_137
   \                     ??USART_SetConfig_145: (+1)
   \      0x632   0x6A60             LDR      R0,[R4, #+36]
   \      0x634   0x2809             CMP      R0,#+9
   \      0x636   0xD101             BNE.N    ??USART_SetConfig_146
   \      0x638   0x2040             MOVS     R0,#+64
   \      0x63A   0xE00B             B.N      ??USART_SetConfig_137
   \                     ??USART_SetConfig_146: (+1)
   \      0x63C   0x6A60             LDR      R0,[R4, #+36]
   \      0x63E   0x280A             CMP      R0,#+10
   \      0x640   0xD101             BNE.N    ??USART_SetConfig_147
   \      0x642   0x2080             MOVS     R0,#+128
   \      0x644   0xE006             B.N      ??USART_SetConfig_137
   \                     ??USART_SetConfig_147: (+1)
   \      0x646   0x6A60             LDR      R0,[R4, #+36]
   \      0x648   0x280B             CMP      R0,#+11
   \      0x64A   0xD102             BNE.N    ??USART_SetConfig_148
   \      0x64C   0xF44F 0x7080      MOV      R0,#+256
   \      0x650   0xE000             B.N      ??USART_SetConfig_137
   \                     ??USART_SetConfig_148: (+1)
   \      0x652   0x2001             MOVS     R0,#+1
   \                     ??USART_SetConfig_137: (+1)
   \      0x654   0xF44F 0x4100      MOV      R1,#+32768
   \      0x658   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \      0x65C   0x6861             LDR      R1,[R4, #+4]
   \      0x65E   0x0849             LSRS     R1,R1,#+1
   \      0x660   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \      0x664   0x6860             LDR      R0,[R4, #+4]
   \      0x666   0xFBB1 0xF1F0      UDIV     R1,R1,R0
   3226                break;
   \      0x66A   0xE000             B.N      ??USART_SetConfig_70
   3227              default:
   3228                ret = HAL_ERROR;
   \                     ??USART_SetConfig_56: (+1)
   \      0x66C   0x2501             MOVS     R5,#+1
   3229                break;
   3230            }
   3231          
   3232            /* USARTDIV must be greater than or equal to 0d16 and smaller than or equal to ffff */
   3233            if ((usartdiv >= USART_BRR_MIN) && (usartdiv <= USART_BRR_MAX))
   \                     ??USART_SetConfig_70: (+1)
   \      0x66E   0xF64F 0x72F0      MOVW     R2,#+65520
   \      0x672   0xF1B1 0x0010      SUBS     R0,R1,#+16
   \      0x676   0x4290             CMP      R0,R2
   \      0x678   0xD207             BCS.N    ??USART_SetConfig_149
   3234            {
   3235              brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
   \      0x67A   0x400A             ANDS     R2,R2,R1
   3236              brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
   \      0x67C   0xF3C1 0x0042      UBFX     R0,R1,#+1,#+3
   \      0x680   0x4302             ORRS     R2,R0,R2
   3237              husart->Instance->BRR = brrtemp;
   \      0x682   0xB292             UXTH     R2,R2
   \      0x684   0x6820             LDR      R0,[R4, #+0]
   \      0x686   0x60C2             STR      R2,[R0, #+12]
   \      0x688   0xE000             B.N      ??USART_SetConfig_150
   3238            }
   3239            else
   3240            {
   3241              ret = HAL_ERROR;
   \                     ??USART_SetConfig_149: (+1)
   \      0x68A   0x2501             MOVS     R5,#+1
   3242            }
   3243          
   3244            /* Initialize the number of data to process during RX/TX ISR execution */
   3245            husart->NbTxDataToProcess = 1U;
   \                     ??USART_SetConfig_150: (+1)
   \      0x68C   0x2001             MOVS     R0,#+1
   \      0x68E   0x87A0             STRH     R0,[R4, #+60]
   3246            husart->NbRxDataToProcess = 1U;
   \      0x690   0x2001             MOVS     R0,#+1
   \      0x692   0x8760             STRH     R0,[R4, #+58]
   3247          
   3248            /* Clear ISR function pointers */
   3249            husart->RxISR   = NULL;
   \      0x694   0x2000             MOVS     R0,#+0
   \      0x696   0x64A0             STR      R0,[R4, #+72]
   3250            husart->TxISR   = NULL;
   \      0x698   0x2000             MOVS     R0,#+0
   \      0x69A   0x64E0             STR      R0,[R4, #+76]
   3251          
   3252            return ret;
   \      0x69C   0x0028             MOVS     R0,R5
   \      0x69E   0xB2C0             UXTB     R0,R0
   \      0x6A0   0xB007             ADD      SP,SP,#+28
   \      0x6A2   0xBD30             POP      {R4,R5,PC}
   3253          }
   3254          
   3255          /**
   3256            * @brief Check the USART Idle State.
   3257            * @param husart USART handle.
   3258            * @retval HAL status
   3259            */

   \                                 In section .text, align 2, keep-with-next
   3260          static HAL_StatusTypeDef USART_CheckIdleState(USART_HandleTypeDef *husart)
   3261          {
   \                     USART_CheckIdleState: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3262            uint32_t tickstart;
   3263          
   3264            /* Initialize the USART ErrorCode */
   3265            husart->ErrorCode = HAL_USART_ERROR_NONE;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x65E0             STR      R0,[R4, #+92]
   3266          
   3267            /* Init tickstart for timeout management */
   3268            tickstart = HAL_GetTick();
   \        0x8   0x.... 0x....      BL       HAL_GetTick
   \        0xC   0x0005             MOVS     R5,R0
   3269          
   3270            /* Check if the Transmitter is enabled */
   3271            if ((husart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x0700             LSLS     R0,R0,#+28
   \       0x14   0xD50D             BPL.N    ??USART_CheckIdleState_0
   3272            {
   3273              /* Wait until TEACK flag is set */
   3274              if (USART_WaitOnFlagUntilTimeout(husart, USART_ISR_TEACK, RESET, tickstart, USART_TEACK_REACK_TIMEOUT) != HAL_OK)
   \       0x16   0xF44F 0x707A      MOV      R0,#+1000
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   \       0x1C   0x002B             MOVS     R3,R5
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0xF45F 0x1100      MOVS     R1,#+2097152
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD001             BEQ.N    ??USART_CheckIdleState_0
   3275              {
   3276                /* Timeout occurred */
   3277                return HAL_TIMEOUT;
   \       0x2E   0x2003             MOVS     R0,#+3
   \       0x30   0xE018             B.N      ??USART_CheckIdleState_1
   3278              }
   3279            }
   3280            /* Check if the Receiver is enabled */
   3281            if ((husart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
   \                     ??USART_CheckIdleState_0: (+1)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0x0740             LSLS     R0,R0,#+29
   \       0x38   0xD50D             BPL.N    ??USART_CheckIdleState_2
   3282            {
   3283              /* Wait until REACK flag is set */
   3284              if (USART_WaitOnFlagUntilTimeout(husart, USART_ISR_REACK, RESET, tickstart, USART_TEACK_REACK_TIMEOUT) != HAL_OK)
   \       0x3A   0xF44F 0x707A      MOV      R0,#+1000
   \       0x3E   0x9000             STR      R0,[SP, #+0]
   \       0x40   0x002B             MOVS     R3,R5
   \       0x42   0x2200             MOVS     R2,#+0
   \       0x44   0xF45F 0x0180      MOVS     R1,#+4194304
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD001             BEQ.N    ??USART_CheckIdleState_2
   3285              {
   3286                /* Timeout occurred */
   3287                return HAL_TIMEOUT;
   \       0x52   0x2003             MOVS     R0,#+3
   \       0x54   0xE006             B.N      ??USART_CheckIdleState_1
   3288              }
   3289            }
   3290          
   3291            /* Initialize the USART state*/
   3292            husart->State = HAL_USART_STATE_READY;
   \                     ??USART_CheckIdleState_2: (+1)
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0xF884 0x0059      STRB     R0,[R4, #+89]
   3293          
   3294            /* Process Unlocked */
   3295            __HAL_UNLOCK(husart);
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0xF884 0x0058      STRB     R0,[R4, #+88]
   3296          
   3297            return HAL_OK;
   \       0x62   0x2000             MOVS     R0,#+0
   \                     ??USART_CheckIdleState_1: (+1)
   \       0x64   0xBD32             POP      {R1,R4,R5,PC}
   3298          }
   3299          
   3300          /**
   3301            * @brief  Simplex send an amount of data in non-blocking mode.
   3302            * @note   Function called under interruption only, once
   3303            *         interruptions have been enabled by HAL_USART_Transmit_IT().
   3304            * @note   The USART errors are not managed to avoid the overrun error.
   3305            * @note   ISR function executed when FIFO mode is disabled and when the
   3306            *         data word length is less than 9 bits long.
   3307            * @param  husart USART handle.
   3308            * @retval None
   3309            */

   \                                 In section .text, align 2, keep-with-next
   3310          static void USART_TxISR_8BIT(USART_HandleTypeDef *husart)
   3311          {
   3312            const HAL_USART_StateTypeDef state = husart->State;
   \                     USART_TxISR_8BIT: (+1)
   \        0x0   0xF890 0x1059      LDRB     R1,[R0, #+89]
   3313          
   3314            /* Check that a Tx process is ongoing */
   3315            if ((state == HAL_USART_STATE_BUSY_TX) ||
   3316                (state == HAL_USART_STATE_BUSY_TX_RX))
   \        0x4   0x000A             MOVS     R2,R1
   \        0x6   0xB2D2             UXTB     R2,R2
   \        0x8   0x2A12             CMP      R2,#+18
   \        0xA   0xD002             BEQ.N    ??USART_TxISR_8BIT_0
   \        0xC   0xB2C9             UXTB     R1,R1
   \        0xE   0x2932             CMP      R1,#+50
   \       0x10   0xD119             BNE.N    ??USART_TxISR_8BIT_1
   3317            {
   3318              if (husart->TxXferCount == 0U)
   \                     ??USART_TxISR_8BIT_0: (+1)
   \       0x12   0x8DC1             LDRH     R1,[R0, #+46]
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD10C             BNE.N    ??USART_TxISR_8BIT_2
   3319              {
   3320                /* Disable the USART Transmit data register empty interrupt */
   3321                __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0x6809             LDR      R1,[R1, #+0]
   \       0x1C   0xF031 0x0180      BICS     R1,R1,#0x80
   \       0x20   0x6802             LDR      R2,[R0, #+0]
   \       0x22   0x6011             STR      R1,[R2, #+0]
   3322          
   3323                /* Enable the USART Transmit Complete Interrupt */
   3324                __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
   \       0x24   0x6801             LDR      R1,[R0, #+0]
   \       0x26   0x6809             LDR      R1,[R1, #+0]
   \       0x28   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0x2C   0x6800             LDR      R0,[R0, #+0]
   \       0x2E   0x6001             STR      R1,[R0, #+0]
   \       0x30   0xE009             B.N      ??USART_TxISR_8BIT_1
   3325              }
   3326              else
   3327              {
   3328                husart->Instance->TDR = (uint8_t)(*husart->pTxBuffPtr & (uint8_t)0xFF);
   \                     ??USART_TxISR_8BIT_2: (+1)
   \       0x32   0x6A81             LDR      R1,[R0, #+40]
   \       0x34   0x7809             LDRB     R1,[R1, #+0]
   \       0x36   0x6802             LDR      R2,[R0, #+0]
   \       0x38   0x6291             STR      R1,[R2, #+40]
   3329                husart->pTxBuffPtr++;
   \       0x3A   0x6A81             LDR      R1,[R0, #+40]
   \       0x3C   0x1C49             ADDS     R1,R1,#+1
   \       0x3E   0x6281             STR      R1,[R0, #+40]
   3330                husart->TxXferCount--;
   \       0x40   0x8DC1             LDRH     R1,[R0, #+46]
   \       0x42   0x1E49             SUBS     R1,R1,#+1
   \       0x44   0x85C1             STRH     R1,[R0, #+46]
   3331              }
   3332            }
   3333          }
   \                     ??USART_TxISR_8BIT_1: (+1)
   \       0x46   0x4770             BX       LR
   3334          
   3335          /**
   3336            * @brief  Simplex send an amount of data in non-blocking mode.
   3337            * @note   Function called under interruption only, once
   3338            *         interruptions have been enabled by HAL_USART_Transmit_IT().
   3339            * @note   The USART errors are not managed to avoid the overrun error.
   3340            * @note   ISR function executed when FIFO mode is disabled and when the
   3341            *         data word length is 9 bits long.
   3342            * @param  husart USART handle.
   3343            * @retval None
   3344            */

   \                                 In section .text, align 2, keep-with-next
   3345          static void USART_TxISR_16BIT(USART_HandleTypeDef *husart)
   3346          {
   3347            const HAL_USART_StateTypeDef state = husart->State;
   \                     USART_TxISR_16BIT: (+1)
   \        0x0   0xF890 0x1059      LDRB     R1,[R0, #+89]
   3348            const uint16_t *tmp;
   3349          
   3350            if ((state == HAL_USART_STATE_BUSY_TX) ||
   3351                (state == HAL_USART_STATE_BUSY_TX_RX))
   \        0x4   0x000A             MOVS     R2,R1
   \        0x6   0xB2D2             UXTB     R2,R2
   \        0x8   0x2A12             CMP      R2,#+18
   \        0xA   0xD002             BEQ.N    ??USART_TxISR_16BIT_0
   \        0xC   0xB2C9             UXTB     R1,R1
   \        0xE   0x2932             CMP      R1,#+50
   \       0x10   0xD11B             BNE.N    ??USART_TxISR_16BIT_1
   3352            {
   3353              if (husart->TxXferCount == 0U)
   \                     ??USART_TxISR_16BIT_0: (+1)
   \       0x12   0x8DC1             LDRH     R1,[R0, #+46]
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD10C             BNE.N    ??USART_TxISR_16BIT_2
   3354              {
   3355                /* Disable the USART Transmit data register empty interrupt */
   3356                __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0x6809             LDR      R1,[R1, #+0]
   \       0x1C   0xF031 0x0180      BICS     R1,R1,#0x80
   \       0x20   0x6802             LDR      R2,[R0, #+0]
   \       0x22   0x6011             STR      R1,[R2, #+0]
   3357          
   3358                /* Enable the USART Transmit Complete Interrupt */
   3359                __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
   \       0x24   0x6801             LDR      R1,[R0, #+0]
   \       0x26   0x6809             LDR      R1,[R1, #+0]
   \       0x28   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0x2C   0x6800             LDR      R0,[R0, #+0]
   \       0x2E   0x6001             STR      R1,[R0, #+0]
   \       0x30   0xE00B             B.N      ??USART_TxISR_16BIT_1
   3360              }
   3361              else
   3362              {
   3363                tmp = (const uint16_t *) husart->pTxBuffPtr;
   \                     ??USART_TxISR_16BIT_2: (+1)
   \       0x32   0x6A81             LDR      R1,[R0, #+40]
   3364                husart->Instance->TDR = (uint16_t)(*tmp & 0x01FFU);
   \       0x34   0x8809             LDRH     R1,[R1, #+0]
   \       0x36   0x05C9             LSLS     R1,R1,#+23
   \       0x38   0x0DC9             LSRS     R1,R1,#+23
   \       0x3A   0x6802             LDR      R2,[R0, #+0]
   \       0x3C   0x6291             STR      R1,[R2, #+40]
   3365                husart->pTxBuffPtr += 2U;
   \       0x3E   0x6A81             LDR      R1,[R0, #+40]
   \       0x40   0x1C89             ADDS     R1,R1,#+2
   \       0x42   0x6281             STR      R1,[R0, #+40]
   3366                husart->TxXferCount--;
   \       0x44   0x8DC1             LDRH     R1,[R0, #+46]
   \       0x46   0x1E49             SUBS     R1,R1,#+1
   \       0x48   0x85C1             STRH     R1,[R0, #+46]
   3367              }
   3368            }
   3369          }
   \                     ??USART_TxISR_16BIT_1: (+1)
   \       0x4A   0x4770             BX       LR
   3370          
   3371          /**
   3372            * @brief  Simplex send an amount of data in non-blocking mode.
   3373            * @note   Function called under interruption only, once
   3374            *         interruptions have been enabled by HAL_USART_Transmit_IT().
   3375            * @note   The USART errors are not managed to avoid the overrun error.
   3376            * @note   ISR function executed when FIFO mode is enabled and when the
   3377            *         data word length is less than 9 bits long.
   3378            * @param  husart USART handle.
   3379            * @retval None
   3380            */

   \                                 In section .text, align 2, keep-with-next
   3381          static void USART_TxISR_8BIT_FIFOEN(USART_HandleTypeDef *husart)
   3382          {
   3383            const HAL_USART_StateTypeDef state = husart->State;
   \                     USART_TxISR_8BIT_FIFOEN: (+1)
   \        0x0   0xF890 0x1059      LDRB     R1,[R0, #+89]
   3384            uint16_t  nb_tx_data;
   3385          
   3386            /* Check that a Tx process is ongoing */
   3387            if ((state == HAL_USART_STATE_BUSY_TX) ||
   3388                (state == HAL_USART_STATE_BUSY_TX_RX))
   \        0x4   0x000A             MOVS     R2,R1
   \        0x6   0xB2D2             UXTB     R2,R2
   \        0x8   0x2A12             CMP      R2,#+18
   \        0xA   0xD002             BEQ.N    ??USART_TxISR_8BIT_FIFOEN_0
   \        0xC   0xB2C9             UXTB     R1,R1
   \        0xE   0x2932             CMP      R1,#+50
   \       0x10   0xD123             BNE.N    ??USART_TxISR_8BIT_FIFOEN_1
   3389            {
   3390              for (nb_tx_data = husart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
   \                     ??USART_TxISR_8BIT_FIFOEN_0: (+1)
   \       0x12   0x8F82             LDRH     R2,[R0, #+60]
   \       0x14   0xE00E             B.N      ??USART_TxISR_8BIT_FIFOEN_2
   3391              {
   3392                if (husart->TxXferCount == 0U)
   3393                {
   3394                  /* Disable the TX FIFO threshold interrupt */
   3395                  __HAL_USART_DISABLE_IT(husart, USART_IT_TXFT);
   3396          
   3397                  /* Enable the USART Transmit Complete Interrupt */
   3398                  __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
   3399          
   3400                  break; /* force exit loop */
   3401                }
   3402                else if (__HAL_USART_GET_FLAG(husart, USART_FLAG_TXFNF) == SET)
   \                     ??USART_TxISR_8BIT_FIFOEN_3: (+1)
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0x69C9             LDR      R1,[R1, #+28]
   \       0x1A   0x0609             LSLS     R1,R1,#+24
   \       0x1C   0xD509             BPL.N    ??USART_TxISR_8BIT_FIFOEN_4
   3403                {
   3404                  husart->Instance->TDR = (uint8_t)(*husart->pTxBuffPtr & (uint8_t)0xFF);
   \       0x1E   0x6A81             LDR      R1,[R0, #+40]
   \       0x20   0x7809             LDRB     R1,[R1, #+0]
   \       0x22   0x6803             LDR      R3,[R0, #+0]
   \       0x24   0x6299             STR      R1,[R3, #+40]
   3405                  husart->pTxBuffPtr++;
   \       0x26   0x6A81             LDR      R1,[R0, #+40]
   \       0x28   0x1C49             ADDS     R1,R1,#+1
   \       0x2A   0x6281             STR      R1,[R0, #+40]
   3406                  husart->TxXferCount--;
   \       0x2C   0x8DC1             LDRH     R1,[R0, #+46]
   \       0x2E   0x1E49             SUBS     R1,R1,#+1
   \       0x30   0x85C1             STRH     R1,[R0, #+46]
   3407                }
   \                     ??USART_TxISR_8BIT_FIFOEN_4: (+1)
   \       0x32   0x1E52             SUBS     R2,R2,#+1
   \                     ??USART_TxISR_8BIT_FIFOEN_2: (+1)
   \       0x34   0x0011             MOVS     R1,R2
   \       0x36   0xB289             UXTH     R1,R1
   \       0x38   0x2900             CMP      R1,#+0
   \       0x3A   0xD00E             BEQ.N    ??USART_TxISR_8BIT_FIFOEN_1
   \       0x3C   0x8DC1             LDRH     R1,[R0, #+46]
   \       0x3E   0x2900             CMP      R1,#+0
   \       0x40   0xD1E9             BNE.N    ??USART_TxISR_8BIT_FIFOEN_3
   \       0x42   0x6801             LDR      R1,[R0, #+0]
   \       0x44   0x6889             LDR      R1,[R1, #+8]
   \       0x46   0xF431 0x0100      BICS     R1,R1,#0x800000
   \       0x4A   0x6802             LDR      R2,[R0, #+0]
   \       0x4C   0x6091             STR      R1,[R2, #+8]
   \       0x4E   0x6801             LDR      R1,[R0, #+0]
   \       0x50   0x6809             LDR      R1,[R1, #+0]
   \       0x52   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0x56   0x6800             LDR      R0,[R0, #+0]
   \       0x58   0x6001             STR      R1,[R0, #+0]
   3408                else
   3409                {
   3410                  /* Nothing to do */
   3411                }
   3412              }
   3413            }
   3414          }
   \                     ??USART_TxISR_8BIT_FIFOEN_1: (+1)
   \       0x5A   0x4770             BX       LR
   3415          
   3416          /**
   3417            * @brief  Simplex send an amount of data in non-blocking mode.
   3418            * @note   Function called under interruption only, once
   3419            *         interruptions have been enabled by HAL_USART_Transmit_IT().
   3420            * @note   The USART errors are not managed to avoid the overrun error.
   3421            * @note   ISR function executed when FIFO mode is enabled and when the
   3422            *         data word length is 9 bits long.
   3423            * @param  husart USART handle.
   3424            * @retval None
   3425            */

   \                                 In section .text, align 2, keep-with-next
   3426          static void USART_TxISR_16BIT_FIFOEN(USART_HandleTypeDef *husart)
   3427          {
   3428            const HAL_USART_StateTypeDef state = husart->State;
   \                     USART_TxISR_16BIT_FIFOEN: (+1)
   \        0x0   0xF890 0x1059      LDRB     R1,[R0, #+89]
   3429            const uint16_t *tmp;
   3430            uint16_t  nb_tx_data;
   3431          
   3432            /* Check that a Tx process is ongoing */
   3433            if ((state == HAL_USART_STATE_BUSY_TX) ||
   3434                (state == HAL_USART_STATE_BUSY_TX_RX))
   \        0x4   0x000A             MOVS     R2,R1
   \        0x6   0xB2D2             UXTB     R2,R2
   \        0x8   0x2A12             CMP      R2,#+18
   \        0xA   0xD002             BEQ.N    ??USART_TxISR_16BIT_FIFOEN_0
   \        0xC   0xB2C9             UXTB     R1,R1
   \        0xE   0x2932             CMP      R1,#+50
   \       0x10   0xD125             BNE.N    ??USART_TxISR_16BIT_FIFOEN_1
   3435            {
   3436              for (nb_tx_data = husart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
   \                     ??USART_TxISR_16BIT_FIFOEN_0: (+1)
   \       0x12   0x8F82             LDRH     R2,[R0, #+60]
   \       0x14   0xE010             B.N      ??USART_TxISR_16BIT_FIFOEN_2
   3437              {
   3438                if (husart->TxXferCount == 0U)
   3439                {
   3440                  /* Disable the TX FIFO threshold interrupt */
   3441                  __HAL_USART_DISABLE_IT(husart, USART_IT_TXFT);
   3442          
   3443                  /* Enable the USART Transmit Complete Interrupt */
   3444                  __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
   3445          
   3446                  break; /* force exit loop */
   3447                }
   3448                else if (__HAL_USART_GET_FLAG(husart, USART_FLAG_TXFNF) == SET)
   \                     ??USART_TxISR_16BIT_FIFOEN_3: (+1)
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0x69C9             LDR      R1,[R1, #+28]
   \       0x1A   0x0609             LSLS     R1,R1,#+24
   \       0x1C   0xD50B             BPL.N    ??USART_TxISR_16BIT_FIFOEN_4
   3449                {
   3450                  tmp = (const uint16_t *) husart->pTxBuffPtr;
   \       0x1E   0x6A81             LDR      R1,[R0, #+40]
   3451                  husart->Instance->TDR = (uint16_t)(*tmp & 0x01FFU);
   \       0x20   0x8809             LDRH     R1,[R1, #+0]
   \       0x22   0x05C9             LSLS     R1,R1,#+23
   \       0x24   0x0DC9             LSRS     R1,R1,#+23
   \       0x26   0x6803             LDR      R3,[R0, #+0]
   \       0x28   0x6299             STR      R1,[R3, #+40]
   3452                  husart->pTxBuffPtr += 2U;
   \       0x2A   0x6A81             LDR      R1,[R0, #+40]
   \       0x2C   0x1C89             ADDS     R1,R1,#+2
   \       0x2E   0x6281             STR      R1,[R0, #+40]
   3453                  husart->TxXferCount--;
   \       0x30   0x8DC1             LDRH     R1,[R0, #+46]
   \       0x32   0x1E49             SUBS     R1,R1,#+1
   \       0x34   0x85C1             STRH     R1,[R0, #+46]
   3454                }
   \                     ??USART_TxISR_16BIT_FIFOEN_4: (+1)
   \       0x36   0x1E52             SUBS     R2,R2,#+1
   \                     ??USART_TxISR_16BIT_FIFOEN_2: (+1)
   \       0x38   0x0011             MOVS     R1,R2
   \       0x3A   0xB289             UXTH     R1,R1
   \       0x3C   0x2900             CMP      R1,#+0
   \       0x3E   0xD00E             BEQ.N    ??USART_TxISR_16BIT_FIFOEN_1
   \       0x40   0x8DC1             LDRH     R1,[R0, #+46]
   \       0x42   0x2900             CMP      R1,#+0
   \       0x44   0xD1E7             BNE.N    ??USART_TxISR_16BIT_FIFOEN_3
   \       0x46   0x6801             LDR      R1,[R0, #+0]
   \       0x48   0x6889             LDR      R1,[R1, #+8]
   \       0x4A   0xF431 0x0100      BICS     R1,R1,#0x800000
   \       0x4E   0x6802             LDR      R2,[R0, #+0]
   \       0x50   0x6091             STR      R1,[R2, #+8]
   \       0x52   0x6801             LDR      R1,[R0, #+0]
   \       0x54   0x6809             LDR      R1,[R1, #+0]
   \       0x56   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0x5A   0x6800             LDR      R0,[R0, #+0]
   \       0x5C   0x6001             STR      R1,[R0, #+0]
   3455                else
   3456                {
   3457                  /* Nothing to do */
   3458                }
   3459              }
   3460            }
   3461          }
   \                     ??USART_TxISR_16BIT_FIFOEN_1: (+1)
   \       0x5E   0x4770             BX       LR
   3462          
   3463          /**
   3464            * @brief  Wraps up transmission in non-blocking mode.
   3465            * @param  husart Pointer to a USART_HandleTypeDef structure that contains
   3466            *                the configuration information for the specified USART module.
   3467            * @retval None
   3468            */

   \                                 In section .text, align 2, keep-with-next
   3469          static void USART_EndTransmit_IT(USART_HandleTypeDef *husart)
   3470          {
   \                     USART_EndTransmit_IT: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3471            /* Disable the USART Transmit Complete Interrupt */
   3472            __HAL_USART_DISABLE_IT(husart, USART_IT_TC);
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0xF031 0x0140      BICS     R1,R1,#0x40
   \        0xA   0x6802             LDR      R2,[R0, #+0]
   \        0xC   0x6011             STR      R1,[R2, #+0]
   3473          
   3474            /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
   3475            __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x6889             LDR      R1,[R1, #+8]
   \       0x12   0x0849             LSRS     R1,R1,#+1
   \       0x14   0x0049             LSLS     R1,R1,#+1
   \       0x16   0x6802             LDR      R2,[R0, #+0]
   \       0x18   0x6091             STR      R1,[R2, #+8]
   3476          
   3477            /* Clear TxISR function pointer */
   3478            husart->TxISR = NULL;
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x64C1             STR      R1,[R0, #+76]
   3479          
   3480            if (husart->State == HAL_USART_STATE_BUSY_TX)
   \       0x1E   0xF890 0x1059      LDRB     R1,[R0, #+89]
   \       0x22   0x2912             CMP      R1,#+18
   \       0x24   0xD10E             BNE.N    ??USART_EndTransmit_IT_0
   3481            {
   3482              /* Clear overrun flag and discard the received data */
   3483              __HAL_USART_CLEAR_OREFLAG(husart);
   \       0x26   0x2108             MOVS     R1,#+8
   \       0x28   0x6802             LDR      R2,[R0, #+0]
   \       0x2A   0x6211             STR      R1,[R2, #+32]
   3484              __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
   \       0x2C   0x6801             LDR      R1,[R0, #+0]
   \       0x2E   0x6989             LDR      R1,[R1, #+24]
   \       0x30   0xF051 0x0108      ORRS     R1,R1,#0x8
   \       0x34   0x6802             LDR      R2,[R0, #+0]
   \       0x36   0x6191             STR      R1,[R2, #+24]
   3485          
   3486              /* Tx process is completed, restore husart->State to Ready */
   3487              husart->State = HAL_USART_STATE_READY;
   \       0x38   0x2101             MOVS     R1,#+1
   \       0x3A   0xF880 0x1059      STRB     R1,[R0, #+89]
   3488          
   3489          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   3490              /* Call registered Tx Complete Callback */
   3491              husart->TxCpltCallback(husart);
   3492          #else
   3493              /* Call legacy weak Tx Complete Callback */
   3494              HAL_USART_TxCpltCallback(husart);
   \       0x3E   0x.... 0x....      BL       HAL_USART_TxCpltCallback
   \       0x42   0xE007             B.N      ??USART_EndTransmit_IT_1
   3495          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   3496            }
   3497            else if (husart->RxXferCount == 0U)
   \                     ??USART_EndTransmit_IT_0: (+1)
   \       0x44   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x46   0x2900             CMP      R1,#+0
   \       0x48   0xD104             BNE.N    ??USART_EndTransmit_IT_1
   3498            {
   3499              /* TxRx process is completed, restore husart->State to Ready */
   3500              husart->State = HAL_USART_STATE_READY;
   \       0x4A   0x2101             MOVS     R1,#+1
   \       0x4C   0xF880 0x1059      STRB     R1,[R0, #+89]
   3501          
   3502          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   3503              /* Call registered Tx Rx Complete Callback */
   3504              husart->TxRxCpltCallback(husart);
   3505          #else
   3506              /* Call legacy weak Tx Rx Complete Callback */
   3507              HAL_USART_TxRxCpltCallback(husart);
   \       0x50   0x.... 0x....      BL       HAL_USART_TxRxCpltCallback
   3508          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   3509            }
   3510            else
   3511            {
   3512              /* Nothing to do */
   3513            }
   3514          }
   \                     ??USART_EndTransmit_IT_1: (+1)
   \       0x54   0xBD01             POP      {R0,PC}
   3515          
   3516          
   3517          /**
   3518            * @brief  Simplex receive an amount of data in non-blocking mode.
   3519            * @note   Function called under interruption only, once
   3520            *         interruptions have been enabled by HAL_USART_Receive_IT().
   3521            * @note   ISR function executed when FIFO mode is disabled and when the
   3522            *         data word length is less than 9 bits long.
   3523            * @param  husart USART handle
   3524            * @retval None
   3525            */

   \                                 In section .text, align 2, keep-with-next
   3526          static void USART_RxISR_8BIT(USART_HandleTypeDef *husart)
   3527          {
   \                     USART_RxISR_8BIT: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3528            const HAL_USART_StateTypeDef state = husart->State;
   \        0x2   0xF890 0x2059      LDRB     R2,[R0, #+89]
   3529            uint16_t txdatacount;
   3530            uint16_t uhMask = husart->Mask;
   \        0x6   0x8F01             LDRH     R1,[R0, #+56]
   3531            uint32_t txftie;
   3532          
   3533            if ((state == HAL_USART_STATE_BUSY_RX) ||
   3534                (state == HAL_USART_STATE_BUSY_TX_RX))
   \        0x8   0x0013             MOVS     R3,R2
   \        0xA   0xB2DB             UXTB     R3,R3
   \        0xC   0x2B22             CMP      R3,#+34
   \        0xE   0xD003             BEQ.N    ??USART_RxISR_8BIT_0
   \       0x10   0x0013             MOVS     R3,R2
   \       0x12   0xB2DB             UXTB     R3,R3
   \       0x14   0x2B32             CMP      R3,#+50
   \       0x16   0xD14F             BNE.N    ??USART_RxISR_8BIT_1
   3535            {
   3536              *husart->pRxBuffPtr = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
   \                     ??USART_RxISR_8BIT_0: (+1)
   \       0x18   0x6803             LDR      R3,[R0, #+0]
   \       0x1A   0x6A5B             LDR      R3,[R3, #+36]
   \       0x1C   0x4019             ANDS     R1,R1,R3
   \       0x1E   0x6B03             LDR      R3,[R0, #+48]
   \       0x20   0x7019             STRB     R1,[R3, #+0]
   3537              husart->pRxBuffPtr++;
   \       0x22   0x6B01             LDR      R1,[R0, #+48]
   \       0x24   0x1C49             ADDS     R1,R1,#+1
   \       0x26   0x6301             STR      R1,[R0, #+48]
   3538              husart->RxXferCount--;
   \       0x28   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x2A   0x1E49             SUBS     R1,R1,#+1
   \       0x2C   0x86C1             STRH     R1,[R0, #+54]
   3539          
   3540              if (husart->RxXferCount == 0U)
   \       0x2E   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD138             BNE.N    ??USART_RxISR_8BIT_2
   3541              {
   3542                /* Disable the USART Parity Error Interrupt and RXNE interrupt*/
   3543                CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
   \       0x34   0x6801             LDR      R1,[R0, #+0]
   \       0x36   0x6809             LDR      R1,[R1, #+0]
   \       0x38   0xF431 0x7190      BICS     R1,R1,#0x120
   \       0x3C   0x6803             LDR      R3,[R0, #+0]
   \       0x3E   0x6019             STR      R1,[R3, #+0]
   3544          
   3545                /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
   3546                CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
   \       0x40   0x6801             LDR      R1,[R0, #+0]
   \       0x42   0x6889             LDR      R1,[R1, #+8]
   \       0x44   0x0849             LSRS     R1,R1,#+1
   \       0x46   0x0049             LSLS     R1,R1,#+1
   \       0x48   0x6803             LDR      R3,[R0, #+0]
   \       0x4A   0x6099             STR      R1,[R3, #+8]
   3547          
   3548                /* Clear RxISR function pointer */
   3549                husart->RxISR = NULL;
   \       0x4C   0x2100             MOVS     R1,#+0
   \       0x4E   0x6481             STR      R1,[R0, #+72]
   3550          
   3551                /* txftie and txdatacount are temporary variables for MISRAC2012-Rule-13.5 */
   3552                txftie = READ_BIT(husart->Instance->CR3, USART_CR3_TXFTIE);
   \       0x50   0x6801             LDR      R1,[R0, #+0]
   \       0x52   0x688B             LDR      R3,[R1, #+8]
   \       0x54   0xF413 0x0300      ANDS     R3,R3,#0x800000
   3553                txdatacount = husart->TxXferCount;
   \       0x58   0x8DC1             LDRH     R1,[R0, #+46]
   3554          
   3555                if (state == HAL_USART_STATE_BUSY_RX)
   \       0x5A   0xB2D2             UXTB     R2,R2
   \       0x5C   0x2A22             CMP      R2,#+34
   \       0x5E   0xD112             BNE.N    ??USART_RxISR_8BIT_3
   3556                {
   3557                  /* Clear SPI slave underrun flag and discard transmit data */
   3558                  if (husart->SlaveMode == USART_SLAVEMODE_ENABLE)
   \       0x60   0x6C01             LDR      R1,[R0, #+64]
   \       0x62   0x2901             CMP      R1,#+1
   \       0x64   0xD109             BNE.N    ??USART_RxISR_8BIT_4
   3559                  {
   3560                    __HAL_USART_CLEAR_UDRFLAG(husart);
   \       0x66   0xF44F 0x5100      MOV      R1,#+8192
   \       0x6A   0x6802             LDR      R2,[R0, #+0]
   \       0x6C   0x6211             STR      R1,[R2, #+32]
   3561                    __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
   \       0x6E   0x6801             LDR      R1,[R0, #+0]
   \       0x70   0x6989             LDR      R1,[R1, #+24]
   \       0x72   0xF051 0x0110      ORRS     R1,R1,#0x10
   \       0x76   0x6802             LDR      R2,[R0, #+0]
   \       0x78   0x6191             STR      R1,[R2, #+24]
   3562                  }
   3563          
   3564                  /* Rx process is completed, restore husart->State to Ready */
   3565                  husart->State = HAL_USART_STATE_READY;
   \                     ??USART_RxISR_8BIT_4: (+1)
   \       0x7A   0x2101             MOVS     R1,#+1
   \       0x7C   0xF880 0x1059      STRB     R1,[R0, #+89]
   3566          
   3567          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   3568                  /* Call registered Rx Complete Callback */
   3569                  husart->RxCpltCallback(husart);
   3570          #else
   3571                  /* Call legacy weak Rx Complete Callback */
   3572                  HAL_USART_RxCpltCallback(husart);
   \       0x80   0x.... 0x....      BL       HAL_USART_RxCpltCallback
   \       0x84   0xE018             B.N      ??USART_RxISR_8BIT_1
   3573          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   3574                }
   3575                else if ((READ_BIT(husart->Instance->CR1, USART_CR1_TCIE) != USART_CR1_TCIE) &&
   3576                         (txftie != USART_CR3_TXFTIE) &&
   3577                         (txdatacount == 0U))
   \                     ??USART_RxISR_8BIT_3: (+1)
   \       0x86   0x6802             LDR      R2,[R0, #+0]
   \       0x88   0x6812             LDR      R2,[R2, #+0]
   \       0x8A   0x0652             LSLS     R2,R2,#+25
   \       0x8C   0xD414             BMI.N    ??USART_RxISR_8BIT_1
   \       0x8E   0xF5B3 0x0F00      CMP      R3,#+8388608
   \       0x92   0xD011             BEQ.N    ??USART_RxISR_8BIT_1
   \       0x94   0xB289             UXTH     R1,R1
   \       0x96   0x2900             CMP      R1,#+0
   \       0x98   0xD10E             BNE.N    ??USART_RxISR_8BIT_1
   3578                {
   3579                  /* TxRx process is completed, restore husart->State to Ready */
   3580                  husart->State = HAL_USART_STATE_READY;
   \       0x9A   0x2101             MOVS     R1,#+1
   \       0x9C   0xF880 0x1059      STRB     R1,[R0, #+89]
   3581          
   3582          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   3583                  /* Call registered Tx Rx Complete Callback */
   3584                  husart->TxRxCpltCallback(husart);
   3585          #else
   3586                  /* Call legacy weak Tx Rx Complete Callback */
   3587                  HAL_USART_TxRxCpltCallback(husart);
   \       0xA0   0x.... 0x....      BL       HAL_USART_TxRxCpltCallback
   \       0xA4   0xE008             B.N      ??USART_RxISR_8BIT_1
   3588          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   3589                }
   3590                else
   3591                {
   3592                  /* Nothing to do */
   3593                }
   3594              }
   3595              else if ((state == HAL_USART_STATE_BUSY_RX) &&
   3596                       (husart->SlaveMode == USART_SLAVEMODE_DISABLE))
   \                     ??USART_RxISR_8BIT_2: (+1)
   \       0xA6   0xB2D2             UXTB     R2,R2
   \       0xA8   0x2A22             CMP      R2,#+34
   \       0xAA   0xD105             BNE.N    ??USART_RxISR_8BIT_1
   \       0xAC   0x6C01             LDR      R1,[R0, #+64]
   \       0xAE   0x2900             CMP      R1,#+0
   \       0xB0   0xD102             BNE.N    ??USART_RxISR_8BIT_1
   3597              {
   3598                /* Send dummy byte in order to generate the clock for the Slave to Send the next data */
   3599                husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
   \       0xB2   0x21FF             MOVS     R1,#+255
   \       0xB4   0x6800             LDR      R0,[R0, #+0]
   \       0xB6   0x6281             STR      R1,[R0, #+40]
   3600              }
   3601              else
   3602              {
   3603                /* Nothing to do */
   3604              }
   3605            }
   3606          }
   \                     ??USART_RxISR_8BIT_1: (+1)
   \       0xB8   0xBD01             POP      {R0,PC}
   3607          
   3608          /**
   3609            * @brief  Simplex receive an amount of data in non-blocking mode.
   3610            * @note   Function called under interruption only, once
   3611            *         interruptions have been enabled by HAL_USART_Receive_IT().
   3612            * @note   ISR function executed when FIFO mode is disabled and when the
   3613            *         data word length is 9 bits long.
   3614            * @param  husart USART handle
   3615            * @retval None
   3616            */

   \                                 In section .text, align 2, keep-with-next
   3617          static void USART_RxISR_16BIT(USART_HandleTypeDef *husart)
   3618          {
   \                     USART_RxISR_16BIT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   3619            const HAL_USART_StateTypeDef state = husart->State;
   \        0x2   0xF890 0x2059      LDRB     R2,[R0, #+89]
   3620            uint16_t txdatacount;
   3621            uint16_t *tmp;
   3622            uint16_t uhMask = husart->Mask;
   \        0x6   0x8F03             LDRH     R3,[R0, #+56]
   3623            uint32_t txftie;
   3624          
   3625            if ((state == HAL_USART_STATE_BUSY_RX) ||
   3626                (state == HAL_USART_STATE_BUSY_TX_RX))
   \        0x8   0x0011             MOVS     R1,R2
   \        0xA   0xB2C9             UXTB     R1,R1
   \        0xC   0x2922             CMP      R1,#+34
   \        0xE   0xD003             BEQ.N    ??USART_RxISR_16BIT_0
   \       0x10   0x0011             MOVS     R1,R2
   \       0x12   0xB2C9             UXTB     R1,R1
   \       0x14   0x2932             CMP      R1,#+50
   \       0x16   0xD14F             BNE.N    ??USART_RxISR_16BIT_1
   3627            {
   3628              tmp = (uint16_t *) husart->pRxBuffPtr;
   \                     ??USART_RxISR_16BIT_0: (+1)
   \       0x18   0x6B01             LDR      R1,[R0, #+48]
   3629              *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
   \       0x1A   0x6804             LDR      R4,[R0, #+0]
   \       0x1C   0x6A64             LDR      R4,[R4, #+36]
   \       0x1E   0x4023             ANDS     R3,R3,R4
   \       0x20   0x800B             STRH     R3,[R1, #+0]
   3630              husart->pRxBuffPtr += 2U;
   \       0x22   0x6B01             LDR      R1,[R0, #+48]
   \       0x24   0x1C89             ADDS     R1,R1,#+2
   \       0x26   0x6301             STR      R1,[R0, #+48]
   3631              husart->RxXferCount--;
   \       0x28   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x2A   0x1E49             SUBS     R1,R1,#+1
   \       0x2C   0x86C1             STRH     R1,[R0, #+54]
   3632          
   3633              if (husart->RxXferCount == 0U)
   \       0x2E   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD138             BNE.N    ??USART_RxISR_16BIT_2
   3634              {
   3635                /* Disable the USART Parity Error Interrupt and RXNE interrupt*/
   3636                CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
   \       0x34   0x6801             LDR      R1,[R0, #+0]
   \       0x36   0x6809             LDR      R1,[R1, #+0]
   \       0x38   0xF431 0x7190      BICS     R1,R1,#0x120
   \       0x3C   0x6803             LDR      R3,[R0, #+0]
   \       0x3E   0x6019             STR      R1,[R3, #+0]
   3637          
   3638                /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
   3639                CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
   \       0x40   0x6801             LDR      R1,[R0, #+0]
   \       0x42   0x6889             LDR      R1,[R1, #+8]
   \       0x44   0x0849             LSRS     R1,R1,#+1
   \       0x46   0x0049             LSLS     R1,R1,#+1
   \       0x48   0x6803             LDR      R3,[R0, #+0]
   \       0x4A   0x6099             STR      R1,[R3, #+8]
   3640          
   3641                /* Clear RxISR function pointer */
   3642                husart->RxISR = NULL;
   \       0x4C   0x2100             MOVS     R1,#+0
   \       0x4E   0x6481             STR      R1,[R0, #+72]
   3643          
   3644                /* txftie and txdatacount are temporary variables for MISRAC2012-Rule-13.5 */
   3645                txftie = READ_BIT(husart->Instance->CR3, USART_CR3_TXFTIE);
   \       0x50   0x6801             LDR      R1,[R0, #+0]
   \       0x52   0x688B             LDR      R3,[R1, #+8]
   \       0x54   0xF413 0x0300      ANDS     R3,R3,#0x800000
   3646                txdatacount = husart->TxXferCount;
   \       0x58   0x8DC1             LDRH     R1,[R0, #+46]
   3647          
   3648                if (state == HAL_USART_STATE_BUSY_RX)
   \       0x5A   0xB2D2             UXTB     R2,R2
   \       0x5C   0x2A22             CMP      R2,#+34
   \       0x5E   0xD112             BNE.N    ??USART_RxISR_16BIT_3
   3649                {
   3650                  /* Clear SPI slave underrun flag and discard transmit data */
   3651                  if (husart->SlaveMode == USART_SLAVEMODE_ENABLE)
   \       0x60   0x6C01             LDR      R1,[R0, #+64]
   \       0x62   0x2901             CMP      R1,#+1
   \       0x64   0xD109             BNE.N    ??USART_RxISR_16BIT_4
   3652                  {
   3653                    __HAL_USART_CLEAR_UDRFLAG(husart);
   \       0x66   0xF44F 0x5100      MOV      R1,#+8192
   \       0x6A   0x6802             LDR      R2,[R0, #+0]
   \       0x6C   0x6211             STR      R1,[R2, #+32]
   3654                    __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
   \       0x6E   0x6801             LDR      R1,[R0, #+0]
   \       0x70   0x6989             LDR      R1,[R1, #+24]
   \       0x72   0xF051 0x0110      ORRS     R1,R1,#0x10
   \       0x76   0x6802             LDR      R2,[R0, #+0]
   \       0x78   0x6191             STR      R1,[R2, #+24]
   3655                  }
   3656          
   3657                  /* Rx process is completed, restore husart->State to Ready */
   3658                  husart->State = HAL_USART_STATE_READY;
   \                     ??USART_RxISR_16BIT_4: (+1)
   \       0x7A   0x2101             MOVS     R1,#+1
   \       0x7C   0xF880 0x1059      STRB     R1,[R0, #+89]
   3659          
   3660          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   3661                  /* Call registered Rx Complete Callback */
   3662                  husart->RxCpltCallback(husart);
   3663          #else
   3664                  /* Call legacy weak Rx Complete Callback */
   3665                  HAL_USART_RxCpltCallback(husart);
   \       0x80   0x.... 0x....      BL       HAL_USART_RxCpltCallback
   \       0x84   0xE018             B.N      ??USART_RxISR_16BIT_1
   3666          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   3667                }
   3668                else if ((READ_BIT(husart->Instance->CR1, USART_CR1_TCIE) != USART_CR1_TCIE) &&
   3669                         (txftie != USART_CR3_TXFTIE) &&
   3670                         (txdatacount == 0U))
   \                     ??USART_RxISR_16BIT_3: (+1)
   \       0x86   0x6802             LDR      R2,[R0, #+0]
   \       0x88   0x6812             LDR      R2,[R2, #+0]
   \       0x8A   0x0652             LSLS     R2,R2,#+25
   \       0x8C   0xD414             BMI.N    ??USART_RxISR_16BIT_1
   \       0x8E   0xF5B3 0x0F00      CMP      R3,#+8388608
   \       0x92   0xD011             BEQ.N    ??USART_RxISR_16BIT_1
   \       0x94   0xB289             UXTH     R1,R1
   \       0x96   0x2900             CMP      R1,#+0
   \       0x98   0xD10E             BNE.N    ??USART_RxISR_16BIT_1
   3671                {
   3672                  /* TxRx process is completed, restore husart->State to Ready */
   3673                  husart->State = HAL_USART_STATE_READY;
   \       0x9A   0x2101             MOVS     R1,#+1
   \       0x9C   0xF880 0x1059      STRB     R1,[R0, #+89]
   3674          
   3675          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   3676                  /* Call registered Tx Rx Complete Callback */
   3677                  husart->TxRxCpltCallback(husart);
   3678          #else
   3679                  /* Call legacy weak Tx Rx Complete Callback */
   3680                  HAL_USART_TxRxCpltCallback(husart);
   \       0xA0   0x.... 0x....      BL       HAL_USART_TxRxCpltCallback
   \       0xA4   0xE008             B.N      ??USART_RxISR_16BIT_1
   3681          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   3682                }
   3683                else
   3684                {
   3685                  /* Nothing to do */
   3686                }
   3687              }
   3688              else if ((state == HAL_USART_STATE_BUSY_RX) &&
   3689                       (husart->SlaveMode == USART_SLAVEMODE_DISABLE))
   \                     ??USART_RxISR_16BIT_2: (+1)
   \       0xA6   0xB2D2             UXTB     R2,R2
   \       0xA8   0x2A22             CMP      R2,#+34
   \       0xAA   0xD105             BNE.N    ??USART_RxISR_16BIT_1
   \       0xAC   0x6C01             LDR      R1,[R0, #+64]
   \       0xAE   0x2900             CMP      R1,#+0
   \       0xB0   0xD102             BNE.N    ??USART_RxISR_16BIT_1
   3690              {
   3691                /* Send dummy byte in order to generate the clock for the Slave to Send the next data */
   3692                husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
   \       0xB2   0x21FF             MOVS     R1,#+255
   \       0xB4   0x6800             LDR      R0,[R0, #+0]
   \       0xB6   0x6281             STR      R1,[R0, #+40]
   3693              }
   3694              else
   3695              {
   3696                /* Nothing to do */
   3697              }
   3698            }
   3699          }
   \                     ??USART_RxISR_16BIT_1: (+1)
   \       0xB8   0xBD10             POP      {R4,PC}
   3700          
   3701          /**
   3702            * @brief  Simplex receive an amount of data in non-blocking mode.
   3703            * @note   Function called under interruption only, once
   3704            *         interruptions have been enabled by HAL_USART_Receive_IT().
   3705            * @note   ISR function executed when FIFO mode is enabled and when the
   3706            *         data word length is less than 9 bits long.
   3707            * @param  husart USART handle
   3708            * @retval None
   3709            */

   \                                 In section .text, align 2, keep-with-next
   3710          static void USART_RxISR_8BIT_FIFOEN(USART_HandleTypeDef *husart)
   3711          {
   \                     USART_RxISR_8BIT_FIFOEN: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3712            HAL_USART_StateTypeDef state = husart->State;
   \        0x4   0xF894 0x5059      LDRB     R5,[R4, #+89]
   3713            uint16_t txdatacount;
   3714            uint16_t rxdatacount;
   3715            uint16_t uhMask = husart->Mask;
   \        0x8   0x8F26             LDRH     R6,[R4, #+56]
   3716            uint16_t nb_rx_data;
   3717            uint32_t txftie;
   3718          
   3719            /* Check that a Rx process is ongoing */
   3720            if ((state == HAL_USART_STATE_BUSY_RX) ||
   3721                (state == HAL_USART_STATE_BUSY_TX_RX))
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x2822             CMP      R0,#+34
   \       0x10   0xD004             BEQ.N    ??USART_RxISR_8BIT_FIFOEN_0
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x2832             CMP      R0,#+50
   \       0x18   0xF040 0x8085      BNE.W    ??USART_RxISR_8BIT_FIFOEN_1
   3722            {
   3723              for (nb_rx_data = husart->NbRxDataToProcess ; nb_rx_data > 0U ; nb_rx_data--)
   \                     ??USART_RxISR_8BIT_FIFOEN_0: (+1)
   \       0x1C   0x8F67             LDRH     R7,[R4, #+58]
   \       0x1E   0xE01C             B.N      ??USART_RxISR_8BIT_FIFOEN_2
   3724              {
   3725                if (__HAL_USART_GET_FLAG(husart, USART_FLAG_RXFNE) == SET)
   3726                {
   3727                  *husart->pRxBuffPtr = (uint8_t)(husart->Instance->RDR & (uint8_t)(uhMask & 0xFFU));
   3728                  husart->pRxBuffPtr++;
   3729                  husart->RxXferCount--;
   3730          
   3731                  if (husart->RxXferCount == 0U)
   3732                  {
   3733                    /* Disable the USART Parity Error Interrupt */
   3734                    CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
   3735          
   3736                    /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error)
   3737                       and RX FIFO Threshold interrupt */
   3738                    CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
   3739          
   3740                    /* Clear RxISR function pointer */
   3741                    husart->RxISR = NULL;
   3742          
   3743                    /* txftie and txdatacount are temporary variables for MISRAC2012-Rule-13.5 */
   3744                    txftie = READ_BIT(husart->Instance->CR3, USART_CR3_TXFTIE);
   3745                    txdatacount = husart->TxXferCount;
   3746          
   3747                    if (state == HAL_USART_STATE_BUSY_RX)
   3748                    {
   3749                      /* Clear SPI slave underrun flag and discard transmit data */
   3750                      if (husart->SlaveMode == USART_SLAVEMODE_ENABLE)
   3751                      {
   3752                        __HAL_USART_CLEAR_UDRFLAG(husart);
   3753                        __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
   3754                      }
   3755          
   3756                      /* Rx process is completed, restore husart->State to Ready */
   3757                      husart->State = HAL_USART_STATE_READY;
   3758                      state = HAL_USART_STATE_READY;
   3759          
   3760          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   3761                      /* Call registered Rx Complete Callback */
   3762                      husart->RxCpltCallback(husart);
   3763          #else
   3764                      /* Call legacy weak Rx Complete Callback */
   3765                      HAL_USART_RxCpltCallback(husart);
   3766          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   3767                    }
   3768                    else if ((READ_BIT(husart->Instance->CR1, USART_CR1_TCIE) != USART_CR1_TCIE) &&
   3769                             (txftie != USART_CR3_TXFTIE) &&
   3770                             (txdatacount == 0U))
   3771                    {
   3772                      /* TxRx process is completed, restore husart->State to Ready */
   3773                      husart->State = HAL_USART_STATE_READY;
   3774                      state = HAL_USART_STATE_READY;
   3775          
   3776          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   3777                      /* Call registered Tx Rx Complete Callback */
   3778                      husart->TxRxCpltCallback(husart);
   3779          #else
   3780                      /* Call legacy weak Tx Rx Complete Callback */
   3781                      HAL_USART_TxRxCpltCallback(husart);
   3782          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   3783                    }
   3784                    else
   3785                    {
   3786                      /* Nothing to do */
   3787                    }
   3788                  }
   3789                  else if ((state == HAL_USART_STATE_BUSY_RX) &&
   3790                           (husart->SlaveMode == USART_SLAVEMODE_DISABLE))
   \                     ??USART_RxISR_8BIT_FIFOEN_3: (+1)
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x2822             CMP      R0,#+34
   \       0x26   0xD117             BNE.N    ??USART_RxISR_8BIT_FIFOEN_4
   \       0x28   0x6C20             LDR      R0,[R4, #+64]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD114             BNE.N    ??USART_RxISR_8BIT_FIFOEN_4
   3791                  {
   3792                    /* Send dummy byte in order to generate the clock for the Slave to Send the next data */
   3793                    husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
   \       0x2E   0x20FF             MOVS     R0,#+255
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x6288             STR      R0,[R1, #+40]
   \       0x34   0xE010             B.N      ??USART_RxISR_8BIT_FIFOEN_4
   3794                  }
   \                     ??USART_RxISR_8BIT_FIFOEN_5: (+1)
   \       0x36   0x6822             LDR      R2,[R4, #+0]
   \       0x38   0x6812             LDR      R2,[R2, #+0]
   \       0x3A   0x0652             LSLS     R2,R2,#+25
   \       0x3C   0xD40C             BMI.N    ??USART_RxISR_8BIT_FIFOEN_4
   \       0x3E   0xF5B1 0x0F00      CMP      R1,#+8388608
   \       0x42   0xD009             BEQ.N    ??USART_RxISR_8BIT_FIFOEN_4
   \       0x44   0xB280             UXTH     R0,R0
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD106             BNE.N    ??USART_RxISR_8BIT_FIFOEN_4
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xF884 0x0059      STRB     R0,[R4, #+89]
   \       0x50   0x2501             MOVS     R5,#+1
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       HAL_USART_TxRxCpltCallback
   \                     ??USART_RxISR_8BIT_FIFOEN_4: (+1)
   \       0x58   0x1E7F             SUBS     R7,R7,#+1
   \                     ??USART_RxISR_8BIT_FIFOEN_2: (+1)
   \       0x5A   0x0038             MOVS     R0,R7
   \       0x5C   0xB280             UXTH     R0,R0
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD03D             BEQ.N    ??USART_RxISR_8BIT_FIFOEN_6
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x69C0             LDR      R0,[R0, #+28]
   \       0x66   0x0680             LSLS     R0,R0,#+26
   \       0x68   0xD5F6             BPL.N    ??USART_RxISR_8BIT_FIFOEN_4
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6A40             LDR      R0,[R0, #+36]
   \       0x6E   0x4030             ANDS     R0,R6,R0
   \       0x70   0x6B21             LDR      R1,[R4, #+48]
   \       0x72   0x7008             STRB     R0,[R1, #+0]
   \       0x74   0x6B20             LDR      R0,[R4, #+48]
   \       0x76   0x1C40             ADDS     R0,R0,#+1
   \       0x78   0x6320             STR      R0,[R4, #+48]
   \       0x7A   0x8EE0             LDRH     R0,[R4, #+54]
   \       0x7C   0x1E40             SUBS     R0,R0,#+1
   \       0x7E   0x86E0             STRH     R0,[R4, #+54]
   \       0x80   0x8EE0             LDRH     R0,[R4, #+54]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD1CC             BNE.N    ??USART_RxISR_8BIT_FIFOEN_3
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x6800             LDR      R0,[R0, #+0]
   \       0x8A   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0x8E   0x6821             LDR      R1,[R4, #+0]
   \       0x90   0x6008             STR      R0,[R1, #+0]
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6881             LDR      R1,[R0, #+8]
   \       0x96   0x....             LDR.N    R0,??DataTable10_5
   \       0x98   0x4001             ANDS     R1,R0,R1
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x6081             STR      R1,[R0, #+8]
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x64A0             STR      R0,[R4, #+72]
   \       0xA2   0x6820             LDR      R0,[R4, #+0]
   \       0xA4   0x6881             LDR      R1,[R0, #+8]
   \       0xA6   0xF411 0x0100      ANDS     R1,R1,#0x800000
   \       0xAA   0x8DE0             LDRH     R0,[R4, #+46]
   \       0xAC   0x002A             MOVS     R2,R5
   \       0xAE   0xB2D2             UXTB     R2,R2
   \       0xB0   0x2A22             CMP      R2,#+34
   \       0xB2   0xD1C0             BNE.N    ??USART_RxISR_8BIT_FIFOEN_5
   \       0xB4   0x6C20             LDR      R0,[R4, #+64]
   \       0xB6   0x2801             CMP      R0,#+1
   \       0xB8   0xD109             BNE.N    ??USART_RxISR_8BIT_FIFOEN_7
   \       0xBA   0xF44F 0x5000      MOV      R0,#+8192
   \       0xBE   0x6821             LDR      R1,[R4, #+0]
   \       0xC0   0x6208             STR      R0,[R1, #+32]
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x6980             LDR      R0,[R0, #+24]
   \       0xC6   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xCA   0x6821             LDR      R1,[R4, #+0]
   \       0xCC   0x6188             STR      R0,[R1, #+24]
   \                     ??USART_RxISR_8BIT_FIFOEN_7: (+1)
   \       0xCE   0x2001             MOVS     R0,#+1
   \       0xD0   0xF884 0x0059      STRB     R0,[R4, #+89]
   \       0xD4   0x2501             MOVS     R5,#+1
   \       0xD6   0x0020             MOVS     R0,R4
   \       0xD8   0x.... 0x....      BL       HAL_USART_RxCpltCallback
   \       0xDC   0xE7BC             B.N      ??USART_RxISR_8BIT_FIFOEN_4
   3795                  else
   3796                  {
   3797                    /* Nothing to do */
   3798                  }
   3799                }
   3800              }
   3801          
   3802              /* When remaining number of bytes to receive is less than the RX FIFO
   3803              threshold, next incoming frames are processed as if FIFO mode was
   3804              disabled (i.e. one interrupt per received frame).
   3805              */
   3806              rxdatacount = husart->RxXferCount;
   \                     ??USART_RxISR_8BIT_FIFOEN_6: (+1)
   \       0xDE   0x8EE0             LDRH     R0,[R4, #+54]
   3807              if (((rxdatacount != 0U)) && (rxdatacount < husart->NbRxDataToProcess))
   \       0xE0   0x0001             MOVS     R1,R0
   \       0xE2   0xB289             UXTH     R1,R1
   \       0xE4   0x2900             CMP      R1,#+0
   \       0xE6   0xD024             BEQ.N    ??USART_RxISR_8BIT_FIFOEN_8
   \       0xE8   0x8F61             LDRH     R1,[R4, #+58]
   \       0xEA   0xB280             UXTH     R0,R0
   \       0xEC   0x4288             CMP      R0,R1
   \       0xEE   0xD220             BCS.N    ??USART_RxISR_8BIT_FIFOEN_8
   3808              {
   3809                /* Disable the USART RXFT interrupt*/
   3810                CLEAR_BIT(husart->Instance->CR3, USART_CR3_RXFTIE);
   \       0xF0   0x6820             LDR      R0,[R4, #+0]
   \       0xF2   0x6880             LDR      R0,[R0, #+8]
   \       0xF4   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \       0xF8   0x6821             LDR      R1,[R4, #+0]
   \       0xFA   0x6088             STR      R0,[R1, #+8]
   3811          
   3812                /* Update the RxISR function pointer */
   3813                husart->RxISR = USART_RxISR_8BIT;
   \       0xFC   0x....             LDR.N    R0,??DataTable10_6
   \       0xFE   0x64A0             STR      R0,[R4, #+72]
   3814          
   3815                /* Enable the USART Data Register Not Empty interrupt */
   3816                SET_BIT(husart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
   \      0x100   0x6820             LDR      R0,[R4, #+0]
   \      0x102   0x6800             LDR      R0,[R0, #+0]
   \      0x104   0xF050 0x0020      ORRS     R0,R0,#0x20
   \      0x108   0x6821             LDR      R1,[R4, #+0]
   \      0x10A   0x6008             STR      R0,[R1, #+0]
   3817          
   3818                if ((husart->TxXferCount == 0U) &&
   3819                    (state == HAL_USART_STATE_BUSY_TX_RX) &&
   3820                    (husart->SlaveMode == USART_SLAVEMODE_DISABLE))
   \      0x10C   0x8DE0             LDRH     R0,[R4, #+46]
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD10F             BNE.N    ??USART_RxISR_8BIT_FIFOEN_8
   \      0x112   0xB2ED             UXTB     R5,R5
   \      0x114   0x2D32             CMP      R5,#+50
   \      0x116   0xD10C             BNE.N    ??USART_RxISR_8BIT_FIFOEN_8
   \      0x118   0x6C20             LDR      R0,[R4, #+64]
   \      0x11A   0x2800             CMP      R0,#+0
   \      0x11C   0xD109             BNE.N    ??USART_RxISR_8BIT_FIFOEN_8
   3821                {
   3822                  /* Send dummy byte in order to generate the clock for the Slave to Send the next data */
   3823                  husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
   \      0x11E   0x20FF             MOVS     R0,#+255
   \      0x120   0x6821             LDR      R1,[R4, #+0]
   \      0x122   0x6288             STR      R0,[R1, #+40]
   \      0x124   0xE005             B.N      ??USART_RxISR_8BIT_FIFOEN_8
   3824                }
   3825              }
   3826            }
   3827            else
   3828            {
   3829              /* Clear RXNE interrupt flag */
   3830              __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
   \                     ??USART_RxISR_8BIT_FIFOEN_1: (+1)
   \      0x126   0x6820             LDR      R0,[R4, #+0]
   \      0x128   0x6980             LDR      R0,[R0, #+24]
   \      0x12A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x12E   0x6821             LDR      R1,[R4, #+0]
   \      0x130   0x6188             STR      R0,[R1, #+24]
   3831            }
   3832          }
   \                     ??USART_RxISR_8BIT_FIFOEN_8: (+1)
   \      0x132   0xBDF1             POP      {R0,R4-R7,PC}
   3833          
   3834          /**
   3835            * @brief  Simplex receive an amount of data in non-blocking mode.
   3836            * @note   Function called under interruption only, once
   3837            *         interruptions have been enabled by HAL_USART_Receive_IT().
   3838            * @note   ISR function executed when FIFO mode is enabled and when the
   3839            *         data word length is 9 bits long.
   3840            * @param  husart USART handle
   3841            * @retval None
   3842            */

   \                                 In section .text, align 2, keep-with-next
   3843          static void USART_RxISR_16BIT_FIFOEN(USART_HandleTypeDef *husart)
   3844          {
   \                     USART_RxISR_16BIT_FIFOEN: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3845            HAL_USART_StateTypeDef state = husart->State;
   \        0x4   0xF894 0x5059      LDRB     R5,[R4, #+89]
   3846            uint16_t txdatacount;
   3847            uint16_t rxdatacount;
   3848            uint16_t *tmp;
   3849            uint16_t uhMask = husart->Mask;
   \        0x8   0x8F26             LDRH     R6,[R4, #+56]
   3850            uint16_t nb_rx_data;
   3851            uint32_t txftie;
   3852          
   3853            /* Check that a Tx process is ongoing */
   3854            if ((state == HAL_USART_STATE_BUSY_RX) ||
   3855                (state == HAL_USART_STATE_BUSY_TX_RX))
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x2822             CMP      R0,#+34
   \       0x10   0xD004             BEQ.N    ??USART_RxISR_16BIT_FIFOEN_0
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x2832             CMP      R0,#+50
   \       0x18   0xF040 0x8085      BNE.W    ??USART_RxISR_16BIT_FIFOEN_1
   3856            {
   3857              for (nb_rx_data = husart->NbRxDataToProcess ; nb_rx_data > 0U ; nb_rx_data--)
   \                     ??USART_RxISR_16BIT_FIFOEN_0: (+1)
   \       0x1C   0x8F67             LDRH     R7,[R4, #+58]
   \       0x1E   0xE01C             B.N      ??USART_RxISR_16BIT_FIFOEN_2
   3858              {
   3859                if (__HAL_USART_GET_FLAG(husart, USART_FLAG_RXFNE) == SET)
   3860                {
   3861                  tmp = (uint16_t *) husart->pRxBuffPtr;
   3862                  *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
   3863                  husart->pRxBuffPtr += 2U;
   3864                  husart->RxXferCount--;
   3865          
   3866                  if (husart->RxXferCount == 0U)
   3867                  {
   3868                    /* Disable the USART Parity Error Interrupt */
   3869                    CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
   3870          
   3871                    /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error)
   3872                       and RX FIFO Threshold interrupt */
   3873                    CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
   3874          
   3875                    /* Clear RxISR function pointer */
   3876                    husart->RxISR = NULL;
   3877          
   3878                    /* txftie and txdatacount are temporary variables for MISRAC2012-Rule-13.5 */
   3879                    txftie = READ_BIT(husart->Instance->CR3, USART_CR3_TXFTIE);
   3880                    txdatacount = husart->TxXferCount;
   3881          
   3882                    if (state == HAL_USART_STATE_BUSY_RX)
   3883                    {
   3884                      /* Clear SPI slave underrun flag and discard transmit data */
   3885                      if (husart->SlaveMode == USART_SLAVEMODE_ENABLE)
   3886                      {
   3887                        __HAL_USART_CLEAR_UDRFLAG(husart);
   3888                        __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
   3889                      }
   3890          
   3891                      /* Rx process is completed, restore husart->State to Ready */
   3892                      husart->State = HAL_USART_STATE_READY;
   3893                      state = HAL_USART_STATE_READY;
   3894          
   3895          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   3896                      /* Call registered Rx Complete Callback */
   3897                      husart->RxCpltCallback(husart);
   3898          #else
   3899                      /* Call legacy weak Rx Complete Callback */
   3900                      HAL_USART_RxCpltCallback(husart);
   3901          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   3902                    }
   3903                    else if ((READ_BIT(husart->Instance->CR1, USART_CR1_TCIE) != USART_CR1_TCIE) &&
   3904                             (txftie != USART_CR3_TXFTIE) &&
   3905                             (txdatacount == 0U))
   3906                    {
   3907                      /* TxRx process is completed, restore husart->State to Ready */
   3908                      husart->State = HAL_USART_STATE_READY;
   3909                      state = HAL_USART_STATE_READY;
   3910          
   3911          #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
   3912                      /* Call registered Tx Rx Complete Callback */
   3913                      husart->TxRxCpltCallback(husart);
   3914          #else
   3915                      /* Call legacy weak Tx Rx Complete Callback */
   3916                      HAL_USART_TxRxCpltCallback(husart);
   3917          #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
   3918                    }
   3919                    else
   3920                    {
   3921                      /* Nothing to do */
   3922                    }
   3923                  }
   3924                  else if ((state == HAL_USART_STATE_BUSY_RX) &&
   3925                           (husart->SlaveMode == USART_SLAVEMODE_DISABLE))
   \                     ??USART_RxISR_16BIT_FIFOEN_3: (+1)
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x2822             CMP      R0,#+34
   \       0x26   0xD117             BNE.N    ??USART_RxISR_16BIT_FIFOEN_4
   \       0x28   0x6C20             LDR      R0,[R4, #+64]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD114             BNE.N    ??USART_RxISR_16BIT_FIFOEN_4
   3926                  {
   3927                    /* Send dummy byte in order to generate the clock for the Slave to Send the next data */
   3928                    husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
   \       0x2E   0x20FF             MOVS     R0,#+255
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x6288             STR      R0,[R1, #+40]
   \       0x34   0xE010             B.N      ??USART_RxISR_16BIT_FIFOEN_4
   3929                  }
   \                     ??USART_RxISR_16BIT_FIFOEN_5: (+1)
   \       0x36   0x6822             LDR      R2,[R4, #+0]
   \       0x38   0x6812             LDR      R2,[R2, #+0]
   \       0x3A   0x0652             LSLS     R2,R2,#+25
   \       0x3C   0xD40C             BMI.N    ??USART_RxISR_16BIT_FIFOEN_4
   \       0x3E   0xF5B1 0x0F00      CMP      R1,#+8388608
   \       0x42   0xD009             BEQ.N    ??USART_RxISR_16BIT_FIFOEN_4
   \       0x44   0xB280             UXTH     R0,R0
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD106             BNE.N    ??USART_RxISR_16BIT_FIFOEN_4
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xF884 0x0059      STRB     R0,[R4, #+89]
   \       0x50   0x2501             MOVS     R5,#+1
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       HAL_USART_TxRxCpltCallback
   \                     ??USART_RxISR_16BIT_FIFOEN_4: (+1)
   \       0x58   0x1E7F             SUBS     R7,R7,#+1
   \                     ??USART_RxISR_16BIT_FIFOEN_2: (+1)
   \       0x5A   0x0038             MOVS     R0,R7
   \       0x5C   0xB280             UXTH     R0,R0
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD03D             BEQ.N    ??USART_RxISR_16BIT_FIFOEN_6
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x69C0             LDR      R0,[R0, #+28]
   \       0x66   0x0680             LSLS     R0,R0,#+26
   \       0x68   0xD5F6             BPL.N    ??USART_RxISR_16BIT_FIFOEN_4
   \       0x6A   0x6B20             LDR      R0,[R4, #+48]
   \       0x6C   0x6821             LDR      R1,[R4, #+0]
   \       0x6E   0x6A49             LDR      R1,[R1, #+36]
   \       0x70   0x4031             ANDS     R1,R6,R1
   \       0x72   0x8001             STRH     R1,[R0, #+0]
   \       0x74   0x6B20             LDR      R0,[R4, #+48]
   \       0x76   0x1C80             ADDS     R0,R0,#+2
   \       0x78   0x6320             STR      R0,[R4, #+48]
   \       0x7A   0x8EE0             LDRH     R0,[R4, #+54]
   \       0x7C   0x1E40             SUBS     R0,R0,#+1
   \       0x7E   0x86E0             STRH     R0,[R4, #+54]
   \       0x80   0x8EE0             LDRH     R0,[R4, #+54]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD1CC             BNE.N    ??USART_RxISR_16BIT_FIFOEN_3
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x6800             LDR      R0,[R0, #+0]
   \       0x8A   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0x8E   0x6821             LDR      R1,[R4, #+0]
   \       0x90   0x6008             STR      R0,[R1, #+0]
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6881             LDR      R1,[R0, #+8]
   \       0x96   0x....             LDR.N    R0,??DataTable10_5
   \       0x98   0x4001             ANDS     R1,R0,R1
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x6081             STR      R1,[R0, #+8]
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x64A0             STR      R0,[R4, #+72]
   \       0xA2   0x6820             LDR      R0,[R4, #+0]
   \       0xA4   0x6881             LDR      R1,[R0, #+8]
   \       0xA6   0xF411 0x0100      ANDS     R1,R1,#0x800000
   \       0xAA   0x8DE0             LDRH     R0,[R4, #+46]
   \       0xAC   0x002A             MOVS     R2,R5
   \       0xAE   0xB2D2             UXTB     R2,R2
   \       0xB0   0x2A22             CMP      R2,#+34
   \       0xB2   0xD1C0             BNE.N    ??USART_RxISR_16BIT_FIFOEN_5
   \       0xB4   0x6C20             LDR      R0,[R4, #+64]
   \       0xB6   0x2801             CMP      R0,#+1
   \       0xB8   0xD109             BNE.N    ??USART_RxISR_16BIT_FIFOEN_7
   \       0xBA   0xF44F 0x5000      MOV      R0,#+8192
   \       0xBE   0x6821             LDR      R1,[R4, #+0]
   \       0xC0   0x6208             STR      R0,[R1, #+32]
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x6980             LDR      R0,[R0, #+24]
   \       0xC6   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xCA   0x6821             LDR      R1,[R4, #+0]
   \       0xCC   0x6188             STR      R0,[R1, #+24]
   \                     ??USART_RxISR_16BIT_FIFOEN_7: (+1)
   \       0xCE   0x2001             MOVS     R0,#+1
   \       0xD0   0xF884 0x0059      STRB     R0,[R4, #+89]
   \       0xD4   0x2501             MOVS     R5,#+1
   \       0xD6   0x0020             MOVS     R0,R4
   \       0xD8   0x.... 0x....      BL       HAL_USART_RxCpltCallback
   \       0xDC   0xE7BC             B.N      ??USART_RxISR_16BIT_FIFOEN_4
   3930                  else
   3931                  {
   3932                    /* Nothing to do */
   3933                  }
   3934                }
   3935              }
   3936          
   3937              /* When remaining number of bytes to receive is less than the RX FIFO
   3938              threshold, next incoming frames are processed as if FIFO mode was
   3939              disabled (i.e. one interrupt per received frame).
   3940              */
   3941              rxdatacount = husart->RxXferCount;
   \                     ??USART_RxISR_16BIT_FIFOEN_6: (+1)
   \       0xDE   0x8EE0             LDRH     R0,[R4, #+54]
   3942              if (((rxdatacount != 0U)) && (rxdatacount < husart->NbRxDataToProcess))
   \       0xE0   0x0001             MOVS     R1,R0
   \       0xE2   0xB289             UXTH     R1,R1
   \       0xE4   0x2900             CMP      R1,#+0
   \       0xE6   0xD024             BEQ.N    ??USART_RxISR_16BIT_FIFOEN_8
   \       0xE8   0x8F61             LDRH     R1,[R4, #+58]
   \       0xEA   0xB280             UXTH     R0,R0
   \       0xEC   0x4288             CMP      R0,R1
   \       0xEE   0xD220             BCS.N    ??USART_RxISR_16BIT_FIFOEN_8
   3943              {
   3944                /* Disable the USART RXFT interrupt*/
   3945                CLEAR_BIT(husart->Instance->CR3, USART_CR3_RXFTIE);
   \       0xF0   0x6820             LDR      R0,[R4, #+0]
   \       0xF2   0x6880             LDR      R0,[R0, #+8]
   \       0xF4   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \       0xF8   0x6821             LDR      R1,[R4, #+0]
   \       0xFA   0x6088             STR      R0,[R1, #+8]
   3946          
   3947                /* Update the RxISR function pointer */
   3948                husart->RxISR = USART_RxISR_16BIT;
   \       0xFC   0x....             LDR.N    R0,??DataTable10_7
   \       0xFE   0x64A0             STR      R0,[R4, #+72]
   3949          
   3950                /* Enable the USART Data Register Not Empty interrupt */
   3951                SET_BIT(husart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
   \      0x100   0x6820             LDR      R0,[R4, #+0]
   \      0x102   0x6800             LDR      R0,[R0, #+0]
   \      0x104   0xF050 0x0020      ORRS     R0,R0,#0x20
   \      0x108   0x6821             LDR      R1,[R4, #+0]
   \      0x10A   0x6008             STR      R0,[R1, #+0]
   3952          
   3953                if ((husart->TxXferCount == 0U) &&
   3954                    (state == HAL_USART_STATE_BUSY_TX_RX) &&
   3955                    (husart->SlaveMode == USART_SLAVEMODE_DISABLE))
   \      0x10C   0x8DE0             LDRH     R0,[R4, #+46]
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD10F             BNE.N    ??USART_RxISR_16BIT_FIFOEN_8
   \      0x112   0xB2ED             UXTB     R5,R5
   \      0x114   0x2D32             CMP      R5,#+50
   \      0x116   0xD10C             BNE.N    ??USART_RxISR_16BIT_FIFOEN_8
   \      0x118   0x6C20             LDR      R0,[R4, #+64]
   \      0x11A   0x2800             CMP      R0,#+0
   \      0x11C   0xD109             BNE.N    ??USART_RxISR_16BIT_FIFOEN_8
   3956                {
   3957                  /* Send dummy byte in order to generate the clock for the Slave to Send the next data */
   3958                  husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
   \      0x11E   0x20FF             MOVS     R0,#+255
   \      0x120   0x6821             LDR      R1,[R4, #+0]
   \      0x122   0x6288             STR      R0,[R1, #+40]
   \      0x124   0xE005             B.N      ??USART_RxISR_16BIT_FIFOEN_8
   3959                }
   3960              }
   3961            }
   3962            else
   3963            {
   3964              /* Clear RXNE interrupt flag */
   3965              __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
   \                     ??USART_RxISR_16BIT_FIFOEN_1: (+1)
   \      0x126   0x6820             LDR      R0,[R4, #+0]
   \      0x128   0x6980             LDR      R0,[R0, #+24]
   \      0x12A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x12E   0x6821             LDR      R1,[R4, #+0]
   \      0x130   0x6188             STR      R0,[R1, #+24]
   3966            }
   3967          }
   \                     ??USART_RxISR_16BIT_FIFOEN_8: (+1)
   \      0x132   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x....'....        DC32     USART_TxISR_16BIT_FIFOEN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x....'....        DC32     USART_TxISR_8BIT_FIFOEN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x....'....        DC32     USART_TxISR_16BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x....'....        DC32     USART_TxISR_8BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \        0x0   0x....'....        DC32     USART_RxISR_16BIT_FIFOEN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \        0x0   0x....'....        DC32     USART_RxISR_8BIT_FIFOEN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \        0x0   0x....'....        DC32     USART_RxISR_16BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     USART_RxISR_8BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0xEF7F'FFFE        DC32     0xef7ffffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x1000'0001        DC32     0x10000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0xCFFF'69F3        DC32     0xcfff69f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0xFFFF'C0F6        DC32     0xffffc0f6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x4001'3800        DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x4402'0CD8        DC32     0x44020cd8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x4000'4400        DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x4000'4800        DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x4000'6400        DC32     0x40006400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x4000'6800        DC32     0x40006800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x4000'6C00        DC32     0x40006c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x4402'0CDC        DC32     0x44020cdc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0x03D0'9000        DC32     0x3d09000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0x003D'0900        DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \        0x0   0xEFFF'FFFE        DC32     0xeffffffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \        0x0   0x....'....        DC32     USART_RxISR_8BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \        0x0   0x....'....        DC32     USART_RxISR_16BIT
   3968          
   3969          /**
   3970            * @}
   3971            */
   3972          
   3973          #endif /* HAL_USART_MODULE_ENABLED */
   3974          /**
   3975            * @}
   3976            */
   3977          
   3978          /**
   3979            * @}
   3980            */
   3981          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_USART_Abort
         8   -> HAL_DMA_Abort
         8   -> HAL_DMA_GetError
       0   HAL_USART_AbortCpltCallback
      16   HAL_USART_Abort_IT
        16   -> HAL_DMA_Abort_IT
        16   -> HAL_USART_AbortCpltCallback
      16   HAL_USART_DMAPause
        16   -> HAL_DMAEx_Suspend
        16   -> HAL_DMA_GetError
      16   HAL_USART_DMAResume
        16   -> HAL_DMAEx_Resume
       8   HAL_USART_DMAStop
         8   -> HAL_DMA_Abort
         8   -> HAL_DMA_GetError
         8   -> USART_EndTransfer
       8   HAL_USART_DeInit
         8   -> HAL_USART_MspDeInit
       0   HAL_USART_ErrorCallback
       0   HAL_USART_GetError
       0   HAL_USART_GetState
      16   HAL_USART_IRQHandler
        16   -- Indirect call
        16   -> HAL_DMA_Abort_IT
        16   -> HAL_USARTEx_RxFifoFullCallback
        16   -> HAL_USARTEx_TxFifoEmptyCallback
        16   -> HAL_USART_ErrorCallback
        16   -> USART_EndTransfer
        16   -> USART_EndTransmit_IT
       8   HAL_USART_Init
         8   -> HAL_USART_MspInit
         8   -> USART_CheckIdleState
         8   -> USART_SetConfig
       0   HAL_USART_MspDeInit
       0   HAL_USART_MspInit
      32   HAL_USART_Receive
        32   -> HAL_GetTick
        32   -> USART_WaitOnFlagUntilTimeout
      24   HAL_USART_Receive_DMA
        24   -> HAL_DMAEx_List_Start_IT
        24   -> HAL_DMA_Abort
        24   -> HAL_DMA_Start_IT
       4   HAL_USART_Receive_IT
       0   HAL_USART_RxCpltCallback
       0   HAL_USART_RxHalfCpltCallback
      32   HAL_USART_Transmit
        32   -> HAL_GetTick
        32   -> USART_WaitOnFlagUntilTimeout
      40   HAL_USART_TransmitReceive
        40   -> HAL_GetTick
        40   -> USART_WaitOnFlagUntilTimeout
      24   HAL_USART_TransmitReceive_DMA
        24   -> HAL_DMAEx_List_Start_IT
        24   -> HAL_DMA_Abort
        24   -> HAL_DMA_Start_IT
       8   HAL_USART_TransmitReceive_IT
      16   HAL_USART_Transmit_DMA
        16   -> HAL_DMAEx_List_Start_IT
        16   -> HAL_DMA_Start_IT
       4   HAL_USART_Transmit_IT
       0   HAL_USART_TxCpltCallback
       0   HAL_USART_TxHalfCpltCallback
       0   HAL_USART_TxRxCpltCallback
      16   USART_CheckIdleState
        16   -> HAL_GetTick
        16   -> USART_WaitOnFlagUntilTimeout
       8   USART_DMAAbortOnError
         8   -> HAL_USART_ErrorCallback
       8   USART_DMAError
         8   -> HAL_USART_ErrorCallback
         8   -> USART_EndTransfer
       8   USART_DMAReceiveCplt
         8   -> HAL_USART_RxCpltCallback
         8   -> HAL_USART_TxRxCpltCallback
       8   USART_DMARxAbortCallback
         8   -> HAL_USART_AbortCpltCallback
       8   USART_DMARxHalfCplt
         8   -> HAL_USART_RxHalfCpltCallback
       8   USART_DMATransmitCplt
         8   -> HAL_USART_TxCpltCallback
       8   USART_DMATxAbortCallback
         8   -> HAL_USART_AbortCpltCallback
       8   USART_DMATxHalfCplt
         8   -> HAL_USART_TxHalfCpltCallback
       0   USART_EndTransfer
       8   USART_EndTransmit_IT
         8   -> HAL_USART_TxCpltCallback
         8   -> HAL_USART_TxRxCpltCallback
       8   USART_RxISR_16BIT
         8   -> HAL_USART_RxCpltCallback
         8   -> HAL_USART_TxRxCpltCallback
      24   USART_RxISR_16BIT_FIFOEN
        24   -> HAL_USART_RxCpltCallback
        24   -> HAL_USART_TxRxCpltCallback
       8   USART_RxISR_8BIT
         8   -> HAL_USART_RxCpltCallback
         8   -> HAL_USART_TxRxCpltCallback
      24   USART_RxISR_8BIT_FIFOEN
        24   -> HAL_USART_RxCpltCallback
        24   -> HAL_USART_TxRxCpltCallback
      40   USART_SetConfig
        40   -> HAL_RCCEx_GetPLL2ClockFreq
        40   -> HAL_RCCEx_GetPLL3ClockFreq
        40   -> HAL_RCC_GetPCLK1Freq
        40   -> HAL_RCC_GetPCLK2Freq
       0   USART_TxISR_16BIT
       0   USART_TxISR_16BIT_FIFOEN
       0   USART_TxISR_8BIT
       0   USART_TxISR_8BIT_FIFOEN
      24   USART_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable6
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
     186  HAL_USART_Abort
       2  HAL_USART_AbortCpltCallback
     230  HAL_USART_Abort_IT
     206  HAL_USART_DMAPause
     174  HAL_USART_DMAResume
     112  HAL_USART_DMAStop
      62  HAL_USART_DeInit
       2  HAL_USART_ErrorCallback
       4  HAL_USART_GetError
       6  HAL_USART_GetState
     458  HAL_USART_IRQHandler
     108  HAL_USART_Init
       2  HAL_USART_MspDeInit
       2  HAL_USART_MspInit
     356  HAL_USART_Receive
     462  HAL_USART_Receive_DMA
     388  HAL_USART_Receive_IT
       2  HAL_USART_RxCpltCallback
       2  HAL_USART_RxHalfCpltCallback
     258  HAL_USART_Transmit
     588  HAL_USART_TransmitReceive
     478  HAL_USART_TransmitReceive_DMA
     412  HAL_USART_TransmitReceive_IT
     266  HAL_USART_Transmit_DMA
     196  HAL_USART_Transmit_IT
       2  HAL_USART_TxCpltCallback
       2  HAL_USART_TxHalfCpltCallback
       2  HAL_USART_TxRxCpltCallback
     102  USART_CheckIdleState
      18  USART_DMAAbortOnError
      40  USART_DMAError
      92  USART_DMAReceiveCplt
      54  USART_DMARxAbortCallback
      10  USART_DMARxHalfCplt
      52  USART_DMATransmitCplt
      54  USART_DMATxAbortCallback
      10  USART_DMATxHalfCplt
      32  USART_EndTransfer
      86  USART_EndTransmit_IT
     186  USART_RxISR_16BIT
     308  USART_RxISR_16BIT_FIFOEN
     186  USART_RxISR_8BIT
     308  USART_RxISR_8BIT_FIFOEN
   1'700  USART_SetConfig
      76  USART_TxISR_16BIT
      96  USART_TxISR_16BIT_FIFOEN
      72  USART_TxISR_8BIT
      92  USART_TxISR_8BIT_FIFOEN
      80  USART_WaitOnFlagUntilTimeout

 
 8'722 bytes in section .text
 
 8'704 bytes of CODE memory (+ 18 bytes shared)

Errors: none
Warnings: none
